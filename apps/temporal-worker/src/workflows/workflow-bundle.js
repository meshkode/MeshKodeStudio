var __TEMPORAL__;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./libs/orchestrator/src/workflows/clone/clone.workflow.ts":
/*!*****************************************************************!*\
  !*** ./libs/orchestrator/src/workflows/clone/clone.workflow.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cloneRepoWorkflow: () => (/* binding */ cloneRepoWorkflow)
/* harmony export */ });
/* harmony import */ var _temporalio_workflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @temporalio/workflow */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/index.js");
/* harmony import */ var _temporalio_workflow__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_temporalio_workflow__WEBPACK_IMPORTED_MODULE_0__);

const { resolveCommit, fetchSnapshot } = (0,_temporalio_workflow__WEBPACK_IMPORTED_MODULE_0__.proxyActivities)({
    startToCloseTimeout: "5 minute",
    retry: {
        maximumAttempts: 3,
        initialInterval: "2s"
    }
});
async function cloneRepoWorkflow(input) {
    console.log(`Starting workflow for ${input.repoUrl} @ ${input.ref}`);
    const sha = await resolveCommit(input.repoUrl, input.ref);
    console.log(`Resolved SHA: ${sha}`);
    const { path } = await fetchSnapshot(input.repoUrl, sha);
    console.log(`Snapshot fetched to: ${path}`);
    return {
        sha,
        path
    };
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/activity-cancellation-details.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/activity-cancellation-details.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActivityCancellationDetails = void 0;
/**
 * Provides the reasons for the activity's cancellation. Cancellation details are set once and do not change once set.
 */
class ActivityCancellationDetails {
    notFound;
    cancelRequested;
    paused;
    timedOut;
    workerShutdown;
    reset;
    constructor(options = {}) {
        this.notFound = options.notFound ?? false;
        this.cancelRequested = options.cancelRequested ?? false;
        this.paused = options.paused ?? false;
        this.timedOut = options.timedOut ?? false;
        this.workerShutdown = options.workerShutdown ?? false;
        this.reset = options.reset ?? false;
    }
    static fromProto(proto) {
        if (proto == null) {
            return new ActivityCancellationDetails();
        }
        return new ActivityCancellationDetails({
            notFound: proto.isNotFound ?? false,
            cancelRequested: proto.isCancelled ?? false,
            paused: proto.isPaused ?? false,
            timedOut: proto.isTimedOut ?? false,
            workerShutdown: proto.isWorkerShutdown ?? false,
            reset: proto.isReset ?? false,
        });
    }
}
exports.ActivityCancellationDetails = ActivityCancellationDetails;


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/activity-options.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/activity-options.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeActivityCancellationType = exports.encodeActivityCancellationType = exports.ActivityCancellationType = void 0;
const internal_workflow_1 = __webpack_require__(/*! ./internal-workflow */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/internal-workflow/index.js");
exports.ActivityCancellationType = {
    TRY_CANCEL: 'TRY_CANCEL',
    WAIT_CANCELLATION_COMPLETED: 'WAIT_CANCELLATION_COMPLETED',
    ABANDON: 'ABANDON',
};
_a = (0, internal_workflow_1.makeProtoEnumConverters)({
    [exports.ActivityCancellationType.TRY_CANCEL]: 0,
    [exports.ActivityCancellationType.WAIT_CANCELLATION_COMPLETED]: 1,
    [exports.ActivityCancellationType.ABANDON]: 2,
}, ''), exports.encodeActivityCancellationType = _a[0], exports.decodeActivityCancellationType = _a[1];


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/converter/data-converter.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/converter/data-converter.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultDataConverter = exports.defaultFailureConverter = void 0;
const failure_converter_1 = __webpack_require__(/*! ./failure-converter */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/converter/failure-converter.js");
const payload_converter_1 = __webpack_require__(/*! ./payload-converter */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/converter/payload-converter.js");
/**
 * The default {@link FailureConverter} used by the SDK.
 *
 * Error messages and stack traces are serizalized as plain text.
 */
exports.defaultFailureConverter = new failure_converter_1.DefaultFailureConverter();
/**
 * A "loaded" data converter that uses the default set of failure and payload converters.
 */
exports.defaultDataConverter = {
    payloadConverter: payload_converter_1.defaultPayloadConverter,
    failureConverter: exports.defaultFailureConverter,
    payloadCodecs: [],
};


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/converter/failure-converter.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/converter/failure-converter.js ***!
  \*************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefaultFailureConverter = void 0;
exports.cutoffStackTrace = cutoffStackTrace;
const nexus = __importStar(__webpack_require__(/*! nexus-rpc */ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/index.js"));
const long_1 = __importDefault(__webpack_require__(/*! long */ "./node_modules/.pnpm/long@5.3.2/node_modules/long/umd/index.js"));
const failure_1 = __webpack_require__(/*! ../failure */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/failure.js");
const internal_workflow_1 = __webpack_require__(/*! ../internal-workflow */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/internal-workflow/index.js");
const type_helpers_1 = __webpack_require__(/*! ../type-helpers */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/type-helpers.js");
const time_1 = __webpack_require__(/*! ../time */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/time.js");
const payload_converter_1 = __webpack_require__(/*! ./payload-converter */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/converter/payload-converter.js");
// Can't import proto enums into the workflow sandbox, use this helper type and enum converter instead.
const NexusHandlerErrorRetryBehavior = {
    RETRYABLE: 'RETRYABLE',
    NON_RETRYABLE: 'NON_RETRYABLE',
};
const [encodeNexusHandlerErrorRetryBehavior, decodeNexusHandlerErrorRetryBehavior] = (0, internal_workflow_1.makeProtoEnumConverters)({
    UNSPECIFIED: 0,
    [NexusHandlerErrorRetryBehavior.RETRYABLE]: 1,
    [NexusHandlerErrorRetryBehavior.NON_RETRYABLE]: 2,
}, 'NEXUS_HANDLER_ERROR_RETRY_BEHAVIOR_');
function combineRegExp(...regexps) {
    return new RegExp(regexps.map((x) => `(?:${x.source})`).join('|'));
}
/**
 * Stack traces will be cutoff when on of these patterns is matched
 */
const CUTOFF_STACK_PATTERNS = combineRegExp(
/** Activity execution */
/\s+at Activity\.execute \(.*[\\/]worker[\\/](?:src|lib)[\\/]activity\.[jt]s:\d+:\d+\)/, 
/** Nexus execution */
/\s+at( async)? NexusHandler\.invokeUserCode \(.*[\\/]worker[\\/](?:src|lib)[\\/]nexus[\\/]index\.[jt]s:\d+:\d+\)/, 
/** Workflow activation */
/\s+at Activator\.\S+NextHandler \(.*[\\/]workflow[\\/](?:src|lib)[\\/]internals\.[jt]s:\d+:\d+\)/, 
/** Workflow run anything in context */
/\s+at Script\.runInContext \((?:node:vm|vm\.js):\d+:\d+\)/);
/**
 * Any stack trace frames that match any of those wil be dopped.
 * The "null." prefix on some cases is to avoid https://github.com/nodejs/node/issues/42417
 */
const DROPPED_STACK_FRAMES_PATTERNS = combineRegExp(
/** Internal functions used to recursively chain interceptors */
/\s+at (null\.)?next \(.*[\\/]common[\\/](?:src|lib)[\\/]interceptors\.[jt]s:\d+:\d+\)/, 
/** Internal functions used to recursively chain interceptors */
/\s+at (null\.)?executeNextHandler \(.*[\\/]worker[\\/](?:src|lib)[\\/]activity\.[jt]s:\d+:\d+\)/);
/**
 * Cuts out the framework part of a stack trace, leaving only user code entries
 */
function cutoffStackTrace(stack) {
    const lines = (stack ?? '').split(/\r?\n/);
    const acc = Array();
    for (const line of lines) {
        if (CUTOFF_STACK_PATTERNS.test(line))
            break;
        if (!DROPPED_STACK_FRAMES_PATTERNS.test(line))
            acc.push(line);
    }
    return acc.join('\n');
}
/**
 * Default, cross-language-compatible Failure converter.
 *
 * By default, it will leave error messages and stack traces as plain text. In order to encrypt them, set
 * `encodeCommonAttributes` to `true` in the constructor options and use a {@link PayloadCodec} that can encrypt /
 * decrypt Payloads in your {@link WorkerOptions.dataConverter | Worker} and
 * {@link ClientOptions.dataConverter | Client options}.
 */
class DefaultFailureConverter {
    options;
    constructor(options) {
        const { encodeCommonAttributes } = options ?? {};
        this.options = {
            encodeCommonAttributes: encodeCommonAttributes ?? false,
        };
    }
    /**
     * Converts a Failure proto message to a JS Error object.
     *
     * Does not set common properties, that is done in {@link failureToError}.
     */
    failureToErrorInner(failure, payloadConverter) {
        if (failure.applicationFailureInfo) {
            return new failure_1.ApplicationFailure(failure.message ?? undefined, failure.applicationFailureInfo.type, Boolean(failure.applicationFailureInfo.nonRetryable), (0, payload_converter_1.arrayFromPayloads)(payloadConverter, failure.applicationFailureInfo.details?.payloads), this.optionalFailureToOptionalError(failure.cause, payloadConverter), undefined, (0, failure_1.decodeApplicationFailureCategory)(failure.applicationFailureInfo.category));
        }
        if (failure.serverFailureInfo) {
            return new failure_1.ServerFailure(failure.message ?? undefined, Boolean(failure.serverFailureInfo.nonRetryable), this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        if (failure.timeoutFailureInfo) {
            return new failure_1.TimeoutFailure(failure.message ?? undefined, (0, payload_converter_1.fromPayloadsAtIndex)(payloadConverter, 0, failure.timeoutFailureInfo.lastHeartbeatDetails?.payloads), (0, failure_1.decodeTimeoutType)(failure.timeoutFailureInfo.timeoutType));
        }
        if (failure.terminatedFailureInfo) {
            return new failure_1.TerminatedFailure(failure.message ?? undefined, this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        if (failure.canceledFailureInfo) {
            return new failure_1.CancelledFailure(failure.message ?? undefined, (0, payload_converter_1.arrayFromPayloads)(payloadConverter, failure.canceledFailureInfo.details?.payloads), this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        if (failure.resetWorkflowFailureInfo) {
            return new failure_1.ApplicationFailure(failure.message ?? undefined, 'ResetWorkflow', false, (0, payload_converter_1.arrayFromPayloads)(payloadConverter, failure.resetWorkflowFailureInfo.lastHeartbeatDetails?.payloads), this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        if (failure.childWorkflowExecutionFailureInfo) {
            const { namespace, workflowType, workflowExecution, retryState } = failure.childWorkflowExecutionFailureInfo;
            if (!(workflowType?.name && workflowExecution)) {
                throw new TypeError('Missing attributes on childWorkflowExecutionFailureInfo');
            }
            return new failure_1.ChildWorkflowFailure(namespace ?? undefined, workflowExecution, workflowType.name, (0, failure_1.decodeRetryState)(retryState), this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        if (failure.activityFailureInfo) {
            if (!failure.activityFailureInfo.activityType?.name) {
                throw new TypeError('Missing activityType?.name on activityFailureInfo');
            }
            return new failure_1.ActivityFailure(failure.message ?? undefined, failure.activityFailureInfo.activityType.name, failure.activityFailureInfo.activityId ?? undefined, (0, failure_1.decodeRetryState)(failure.activityFailureInfo.retryState), failure.activityFailureInfo.identity ?? undefined, this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        if (failure.nexusHandlerFailureInfo) {
            let retryableOverride = undefined;
            const retryBehavior = decodeNexusHandlerErrorRetryBehavior(failure.nexusHandlerFailureInfo.retryBehavior);
            switch (retryBehavior) {
                case 'RETRYABLE':
                    retryableOverride = true;
                    break;
                case 'NON_RETRYABLE':
                    retryableOverride = false;
                    break;
            }
            return new nexus.HandlerError(failure.nexusHandlerFailureInfo.type ?? 'INTERNAL', 
            // TODO(nexus/error): Maybe set a default message here, once we've decided on error handling.
            failure.message ?? undefined, {
                cause: this.optionalFailureToOptionalError(failure.cause, payloadConverter),
                retryableOverride,
            });
        }
        if (failure.nexusOperationExecutionFailureInfo) {
            return new failure_1.NexusOperationFailure(
            // TODO(nexus/error): Maybe set a default message here, once we've decided on error handling.
            failure.message ?? undefined, failure.nexusOperationExecutionFailureInfo.scheduledEventId?.toNumber(), 
            // We assume these will always be set or gracefully set to empty strings.
            failure.nexusOperationExecutionFailureInfo.endpoint ?? '', failure.nexusOperationExecutionFailureInfo.service ?? '', failure.nexusOperationExecutionFailureInfo.operation ?? '', failure.nexusOperationExecutionFailureInfo.operationToken ?? undefined, this.optionalFailureToOptionalError(failure.cause, payloadConverter));
        }
        return new failure_1.TemporalFailure(failure.message ?? undefined, this.optionalFailureToOptionalError(failure.cause, payloadConverter));
    }
    failureToError(failure, payloadConverter) {
        if (failure.encodedAttributes) {
            const attrs = payloadConverter.fromPayload(failure.encodedAttributes);
            // Don't apply encodedAttributes unless they conform to an expected schema
            if (typeof attrs === 'object' && attrs !== null) {
                const { message, stack_trace } = attrs;
                // Avoid mutating the argument
                failure = { ...failure };
                if (typeof message === 'string') {
                    failure.message = message;
                }
                if (typeof stack_trace === 'string') {
                    failure.stackTrace = stack_trace;
                }
            }
        }
        const err = this.failureToErrorInner(failure, payloadConverter);
        err.stack = failure.stackTrace ?? '';
        if (err instanceof failure_1.TemporalFailure) {
            err.failure = failure;
        }
        return err;
    }
    errorToFailure(err, payloadConverter) {
        const failure = this.errorToFailureInner(err, payloadConverter);
        if (this.options.encodeCommonAttributes) {
            const { message, stackTrace } = failure;
            failure.message = 'Encoded failure';
            failure.stackTrace = '';
            failure.encodedAttributes = payloadConverter.toPayload({ message, stack_trace: stackTrace });
        }
        return failure;
    }
    errorToFailureInner(err, payloadConverter) {
        // TODO(nexus/error): If we decide not to have a NexusHandlerFailure, we could still attach the
        //                    failure proto to the Nexus HandlerError object, by using a private symbol
        //                    property. To be considered once we have a decision on error handling.
        if (err instanceof failure_1.TemporalFailure || err instanceof nexus.HandlerError) {
            if (err instanceof failure_1.TemporalFailure && err.failure)
                return err.failure;
            const base = {
                message: err.message,
                stackTrace: cutoffStackTrace(err.stack),
                cause: this.optionalErrorToOptionalFailure(err.cause, payloadConverter),
                source: failure_1.FAILURE_SOURCE,
            };
            if (err instanceof failure_1.ActivityFailure) {
                return {
                    ...base,
                    activityFailureInfo: {
                        ...err,
                        retryState: (0, failure_1.encodeRetryState)(err.retryState),
                        activityType: { name: err.activityType },
                    },
                };
            }
            if (err instanceof failure_1.ChildWorkflowFailure) {
                return {
                    ...base,
                    childWorkflowExecutionFailureInfo: {
                        ...err,
                        retryState: (0, failure_1.encodeRetryState)(err.retryState),
                        workflowExecution: err.execution,
                        workflowType: { name: err.workflowType },
                    },
                };
            }
            if (err instanceof failure_1.ApplicationFailure) {
                return {
                    ...base,
                    applicationFailureInfo: {
                        type: err.type,
                        nonRetryable: err.nonRetryable,
                        details: err.details && err.details.length
                            ? { payloads: (0, payload_converter_1.toPayloads)(payloadConverter, ...err.details) }
                            : undefined,
                        nextRetryDelay: (0, time_1.msOptionalToTs)(err.nextRetryDelay),
                        category: (0, failure_1.encodeApplicationFailureCategory)(err.category),
                    },
                };
            }
            if (err instanceof failure_1.CancelledFailure) {
                return {
                    ...base,
                    canceledFailureInfo: {
                        details: err.details && err.details.length
                            ? { payloads: (0, payload_converter_1.toPayloads)(payloadConverter, ...err.details) }
                            : undefined,
                    },
                };
            }
            if (err instanceof failure_1.TimeoutFailure) {
                return {
                    ...base,
                    timeoutFailureInfo: {
                        timeoutType: (0, failure_1.encodeTimeoutType)(err.timeoutType),
                        lastHeartbeatDetails: err.lastHeartbeatDetails
                            ? { payloads: (0, payload_converter_1.toPayloads)(payloadConverter, err.lastHeartbeatDetails) }
                            : undefined,
                    },
                };
            }
            if (err instanceof failure_1.ServerFailure) {
                return {
                    ...base,
                    serverFailureInfo: { nonRetryable: err.nonRetryable },
                };
            }
            if (err instanceof failure_1.TerminatedFailure) {
                return {
                    ...base,
                    terminatedFailureInfo: {},
                };
            }
            if (err instanceof nexus.HandlerError) {
                let retryBehavior = undefined;
                switch (err.retryableOverride) {
                    case true:
                        retryBehavior = encodeNexusHandlerErrorRetryBehavior('RETRYABLE');
                        break;
                    case false:
                        retryBehavior = encodeNexusHandlerErrorRetryBehavior('NON_RETRYABLE');
                        break;
                }
                return {
                    // TODO(nexus/error): Maybe set a default message here, once we've decided on error handling.
                    ...base,
                    nexusHandlerFailureInfo: {
                        type: err.type,
                        retryBehavior,
                    },
                };
            }
            if (err instanceof failure_1.NexusOperationFailure) {
                return {
                    // TODO(nexus/error): Maybe set a default message here, once we've decided on error handling.
                    ...base,
                    nexusOperationExecutionFailureInfo: {
                        scheduledEventId: err.scheduledEventId ? long_1.default.fromNumber(err.scheduledEventId) : undefined,
                        endpoint: err.endpoint,
                        service: err.service,
                        operation: err.operation,
                        operationToken: err.operationToken,
                    },
                };
            }
            // Just a TemporalFailure
            return base;
        }
        const base = {
            source: failure_1.FAILURE_SOURCE,
        };
        if ((0, type_helpers_1.isError)(err)) {
            return {
                ...base,
                message: String(err.message) ?? '',
                stackTrace: cutoffStackTrace(err.stack),
                cause: this.optionalErrorToOptionalFailure(err.cause, payloadConverter),
            };
        }
        const recommendation = ` [A non-Error value was thrown from your code. We recommend throwing Error objects so that we can provide a stack trace]`;
        if (typeof err === 'string') {
            return { ...base, message: err + recommendation };
        }
        if (typeof err === 'object') {
            let message = '';
            try {
                message = JSON.stringify(err);
            }
            catch (_err) {
                message = String(err);
            }
            return { ...base, message: message + recommendation };
        }
        return { ...base, message: String(err) + recommendation };
    }
    /**
     * Converts a Failure proto message to a JS Error object if defined or returns undefined.
     */
    optionalFailureToOptionalError(failure, payloadConverter) {
        return failure ? this.failureToError(failure, payloadConverter) : undefined;
    }
    /**
     * Converts an error to a Failure proto message if defined or returns undefined
     */
    optionalErrorToOptionalFailure(err, payloadConverter) {
        return err ? this.errorToFailure(err, payloadConverter) : undefined;
    }
}
exports.DefaultFailureConverter = DefaultFailureConverter;


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/converter/payload-codec.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/converter/payload-codec.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/converter/payload-converter.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/converter/payload-converter.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultPayloadConverter = exports.DefaultPayloadConverter = exports.JsonPayloadConverter = exports.BinaryPayloadConverter = exports.UndefinedPayloadConverter = exports.CompositePayloadConverter = exports.RawValue = void 0;
exports.toPayloads = toPayloads;
exports.convertOptionalToPayload = convertOptionalToPayload;
exports.mapToPayloads = mapToPayloads;
exports.fromPayloadsAtIndex = fromPayloadsAtIndex;
exports.arrayFromPayloads = arrayFromPayloads;
exports.mapFromPayloads = mapFromPayloads;
const encoding_1 = __webpack_require__(/*! ../encoding */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/encoding.js");
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/errors.js");
const types_1 = __webpack_require__(/*! ./types */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/converter/types.js");
/**
 * Implements conversion of a list of values.
 *
 * @param converter
 * @param values JS values to convert to Payloads
 * @return list of {@link Payload}s
 * @throws {@link ValueError} if conversion of the value passed as parameter failed for any
 *     reason.
 */
function toPayloads(converter, ...values) {
    if (values.length === 0) {
        return undefined;
    }
    return values.map((value) => converter.toPayload(value));
}
/**
 * Run {@link PayloadConverter.toPayload} on an optional value, and then encode it.
 */
function convertOptionalToPayload(payloadConverter, value) {
    if (value == null)
        return value;
    return payloadConverter.toPayload(value);
}
/**
 * Run {@link PayloadConverter.toPayload} on each value in the map.
 *
 * @throws {@link ValueError} if conversion of any value in the map fails
 */
function mapToPayloads(converter, map) {
    return Object.fromEntries(Object.entries(map).map(([k, v]) => [k, converter.toPayload(v)]));
}
/**
 * Implements conversion of an array of values of different types. Useful for deserializing
 * arguments of function invocations.
 *
 * @param converter
 * @param index index of the value in the payloads
 * @param payloads serialized value to convert to JS values.
 * @return converted JS value
 * @throws {@link PayloadConverterError} if conversion of the data passed as parameter failed for any
 *     reason.
 */
function fromPayloadsAtIndex(converter, index, payloads) {
    // To make adding arguments a backwards compatible change
    if (payloads === undefined || payloads === null || index >= payloads.length) {
        return undefined;
    }
    return converter.fromPayload(payloads[index]);
}
/**
 * Run {@link PayloadConverter.fromPayload} on each value in the array.
 */
function arrayFromPayloads(converter, payloads) {
    if (!payloads) {
        return [];
    }
    return payloads.map((payload) => converter.fromPayload(payload));
}
function mapFromPayloads(converter, map) {
    if (map == null)
        return undefined;
    return Object.fromEntries(Object.entries(map).map(([k, payload]) => {
        const value = converter.fromPayload(payload);
        return [k, value];
    }));
}
/**
 * RawValue is a wrapper over a payload.
 * A payload that belongs to a RawValue is special in that it bypasses user-defined payload converters,
 * instead using the default payload converter. The payload still undergoes codec conversion.
 */
class RawValue {
    _payload;
    [exports.rawPayloadTypeBrand] = undefined;
    constructor(value, payloadConverter = exports.defaultPayloadConverter) {
        this._payload = payloadConverter.toPayload(value);
    }
    get payload() {
        return this._payload;
    }
}
exports.RawValue = RawValue;
/**
 * Tries to convert values to {@link Payload}s using the {@link PayloadConverterWithEncoding}s provided to the constructor, in the order provided.
 *
 * Converts Payloads to values based on the `Payload.metadata.encoding` field, which matches the {@link PayloadConverterWithEncoding.encodingType}
 * of the converter that created the Payload.
 */
class CompositePayloadConverter {
    converters;
    converterByEncoding = new Map();
    constructor(...converters) {
        if (converters.length === 0) {
            throw new errors_1.PayloadConverterError('Must provide at least one PayloadConverterWithEncoding');
        }
        this.converters = converters;
        for (const converter of converters) {
            this.converterByEncoding.set(converter.encodingType, converter);
        }
    }
    /**
     * Tries to run `.toPayload(value)` on each converter in the order provided at construction.
     * Returns the first successful result, throws {@link ValueError} if there is no converter that can handle the value.
     */
    toPayload(value) {
        if (value instanceof RawValue) {
            return value.payload;
        }
        for (const converter of this.converters) {
            const result = converter.toPayload(value);
            if (result !== undefined) {
                return result;
            }
        }
        throw new errors_1.ValueError(`Unable to convert ${value} to payload`);
    }
    /**
     * Run {@link PayloadConverterWithEncoding.fromPayload} based on the `encoding` metadata of the {@link Payload}.
     */
    fromPayload(payload) {
        if (payload.metadata === undefined || payload.metadata === null) {
            throw new errors_1.ValueError('Missing payload metadata');
        }
        const encoding = (0, encoding_1.decode)(payload.metadata[types_1.METADATA_ENCODING_KEY]);
        const converter = this.converterByEncoding.get(encoding);
        if (converter === undefined) {
            throw new errors_1.ValueError(`Unknown encoding: ${encoding}`);
        }
        return converter.fromPayload(payload);
    }
}
exports.CompositePayloadConverter = CompositePayloadConverter;
/**
 * Converts between JS undefined and NULL Payload
 */
class UndefinedPayloadConverter {
    encodingType = types_1.encodingTypes.METADATA_ENCODING_NULL;
    toPayload(value) {
        if (value !== undefined) {
            return undefined;
        }
        return {
            metadata: {
                [types_1.METADATA_ENCODING_KEY]: types_1.encodingKeys.METADATA_ENCODING_NULL,
            },
        };
    }
    fromPayload(_content) {
        return undefined; // Just return undefined
    }
}
exports.UndefinedPayloadConverter = UndefinedPayloadConverter;
/**
 * Converts between binary data types and RAW Payload
 */
class BinaryPayloadConverter {
    encodingType = types_1.encodingTypes.METADATA_ENCODING_RAW;
    toPayload(value) {
        if (!(value instanceof Uint8Array)) {
            return undefined;
        }
        return {
            metadata: {
                [types_1.METADATA_ENCODING_KEY]: types_1.encodingKeys.METADATA_ENCODING_RAW,
            },
            data: value,
        };
    }
    fromPayload(content) {
        return (
        // Wrap with Uint8Array from this context to ensure `instanceof` works
        (content.data ? new Uint8Array(content.data.buffer, content.data.byteOffset, content.data.length) : content.data));
    }
}
exports.BinaryPayloadConverter = BinaryPayloadConverter;
/**
 * Converts between non-undefined values and serialized JSON Payload
 */
class JsonPayloadConverter {
    encodingType = types_1.encodingTypes.METADATA_ENCODING_JSON;
    toPayload(value) {
        if (value === undefined) {
            return undefined;
        }
        let json;
        try {
            json = JSON.stringify(value);
        }
        catch (_err) {
            return undefined;
        }
        return {
            metadata: {
                [types_1.METADATA_ENCODING_KEY]: types_1.encodingKeys.METADATA_ENCODING_JSON,
            },
            data: (0, encoding_1.encode)(json),
        };
    }
    fromPayload(content) {
        if (content.data === undefined || content.data === null) {
            throw new errors_1.ValueError('Got payload with no data');
        }
        return JSON.parse((0, encoding_1.decode)(content.data));
    }
}
exports.JsonPayloadConverter = JsonPayloadConverter;
class DefaultPayloadConverter extends CompositePayloadConverter {
    // Match the order used in other SDKs, but exclude Protobuf converters so that the code, including
    // `proto3-json-serializer`, doesn't take space in Workflow bundles that don't use Protobufs. To use Protobufs, use
    // {@link DefaultPayloadConverterWithProtobufs}.
    //
    // Go SDK:
    // https://github.com/temporalio/sdk-go/blob/5e5645f0c550dcf717c095ae32c76a7087d2e985/converter/default_data_converter.go#L28
    constructor() {
        super(new UndefinedPayloadConverter(), new BinaryPayloadConverter(), new JsonPayloadConverter());
    }
}
exports.DefaultPayloadConverter = DefaultPayloadConverter;
/**
 * The default {@link PayloadConverter} used by the SDK. Supports `Uint8Array` and JSON serializables (so if
 * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#description | `JSON.stringify(yourArgOrRetval)`}
 * works, the default payload converter will work).
 *
 * To also support Protobufs, create a custom payload converter with {@link DefaultPayloadConverter}:
 *
 * `const myConverter = new DefaultPayloadConverter({ protobufRoot })`
 */
exports.defaultPayloadConverter = new DefaultPayloadConverter();


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/converter/payload-search-attributes.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/converter/payload-search-attributes.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.typedSearchAttributePayloadConverter = exports.TypedSearchAttributePayloadConverter = exports.searchAttributePayloadConverter = exports.SearchAttributePayloadConverter = void 0;
exports.encodeUnifiedSearchAttributes = encodeUnifiedSearchAttributes;
exports.decodeSearchAttributes = decodeSearchAttributes;
exports.decodeTypedSearchAttributes = decodeTypedSearchAttributes;
const encoding_1 = __webpack_require__(/*! ../encoding */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/encoding.js");
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/errors.js");
const search_attributes_1 = __webpack_require__(/*! ../search-attributes */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/search-attributes.js");
const payload_converter_1 = __webpack_require__(/*! ./payload-converter */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/converter/payload-converter.js");
/**
 * Converts Search Attribute values using JsonPayloadConverter
 */
class SearchAttributePayloadConverter {
    jsonConverter = new payload_converter_1.JsonPayloadConverter();
    validNonDateTypes = ['string', 'number', 'boolean'];
    toPayload(values) {
        if (!Array.isArray(values)) {
            throw new errors_1.ValueError(`SearchAttribute value must be an array`);
        }
        if (values.length > 0) {
            const firstValue = values[0];
            const firstType = typeof firstValue;
            if (firstType === 'object') {
                for (const [idx, value] of values.entries()) {
                    if (!(value instanceof Date)) {
                        throw new errors_1.ValueError(`SearchAttribute values must arrays of strings, numbers, booleans, or Dates. The value ${value} at index ${idx} is of type ${typeof value}`);
                    }
                }
            }
            else {
                if (!this.validNonDateTypes.includes(firstType)) {
                    throw new errors_1.ValueError(`SearchAttribute array values must be: string | number | boolean | Date`);
                }
                for (const [idx, value] of values.entries()) {
                    if (typeof value !== firstType) {
                        throw new errors_1.ValueError(`All SearchAttribute array values must be of the same type. The first value ${firstValue} of type ${firstType} doesn't match value ${value} of type ${typeof value} at index ${idx}`);
                    }
                }
            }
        }
        // JSON.stringify takes care of converting Dates to ISO strings
        const ret = this.jsonConverter.toPayload(values);
        if (ret === undefined) {
            throw new errors_1.ValueError('Could not convert search attributes to payloads');
        }
        return ret;
    }
    /**
     * Datetime Search Attribute values are converted to `Date`s
     */
    fromPayload(payload) {
        if (payload.metadata == null) {
            throw new errors_1.ValueError('Missing payload metadata');
        }
        const value = this.jsonConverter.fromPayload(payload);
        let arrayWrappedValue = Array.isArray(value) ? value : [value];
        const searchAttributeType = (0, encoding_1.decode)(payload.metadata.type);
        if (searchAttributeType === 'Datetime') {
            arrayWrappedValue = arrayWrappedValue.map((dateString) => new Date(dateString));
        }
        return arrayWrappedValue;
    }
}
exports.SearchAttributePayloadConverter = SearchAttributePayloadConverter;
exports.searchAttributePayloadConverter = new SearchAttributePayloadConverter();
class TypedSearchAttributePayloadConverter {
    jsonConverter = new payload_converter_1.JsonPayloadConverter();
    toPayload(attr) {
        if (!(attr instanceof search_attributes_1.TypedSearchAttributeValue || attr instanceof search_attributes_1.TypedSearchAttributeUpdateValue)) {
            throw new errors_1.ValueError(`Expect input to be instance of TypedSearchAttributeValue or TypedSearchAttributeUpdateValue, got: ${JSON.stringify(attr)}`);
        }
        // We check for deletion as well as regular typed search attributes.
        if (attr.value !== null && !(0, search_attributes_1.isValidValueForType)(attr.type, attr.value)) {
            throw new errors_1.ValueError(`Invalid search attribute value ${attr.value} for given type ${attr.type}`);
        }
        // For server search attributes to work properly, we cannot set the metadata
        // type when we set null
        if (attr.value === null) {
            const payload = this.jsonConverter.toPayload(attr.value);
            if (payload === undefined) {
                throw new errors_1.ValueError('Could not convert typed search attribute to payload');
            }
            return payload;
        }
        // JSON.stringify takes care of converting Dates to ISO strings
        const payload = this.jsonConverter.toPayload(attr.value);
        if (payload === undefined) {
            throw new errors_1.ValueError('Could not convert typed search attribute to payload');
        }
        // Note: this shouldn't be the case but the compiler complains without this check.
        if (payload.metadata == null) {
            throw new errors_1.ValueError('Missing payload metadata');
        }
        // Add encoded type of search attribute to metatdata
        payload.metadata['type'] = (0, encoding_1.encode)(search_attributes_1.TypedSearchAttributes.toMetadataType(attr.type));
        return payload;
    }
    // Note: type casting undefined values is not clear to caller.
    // We can't change the typing of the method to return undefined, it's not allowed by the interface.
    fromPayload(payload) {
        if (payload.metadata == null) {
            throw new errors_1.ValueError('Missing payload metadata');
        }
        // If no 'type' metadata field or no given value, we skip.
        if (payload.metadata.type == null) {
            return undefined;
        }
        const type = search_attributes_1.TypedSearchAttributes.toSearchAttributeType((0, encoding_1.decode)(payload.metadata.type));
        // Unrecognized metadata type (sanity check).
        if (type === undefined) {
            return undefined;
        }
        let value = this.jsonConverter.fromPayload(payload);
        // Handle legacy values without KEYWORD_LIST type.
        if (type !== search_attributes_1.SearchAttributeType.KEYWORD_LIST && Array.isArray(value)) {
            // Cannot have an array with multiple values for non-KEYWORD_LIST type.
            if (value.length > 1) {
                return undefined;
            }
            // Unpack single value array.
            value = value[0];
        }
        if (type === search_attributes_1.SearchAttributeType.DATETIME && value) {
            value = new Date(value);
        }
        // Check if the value is a valid for the given type. If not, skip.
        if (!(0, search_attributes_1.isValidValueForType)(type, value)) {
            return undefined;
        }
        return new search_attributes_1.TypedSearchAttributeValue(type, value);
    }
}
exports.TypedSearchAttributePayloadConverter = TypedSearchAttributePayloadConverter;
exports.typedSearchAttributePayloadConverter = new TypedSearchAttributePayloadConverter();
// If both params are provided, conflicting keys will be overwritten by typedSearchAttributes.
function encodeUnifiedSearchAttributes(searchAttributes, // eslint-disable-line deprecation/deprecation
typedSearchAttributes) {
    return {
        ...(searchAttributes ? (0, payload_converter_1.mapToPayloads)(exports.searchAttributePayloadConverter, searchAttributes) : {}),
        ...(typedSearchAttributes
            ? (0, payload_converter_1.mapToPayloads)(exports.typedSearchAttributePayloadConverter, Object.fromEntries((Array.isArray(typedSearchAttributes) ? typedSearchAttributes : typedSearchAttributes.getAll()).map((pair) => {
                return [pair.key.name, new search_attributes_1.TypedSearchAttributeUpdateValue(pair.key.type, pair.value)];
            })))
            : {}),
    };
}
// eslint-disable-next-line deprecation/deprecation
function decodeSearchAttributes(indexedFields) {
    if (!indexedFields)
        return {};
    return Object.fromEntries(
    // eslint-disable-next-line deprecation/deprecation
    Object.entries((0, payload_converter_1.mapFromPayloads)(exports.searchAttributePayloadConverter, indexedFields)).filter(([_, v]) => v && v.length > 0) // Filter out empty arrays returned by pre 1.18 servers
    );
}
function decodeTypedSearchAttributes(indexedFields) {
    return new search_attributes_1.TypedSearchAttributes(Object.entries((0, payload_converter_1.mapFromPayloads)(exports.typedSearchAttributePayloadConverter, indexedFields) ?? {}).reduce((acc, [k, attr]) => {
        // Filter out undefined values from converter.
        if (!attr) {
            return acc;
        }
        const key = { name: k, type: attr.type };
        // Ensure is valid pair.
        if ((0, search_attributes_1.isValidValueForType)(key.type, attr.value)) {
            acc.push({ key, value: attr.value });
        }
        return acc;
    }, []));
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/converter/types.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/converter/types.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.METADATA_MESSAGE_TYPE_KEY = exports.encodingKeys = exports.encodingTypes = exports.METADATA_ENCODING_KEY = void 0;
const encoding_1 = __webpack_require__(/*! ../encoding */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/encoding.js");
exports.METADATA_ENCODING_KEY = 'encoding';
exports.encodingTypes = {
    METADATA_ENCODING_NULL: 'binary/null',
    METADATA_ENCODING_RAW: 'binary/plain',
    METADATA_ENCODING_JSON: 'json/plain',
    METADATA_ENCODING_PROTOBUF_JSON: 'json/protobuf',
    METADATA_ENCODING_PROTOBUF: 'binary/protobuf',
};
exports.encodingKeys = {
    METADATA_ENCODING_NULL: (0, encoding_1.encode)(exports.encodingTypes.METADATA_ENCODING_NULL),
    METADATA_ENCODING_RAW: (0, encoding_1.encode)(exports.encodingTypes.METADATA_ENCODING_RAW),
    METADATA_ENCODING_JSON: (0, encoding_1.encode)(exports.encodingTypes.METADATA_ENCODING_JSON),
    METADATA_ENCODING_PROTOBUF_JSON: (0, encoding_1.encode)(exports.encodingTypes.METADATA_ENCODING_PROTOBUF_JSON),
    METADATA_ENCODING_PROTOBUF: (0, encoding_1.encode)(exports.encodingTypes.METADATA_ENCODING_PROTOBUF),
};
exports.METADATA_MESSAGE_TYPE_KEY = 'messageType';


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/deprecated-time.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/deprecated-time.js ***!
  \*************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.optionalTsToMs = optionalTsToMs;
exports.tsToMs = tsToMs;
exports.msNumberToTs = msNumberToTs;
exports.msToTs = msToTs;
exports.msOptionalToTs = msOptionalToTs;
exports.msOptionalToNumber = msOptionalToNumber;
exports.msToNumber = msToNumber;
exports.tsToDate = tsToDate;
exports.optionalTsToDate = optionalTsToDate;
const time = __importStar(__webpack_require__(/*! ./time */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/time.js"));
/**
 * Lossy conversion function from Timestamp to number due to possible overflow.
 * If ts is null or undefined returns undefined.
 *
 * @hidden
 * @deprecated - meant for internal use only
 */
function optionalTsToMs(ts) {
    return time.optionalTsToMs(ts);
}
/**
 * Lossy conversion function from Timestamp to number due to possible overflow
 *
 * @hidden
 * @deprecated - meant for internal use only
 * @deprecated - meant for internal use only
 */
function tsToMs(ts) {
    return time.tsToMs(ts);
}
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function msNumberToTs(millis) {
    return time.msNumberToTs(millis);
}
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function msToTs(str) {
    return time.msToTs(str);
}
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function msOptionalToTs(str) {
    return time.msOptionalToTs(str);
}
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function msOptionalToNumber(val) {
    return time.msOptionalToNumber(val);
}
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function msToNumber(val) {
    return time.msToNumber(val);
}
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function tsToDate(ts) {
    return time.tsToDate(ts);
}
/**
 * @hidden
 * @deprecated - meant for internal use only
 */
function optionalTsToDate(ts) {
    return time.optionalTsToDate(ts);
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/encoding.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/encoding.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Pasted with modifications from: https://raw.githubusercontent.com/anonyco/FastestSmallestTextEncoderDecoder/master/EncoderDecoderTogether.src.js
/* eslint no-fallthrough: 0 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextEncoder = exports.TextDecoder = void 0;
exports.encode = encode;
exports.decode = decode;
const fromCharCode = String.fromCharCode;
const encoderRegexp = /[\x80-\uD7ff\uDC00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]?/g;
const tmpBufferU16 = new Uint16Array(32);
class TextDecoder {
    decode(inputArrayOrBuffer) {
        const inputAs8 = inputArrayOrBuffer instanceof Uint8Array ? inputArrayOrBuffer : new Uint8Array(inputArrayOrBuffer);
        let resultingString = '', tmpStr = '', index = 0, nextEnd = 0, cp0 = 0, codePoint = 0, minBits = 0, cp1 = 0, pos = 0, tmp = -1;
        const len = inputAs8.length | 0;
        const lenMinus32 = (len - 32) | 0;
        // Note that tmp represents the 2nd half of a surrogate pair incase a surrogate gets divided between blocks
        for (; index < len;) {
            nextEnd = index <= lenMinus32 ? 32 : (len - index) | 0;
            for (; pos < nextEnd; index = (index + 1) | 0, pos = (pos + 1) | 0) {
                cp0 = inputAs8[index] & 0xff;
                switch (cp0 >> 4) {
                    case 15:
                        cp1 = inputAs8[(index = (index + 1) | 0)] & 0xff;
                        if (cp1 >> 6 !== 0b10 || 0b11110111 < cp0) {
                            index = (index - 1) | 0;
                            break;
                        }
                        codePoint = ((cp0 & 0b111) << 6) | (cp1 & 0b00111111);
                        minBits = 5; // 20 ensures it never passes -> all invalid replacements
                        cp0 = 0x100; //  keep track of th bit size
                    case 14:
                        cp1 = inputAs8[(index = (index + 1) | 0)] & 0xff;
                        codePoint <<= 6;
                        codePoint |= ((cp0 & 0b1111) << 6) | (cp1 & 0b00111111);
                        minBits = cp1 >> 6 === 0b10 ? (minBits + 4) | 0 : 24; // 24 ensures it never passes -> all invalid replacements
                        cp0 = (cp0 + 0x100) & 0x300; // keep track of th bit size
                    case 13:
                    case 12:
                        cp1 = inputAs8[(index = (index + 1) | 0)] & 0xff;
                        codePoint <<= 6;
                        codePoint |= ((cp0 & 0b11111) << 6) | (cp1 & 0b00111111);
                        minBits = (minBits + 7) | 0;
                        // Now, process the code point
                        if (index < len && cp1 >> 6 === 0b10 && codePoint >> minBits && codePoint < 0x110000) {
                            cp0 = codePoint;
                            codePoint = (codePoint - 0x10000) | 0;
                            if (0 <= codePoint /*0xffff < codePoint*/) {
                                // BMP code point
                                //nextEnd = nextEnd - 1|0;
                                tmp = ((codePoint >> 10) + 0xd800) | 0; // highSurrogate
                                cp0 = ((codePoint & 0x3ff) + 0xdc00) | 0; // lowSurrogate (will be inserted later in the switch-statement)
                                if (pos < 31) {
                                    // notice 31 instead of 32
                                    tmpBufferU16[pos] = tmp;
                                    pos = (pos + 1) | 0;
                                    tmp = -1;
                                }
                                else {
                                    // else, we are at the end of the inputAs8 and let tmp0 be filled in later on
                                    // NOTE that cp1 is being used as a temporary variable for the swapping of tmp with cp0
                                    cp1 = tmp;
                                    tmp = cp0;
                                    cp0 = cp1;
                                }
                            }
                            else
                                nextEnd = (nextEnd + 1) | 0; // because we are advancing i without advancing pos
                        }
                        else {
                            // invalid code point means replacing the whole thing with null replacement characters
                            cp0 >>= 8;
                            index = (index - cp0 - 1) | 0; // reset index  back to what it was before
                            cp0 = 0xfffd;
                        }
                        // Finally, reset the variables for the next go-around
                        minBits = 0;
                        codePoint = 0;
                        nextEnd = index <= lenMinus32 ? 32 : (len - index) | 0;
                    /*case 11:
                  case 10:
                  case 9:
                  case 8:
                    codePoint ? codePoint = 0 : cp0 = 0xfffd; // fill with invalid replacement character
                  case 7:
                  case 6:
                  case 5:
                  case 4:
                  case 3:
                  case 2:
                  case 1:
                  case 0:
                    tmpBufferU16[pos] = cp0;
                    continue;*/
                    default: // fill with invalid replacement character
                        tmpBufferU16[pos] = cp0;
                        continue;
                    case 11:
                    case 10:
                    case 9:
                    case 8:
                }
                tmpBufferU16[pos] = 0xfffd; // fill with invalid replacement character
            }
            tmpStr += fromCharCode(tmpBufferU16[0], tmpBufferU16[1], tmpBufferU16[2], tmpBufferU16[3], tmpBufferU16[4], tmpBufferU16[5], tmpBufferU16[6], tmpBufferU16[7], tmpBufferU16[8], tmpBufferU16[9], tmpBufferU16[10], tmpBufferU16[11], tmpBufferU16[12], tmpBufferU16[13], tmpBufferU16[14], tmpBufferU16[15], tmpBufferU16[16], tmpBufferU16[17], tmpBufferU16[18], tmpBufferU16[19], tmpBufferU16[20], tmpBufferU16[21], tmpBufferU16[22], tmpBufferU16[23], tmpBufferU16[24], tmpBufferU16[25], tmpBufferU16[26], tmpBufferU16[27], tmpBufferU16[28], tmpBufferU16[29], tmpBufferU16[30], tmpBufferU16[31]);
            if (pos < 32)
                tmpStr = tmpStr.slice(0, (pos - 32) | 0); //-(32-pos));
            if (index < len) {
                //fromCharCode.apply(0, tmpBufferU16 : Uint8Array ?  tmpBufferU16.subarray(0,pos) : tmpBufferU16.slice(0,pos));
                tmpBufferU16[0] = tmp;
                pos = ~tmp >>> 31; //tmp !== -1 ? 1 : 0;
                tmp = -1;
                if (tmpStr.length < resultingString.length)
                    continue;
            }
            else if (tmp !== -1) {
                tmpStr += fromCharCode(tmp);
            }
            resultingString += tmpStr;
            tmpStr = '';
        }
        return resultingString;
    }
}
exports.TextDecoder = TextDecoder;
//////////////////////////////////////////////////////////////////////////////////////
function encoderReplacer(nonAsciiChars) {
    // make the UTF string into a binary UTF-8 encoded string
    let point = nonAsciiChars.charCodeAt(0) | 0;
    if (0xd800 <= point) {
        if (point <= 0xdbff) {
            const nextcode = nonAsciiChars.charCodeAt(1) | 0; // defaults to 0 when NaN, causing null replacement character
            if (0xdc00 <= nextcode && nextcode <= 0xdfff) {
                //point = ((point - 0xD800)<<10) + nextcode - 0xDC00 + 0x10000|0;
                point = ((point << 10) + nextcode - 0x35fdc00) | 0;
                if (point > 0xffff)
                    return fromCharCode((0x1e /*0b11110*/ << 3) | (point >> 18), (0x2 /*0b10*/ << 6) | ((point >> 12) & 0x3f) /*0b00111111*/, (0x2 /*0b10*/ << 6) | ((point >> 6) & 0x3f) /*0b00111111*/, (0x2 /*0b10*/ << 6) | (point & 0x3f) /*0b00111111*/);
            }
            else
                point = 65533 /*0b1111111111111101*/; //return '\xEF\xBF\xBD';//fromCharCode(0xef, 0xbf, 0xbd);
        }
        else if (point <= 0xdfff) {
            point = 65533 /*0b1111111111111101*/; //return '\xEF\xBF\xBD';//fromCharCode(0xef, 0xbf, 0xbd);
        }
    }
    /*if (point <= 0x007f) return nonAsciiChars;
    else */ if (point <= 0x07ff) {
        return fromCharCode((0x6 << 5) | (point >> 6), (0x2 << 6) | (point & 0x3f));
    }
    else
        return fromCharCode((0xe /*0b1110*/ << 4) | (point >> 12), (0x2 /*0b10*/ << 6) | ((point >> 6) & 0x3f) /*0b00111111*/, (0x2 /*0b10*/ << 6) | (point & 0x3f) /*0b00111111*/);
}
class TextEncoder {
    encode(inputString) {
        // 0xc0 => 0b11000000; 0xff => 0b11111111; 0xc0-0xff => 0b11xxxxxx
        // 0x80 => 0b10000000; 0xbf => 0b10111111; 0x80-0xbf => 0b10xxxxxx
        const encodedString = inputString === void 0 ? '' : '' + inputString, len = encodedString.length | 0;
        let result = new Uint8Array(((len << 1) + 8) | 0);
        let tmpResult;
        let i = 0, pos = 0, point = 0, nextcode = 0;
        let upgradededArraySize = !Uint8Array; // normal arrays are auto-expanding
        for (i = 0; i < len; i = (i + 1) | 0, pos = (pos + 1) | 0) {
            point = encodedString.charCodeAt(i) | 0;
            if (point <= 0x007f) {
                result[pos] = point;
            }
            else if (point <= 0x07ff) {
                result[pos] = (0x6 << 5) | (point >> 6);
                result[(pos = (pos + 1) | 0)] = (0x2 << 6) | (point & 0x3f);
            }
            else {
                widenCheck: {
                    if (0xd800 <= point) {
                        if (point <= 0xdbff) {
                            nextcode = encodedString.charCodeAt((i = (i + 1) | 0)) | 0; // defaults to 0 when NaN, causing null replacement character
                            if (0xdc00 <= nextcode && nextcode <= 0xdfff) {
                                //point = ((point - 0xD800)<<10) + nextcode - 0xDC00 + 0x10000|0;
                                point = ((point << 10) + nextcode - 0x35fdc00) | 0;
                                if (point > 0xffff) {
                                    result[pos] = (0x1e /*0b11110*/ << 3) | (point >> 18);
                                    result[(pos = (pos + 1) | 0)] = (0x2 /*0b10*/ << 6) | ((point >> 12) & 0x3f) /*0b00111111*/;
                                    result[(pos = (pos + 1) | 0)] = (0x2 /*0b10*/ << 6) | ((point >> 6) & 0x3f) /*0b00111111*/;
                                    result[(pos = (pos + 1) | 0)] = (0x2 /*0b10*/ << 6) | (point & 0x3f) /*0b00111111*/;
                                    continue;
                                }
                                break widenCheck;
                            }
                            point = 65533 /*0b1111111111111101*/; //return '\xEF\xBF\xBD';//fromCharCode(0xef, 0xbf, 0xbd);
                        }
                        else if (point <= 0xdfff) {
                            point = 65533 /*0b1111111111111101*/; //return '\xEF\xBF\xBD';//fromCharCode(0xef, 0xbf, 0xbd);
                        }
                    }
                    if (!upgradededArraySize && i << 1 < pos && i << 1 < ((pos - 7) | 0)) {
                        upgradededArraySize = true;
                        tmpResult = new Uint8Array(len * 3);
                        tmpResult.set(result);
                        result = tmpResult;
                    }
                }
                result[pos] = (0xe /*0b1110*/ << 4) | (point >> 12);
                result[(pos = (pos + 1) | 0)] = (0x2 /*0b10*/ << 6) | ((point >> 6) & 0x3f) /*0b00111111*/;
                result[(pos = (pos + 1) | 0)] = (0x2 /*0b10*/ << 6) | (point & 0x3f) /*0b00111111*/;
            }
        }
        return Uint8Array ? result.subarray(0, pos) : result.slice(0, pos);
    }
    encodeInto(inputString, u8Arr) {
        const encodedString = inputString === void 0 ? '' : ('' + inputString).replace(encoderRegexp, encoderReplacer);
        let len = encodedString.length | 0, i = 0, char = 0, read = 0;
        const u8ArrLen = u8Arr.length | 0;
        const inputLength = inputString.length | 0;
        if (u8ArrLen < len)
            len = u8ArrLen;
        putChars: {
            for (; i < len; i = (i + 1) | 0) {
                char = encodedString.charCodeAt(i) | 0;
                switch (char >> 4) {
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                        read = (read + 1) | 0;
                    // extension points:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                        break;
                    case 12:
                    case 13:
                        if (((i + 1) | 0) < u8ArrLen) {
                            read = (read + 1) | 0;
                            break;
                        }
                    case 14:
                        if (((i + 2) | 0) < u8ArrLen) {
                            //if (!(char === 0xEF && encodedString.substr(i+1|0,2) === "\xBF\xBD"))
                            read = (read + 1) | 0;
                            break;
                        }
                    case 15:
                        if (((i + 3) | 0) < u8ArrLen) {
                            read = (read + 1) | 0;
                            break;
                        }
                    default:
                        break putChars;
                }
                //read = read + ((char >> 6) !== 2) |0;
                u8Arr[i] = char;
            }
        }
        return { written: i, read: inputLength < read ? inputLength : read };
    }
}
exports.TextEncoder = TextEncoder;
/**
 * Encode a UTF-8 string into a Uint8Array
 */
function encode(s) {
    return TextEncoder.prototype.encode(s);
}
/**
 * Decode a Uint8Array into a UTF-8 string
 */
function decode(a) {
    return TextDecoder.prototype.decode(a);
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/errors.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/errors.js ***!
  \****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NamespaceNotFoundError = exports.WorkflowNotFoundError = exports.IllegalStateError = exports.PayloadConverterError = exports.ValueError = void 0;
const type_helpers_1 = __webpack_require__(/*! ./type-helpers */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/type-helpers.js");
/**
 * Thrown from code that receives a value that is unexpected or that it's unable to handle.
 */
let ValueError = class ValueError extends Error {
    cause;
    constructor(message, cause) {
        super(message ?? undefined);
        this.cause = cause;
    }
};
exports.ValueError = ValueError;
exports.ValueError = ValueError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('ValueError')
], ValueError);
/**
 * Thrown when a Payload Converter is misconfigured.
 */
let PayloadConverterError = class PayloadConverterError extends ValueError {
};
exports.PayloadConverterError = PayloadConverterError;
exports.PayloadConverterError = PayloadConverterError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('PayloadConverterError')
], PayloadConverterError);
/**
 * Signals that a requested operation can't be completed because it is illegal given the
 * current state of the object; e.g. trying to use a resource after it has been closed.
 */
let IllegalStateError = class IllegalStateError extends Error {
};
exports.IllegalStateError = IllegalStateError;
exports.IllegalStateError = IllegalStateError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('IllegalStateError')
], IllegalStateError);
/**
 * Thrown when a Workflow with the given Id is not known to Temporal Server.
 * It could be because:
 * - Id passed is incorrect
 * - Workflow is closed (for some calls, e.g. `terminate`)
 * - Workflow was deleted from the Server after reaching its retention limit
 */
let WorkflowNotFoundError = class WorkflowNotFoundError extends Error {
    workflowId;
    runId;
    constructor(message, workflowId, runId) {
        super(message);
        this.workflowId = workflowId;
        this.runId = runId;
    }
};
exports.WorkflowNotFoundError = WorkflowNotFoundError;
exports.WorkflowNotFoundError = WorkflowNotFoundError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('WorkflowNotFoundError')
], WorkflowNotFoundError);
/**
 * Thrown when the specified namespace is not known to Temporal Server.
 */
let NamespaceNotFoundError = class NamespaceNotFoundError extends Error {
    namespace;
    constructor(namespace) {
        super(`Namespace not found: '${namespace}'`);
        this.namespace = namespace;
    }
};
exports.NamespaceNotFoundError = NamespaceNotFoundError;
exports.NamespaceNotFoundError = NamespaceNotFoundError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('NamespaceNotFoundError')
], NamespaceNotFoundError);


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/failure.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/failure.js ***!
  \*****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var _a, _b, _c;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkflowExecutionAlreadyStartedError = exports.NexusOperationFailure = exports.ChildWorkflowFailure = exports.ActivityFailure = exports.TimeoutFailure = exports.TerminatedFailure = exports.CancelledFailure = exports.ApplicationFailure = exports.ServerFailure = exports.TemporalFailure = exports.decodeApplicationFailureCategory = exports.encodeApplicationFailureCategory = exports.ApplicationFailureCategory = exports.decodeRetryState = exports.encodeRetryState = exports.RetryState = exports.decodeTimeoutType = exports.encodeTimeoutType = exports.TimeoutType = exports.FAILURE_SOURCE = void 0;
exports.ensureApplicationFailure = ensureApplicationFailure;
exports.ensureTemporalFailure = ensureTemporalFailure;
exports.rootCause = rootCause;
const type_helpers_1 = __webpack_require__(/*! ./type-helpers */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/type-helpers.js");
const internal_workflow_1 = __webpack_require__(/*! ./internal-workflow */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/internal-workflow/index.js");
exports.FAILURE_SOURCE = 'TypeScriptSDK';
exports.TimeoutType = {
    START_TO_CLOSE: 'START_TO_CLOSE',
    SCHEDULE_TO_START: 'SCHEDULE_TO_START',
    SCHEDULE_TO_CLOSE: 'SCHEDULE_TO_CLOSE',
    HEARTBEAT: 'HEARTBEAT',
    /** @deprecated Use {@link START_TO_CLOSE} instead. */
    TIMEOUT_TYPE_START_TO_CLOSE: 'START_TO_CLOSE', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use {@link SCHEDULE_TO_START} instead. */
    TIMEOUT_TYPE_SCHEDULE_TO_START: 'SCHEDULE_TO_START', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use {@link SCHEDULE_TO_CLOSE} instead. */
    TIMEOUT_TYPE_SCHEDULE_TO_CLOSE: 'SCHEDULE_TO_CLOSE', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use {@link HEARTBEAT} instead. */
    TIMEOUT_TYPE_HEARTBEAT: 'HEARTBEAT', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use `undefined` instead. */
    TIMEOUT_TYPE_UNSPECIFIED: undefined, // eslint-disable-line deprecation/deprecation
};
_a = (0, internal_workflow_1.makeProtoEnumConverters)({
    [exports.TimeoutType.START_TO_CLOSE]: 1,
    [exports.TimeoutType.SCHEDULE_TO_START]: 2,
    [exports.TimeoutType.SCHEDULE_TO_CLOSE]: 3,
    [exports.TimeoutType.HEARTBEAT]: 4,
    UNSPECIFIED: 0,
}, 'TIMEOUT_TYPE_'), exports.encodeTimeoutType = _a[0], exports.decodeTimeoutType = _a[1];
exports.RetryState = {
    IN_PROGRESS: 'IN_PROGRESS',
    NON_RETRYABLE_FAILURE: 'NON_RETRYABLE_FAILURE',
    TIMEOUT: 'TIMEOUT',
    MAXIMUM_ATTEMPTS_REACHED: 'MAXIMUM_ATTEMPTS_REACHED',
    RETRY_POLICY_NOT_SET: 'RETRY_POLICY_NOT_SET',
    INTERNAL_SERVER_ERROR: 'INTERNAL_SERVER_ERROR',
    CANCEL_REQUESTED: 'CANCEL_REQUESTED',
    /** @deprecated Use {@link IN_PROGRESS} instead. */
    RETRY_STATE_IN_PROGRESS: 'IN_PROGRESS', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use {@link NON_RETRYABLE_FAILURE} instead. */
    RETRY_STATE_NON_RETRYABLE_FAILURE: 'NON_RETRYABLE_FAILURE', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use {@link TIMEOUT} instead. */
    RETRY_STATE_TIMEOUT: 'TIMEOUT', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use {@link MAXIMUM_ATTEMPTS_REACHED} instead. */
    RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED: 'MAXIMUM_ATTEMPTS_REACHED', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use {@link RETRY_POLICY_NOT_SET} instead. */
    RETRY_STATE_RETRY_POLICY_NOT_SET: 'RETRY_POLICY_NOT_SET', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use {@link INTERNAL_SERVER_ERROR} instead. */
    RETRY_STATE_INTERNAL_SERVER_ERROR: 'INTERNAL_SERVER_ERROR', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use {@link CANCEL_REQUESTED} instead. */
    RETRY_STATE_CANCEL_REQUESTED: 'CANCEL_REQUESTED', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use `undefined` instead. */
    RETRY_STATE_UNSPECIFIED: undefined, // eslint-disable-line deprecation/deprecation
};
_b = (0, internal_workflow_1.makeProtoEnumConverters)({
    [exports.RetryState.IN_PROGRESS]: 1,
    [exports.RetryState.NON_RETRYABLE_FAILURE]: 2,
    [exports.RetryState.TIMEOUT]: 3,
    [exports.RetryState.MAXIMUM_ATTEMPTS_REACHED]: 4,
    [exports.RetryState.RETRY_POLICY_NOT_SET]: 5,
    [exports.RetryState.INTERNAL_SERVER_ERROR]: 6,
    [exports.RetryState.CANCEL_REQUESTED]: 7,
    UNSPECIFIED: 0,
}, 'RETRY_STATE_'), exports.encodeRetryState = _b[0], exports.decodeRetryState = _b[1];
/**
 * A category to describe the severity and change the observability behavior of an application failure.
 *
 * Currently, observability behaviour changes are limited to:
 * - activities that fail due to a BENIGN application failure emit DEBUG level logs and do not record metrics
 *
 * @experimental Category is a new feature and may be subject to change.
 */
exports.ApplicationFailureCategory = {
    BENIGN: 'BENIGN',
};
_c = (0, internal_workflow_1.makeProtoEnumConverters)({
    [exports.ApplicationFailureCategory.BENIGN]: 1,
    UNSPECIFIED: 0,
}, 'APPLICATION_ERROR_CATEGORY_'), exports.encodeApplicationFailureCategory = _c[0], exports.decodeApplicationFailureCategory = _c[1];
/**
 * Represents failures that can cross Workflow and Activity boundaries.
 *
 * **Never extend this class or any of its children.**
 *
 * The only child class you should ever throw from your code is {@link ApplicationFailure}.
 */
let TemporalFailure = class TemporalFailure extends Error {
    cause;
    /**
     * The original failure that constructed this error.
     *
     * Only present if this error was generated from an external operation.
     */
    failure;
    constructor(message, cause) {
        super(message ?? undefined);
        this.cause = cause;
    }
};
exports.TemporalFailure = TemporalFailure;
exports.TemporalFailure = TemporalFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('TemporalFailure')
], TemporalFailure);
/** Exceptions originated at the Temporal service. */
let ServerFailure = class ServerFailure extends TemporalFailure {
    nonRetryable;
    constructor(message, nonRetryable, cause) {
        super(message, cause);
        this.nonRetryable = nonRetryable;
    }
};
exports.ServerFailure = ServerFailure;
exports.ServerFailure = ServerFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('ServerFailure')
], ServerFailure);
/**
 * `ApplicationFailure`s are used to communicate application-specific failures in Workflows and Activities.
 *
 * The {@link type} property is matched against {@link RetryPolicy.nonRetryableErrorTypes} to determine if an instance
 * of this error is retryable. Another way to avoid retrying is by setting the {@link nonRetryable} flag to `true`.
 *
 * In Workflows, if you throw a non-`ApplicationFailure`, the Workflow Task will fail and be retried. If you throw an
 * `ApplicationFailure`, the Workflow Execution will fail.
 *
 * In Activities, you can either throw an `ApplicationFailure` or another `Error` to fail the Activity Task. In the
 * latter case, the `Error` will be converted to an `ApplicationFailure`. The conversion is done as following:
 *
 * - `type` is set to `error.constructor?.name ?? error.name`
 * - `message` is set to `error.message`
 * - `nonRetryable` is set to false
 * - `details` are set to null
 * - stack trace is copied from the original error
 *
 * When an {@link https://docs.temporal.io/concepts/what-is-an-activity-execution | Activity Execution} fails, the
 * `ApplicationFailure` from the last Activity Task will be the `cause` of the {@link ActivityFailure} thrown in the
 * Workflow.
 */
let ApplicationFailure = class ApplicationFailure extends TemporalFailure {
    type;
    nonRetryable;
    details;
    nextRetryDelay;
    category;
    /**
     * Alternatively, use {@link fromError} or {@link create}.
     */
    constructor(message, type, nonRetryable, details, cause, nextRetryDelay, category) {
        super(message, cause);
        this.type = type;
        this.nonRetryable = nonRetryable;
        this.details = details;
        this.nextRetryDelay = nextRetryDelay;
        this.category = category;
    }
    /**
     * Create a new `ApplicationFailure` from an Error object.
     *
     * First calls {@link ensureApplicationFailure | `ensureApplicationFailure(error)`} and then overrides any fields
     * provided in `overrides`.
     */
    static fromError(error, overrides) {
        const failure = ensureApplicationFailure(error);
        Object.assign(failure, overrides);
        return failure;
    }
    /**
     * Create a new `ApplicationFailure`.
     *
     * By default, will be retryable (unless its `type` is included in {@link RetryPolicy.nonRetryableErrorTypes}).
     */
    static create(options) {
        const { message, type, nonRetryable = false, details, nextRetryDelay, cause, category } = options;
        return new this(message, type, nonRetryable, details, cause, nextRetryDelay, category);
    }
    /**
     * Get a new `ApplicationFailure` with the {@link nonRetryable} flag set to false. Note that this error will still
     * not be retried if its `type` is included in {@link RetryPolicy.nonRetryableErrorTypes}.
     *
     * @param message Optional error message
     * @param type Optional error type (used by {@link RetryPolicy.nonRetryableErrorTypes})
     * @param details Optional details about the failure. Serialized by the Worker's {@link PayloadConverter}.
     */
    static retryable(message, type, ...details) {
        return new this(message, type ?? 'Error', false, details);
    }
    /**
     * Get a new `ApplicationFailure` with the {@link nonRetryable} flag set to true.
     *
     * When thrown from an Activity or Workflow, the Activity or Workflow will not be retried (even if `type` is not
     * listed in {@link RetryPolicy.nonRetryableErrorTypes}).
     *
     * @param message Optional error message
     * @param type Optional error type
     * @param details Optional details about the failure. Serialized by the Worker's {@link PayloadConverter}.
     */
    static nonRetryable(message, type, ...details) {
        return new this(message, type ?? 'Error', true, details);
    }
};
exports.ApplicationFailure = ApplicationFailure;
exports.ApplicationFailure = ApplicationFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('ApplicationFailure')
], ApplicationFailure);
/**
 * This error is thrown when Cancellation has been requested. To allow Cancellation to happen, let it propagate. To
 * ignore Cancellation, catch it and continue executing. Note that Cancellation can only be requested a single time, so
 * your Workflow/Activity Execution will not receive further Cancellation requests.
 *
 * When a Workflow or Activity has been successfully cancelled, a `CancelledFailure` will be the `cause`.
 */
let CancelledFailure = class CancelledFailure extends TemporalFailure {
    details;
    constructor(message, details = [], cause) {
        super(message, cause);
        this.details = details;
    }
};
exports.CancelledFailure = CancelledFailure;
exports.CancelledFailure = CancelledFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('CancelledFailure')
], CancelledFailure);
/**
 * Used as the `cause` when a Workflow has been terminated
 */
let TerminatedFailure = class TerminatedFailure extends TemporalFailure {
    constructor(message, cause) {
        super(message, cause);
    }
};
exports.TerminatedFailure = TerminatedFailure;
exports.TerminatedFailure = TerminatedFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('TerminatedFailure')
], TerminatedFailure);
/**
 * Used to represent timeouts of Activities and Workflows
 */
let TimeoutFailure = class TimeoutFailure extends TemporalFailure {
    lastHeartbeatDetails;
    timeoutType;
    constructor(message, lastHeartbeatDetails, timeoutType) {
        super(message);
        this.lastHeartbeatDetails = lastHeartbeatDetails;
        this.timeoutType = timeoutType;
    }
};
exports.TimeoutFailure = TimeoutFailure;
exports.TimeoutFailure = TimeoutFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('TimeoutFailure')
], TimeoutFailure);
/**
 * Contains information about an Activity failure. Always contains the original reason for the failure as its `cause`.
 * For example, if an Activity timed out, the cause will be a {@link TimeoutFailure}.
 *
 * This exception is expected to be thrown only by the framework code.
 */
let ActivityFailure = class ActivityFailure extends TemporalFailure {
    activityType;
    activityId;
    retryState;
    identity;
    constructor(message, activityType, activityId, retryState, identity, cause) {
        super(message, cause);
        this.activityType = activityType;
        this.activityId = activityId;
        this.retryState = retryState;
        this.identity = identity;
    }
};
exports.ActivityFailure = ActivityFailure;
exports.ActivityFailure = ActivityFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('ActivityFailure')
], ActivityFailure);
/**
 * Contains information about a Child Workflow failure. Always contains the reason for the failure as its {@link cause}.
 * For example, if the Child was Terminated, the `cause` is a {@link TerminatedFailure}.
 *
 * This exception is expected to be thrown only by the framework code.
 */
let ChildWorkflowFailure = class ChildWorkflowFailure extends TemporalFailure {
    namespace;
    execution;
    workflowType;
    retryState;
    constructor(namespace, execution, workflowType, retryState, cause) {
        super('Child Workflow execution failed', cause);
        this.namespace = namespace;
        this.execution = execution;
        this.workflowType = workflowType;
        this.retryState = retryState;
    }
};
exports.ChildWorkflowFailure = ChildWorkflowFailure;
exports.ChildWorkflowFailure = ChildWorkflowFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('ChildWorkflowFailure')
], ChildWorkflowFailure);
/**
 * Thrown when a Nexus Operation executed inside a Workflow fails.
 *
 * @experimental Nexus support in Temporal SDK is experimental.
 */
let NexusOperationFailure = class NexusOperationFailure extends TemporalFailure {
    scheduledEventId;
    endpoint;
    service;
    operation;
    operationToken;
    constructor(message, scheduledEventId, endpoint, service, operation, operationToken, cause) {
        super(message, cause);
        this.scheduledEventId = scheduledEventId;
        this.endpoint = endpoint;
        this.service = service;
        this.operation = operation;
        this.operationToken = operationToken;
    }
};
exports.NexusOperationFailure = NexusOperationFailure;
exports.NexusOperationFailure = NexusOperationFailure = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('NexusOperationFailure')
], NexusOperationFailure);
// TODO(nexus/error): Maybe add a NexusHandlerFailure class here, once we've decided on error handling.
/**
 * This exception is thrown in the following cases:
 *  - Workflow with the same Workflow ID is currently running and the {@link WorkflowOptions.workflowIdConflictPolicy} is `WORKFLOW_ID_CONFLICT_POLICY_FAIL`
 *  - There is a closed Workflow with the same Workflow Id and the {@link WorkflowOptions.workflowIdReusePolicy}
 *    is `WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE`
 *  - There is closed Workflow in the `Completed` state with the same Workflow Id and the {@link WorkflowOptions.workflowIdReusePolicy}
 *    is `WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY`
 */
let WorkflowExecutionAlreadyStartedError = class WorkflowExecutionAlreadyStartedError extends TemporalFailure {
    workflowId;
    workflowType;
    constructor(message, workflowId, workflowType) {
        super(message);
        this.workflowId = workflowId;
        this.workflowType = workflowType;
    }
};
exports.WorkflowExecutionAlreadyStartedError = WorkflowExecutionAlreadyStartedError;
exports.WorkflowExecutionAlreadyStartedError = WorkflowExecutionAlreadyStartedError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('WorkflowExecutionAlreadyStartedError')
], WorkflowExecutionAlreadyStartedError);
/**
 * If `error` is already an `ApplicationFailure`, returns `error`.
 *
 * Otherwise, converts `error` into an `ApplicationFailure` with:
 *
 * - `message`: `error.message` or `String(error)`
 * - `type`: `error.constructor.name` or `error.name`
 * - `stack`: `error.stack` or `''`
 */
function ensureApplicationFailure(error) {
    if (error instanceof ApplicationFailure) {
        return error;
    }
    const message = ((0, type_helpers_1.isRecord)(error) && String(error.message)) || String(error);
    const type = ((0, type_helpers_1.isRecord)(error) && (error.constructor?.name ?? error.name)) || undefined;
    const failure = ApplicationFailure.create({ message, type, nonRetryable: false });
    failure.stack = ((0, type_helpers_1.isRecord)(error) && String(error.stack)) || '';
    return failure;
}
/**
 * If `err` is an Error it is turned into an `ApplicationFailure`.
 *
 * If `err` was already a `TemporalFailure`, returns the original error.
 *
 * Otherwise returns an `ApplicationFailure` with `String(err)` as the message.
 */
function ensureTemporalFailure(err) {
    if (err instanceof TemporalFailure) {
        return err;
    }
    return ensureApplicationFailure(err);
}
/**
 * Get the root cause message of given `error`.
 *
 * In case `error` is a {@link TemporalFailure}, recurse the `cause` chain and return the root `cause.message`.
 * Otherwise, return `error.message`.
 */
function rootCause(error) {
    if (error instanceof TemporalFailure) {
        return error.cause ? rootCause(error.cause) : error.message;
    }
    return (0, type_helpers_1.errorMessage)(error);
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/index.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/index.js ***!
  \***************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * Common library for code that's used across the Client, Worker, and/or Workflow
 *
 * @module
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defineSearchAttributeKey = exports.TypedSearchAttributes = exports.SearchAttributeType = exports.ActivityCancellationDetails = void 0;
exports.u8 = u8;
exports.str = str;
exports.errorMessage = errorMessage;
exports.errorCode = errorCode;
const encoding = __importStar(__webpack_require__(/*! ./encoding */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/encoding.js"));
const helpers = __importStar(__webpack_require__(/*! ./type-helpers */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/type-helpers.js"));
__exportStar(__webpack_require__(/*! ./activity-options */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/activity-options.js"), exports);
var activity_cancellation_details_1 = __webpack_require__(/*! ./activity-cancellation-details */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/activity-cancellation-details.js");
Object.defineProperty(exports, "ActivityCancellationDetails", ({ enumerable: true, get: function () { return activity_cancellation_details_1.ActivityCancellationDetails; } }));
__exportStar(__webpack_require__(/*! ./converter/data-converter */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/converter/data-converter.js"), exports);
__exportStar(__webpack_require__(/*! ./converter/failure-converter */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/converter/failure-converter.js"), exports);
__exportStar(__webpack_require__(/*! ./converter/payload-codec */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/converter/payload-codec.js"), exports);
__exportStar(__webpack_require__(/*! ./converter/payload-converter */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/converter/payload-converter.js"), exports);
__exportStar(__webpack_require__(/*! ./converter/types */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/converter/types.js"), exports);
__exportStar(__webpack_require__(/*! ./deprecated-time */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/deprecated-time.js"), exports);
__exportStar(__webpack_require__(/*! ./errors */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/errors.js"), exports);
__exportStar(__webpack_require__(/*! ./failure */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/failure.js"), exports);
__exportStar(__webpack_require__(/*! ./interfaces */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/interfaces.js"), exports);
__exportStar(__webpack_require__(/*! ./logger */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/logger.js"), exports);
__exportStar(__webpack_require__(/*! ./priority */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/priority.js"), exports);
__exportStar(__webpack_require__(/*! ./metrics */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/metrics.js"), exports);
__exportStar(__webpack_require__(/*! ./retry-policy */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/retry-policy.js"), exports);
__exportStar(__webpack_require__(/*! ./worker-deployments */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/worker-deployments.js"), exports);
__exportStar(__webpack_require__(/*! ./workflow-definition-options */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/workflow-definition-options.js"), exports);
__exportStar(__webpack_require__(/*! ./workflow-handle */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/workflow-handle.js"), exports);
__exportStar(__webpack_require__(/*! ./workflow-options */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/workflow-options.js"), exports);
__exportStar(__webpack_require__(/*! ./versioning-intent */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/versioning-intent.js"), exports);
var search_attributes_1 = __webpack_require__(/*! ./search-attributes */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/search-attributes.js");
Object.defineProperty(exports, "SearchAttributeType", ({ enumerable: true, get: function () { return search_attributes_1.SearchAttributeType; } }));
Object.defineProperty(exports, "TypedSearchAttributes", ({ enumerable: true, get: function () { return search_attributes_1.TypedSearchAttributes; } }));
Object.defineProperty(exports, "defineSearchAttributeKey", ({ enumerable: true, get: function () { return search_attributes_1.defineSearchAttributeKey; } }));
/**
 * Encode a UTF-8 string into a Uint8Array
 *
 * @hidden
 * @deprecated - meant for internal use only
 */
function u8(s) {
    return encoding.encode(s);
}
/**
 * Decode a Uint8Array into a UTF-8 string
 *
 * @hidden
 * @deprecated - meant for internal use only
 */
function str(arr) {
    return encoding.decode(arr);
}
/**
 * Get `error.message` (or `undefined` if not present)
 *
 * @hidden
 * @deprecated - meant for internal use only
 */
function errorMessage(error) {
    return helpers.errorMessage(error);
}
/**
 * Get `error.code` (or `undefined` if not present)
 *
 * @hidden
 * @deprecated - meant for internal use only
 */
function errorCode(error) {
    return helpers.errorCode(error);
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/interceptors.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/interceptors.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.composeInterceptors = composeInterceptors;
/**
 * Compose all interceptor methods into a single function.
 *
 * Calling the composed function results in calling each of the provided interceptor, in order (from the first to
 * the last), followed by the original function provided as argument to `composeInterceptors()`.
 *
 * @param interceptors a list of interceptors
 * @param method the name of the interceptor method to compose
 * @param next the original function to be executed at the end of the interception chain
 */
// ts-prune-ignore-next (imported via lib/interceptors)
function composeInterceptors(interceptors, method, next) {
    for (let i = interceptors.length - 1; i >= 0; --i) {
        const interceptor = interceptors[i];
        if (interceptor[method] !== undefined) {
            const prev = next;
            // We lose type safety here because Typescript can't deduce that interceptor[method] is a function that returns
            // the same type as Next<I, M>
            next = ((input) => interceptor[method](input, prev));
        }
    }
    return next;
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/interfaces.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/interfaces.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HandlerUnfinishedPolicy = void 0;
/**
 * Policy defining actions taken when a workflow exits while update or signal handlers are running.
 * The workflow exit may be due to successful return, failure, cancellation, or continue-as-new.
 */
exports.HandlerUnfinishedPolicy = {
    /**
     * Issue a warning in addition to abandoning the handler execution. The warning will not be issued if the workflow fails.
     */
    WARN_AND_ABANDON: 'WARN_AND_ABANDON',
    /**
     * Abandon the handler execution.
     *
     * In the case of an update handler this means that the client will receive an error rather than
     * the update result.
     */
    ABANDON: 'ABANDON',
};


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/internal-workflow/enums-helpers.js":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/internal-workflow/enums-helpers.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.makeProtoEnumConverters = makeProtoEnumConverters;
const errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/errors.js");
/**
 * Create encoding and decoding functions to convert between the numeric `enum` types produced by our
 * Protobuf compiler and "const object of strings" enum values that we expose in our public APIs.
 *
 * ### Usage
 *
 * Newly introduced enums should follow the following pattern:
 *
 * ```ts
 *     type ParentClosePolicy = (typeof ParentClosePolicy)[keyof typeof ParentClosePolicy];
 *     const ParentClosePolicy = {
 *       TERMINATE: 'TERMINATE',
 *       ABANDON: 'ABANDON',
 *       REQUEST_CANCEL: 'REQUEST_CANCEL',
 *     } as const;
 *
 *     const [encodeParentClosePolicy, decodeParentClosePolicy] = //
 *       makeProtoEnumConverters<
 *         coresdk.child_workflow.ParentClosePolicy,
 *         typeof coresdk.child_workflow.ParentClosePolicy,
 *         keyof typeof coresdk.child_workflow.ParentClosePolicy,
 *         typeof ParentClosePolicy,
 *         'PARENT_CLOSE_POLICY_'  // This may be an empty string if the proto enum doesn't add a repeated prefix on values
 *       >(
 *         {
 *           [ParentClosePolicy.TERMINATE]: 1, // These numbers must match the ones in the proto enum
 *           [ParentClosePolicy.ABANDON]: 2,
 *           [ParentClosePolicy.REQUEST_CANCEL]: 3,
 *
 *           UNSPECIFIED: 0,
 *         } as const,
 *         'PARENT_CLOSE_POLICY_'
 *       );
 * ```
 *
 * `makeProtoEnumConverters` supports other usage patterns, but they are only meant for
 * backward compatibility with former enum definitions and should not be used for new enums.
 *
 * ### Context
 *
 * Temporal's Protobuf APIs define several `enum` types; our Protobuf compiler transforms these to
 * traditional (i.e. non-const) [TypeScript numeric `enum`s](https://www.typescriptlang.org/docs/handbook/enums.html#numeric-enums).
 *
 * For various reasons, this is far from ideal:
 *
 *  - Due to the dual nature of non-const TypeScript `enum`s (they are both a type and a value),
 *    it is not possible to refer to an enum value from code without a "real" import of the enum type
 *    (i.e. can't simply do `import type ...`). In Workflow code, such an import would result in
 *    loading our entire Protobuf definitions into the workflow sandbox, adding several megabytes to
 *    the per-workflow memory footprint, which is unacceptable; to avoid that, we need to maintain
 *    a mirror copy of each enum types used by in-workflow APIs, and export these from either
 *    `@temporalio/common` or `@temporalio/workflow`.
 *  - It is not desirable for users to need an explicit dependency on `@temporalio/proto` just to
 *    get access to these enum types; we therefore made it a common practice to reexport these enums
 *    from our public facing packages. However, experience demontrated that these reexports effectively
 *    resulted in poor and inconsistent documentation coverage compared to mirrored enums types.
 *  - Our Protobuf enum types tend to follow a verbose and redundant naming convention, which feels
 *    unatural and excessive according to most TypeScript style guides; e.g. instead of
 *    `workflowIdReusePolicy: WorkflowIdReusePolicy.WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE`,
 *    a TypeScript developer would generally expect to be able to write something similar to
 *    `workflowIdReusePolicy: 'REJECT_DUPLICATE'`.
 *  - Because of the way Protobuf works, many of our enum types contain an `UNSPECIFIED` value, which
 *    is used to explicitly identify a value that is unset. In TypeScript code, the `undefined` value
 *    already serves that purpose, and is definitely more idiomatic to TS developers, whereas these
 *    `UNSPECIFIED` values create noise and confusion in our APIs.
 *  - TypeScript editors generally do a very bad job at providing autocompletion that implies reaching
 *    for values of a TypeScript enum type, forcing developers to explicitly type in at least part
 *    of the name of the enum type before they can get autocompletion for its values. On the other
 *    hand, all TS editors immediately provide autocompletion for string union types.
 *  - The [TypeScript's official documentation](https://www.typescriptlang.org/docs/handbook/enums.html#objects-vs-enums)
 *    itself suggests that, in modern TypeScript, the use of `as const` objects may generally suffice
 *    and may be advantageous over the use of `enum` types.
 *
 * A const object of strings, combined with a union type of possible string values, provides a much
 * more idiomatic syntax and a better DX for TypeScript developers. This however requires a way to
 * convert back and forth between the `enum` values produced by the Protobuf compiler and the
 * equivalent string values.
 *
 * This helper dynamically creates these conversion functions for a given Protobuf enum type,
 * strongly building upon specific conventions that we have adopted in our Protobuf definitions.
 *
 * ### Validations
 *
 * The complex type signature of this helper is there to prevent most potential incoherencies
 * that could result from having to manually synchronize the const object of strings enum and the
 * conversion table with the proto enum, while not requiring a regular import on the Protobuf enum
 * itself (so it can be used safely for enums meant to be used from workflow code).
 *
 * In particular, failing any of the following invariants will result in build time errors:
 *
 * - For every key of the form `PREFIX_KEY: number` in the proto enum, excluding the `UNSPECIFIED` key:
 *   - There MUST be a corresponding `KEY: 'KEY'` entry in the const object of strings enum;
 *   - There MAY be a corresponding `PREFIX_KEY: 'KEY'` in the const object of strings enum
 *     (this is meant to preserve backward compatibility with the former syntax; such aliases should
 *     not be added for new enums and enum entries introduced going forward);
 *   - There MUST be a corresponding `KEY: number` in the mapping table.
 * - If the proto enum contains a `PREFIX_UNSPECIFIED` entry, then:
 *   - There MAY be a corresponding `PREFIX_UNSPECIFIED: undefined` and/or `UNSPECIFIED: undefined`
 *     entries in the const object of strings enum  this is meant to preserve backward compatibility
 *     with the former syntax; this alias should not be added for new enums introduced going forward;
 *   - There MUST be an `UNSPECIFIED: 0` in the mapping table.
 * - The const object of strings enum MUST NOT contain any other keys than the ones mandated or
 *   optionally allowed be the preceeding rules.
 * - The mapping table MUST NOT contain any other keys than the ones mandated above.
 *
 * These rules notably ensure that whenever a new value is added to an existing Proto enum, the code
 * will fail to compile until the corresponding entry is added on the const object of strings enum
 * and the mapping table.
 *
 * @internal
 */
function makeProtoEnumConverters(mapTable, prefix) {
    const reverseTable = Object.fromEntries(Object.entries(mapTable).map(([k, v]) => [v, k]));
    const hasUnspecified = mapTable['UNSPECIFIED'] === 0 || mapTable[`${prefix}UNSPECIFIED`] === 0;
    function isShortStringEnumKeys(x) {
        return typeof x === 'string' && x in mapTable;
    }
    function isNumericEnumValue(x) {
        return typeof x === 'number' && x in reverseTable;
    }
    function encode(input) {
        if (input == null) {
            return undefined;
        }
        else if (typeof input === 'string') {
            let shorten = input;
            if (shorten.startsWith(prefix)) {
                shorten = shorten.slice(prefix.length);
            }
            if (isShortStringEnumKeys(shorten)) {
                return mapTable[shorten];
            }
            throw new errors_1.ValueError(`Invalid enum value: '${input}'`);
        }
        else if (typeof input === 'number') {
            return input;
        }
        else {
            throw new errors_1.ValueError(`Invalid enum value: '${input}' of type ${typeof input}`);
        }
    }
    function decode(input) {
        if (input == null) {
            return undefined;
        }
        else if (typeof input === 'number') {
            if (hasUnspecified && input === 0) {
                return undefined;
            }
            if (isNumericEnumValue(input)) {
                return reverseTable[input];
            }
            // We got a proto enum value that we don't yet know about (i.e. it didn't exist when this code
            // was compiled). This is certainly a possibility, but given how our APIs evolve, this is is
            // unlikely to be a terribly bad thing by itself (we avoid adding new enum values in places
            // that would break backward compatibility with existing deployed code). Therefore, throwing
            // on "unexpected" values is likely to end up causing more problems than it might avoid,
            // especially given that the decoded value may actually never get read anwyay.
            //
            // Therefore, we instead cheat on type constraints and return a string of the form "unknown_23".
            // That somewhat mirrors the behavior we'd get with the pure numerical approach.
            return `unknown_${input}`;
        }
        throw new errors_1.ValueError(`Invalid proto enum value: '${input}' of type ${typeof input}`);
    }
    return [encode, decode];
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/internal-workflow/index.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/internal-workflow/index.js ***!
  \*********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deepMerge = exports.mergeObjects = exports.filterNullAndUndefined = void 0;
__exportStar(__webpack_require__(/*! ./enums-helpers */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/internal-workflow/enums-helpers.js"), exports);
var objects_helpers_1 = __webpack_require__(/*! ./objects-helpers */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/internal-workflow/objects-helpers.js");
Object.defineProperty(exports, "filterNullAndUndefined", ({ enumerable: true, get: function () { return objects_helpers_1.filterNullAndUndefined; } }));
Object.defineProperty(exports, "mergeObjects", ({ enumerable: true, get: function () { return objects_helpers_1.mergeObjects; } }));
// ts-prune-ignore-next
Object.defineProperty(exports, "deepMerge", ({ enumerable: true, get: function () { return objects_helpers_1.deepMerge; } }));


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/internal-workflow/objects-helpers.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/internal-workflow/objects-helpers.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.filterNullAndUndefined = filterNullAndUndefined;
exports.mergeObjects = mergeObjects;
exports.deepMerge = deepMerge;
/**
 * Helper to prevent `undefined` and `null` values overriding defaults when merging maps.
 */
function filterNullAndUndefined(obj) {
    return Object.fromEntries(Object.entries(obj).filter(([_k, v]) => v != null));
}
function mergeObjects(original, delta) {
    if (original == null)
        return delta;
    if (delta == null)
        return original;
    const merged = { ...original };
    let changed = false;
    for (const [k, v] of Object.entries(delta)) {
        if (v !== merged[k]) {
            if (v == null)
                delete merged[k];
            else
                merged[k] = v;
            changed = true;
        }
    }
    return changed ? merged : original;
}
function isObject(item) {
    return item && typeof item === 'object' && !Array.isArray(item);
}
/**
 * Recursively merges two objects, returning a new object.
 *
 * Properties from `source` will overwrite properties on `target`.
 * Nested objects are merged recursively.
 *
 * Object fields in the returned object are references, as in,
 * the returned object is not completely fresh.
 */
function deepMerge(target, source) {
    const output = { ...target };
    if (isObject(target) && isObject(source)) {
        for (const key of Object.keys(source)) {
            const sourceValue = source[key];
            if (isObject(sourceValue) && key in target && isObject(target[key])) {
                output[key] = deepMerge(target[key], sourceValue);
            }
            else {
                output[key] = sourceValue;
            }
        }
    }
    return output;
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/logger.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/logger.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoggerWithComposedMetadata = exports.SdkComponent = void 0;
const internal_workflow_1 = __webpack_require__(/*! ./internal-workflow */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/internal-workflow/index.js");
/**
 * Possible values of the `sdkComponent` meta attributes on log messages. This
 * attribute indicates which subsystem emitted the log message; this may for
 * example be used to implement fine-grained filtering of log messages.
 *
 * Note that there is no guarantee that this list will remain stable in the
 * future; values may be added or removed, and messages that are currently
 * emitted with some `sdkComponent` value may use a different value in the future.
 */
var SdkComponent;
(function (SdkComponent) {
    /**
     * Component name for messages emited from Workflow code, using the {@link Workflow context logger|workflow.log}.
     * The SDK itself never publishes messages with this component name.
     */
    SdkComponent["workflow"] = "workflow";
    /**
     * Component name for messages emited from an activity, using the {@link activity context logger|Context.log}.
     * The SDK itself never publishes messages with this component name.
     */
    SdkComponent["activity"] = "activity";
    /**
     * Component name for messages emited from a Nexus Operation Handler, using the Nexus context logger.
     * The SDK itself never publishes messages with this component name.
     */
    SdkComponent["nexus"] = "nexus";
    /**
     * Component name for messages emited from a Temporal Worker instance.
     *
     * This notably includes:
     * - Issues with Worker or runtime configuration, or the JS execution environment;
     * - Worker's, Activity's, and Workflow's lifecycle events;
     * - Workflow Activation and Activity Task processing events;
     * - Workflow bundling messages;
     * - Sink processing issues.
     */
    SdkComponent["worker"] = "worker";
    /**
     * Component name for all messages emitted by the Rust Core SDK library.
     */
    SdkComponent["core"] = "core";
})(SdkComponent || (exports.SdkComponent = SdkComponent = {}));
/**
 * A logger implementation that adds metadata before delegating calls to a parent logger.
 *
 * @internal
 * @hidden
 */
class LoggerWithComposedMetadata {
    parentLogger;
    contributors;
    /**
     * Return a {@link Logger} that adds metadata before delegating calls to a parent logger.
     *
     * New metadata may either be specified statically as a delta object, or as a function evaluated
     * every time a log is emitted that will return a delta object.
     *
     * Some optimizations are performed to avoid creating unnecessary objects and to keep runtime
     * overhead associated with resolving metadata as low as possible.
     */
    static compose(logger, metaOrFunc) {
        // Flatten recursive LoggerWithComposedMetadata instances
        if (logger instanceof LoggerWithComposedMetadata) {
            const contributors = appendToChain(logger.contributors, metaOrFunc);
            // If the new contributor results in no actual change to the chain, then we don't need a new logger
            if (contributors === undefined)
                return logger;
            return new LoggerWithComposedMetadata(logger.parentLogger, contributors);
        }
        else {
            const contributors = appendToChain(undefined, metaOrFunc);
            if (contributors === undefined)
                return logger;
            return new LoggerWithComposedMetadata(logger, contributors);
        }
    }
    constructor(parentLogger, contributors) {
        this.parentLogger = parentLogger;
        this.contributors = contributors;
    }
    log(level, message, extraMeta) {
        this.parentLogger.log(level, message, resolveMetadata(this.contributors, extraMeta));
    }
    trace(message, extraMeta) {
        this.parentLogger.trace(message, resolveMetadata(this.contributors, extraMeta));
    }
    debug(message, extraMeta) {
        this.parentLogger.debug(message, resolveMetadata(this.contributors, extraMeta));
    }
    info(message, extraMeta) {
        this.parentLogger.info(message, resolveMetadata(this.contributors, extraMeta));
    }
    warn(message, extraMeta) {
        this.parentLogger.warn(message, resolveMetadata(this.contributors, extraMeta));
    }
    error(message, extraMeta) {
        this.parentLogger.error(message, resolveMetadata(this.contributors, extraMeta));
    }
}
exports.LoggerWithComposedMetadata = LoggerWithComposedMetadata;
function resolveMetadata(contributors, extraMeta) {
    const resolved = {};
    for (const contributor of contributors) {
        Object.assign(resolved, typeof contributor === 'function' ? contributor() : contributor);
    }
    Object.assign(resolved, extraMeta);
    return (0, internal_workflow_1.filterNullAndUndefined)(resolved);
}
/**
 * Append a metadata contributor to the chain, merging it with the former last contributor if both are plain objects
 */
function appendToChain(existingContributors, newContributor) {
    // If the new contributor is an empty object, then it results in no actual change to the chain
    if (typeof newContributor === 'object' && Object.keys(newContributor).length === 0) {
        return existingContributors;
    }
    // If existing chain is empty, then the new contributor is the chain
    if (existingContributors == null || existingContributors.length === 0) {
        return [newContributor];
    }
    // If both last contributor and new contributor are plain objects, merge them to a single object.
    const last = existingContributors[existingContributors.length - 1];
    if (typeof last === 'object' && typeof newContributor === 'object') {
        const merged = (0, internal_workflow_1.mergeObjects)(last, newContributor);
        if (merged === last)
            return existingContributors;
        return [...existingContributors.slice(0, -1), merged];
    }
    // Otherwise, just append the new contributor to the chain.
    return [...existingContributors, newContributor];
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/metrics.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/metrics.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetricMeterWithComposedTags = exports.noopMetricMeter = void 0;
const internal_workflow_1 = __webpack_require__(/*! ./internal-workflow */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/internal-workflow/index.js");
////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * A meter implementation that does nothing.
 */
class NoopMetricMeter {
    createCounter(name, unit, description) {
        return {
            name,
            unit,
            description,
            add(_value, _extraTags) { },
            withTags(_extraTags) {
                return this;
            },
        };
    }
    createHistogram(name, valueType = 'int', unit, description) {
        return {
            name,
            valueType,
            unit,
            description,
            record(_value, _extraTags) { },
            withTags(_extraTags) {
                return this;
            },
        };
    }
    createGauge(name, valueType, unit, description) {
        return {
            name,
            valueType: valueType ?? 'int',
            unit,
            description,
            set(_value, _extraTags) { },
            withTags(_extraTags) {
                return this;
            },
        };
    }
    withTags(_extraTags) {
        return this;
    }
}
exports.noopMetricMeter = new NoopMetricMeter();
/**
 * A meter implementation that adds tags before delegating calls to a parent meter.
 *
 * @experimental The Metric API is an experimental feature and may be subject to change.
 * @internal
 * @hidden
 */
class MetricMeterWithComposedTags {
    parentMeter;
    contributors;
    /**
     * Return a {@link MetricMeter} that adds tags before delegating calls to a parent meter.
     *
     * New tags may either be specified statically as a delta object, or as a function evaluated
     * every time a metric is recorded that will return a delta object.
     *
     * Some optimizations are performed to avoid creating unnecessary objects and to keep runtime
     * overhead associated with resolving tags as low as possible.
     *
     * @param meter The parent meter to delegate calls to.
     * @param tagsOrFunc New tags may either be specified statically as a delta object, or as a function
     *                   evaluated every time a metric is recorded that will return a delta object.
     * @param force if `true`, then a `MetricMeterWithComposedTags` will be created even if there
     *              is no tags to add. This is useful to add tags support to an underlying meter
     *              implementation that does not support tags directly.
     */
    static compose(meter, tagsOrFunc, force = false) {
        if (meter instanceof MetricMeterWithComposedTags) {
            const contributors = appendToChain(meter.contributors, tagsOrFunc);
            // If the new contributor results in no actual change to the chain, then we don't need a new meter
            if (contributors === undefined && !force)
                return meter;
            return new MetricMeterWithComposedTags(meter.parentMeter, contributors ?? []);
        }
        else {
            const contributors = appendToChain(undefined, tagsOrFunc);
            if (contributors === undefined && !force)
                return meter;
            return new MetricMeterWithComposedTags(meter, contributors ?? []);
        }
    }
    constructor(parentMeter, contributors) {
        this.parentMeter = parentMeter;
        this.contributors = contributors;
    }
    createCounter(name, unit, description) {
        const parentCounter = this.parentMeter.createCounter(name, unit, description);
        return new MetricCounterWithComposedTags(parentCounter, this.contributors);
    }
    createHistogram(name, valueType = 'int', unit, description) {
        const parentHistogram = this.parentMeter.createHistogram(name, valueType, unit, description);
        return new MetricHistogramWithComposedTags(parentHistogram, this.contributors);
    }
    createGauge(name, valueType = 'int', unit, description) {
        const parentGauge = this.parentMeter.createGauge(name, valueType, unit, description);
        return new MetricGaugeWithComposedTags(parentGauge, this.contributors);
    }
    withTags(tags) {
        return MetricMeterWithComposedTags.compose(this, tags);
    }
}
exports.MetricMeterWithComposedTags = MetricMeterWithComposedTags;
/**
 * @experimental The Metric API is an experimental feature and may be subject to change.
 */
class MetricCounterWithComposedTags {
    parentCounter;
    contributors;
    constructor(parentCounter, contributors) {
        this.parentCounter = parentCounter;
        this.contributors = contributors;
    }
    add(value, extraTags) {
        this.parentCounter.add(value, resolveTags(this.contributors, extraTags));
    }
    withTags(extraTags) {
        const contributors = appendToChain(this.contributors, extraTags);
        if (contributors === undefined)
            return this;
        return new MetricCounterWithComposedTags(this.parentCounter, contributors);
    }
    get name() {
        return this.parentCounter.name;
    }
    get unit() {
        return this.parentCounter.unit;
    }
    get description() {
        return this.parentCounter.description;
    }
}
/**
 * @experimental The Metric API is an experimental feature and may be subject to change.
 */
class MetricHistogramWithComposedTags {
    parentHistogram;
    contributors;
    constructor(parentHistogram, contributors) {
        this.parentHistogram = parentHistogram;
        this.contributors = contributors;
    }
    record(value, extraTags) {
        this.parentHistogram.record(value, resolveTags(this.contributors, extraTags));
    }
    withTags(extraTags) {
        const contributors = appendToChain(this.contributors, extraTags);
        if (contributors === undefined)
            return this;
        return new MetricHistogramWithComposedTags(this.parentHistogram, contributors);
    }
    get name() {
        return this.parentHistogram.name;
    }
    get valueType() {
        return this.parentHistogram.valueType;
    }
    get unit() {
        return this.parentHistogram.unit;
    }
    get description() {
        return this.parentHistogram.description;
    }
}
/**
 * @internal
 * @hidden
 */
class MetricGaugeWithComposedTags {
    parentGauge;
    contributors;
    constructor(parentGauge, contributors) {
        this.parentGauge = parentGauge;
        this.contributors = contributors;
    }
    set(value, extraTags) {
        this.parentGauge.set(value, resolveTags(this.contributors, extraTags));
    }
    withTags(extraTags) {
        const contributors = appendToChain(this.contributors, extraTags);
        if (contributors === undefined)
            return this;
        return new MetricGaugeWithComposedTags(this.parentGauge, contributors);
    }
    get name() {
        return this.parentGauge.name;
    }
    get valueType() {
        return this.parentGauge.valueType;
    }
    get unit() {
        return this.parentGauge.unit;
    }
    get description() {
        return this.parentGauge.description;
    }
}
function resolveTags(contributors, extraTags) {
    const resolved = {};
    for (const contributor of contributors) {
        Object.assign(resolved, typeof contributor === 'function' ? contributor() : contributor);
    }
    Object.assign(resolved, extraTags);
    return (0, internal_workflow_1.filterNullAndUndefined)(resolved);
}
/**
 * Append a tags contributor to the chain, merging it with the former last contributor if possible.
 *
 * If appending the new contributor results in no actual change to the chain of contributors, return
 * `existingContributors`; in that case, the caller should avoid creating a new object if possible.
 */
function appendToChain(existingContributors, newContributor) {
    // If the new contributor is an empty object, then it results in no actual change to the chain
    if (typeof newContributor === 'object' && Object.keys(newContributor).length === 0) {
        return existingContributors;
    }
    // If existing chain is empty, then the new contributor is the chain
    if (existingContributors == null || existingContributors.length === 0) {
        return [newContributor];
    }
    // If both last contributor and new contributor are plain objects, merge them to a single object.
    const last = existingContributors[existingContributors.length - 1];
    if (typeof last === 'object' && typeof newContributor === 'object') {
        const merged = (0, internal_workflow_1.mergeObjects)(last, newContributor);
        if (merged === last)
            return existingContributors;
        return [...existingContributors.slice(0, -1), merged];
    }
    // Otherwise, just append the new contributor to the chain.
    return [...existingContributors, newContributor];
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/priority.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/priority.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodePriority = decodePriority;
exports.compilePriority = compilePriority;
/**
 * Turn a proto compatible Priority into a TS Priority
 */
function decodePriority(priority) {
    return {
        priorityKey: priority?.priorityKey ?? undefined,
        fairnessKey: priority?.fairnessKey ?? undefined,
        fairnessWeight: priority?.fairnessWeight ?? undefined,
    };
}
/**
 * Turn a TS Priority into a proto compatible Priority
 */
function compilePriority(priority) {
    if (priority.priorityKey !== undefined && priority.priorityKey !== null) {
        if (!Number.isInteger(priority.priorityKey)) {
            throw new TypeError('priorityKey must be an integer');
        }
        if (priority.priorityKey < 0) {
            throw new RangeError('priorityKey must be a positive integer');
        }
    }
    return {
        priorityKey: priority.priorityKey ?? 0,
        fairnessKey: priority.fairnessKey ?? '',
        fairnessWeight: priority.fairnessWeight ?? 0,
    };
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/reserved.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/reserved.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ENHANCED_STACK_TRACE_QUERY_NAME = exports.STACK_TRACE_QUERY_NAME = exports.TEMPORAL_RESERVED_PREFIX = void 0;
exports.throwIfReservedName = throwIfReservedName;
exports.TEMPORAL_RESERVED_PREFIX = '__temporal_';
exports.STACK_TRACE_QUERY_NAME = '__stack_trace';
exports.ENHANCED_STACK_TRACE_QUERY_NAME = '__enhanced_stack_trace';
/**
 * Validates if the provided name contains any reserved prefixes or matches any reserved names.
 * Throws a TypeError if validation fails, with a specific message indicating whether the issue
 * is with a reserved prefix or an exact match to a reserved name.
 *
 * @param type The entity type being checked
 * @param name The name to check against reserved prefixes/names
 */
function throwIfReservedName(type, name) {
    if (name.startsWith(exports.TEMPORAL_RESERVED_PREFIX)) {
        throw new TypeError(`Cannot use ${type} name: '${name}', with reserved prefix: '${exports.TEMPORAL_RESERVED_PREFIX}'`);
    }
    if (name === exports.STACK_TRACE_QUERY_NAME || name === exports.ENHANCED_STACK_TRACE_QUERY_NAME) {
        throw new TypeError(`Cannot use ${type} name: '${name}', which is a reserved name`);
    }
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/retry-policy.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/retry-policy.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compileRetryPolicy = compileRetryPolicy;
exports.decompileRetryPolicy = decompileRetryPolicy;
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/errors.js");
const time_1 = __webpack_require__(/*! ./time */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/time.js");
/**
 * Turn a TS RetryPolicy into a proto compatible RetryPolicy
 */
function compileRetryPolicy(retryPolicy) {
    if (retryPolicy.backoffCoefficient != null && retryPolicy.backoffCoefficient <= 0) {
        throw new errors_1.ValueError('RetryPolicy.backoffCoefficient must be greater than 0');
    }
    if (retryPolicy.maximumAttempts != null) {
        if (retryPolicy.maximumAttempts === Number.POSITIVE_INFINITY) {
            // drop field (Infinity is the default)
            const { maximumAttempts: _, ...without } = retryPolicy;
            retryPolicy = without;
        }
        else if (retryPolicy.maximumAttempts <= 0) {
            throw new errors_1.ValueError('RetryPolicy.maximumAttempts must be a positive integer');
        }
        else if (!Number.isInteger(retryPolicy.maximumAttempts)) {
            throw new errors_1.ValueError('RetryPolicy.maximumAttempts must be an integer');
        }
    }
    const maximumInterval = (0, time_1.msOptionalToNumber)(retryPolicy.maximumInterval);
    const initialInterval = (0, time_1.msToNumber)(retryPolicy.initialInterval ?? 1000);
    if (maximumInterval === 0) {
        throw new errors_1.ValueError('RetryPolicy.maximumInterval cannot be 0');
    }
    if (initialInterval === 0) {
        throw new errors_1.ValueError('RetryPolicy.initialInterval cannot be 0');
    }
    if (maximumInterval != null && maximumInterval < initialInterval) {
        throw new errors_1.ValueError('RetryPolicy.maximumInterval cannot be less than its initialInterval');
    }
    return {
        maximumAttempts: retryPolicy.maximumAttempts,
        initialInterval: (0, time_1.msToTs)(initialInterval),
        maximumInterval: (0, time_1.msOptionalToTs)(maximumInterval),
        backoffCoefficient: retryPolicy.backoffCoefficient,
        nonRetryableErrorTypes: retryPolicy.nonRetryableErrorTypes,
    };
}
/**
 * Turn a proto compatible RetryPolicy into a TS RetryPolicy
 */
function decompileRetryPolicy(retryPolicy) {
    if (!retryPolicy) {
        return undefined;
    }
    return {
        backoffCoefficient: retryPolicy.backoffCoefficient ?? undefined,
        maximumAttempts: retryPolicy.maximumAttempts ?? undefined,
        maximumInterval: (0, time_1.optionalTsToMs)(retryPolicy.maximumInterval),
        initialInterval: (0, time_1.optionalTsToMs)(retryPolicy.initialInterval),
        nonRetryableErrorTypes: retryPolicy.nonRetryableErrorTypes ?? undefined,
    };
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/search-attributes.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/search-attributes.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypedSearchAttributes = exports.TypedSearchAttributeUpdateValue = exports.TypedSearchAttributeValue = exports._ = exports.encodeSearchAttributeIndexedValueType = exports.SearchAttributeType = void 0;
exports.isValidValueForType = isValidValueForType;
exports.defineSearchAttributeKey = defineSearchAttributeKey;
const internal_workflow_1 = __webpack_require__(/*! ./internal-workflow */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/internal-workflow/index.js");
exports.SearchAttributeType = {
    TEXT: 'TEXT',
    KEYWORD: 'KEYWORD',
    INT: 'INT',
    DOUBLE: 'DOUBLE',
    BOOL: 'BOOL',
    DATETIME: 'DATETIME',
    KEYWORD_LIST: 'KEYWORD_LIST',
};
// Note: encodeSearchAttributeIndexedValueType exported for use in tests to register search attributes
// ts-prune-ignore-next
_a = (0, internal_workflow_1.makeProtoEnumConverters)({
    [exports.SearchAttributeType.TEXT]: 1,
    [exports.SearchAttributeType.KEYWORD]: 2,
    [exports.SearchAttributeType.INT]: 3,
    [exports.SearchAttributeType.DOUBLE]: 4,
    [exports.SearchAttributeType.BOOL]: 5,
    [exports.SearchAttributeType.DATETIME]: 6,
    [exports.SearchAttributeType.KEYWORD_LIST]: 7,
    UNSPECIFIED: 0,
}, 'INDEXED_VALUE_TYPE_'), exports.encodeSearchAttributeIndexedValueType = _a[0], exports._ = _a[1];
function isValidValueForType(type, value) {
    switch (type) {
        case exports.SearchAttributeType.TEXT:
        case exports.SearchAttributeType.KEYWORD:
            return typeof value === 'string';
        case exports.SearchAttributeType.INT:
            return Number.isInteger(value);
        case exports.SearchAttributeType.DOUBLE:
            return typeof value === 'number';
        case exports.SearchAttributeType.BOOL:
            return typeof value === 'boolean';
        case exports.SearchAttributeType.DATETIME:
            return value instanceof Date;
        case exports.SearchAttributeType.KEYWORD_LIST:
            return Array.isArray(value) && value.every((item) => typeof item === 'string');
        default:
            return false;
    }
}
function defineSearchAttributeKey(name, type) {
    return { name, type };
}
class BaseSearchAttributeValue {
    _type;
    _value;
    constructor(type, value) {
        this._type = type;
        this._value = value;
    }
    get type() {
        return this._type;
    }
    get value() {
        return this._value;
    }
}
// Internal type for class private data.
// Exported for use in payload conversion.
class TypedSearchAttributeValue extends BaseSearchAttributeValue {
}
exports.TypedSearchAttributeValue = TypedSearchAttributeValue;
// ts-prune-ignore-next
class TypedSearchAttributeUpdateValue extends BaseSearchAttributeValue {
}
exports.TypedSearchAttributeUpdateValue = TypedSearchAttributeUpdateValue;
class TypedSearchAttributes {
    searchAttributes = {};
    constructor(initialAttributes) {
        if (initialAttributes === undefined)
            return;
        for (const pair of initialAttributes) {
            if (pair.key.name in this.searchAttributes) {
                throw new Error(`Duplicate search attribute key: ${pair.key.name}`);
            }
            this.searchAttributes[pair.key.name] = new TypedSearchAttributeValue(pair.key.type, pair.value);
        }
    }
    get(key) {
        const attr = this.searchAttributes[key.name];
        // Key not found or type mismatch.
        if (attr === undefined || !isValidValueForType(key.type, attr.value)) {
            return undefined;
        }
        return attr.value;
    }
    /** Returns a deep copy of the given TypedSearchAttributes instance */
    copy() {
        const state = {};
        for (const [key, attr] of Object.entries(this.searchAttributes)) {
            // Create a new instance with the same properties
            let value = attr.value;
            // For non-primitive types, create a deep copy
            if (attr.value instanceof Date) {
                value = new Date(attr.value);
            }
            else if (Array.isArray(attr.value)) {
                value = [...attr.value];
            }
            state[key] = new TypedSearchAttributeValue(attr.type, value);
        }
        // Create return value with manually assigned state.
        const res = new TypedSearchAttributes();
        res.searchAttributes = state;
        return res;
    }
    /**
     * @hidden
     * Return JSON representation of this class as SearchAttributePair[]
     * Default toJSON method is not used because it's JSON representation includes private state.
     */
    toJSON() {
        return this.getAll();
    }
    /** Returns a copy of the current TypedSearchAttributes instance with the updated attributes. */
    updateCopy(updates) {
        // Create a deep copy of the current instance.
        const res = this.copy();
        // Apply updates.
        res.update(updates);
        return res;
    }
    // Performs direct mutation on the current instance.
    update(updates) {
        // Apply updates.
        for (const pair of updates) {
            // Delete attribute.
            if (pair.value === null) {
                // Delete only if the update matches a key and type.
                const attrVal = this.searchAttributes[pair.key.name];
                if (attrVal && attrVal.type === pair.key.type) {
                    delete this.searchAttributes[pair.key.name];
                }
                continue;
            }
            // Add or update attribute.
            this.searchAttributes[pair.key.name] = new TypedSearchAttributeValue(pair.key.type, pair.value);
        }
    }
    getAll() {
        const res = [];
        for (const [key, attr] of Object.entries(this.searchAttributes)) {
            const attrKey = { name: key, type: attr.type };
            // Sanity check, should always be legal.
            if (isValidValueForType(attrKey.type, attr.value)) {
                res.push({ key: attrKey, value: attr.value });
            }
        }
        return res;
    }
    static getKeyFromUntyped(key, value // eslint-disable-line deprecation/deprecation
    ) {
        if (value == null) {
            return;
        }
        // Unpack single-element arrays.
        const val = value.length === 1 ? value[0] : value;
        switch (typeof val) {
            case 'string':
                // Check if val is an ISO string, if so, return a DATETIME key.
                if (!isNaN(Date.parse(val)) && Date.parse(val) === new Date(val).getTime()) {
                    return { name: key, type: exports.SearchAttributeType.DATETIME };
                }
                return { name: key, type: exports.SearchAttributeType.TEXT };
            case 'number':
                return {
                    name: key,
                    type: Number.isInteger(val) ? exports.SearchAttributeType.INT : exports.SearchAttributeType.DOUBLE,
                };
            case 'boolean':
                return { name: key, type: exports.SearchAttributeType.BOOL };
            case 'object':
                if (val instanceof Date) {
                    return { name: key, type: exports.SearchAttributeType.DATETIME };
                }
                if (Array.isArray(val) && val.every((item) => typeof item === 'string')) {
                    return { name: key, type: exports.SearchAttributeType.KEYWORD_LIST };
                }
                return;
            default:
                return;
        }
    }
    static toMetadataType(type) {
        switch (type) {
            case exports.SearchAttributeType.TEXT:
                return 'Text';
            case exports.SearchAttributeType.KEYWORD:
                return 'Keyword';
            case exports.SearchAttributeType.INT:
                return 'Int';
            case exports.SearchAttributeType.DOUBLE:
                return 'Double';
            case exports.SearchAttributeType.BOOL:
                return 'Bool';
            case exports.SearchAttributeType.DATETIME:
                return 'Datetime';
            case exports.SearchAttributeType.KEYWORD_LIST:
                return 'KeywordList';
            default:
                throw new Error(`Unknown search attribute type: ${type}`);
        }
    }
    static toSearchAttributeType(type) {
        switch (type) {
            case 'Text':
                return exports.SearchAttributeType.TEXT;
            case 'Keyword':
                return exports.SearchAttributeType.KEYWORD;
            case 'Int':
                return exports.SearchAttributeType.INT;
            case 'Double':
                return exports.SearchAttributeType.DOUBLE;
            case 'Bool':
                return exports.SearchAttributeType.BOOL;
            case 'Datetime':
                return exports.SearchAttributeType.DATETIME;
            case 'KeywordList':
                return exports.SearchAttributeType.KEYWORD_LIST;
            default:
                return;
        }
    }
}
exports.TypedSearchAttributes = TypedSearchAttributes;


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/time.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/time.js ***!
  \**************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.optionalTsToMs = optionalTsToMs;
exports.requiredTsToMs = requiredTsToMs;
exports.tsToMs = tsToMs;
exports.msNumberToTs = msNumberToTs;
exports.msToTs = msToTs;
exports.msOptionalToTs = msOptionalToTs;
exports.msOptionalToNumber = msOptionalToNumber;
exports.msToNumber = msToNumber;
exports.tsToDate = tsToDate;
exports.requiredTsToDate = requiredTsToDate;
exports.optionalTsToDate = optionalTsToDate;
exports.optionalDateToTs = optionalDateToTs;
const long_1 = __importDefault(__webpack_require__(/*! long */ "./node_modules/.pnpm/long@5.3.2/node_modules/long/umd/index.js")); // eslint-disable-line import/no-named-as-default
const ms_1 = __importDefault(__webpack_require__(/*! ms */ "./node_modules/.pnpm/ms@3.0.0-canary.1/node_modules/ms/dist/index.cjs"));
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/errors.js");
/**
 * Lossy conversion function from Timestamp to number due to possible overflow.
 * If ts is null or undefined returns undefined.
 */
function optionalTsToMs(ts) {
    if (ts === undefined || ts === null) {
        return undefined;
    }
    return tsToMs(ts);
}
/**
 * Lossy conversion function from Timestamp to number due to possible overflow.
 * If ts is null or undefined, throws a TypeError, with error message including the name of the field.
 */
function requiredTsToMs(ts, fieldName) {
    if (ts === undefined || ts === null) {
        throw new TypeError(`Expected ${fieldName} to be a timestamp, got ${ts}`);
    }
    return tsToMs(ts);
}
/**
 * Lossy conversion function from Timestamp to number due to possible overflow
 */
function tsToMs(ts) {
    if (ts === undefined || ts === null) {
        throw new Error(`Expected timestamp, got ${ts}`);
    }
    const { seconds, nanos } = ts;
    return (seconds || long_1.default.UZERO)
        .mul(1000)
        .add(Math.floor((nanos || 0) / 1000000))
        .toNumber();
}
function msNumberToTs(millis) {
    const seconds = Math.floor(millis / 1000);
    const nanos = (millis % 1000) * 1000000;
    if (Number.isNaN(seconds) || Number.isNaN(nanos)) {
        throw new errors_1.ValueError(`Invalid millis ${millis}`);
    }
    return { seconds: long_1.default.fromNumber(seconds), nanos };
}
function msToTs(str) {
    return msNumberToTs(msToNumber(str));
}
function msOptionalToTs(str) {
    return str ? msToTs(str) : undefined;
}
function msOptionalToNumber(val) {
    if (val === undefined)
        return undefined;
    return msToNumber(val);
}
function msToNumber(val) {
    if (typeof val === 'number') {
        return val;
    }
    return msWithValidation(val);
}
function msWithValidation(str) {
    const millis = (0, ms_1.default)(str);
    if (millis == null || isNaN(millis)) {
        throw new TypeError(`Invalid duration string: '${str}'`);
    }
    return millis;
}
function tsToDate(ts) {
    return new Date(tsToMs(ts));
}
// ts-prune-ignore-next
function requiredTsToDate(ts, fieldName) {
    return new Date(requiredTsToMs(ts, fieldName));
}
function optionalTsToDate(ts) {
    if (ts === undefined || ts === null) {
        return undefined;
    }
    return new Date(tsToMs(ts));
}
// ts-prune-ignore-next (imported via schedule-helpers.ts)
function optionalDateToTs(date) {
    if (date === undefined || date === null) {
        return undefined;
    }
    return msToTs(date.getTime());
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/type-helpers.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/type-helpers.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkExtends = checkExtends;
exports.isRecord = isRecord;
exports.hasOwnProperty = hasOwnProperty;
exports.hasOwnProperties = hasOwnProperties;
exports.isError = isError;
exports.isAbortError = isAbortError;
exports.errorMessage = errorMessage;
exports.errorCode = errorCode;
exports.assertNever = assertNever;
exports.SymbolBasedInstanceOfError = SymbolBasedInstanceOfError;
/** Verify that an type _Copy extends _Orig */
function checkExtends() {
    // noop, just type check
}
function isRecord(value) {
    return typeof value === 'object' && value !== null;
}
function hasOwnProperty(record, prop) {
    return prop in record;
}
function hasOwnProperties(record, props) {
    return props.every((prop) => prop in record);
}
function isError(error) {
    return (isRecord(error) &&
        typeof error.name === 'string' &&
        typeof error.message === 'string' &&
        (error.stack == null || typeof error.stack === 'string'));
}
function isAbortError(error) {
    return isError(error) && error.name === 'AbortError';
}
/**
 * Get `error.message` (or `undefined` if not present)
 */
function errorMessage(error) {
    if (isError(error)) {
        return error.message;
    }
    else if (typeof error === 'string') {
        return error;
    }
    return undefined;
}
function isErrorWithCode(error) {
    return isRecord(error) && typeof error.code === 'string';
}
/**
 * Get `error.code` (or `undefined` if not present)
 */
function errorCode(error) {
    if (isErrorWithCode(error)) {
        return error.code;
    }
    return undefined;
}
/**
 * Asserts that some type is the never type
 */
function assertNever(msg, x) {
    throw new TypeError(msg + ': ' + x);
}
/**
 * A decorator to be used on error classes. It adds the 'name' property AND provides a custom
 * 'instanceof' handler that works correctly across execution contexts.
 *
 * ### Details ###
 *
 * According to the EcmaScript's spec, the default behavior of JavaScript's `x instanceof Y` operator is to walk up the
 * prototype chain of object 'x', checking if any constructor in that hierarchy is _exactly the same object_ as the
 * constructor function 'Y'.
 *
 * Unfortunately, it happens in various situations that different constructor function objects get created for what
 * appears to be the very same class. This leads to surprising behavior where `instanceof` returns false though it is
 * known that the object is indeed an instance of that class. One particular case where this happens is when constructor
 * 'Y' belongs to a different realm than the constuctor with which 'x' was instantiated. Another case is when two copies
 * of the same library gets loaded in the same realm.
 *
 * In practice, this tends to cause issues when crossing the workflow-sandboxing boundary (since Node's vm module
 * really creates new execution realms), as well as when running tests using Jest (see https://github.com/jestjs/jest/issues/2549
 * for some details on that one).
 *
 * This function injects a custom 'instanceof' handler into the prototype of 'clazz', which is both cross-realm safe and
 * cross-copies-of-the-same-lib safe. It works by adding a special symbol property to the prototype of 'clazz', and then
 * checking for the presence of that symbol.
 */
function SymbolBasedInstanceOfError(markerName) {
    return (clazz) => {
        const marker = Symbol.for(`__temporal_is${markerName}`);
        Object.defineProperty(clazz.prototype, 'name', { value: markerName, enumerable: true });
        Object.defineProperty(clazz.prototype, marker, { value: true, enumerable: false });
        Object.defineProperty(clazz, Symbol.hasInstance, {
            // eslint-disable-next-line object-shorthand
            value: function (error) {
                if (this === clazz) {
                    return isRecord(error) && error[marker] === true;
                }
                else {
                    // 'this' must be a _subclass_ of clazz that doesn't redefined [Symbol.hasInstance], so that it inherited
                    // from clazz's [Symbol.hasInstance]. If we don't handle this particular situation, then
                    // `x instanceof SubclassOfParent` would return true for any instance of 'Parent', which is clearly wrong.
                    //
                    // Ideally, it'd be preferable to avoid this case entirely, by making sure that all subclasses of 'clazz'
                    // redefine [Symbol.hasInstance], but we can't enforce that. We therefore fallback to the default instanceof
                    // behavior (which is NOT cross-realm safe).
                    return this.prototype.isPrototypeOf(error); // eslint-disable-line no-prototype-builtins
                }
            },
        });
    };
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/user-metadata.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/user-metadata.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.userMetadataToPayload = userMetadataToPayload;
const payload_converter_1 = __webpack_require__(/*! ./converter/payload-converter */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/converter/payload-converter.js");
function userMetadataToPayload(payloadConverter, staticSummary, staticDetails) {
    if (staticSummary == null && staticDetails == null)
        return undefined;
    const summary = (0, payload_converter_1.convertOptionalToPayload)(payloadConverter, staticSummary);
    const details = (0, payload_converter_1.convertOptionalToPayload)(payloadConverter, staticDetails);
    if (summary == null && details == null)
        return undefined;
    return { summary, details };
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/versioning-intent-enum.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/versioning-intent-enum.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VersioningIntent = void 0;
exports.versioningIntentToProto = versioningIntentToProto;
const type_helpers_1 = __webpack_require__(/*! ./type-helpers */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/type-helpers.js");
/* eslint-disable deprecation/deprecation */
// Avoid importing the proto implementation to reduce workflow bundle size
// Copied from coresdk.common.VersioningIntent
/**
 * Protobuf enum representation of {@link VersioningIntentString}.
 *
 * @deprecated In favor of the new Worker Deployment API.
 * @experimental The Worker Versioning API is still being designed. Major changes are expected.
 */
var VersioningIntent;
(function (VersioningIntent) {
    VersioningIntent[VersioningIntent["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    VersioningIntent[VersioningIntent["COMPATIBLE"] = 1] = "COMPATIBLE";
    VersioningIntent[VersioningIntent["DEFAULT"] = 2] = "DEFAULT";
})(VersioningIntent || (exports.VersioningIntent = VersioningIntent = {}));
(0, type_helpers_1.checkExtends)();
(0, type_helpers_1.checkExtends)();
function versioningIntentToProto(intent) {
    switch (intent) {
        case 'DEFAULT':
            return VersioningIntent.DEFAULT;
        case 'COMPATIBLE':
            return VersioningIntent.COMPATIBLE;
        case undefined:
            return VersioningIntent.UNSPECIFIED;
        default:
            (0, type_helpers_1.assertNever)('Unexpected VersioningIntent', intent);
    }
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/versioning-intent.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/versioning-intent.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/worker-deployments.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/worker-deployments.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeVersioningBehavior = exports.encodeVersioningBehavior = exports.VersioningBehavior = void 0;
exports.toCanonicalString = toCanonicalString;
const internal_workflow_1 = __webpack_require__(/*! ./internal-workflow */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/internal-workflow/index.js");
/**
 * @returns The canonical representation of a deployment version, which is a string in the format
 * `deploymentName.buildId`.
 */
function toCanonicalString(version) {
    return `${version.deploymentName}.${version.buildId}`;
}
/**
 * Specifies when a workflow might move from a worker of one Build Id to another.
 *
 * * 'PINNED' - The workflow will be pinned to the current Build ID unless manually moved.
 * * 'AUTO_UPGRADE' - The workflow will automatically move to the latest version (default Build ID
 *    of the task queue) when the next task is dispatched.
 *
 * @experimental Deployment based versioning is experimental and may change in the future.
 */
exports.VersioningBehavior = {
    PINNED: 'PINNED',
    AUTO_UPGRADE: 'AUTO_UPGRADE',
};
_a = (0, internal_workflow_1.makeProtoEnumConverters)({
    [exports.VersioningBehavior.PINNED]: 1,
    [exports.VersioningBehavior.AUTO_UPGRADE]: 2,
    UNSPECIFIED: 0,
}, 'VERSIONING_BEHAVIOR_'), exports.encodeVersioningBehavior = _a[0], exports.decodeVersioningBehavior = _a[1];


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/workflow-definition-options.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/workflow-definition-options.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/workflow-handle.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/workflow-handle.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/workflow-options.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/workflow-options.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeWorkflowIdConflictPolicy = exports.encodeWorkflowIdConflictPolicy = exports.WorkflowIdConflictPolicy = exports.decodeWorkflowIdReusePolicy = exports.encodeWorkflowIdReusePolicy = exports.WorkflowIdReusePolicy = void 0;
exports.extractWorkflowType = extractWorkflowType;
const internal_workflow_1 = __webpack_require__(/*! ./internal-workflow */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/internal-workflow/index.js");
/**
 * Defines what happens when trying to start a Workflow with the same ID as a *Closed* Workflow.
 *
 * See {@link WorkflowOptions.workflowIdConflictPolicy} for what happens when trying to start a
 * Workflow with the same ID as a *Running* Workflow.
 *
 * Concept: {@link https://docs.temporal.io/concepts/what-is-a-workflow-id-reuse-policy/ | Workflow Id Reuse Policy}
 *
 * *Note: It is not possible to have two actively running Workflows with the same ID.*
 *
 */
exports.WorkflowIdReusePolicy = {
    /**
     * The Workflow can be started if the previous Workflow is in a Closed state.
     * @default
     */
    ALLOW_DUPLICATE: 'ALLOW_DUPLICATE',
    /**
     * The Workflow can be started if the previous Workflow is in a Closed state that is not Completed.
     */
    ALLOW_DUPLICATE_FAILED_ONLY: 'ALLOW_DUPLICATE_FAILED_ONLY',
    /**
     * The Workflow cannot be started.
     */
    REJECT_DUPLICATE: 'REJECT_DUPLICATE',
    /**
     * Terminate the current Workflow if one is already running; otherwise allow reusing the Workflow ID.
     *
     * @deprecated Use {@link WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE} instead, and
     *             set `WorkflowOptions.workflowIdConflictPolicy` to
     *             {@link WorkflowIdConflictPolicy.WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING}.
     *             When using this option, `WorkflowOptions.workflowIdConflictPolicy` must be left unspecified.
     */
    TERMINATE_IF_RUNNING: 'TERMINATE_IF_RUNNING', // eslint-disable-line deprecation/deprecation
    /// Anything below this line has been deprecated
    /**
     * No need to use this. If a `WorkflowIdReusePolicy` is set to this, or is not set at all, the default value will be used.
     *
     * @deprecated Either leave property `undefined`, or use {@link ALLOW_DUPLICATE} instead.
     */
    WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED: undefined, // eslint-disable-line deprecation/deprecation
    /** @deprecated Use {@link ALLOW_DUPLICATE} instead. */
    WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE: 'ALLOW_DUPLICATE', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use {@link ALLOW_DUPLICATE_FAILED_ONLY} instead. */
    WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY: 'ALLOW_DUPLICATE_FAILED_ONLY', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use {@link REJECT_DUPLICATE} instead. */
    WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE: 'REJECT_DUPLICATE', // eslint-disable-line deprecation/deprecation
    /** @deprecated Use {@link TERMINATE_IF_RUNNING} instead. */
    WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING: 'TERMINATE_IF_RUNNING', // eslint-disable-line deprecation/deprecation
};
_a = (0, internal_workflow_1.makeProtoEnumConverters)({
    [exports.WorkflowIdReusePolicy.ALLOW_DUPLICATE]: 1,
    [exports.WorkflowIdReusePolicy.ALLOW_DUPLICATE_FAILED_ONLY]: 2,
    [exports.WorkflowIdReusePolicy.REJECT_DUPLICATE]: 3,
    [exports.WorkflowIdReusePolicy.TERMINATE_IF_RUNNING]: 4, // eslint-disable-line deprecation/deprecation
    UNSPECIFIED: 0,
}, 'WORKFLOW_ID_REUSE_POLICY_'), exports.encodeWorkflowIdReusePolicy = _a[0], exports.decodeWorkflowIdReusePolicy = _a[1];
exports.WorkflowIdConflictPolicy = {
    /**
     * Do not start a new Workflow. Instead raise a `WorkflowExecutionAlreadyStartedError`.
     */
    FAIL: 'FAIL',
    /**
     * Do not start a new Workflow. Instead return a Workflow Handle for the already Running Workflow.
     */
    USE_EXISTING: 'USE_EXISTING',
    /**
     * Start a new Workflow, terminating the current workflow if one is already running.
     */
    TERMINATE_EXISTING: 'TERMINATE_EXISTING',
};
_b = (0, internal_workflow_1.makeProtoEnumConverters)({
    [exports.WorkflowIdConflictPolicy.FAIL]: 1,
    [exports.WorkflowIdConflictPolicy.USE_EXISTING]: 2,
    [exports.WorkflowIdConflictPolicy.TERMINATE_EXISTING]: 3,
    UNSPECIFIED: 0,
}, 'WORKFLOW_ID_CONFLICT_POLICY_'), exports.encodeWorkflowIdConflictPolicy = _b[0], exports.decodeWorkflowIdConflictPolicy = _b[1];
function extractWorkflowType(workflowTypeOrFunc) {
    if (typeof workflowTypeOrFunc === 'string')
        return workflowTypeOrFunc;
    if (typeof workflowTypeOrFunc === 'function') {
        if (workflowTypeOrFunc?.name)
            return workflowTypeOrFunc.name;
        throw new TypeError('Invalid workflow type: the workflow function is anonymous');
    }
    throw new TypeError(`Invalid workflow type: expected either a string or a function, got '${typeof workflowTypeOrFunc}'`);
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/alea.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/alea.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// A port of an algorithm by Johannes Baage <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Mash = void 0;
exports.alea = alea;
// Copyright (C) 2010 by Johannes Baage <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// Taken and modified from https://github.com/davidbau/seedrandom/blob/released/lib/alea.js
class Alea {
    c;
    s0;
    s1;
    s2;
    constructor(seed) {
        const mash = new Mash();
        // Apply the seeding algorithm from Baagoe.
        this.c = 1;
        this.s0 = mash.mash([32]);
        this.s1 = mash.mash([32]);
        this.s2 = mash.mash([32]);
        this.s0 -= mash.mash(seed);
        if (this.s0 < 0) {
            this.s0 += 1;
        }
        this.s1 -= mash.mash(seed);
        if (this.s1 < 0) {
            this.s1 += 1;
        }
        this.s2 -= mash.mash(seed);
        if (this.s2 < 0) {
            this.s2 += 1;
        }
    }
    next() {
        const t = 2091639 * this.s0 + this.c * 2.3283064365386963e-10; // 2^-32
        this.s0 = this.s1;
        this.s1 = this.s2;
        return (this.s2 = t - (this.c = t | 0));
    }
}
function alea(seed) {
    const xg = new Alea(seed);
    return xg.next.bind(xg);
}
class Mash {
    n = 0xefc8249d;
    mash(data) {
        let { n } = this;
        for (let i = 0; i < data.length; i++) {
            n += data[i];
            let h = 0.02519603282416938 * n;
            n = h >>> 0;
            h -= n;
            h *= n;
            n = h >>> 0;
            h -= n;
            n += h * 0x100000000; // 2^32
        }
        this.n = n;
        return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
    }
}
exports.Mash = Mash;


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/cancellation-scope.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/cancellation-scope.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RootCancellationScope = exports.CancellationScope = exports.AsyncLocalStorage = void 0;
exports.disableStorage = disableStorage;
exports.registerSleepImplementation = registerSleepImplementation;
const common_1 = __webpack_require__(/*! @temporalio/common */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/index.js");
const time_1 = __webpack_require__(/*! @temporalio/common/lib/time */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/time.js");
const stack_helpers_1 = __webpack_require__(/*! ./stack-helpers */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/stack-helpers.js");
const global_attributes_1 = __webpack_require__(/*! ./global-attributes */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/global-attributes.js");
const flags_1 = __webpack_require__(/*! ./flags */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/flags.js");
// AsyncLocalStorage is injected via vm module into global scope.
// In case Workflow code is imported in Node.js context, replace with an empty class.
exports.AsyncLocalStorage = globalThis.AsyncLocalStorage ?? class {
};
/** Magic symbol used to create the root scope - intentionally not exported */
const NO_PARENT = Symbol('NO_PARENT');
/**
 * Cancellation Scopes provide the mechanic by which a Workflow may gracefully handle incoming requests for cancellation
 * (e.g. in response to {@link WorkflowHandle.cancel} or through the UI or CLI), as well as request cancelation of
 * cancellable operations it owns (e.g. Activities, Timers, Child Workflows, etc).
 *
 * Cancellation Scopes form a tree, with the Workflow's main function running in the root scope of that tree.
 * By default, cancellation propagates down from a parent scope to its children and its cancellable operations.
 * A non-cancellable scope can receive cancellation requests, but is never effectively considered as cancelled,
 * thus shieldding its children and cancellable operations from propagation of cancellation requests it receives.
 *
 * Scopes are created using the `CancellationScope` constructor or the static helper methods {@link cancellable},
 * {@link nonCancellable} and {@link withTimeout}. `withTimeout` creates a scope that automatically cancels itself after
 * some duration.
 *
 * Cancellation of a cancellable scope results in all operations created directly in that scope to throw a
 * {@link CancelledFailure} (either directly, or as the `cause` of an {@link ActivityFailure} or a
 * {@link ChildWorkflowFailure}). Further attempt to create new cancellable scopes or cancellable operations within a
 * scope that has already been cancelled will also immediately throw a {@link CancelledFailure} exception. It is however
 * possible to create a non-cancellable scope at that point; this is often used to execute rollback or cleanup
 * operations. For example:
 *
 * ```ts
 * async function myWorkflow(...): Promise<void> {
 *   try {
 *     // This activity runs in the root cancellation scope. Therefore, a cancelation request on
 *     // the Workflow execution (e.g. through the UI or CLI) automatically propagates to this
 *     // activity. Assuming that the activity properly handle the cancellation request, then the
 *     // call below will throw an `ActivityFailure` exception, with `cause` sets to an
 *     // instance of `CancelledFailure`.
 *     await someActivity();
 *   } catch (e) {
 *     if (isCancellation(e)) {
 *       // Run cleanup activity in a non-cancellable scope
 *       await CancellationScope.nonCancellable(async () => {
 *         await cleanupActivity();
 *       }
 *     } else {
 *       throw e;
 *     }
 *   }
 * }
 * ```
 *
 * A cancellable scope may be programatically cancelled by calling {@link cancel|`scope.cancel()`}`. This may be used,
 * for example, to explicitly request cancellation of an Activity or Child Workflow:
 *
 * ```ts
 * const cancellableActivityScope = new CancellationScope();
 * const activityPromise = cancellableActivityScope.run(() => someActivity());
 * cancellableActivityScope.cancel(); // Cancels the activity
 * await activityPromise; // Throws `ActivityFailure` with `cause` set to `CancelledFailure`
 * ```
 */
class CancellationScope {
    /**
     * Time in milliseconds before the scope cancellation is automatically requested
     */
    timeout;
    /**
     * If false, then this scope will never be considered cancelled, even if a cancellation request is received (either
     * directly by calling `scope.cancel()` or indirectly by cancelling a cancellable parent scope). This effectively
     * shields the scope's children and cancellable operations from propagation of cancellation requests made on the
     * non-cancellable scope.
     *
     * Note that the Promise returned by the `run` function of non-cancellable scope may still throw a `CancelledFailure`
     * if such an exception is thrown from within that scope (e.g. by directly cancelling a cancellable child scope).
     */
    cancellable;
    /**
     * An optional CancellationScope (useful for running background tasks), defaults to {@link CancellationScope.current}()
     */
    parent;
    /**
     * A Promise that throws when a cancellable scope receives a cancellation request, either directly
     * (i.e. `scope.cancel()`), or indirectly (by cancelling a cancellable parent scope).
     *
     * Note that a non-cancellable scope may receive cancellation requests, resulting in the `cancelRequested` promise for
     * that scope to throw, though the scope will not effectively get cancelled (i.e. `consideredCancelled` will still
     * return `false`, and cancellation will not be propagated to child scopes and contained operations).
     */
    cancelRequested;
    #cancelRequested = false;
    // Typescript does not understand that the Promise executor runs synchronously in the constructor
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    reject;
    constructor(options) {
        this.timeout = (0, time_1.msOptionalToNumber)(options?.timeout);
        this.cancellable = options?.cancellable ?? true;
        this.cancelRequested = new Promise((_, reject) => {
            // @ts-expect-error TSC doesn't understand that the Promise executor runs synchronously
            this.reject = (err) => {
                this.#cancelRequested = true;
                reject(err);
            };
        });
        (0, stack_helpers_1.untrackPromise)(this.cancelRequested);
        // Avoid unhandled rejections
        (0, stack_helpers_1.untrackPromise)(this.cancelRequested.catch(() => undefined));
        if (options?.parent !== NO_PARENT) {
            this.parent = options?.parent || CancellationScope.current();
            if (this.parent.cancellable ||
                (this.parent.#cancelRequested &&
                    !(0, global_attributes_1.getActivator)().hasFlag(flags_1.SdkFlags.NonCancellableScopesAreShieldedFromPropagation))) {
                this.#cancelRequested = this.parent.#cancelRequested;
                (0, stack_helpers_1.untrackPromise)(this.parent.cancelRequested.catch((err) => {
                    this.reject(err);
                }));
            }
            else {
                (0, stack_helpers_1.untrackPromise)(this.parent.cancelRequested.catch((err) => {
                    if (!(0, global_attributes_1.getActivator)().hasFlag(flags_1.SdkFlags.NonCancellableScopesAreShieldedFromPropagation)) {
                        this.reject(err);
                    }
                }));
            }
        }
    }
    /**
     * Whether the scope was effectively cancelled. A non-cancellable scope can never be considered cancelled.
     */
    get consideredCancelled() {
        return this.#cancelRequested && this.cancellable;
    }
    /**
     * Activate the scope as current and run  `fn`
     *
     * Any timers, Activities, Triggers and CancellationScopes created in the body of `fn`
     * automatically link their cancellation to this scope.
     *
     * @return the result of `fn`
     */
    run(fn) {
        return storage.run(this, this.runInContext.bind(this, fn));
    }
    /**
     * Method that runs a function in AsyncLocalStorage context.
     *
     * Could have been written as anonymous function, made into a method for improved stack traces.
     */
    async runInContext(fn) {
        let timerScope;
        if (this.timeout) {
            timerScope = new CancellationScope();
            (0, stack_helpers_1.untrackPromise)(timerScope
                .run(() => sleep(this.timeout))
                .then(() => this.cancel(), () => {
                // scope was already cancelled, ignore
            }));
        }
        try {
            return await fn();
        }
        finally {
            if (timerScope &&
                !timerScope.consideredCancelled &&
                (0, global_attributes_1.getActivator)().hasFlag(flags_1.SdkFlags.NonCancellableScopesAreShieldedFromPropagation)) {
                timerScope.cancel();
            }
        }
    }
    /**
     * Request to cancel the scope and linked children
     */
    cancel() {
        this.reject(new common_1.CancelledFailure('Cancellation scope cancelled'));
    }
    /**
     * Get the current "active" scope
     */
    static current() {
        // Using globals directly instead of a helper function to avoid circular import
        return storage.getStore() ?? globalThis.__TEMPORAL_ACTIVATOR__.rootScope;
    }
    /** Alias to `new CancellationScope({ cancellable: true }).run(fn)` */
    static cancellable(fn) {
        return new this({ cancellable: true }).run(fn);
    }
    /** Alias to `new CancellationScope({ cancellable: false }).run(fn)` */
    static nonCancellable(fn) {
        return new this({ cancellable: false }).run(fn);
    }
    /** Alias to `new CancellationScope({ cancellable: true, timeout }).run(fn)` */
    static withTimeout(timeout, fn) {
        return new this({ cancellable: true, timeout }).run(fn);
    }
}
exports.CancellationScope = CancellationScope;
const storage = new exports.AsyncLocalStorage();
/**
 * Avoid exposing the storage directly so it doesn't get frozen
 */
function disableStorage() {
    storage.disable();
}
class RootCancellationScope extends CancellationScope {
    constructor() {
        super({ cancellable: true, parent: NO_PARENT });
    }
    cancel() {
        this.reject(new common_1.CancelledFailure('Workflow cancelled'));
    }
}
exports.RootCancellationScope = RootCancellationScope;
/** This function is here to avoid a circular dependency between this module and workflow.ts */
let sleep = (_) => {
    throw new common_1.IllegalStateError('Workflow has not been properly initialized');
};
function registerSleepImplementation(fn) {
    sleep = fn;
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/errors.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/errors.js ***!
  \********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocalActivityDoBackoff = exports.DeterminismViolationError = exports.WorkflowError = void 0;
exports.isCancellation = isCancellation;
const common_1 = __webpack_require__(/*! @temporalio/common */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/index.js");
const type_helpers_1 = __webpack_require__(/*! @temporalio/common/lib/type-helpers */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/type-helpers.js");
/**
 * Base class for all workflow errors
 */
let WorkflowError = class WorkflowError extends Error {
};
exports.WorkflowError = WorkflowError;
exports.WorkflowError = WorkflowError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('WorkflowError')
], WorkflowError);
/**
 * Thrown in workflow when it tries to do something that non-deterministic such as construct a WeakRef()
 */
let DeterminismViolationError = class DeterminismViolationError extends WorkflowError {
};
exports.DeterminismViolationError = DeterminismViolationError;
exports.DeterminismViolationError = DeterminismViolationError = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('DeterminismViolationError')
], DeterminismViolationError);
/**
 * A class that acts as a marker for this special result type
 */
let LocalActivityDoBackoff = class LocalActivityDoBackoff extends Error {
    backoff;
    constructor(backoff) {
        super();
        this.backoff = backoff;
    }
};
exports.LocalActivityDoBackoff = LocalActivityDoBackoff;
exports.LocalActivityDoBackoff = LocalActivityDoBackoff = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('LocalActivityDoBackoff')
], LocalActivityDoBackoff);
/**
 * Returns whether provided `err` is caused by cancellation
 */
function isCancellation(err) {
    return (err instanceof common_1.CancelledFailure ||
        ((err instanceof common_1.ActivityFailure || err instanceof common_1.ChildWorkflowFailure || err instanceof common_1.NexusOperationFailure) &&
            err.cause instanceof common_1.CancelledFailure));
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/flags.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/flags.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SdkFlags = void 0;
exports.assertValidFlag = assertValidFlag;
const flagsRegistry = new Map();
exports.SdkFlags = {
    /**
     * This flag gates multiple fixes related to cancellation scopes and timers introduced in 1.10.2/1.11.0:
     * - Cancellation of a non-cancellable scope no longer propagates to children scopes
     *   (see https://github.com/temporalio/sdk-typescript/issues/1423).
     * - CancellationScope.withTimeout(fn) now cancel the timer if `fn` completes before expiration
     *   of the timeout, similar to how `condition(fn, timeout)` works.
     * - Timers created using setTimeout can now be intercepted.
     *
     * @since Introduced in 1.10.2/1.11.0. However, due to an SDK bug, SDKs v1.11.0 and v1.11.1 were not
     *        properly writing back the flags to history, possibly resulting in NDE on replay. We therefore
     *        consider that a WFT emitted by Worker v1.11.0 or v1.11.1 to implicitly have this flag on.
     */
    NonCancellableScopesAreShieldedFromPropagation: defineFlag(1, true, [buildIdSdkVersionMatches(/1\.11\.[01]/)]),
    /**
     * Prior to 1.11.0, when processing a Workflow activation, the SDK would execute `notifyHasPatch`
     * and `signalWorkflow` jobs in distinct phases, before other types of jobs. The primary reason
     * behind that multi-phase algorithm was to avoid the possibility that a Workflow execution might
     * complete before all incoming signals have been dispatched (at least to the point that the
     * _synchronous_ part of the handler function has been executed).
     *
     * This flag replaces that multi-phase algorithm with a simpler one where jobs are simply sorted as
     * `(signals and updates) -> others`, but without processing them as distinct batches (i.e. without
     * leaving/reentering the VM context between each group, which automatically triggers the execution
     * of all outstanding microtasks). That single-phase approach resolves a number of quirks of the
     * former algorithm, and yet still satisfies to the original requirement of ensuring that every
     * `signalWorkflow` jobs - and now `doUpdate` jobs as well - have been given a proper chance to
     * execute before the Workflow main function might completes.
     *
     * @since Introduced in 1.11.0. This change is not rollback-safe. However, due to an SDK bug, SDKs
     *        v1.11.0 and v1.11.1 were not properly writing back the flags to history, possibly resulting
     *        in NDE on replay. We therefore consider that a WFT emitted by Worker v1.11.0 or v1.11.1
     *        to implicitely have this flag on.
     */
    ProcessWorkflowActivationJobsAsSingleBatch: defineFlag(2, true, [buildIdSdkVersionMatches(/1\.11\.[01]/)]),
};
function defineFlag(id, def, alternativeConditions) {
    const flag = { id, default: def, alternativeConditions };
    flagsRegistry.set(id, flag);
    return flag;
}
function assertValidFlag(id) {
    if (!flagsRegistry.has(id))
        throw new TypeError(`Unknown SDK flag: ${id}`);
}
function buildIdSdkVersionMatches(version) {
    const regex = new RegExp(`^@temporalio/worker@(${version.source})[+]`);
    return ({ info }) => info.currentBuildId != null && regex.test(info.currentBuildId); // eslint-disable-line deprecation/deprecation
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/global-attributes.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/global-attributes.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.maybeGetActivatorUntyped = maybeGetActivatorUntyped;
exports.setActivatorUntyped = setActivatorUntyped;
exports.maybeGetActivator = maybeGetActivator;
exports.assertInWorkflowContext = assertInWorkflowContext;
exports.getActivator = getActivator;
const common_1 = __webpack_require__(/*! @temporalio/common */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/index.js");
function maybeGetActivatorUntyped() {
    return globalThis.__TEMPORAL_ACTIVATOR__;
}
function setActivatorUntyped(activator) {
    globalThis.__TEMPORAL_ACTIVATOR__ = activator;
}
function maybeGetActivator() {
    return maybeGetActivatorUntyped();
}
function assertInWorkflowContext(message) {
    const activator = maybeGetActivator();
    if (activator == null)
        throw new common_1.IllegalStateError(message);
    return activator;
}
function getActivator() {
    const activator = maybeGetActivator();
    if (activator === undefined) {
        throw new common_1.IllegalStateError('Workflow uninitialized');
    }
    return activator;
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/global-overrides.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/global-overrides.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.overrideGlobals = overrideGlobals;
/**
 * Overrides some global objects to make them deterministic.
 *
 * @module
 */
const time_1 = __webpack_require__(/*! @temporalio/common/lib/time */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/time.js");
const cancellation_scope_1 = __webpack_require__(/*! ./cancellation-scope */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/cancellation-scope.js");
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/errors.js");
const global_attributes_1 = __webpack_require__(/*! ./global-attributes */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/global-attributes.js");
const flags_1 = __webpack_require__(/*! ./flags */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/flags.js");
const workflow_1 = __webpack_require__(/*! ./workflow */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/workflow.js");
const stack_helpers_1 = __webpack_require__(/*! ./stack-helpers */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/stack-helpers.js");
const global = globalThis;
const OriginalDate = globalThis.Date;
function overrideGlobals() {
    // Mock any weak reference because GC is non-deterministic and the effect is observable from the Workflow.
    // Workflow developer will get a meaningful exception if they try to use these.
    global.WeakRef = function () {
        throw new errors_1.DeterminismViolationError('WeakRef cannot be used in Workflows because v8 GC is non-deterministic');
    };
    global.FinalizationRegistry = function () {
        throw new errors_1.DeterminismViolationError('FinalizationRegistry cannot be used in Workflows because v8 GC is non-deterministic');
    };
    global.Date = function (...args) {
        if (args.length > 0) {
            return new OriginalDate(...args);
        }
        return new OriginalDate((0, global_attributes_1.getActivator)().now);
    };
    global.Date.now = function () {
        return (0, global_attributes_1.getActivator)().now;
    };
    global.Date.parse = OriginalDate.parse.bind(OriginalDate);
    global.Date.UTC = OriginalDate.UTC.bind(OriginalDate);
    global.Date.prototype = OriginalDate.prototype;
    const timeoutCancelationScopes = new Map();
    /**
     * @param ms sleep duration -  number of milliseconds. If given a negative number, value will be set to 1.
     */
    global.setTimeout = function (cb, ms, ...args) {
        ms = Math.max(1, ms);
        const activator = (0, global_attributes_1.getActivator)();
        if (activator.hasFlag(flags_1.SdkFlags.NonCancellableScopesAreShieldedFromPropagation)) {
            // Capture the sequence number that sleep will allocate
            const seq = activator.nextSeqs.timer;
            const timerScope = new cancellation_scope_1.CancellationScope({ cancellable: true });
            const sleepPromise = timerScope.run(() => (0, workflow_1.sleep)(ms));
            sleepPromise.then(() => {
                timeoutCancelationScopes.delete(seq);
                cb(...args);
            }, () => {
                timeoutCancelationScopes.delete(seq);
            });
            (0, stack_helpers_1.untrackPromise)(sleepPromise);
            timeoutCancelationScopes.set(seq, timerScope);
            return seq;
        }
        else {
            const seq = activator.nextSeqs.timer++;
            // Create a Promise for AsyncLocalStorage to be able to track this completion using promise hooks.
            new Promise((resolve, reject) => {
                activator.completions.timer.set(seq, { resolve, reject });
                activator.pushCommand({
                    startTimer: {
                        seq,
                        startToFireTimeout: (0, time_1.msToTs)(ms),
                    },
                });
            }).then(() => cb(...args), () => undefined /* ignore cancellation */);
            return seq;
        }
    };
    global.clearTimeout = function (handle) {
        const activator = (0, global_attributes_1.getActivator)();
        const timerScope = timeoutCancelationScopes.get(handle);
        if (timerScope) {
            timeoutCancelationScopes.delete(handle);
            timerScope.cancel();
        }
        else {
            activator.nextSeqs.timer++; // Shouldn't increase seq number, but that's the legacy behavior
            activator.completions.timer.delete(handle);
            activator.pushCommand({
                cancelTimer: {
                    seq: handle,
                },
            });
        }
    };
    // activator.random is mutable, don't hardcode its reference
    Math.random = () => (0, global_attributes_1.getActivator)().random();
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/index.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/index.js ***!
  \*******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * This library provides tools required for authoring workflows.
 *
 * ## Usage
 * See the {@link https://docs.temporal.io/typescript/hello-world#workflows | tutorial} for writing your first workflow.
 *
 * ### Timers
 *
 * The recommended way of scheduling timers is by using the {@link sleep} function. We've replaced `setTimeout` and
 * `clearTimeout` with deterministic versions so these are also usable but have a limitation that they don't play well
 * with {@link https://docs.temporal.io/typescript/cancellation-scopes | cancellation scopes}.
 *
 * <!--SNIPSTART typescript-sleep-workflow-->
 * <!--SNIPEND-->
 *
 * ### Activities
 *
 * To schedule Activities, use {@link proxyActivities} to obtain an Activity function and call.
 *
 * <!--SNIPSTART typescript-schedule-activity-workflow-->
 * <!--SNIPEND-->
 *
 * ### Updates, Signals and Queries
 *
 * Use {@link setHandler} to set handlers for Updates, Signals, and Queries.
 *
 * Update and Signal handlers can be either async or non-async functions. Update handlers may return a value, but signal
 * handlers may not (return `void` or `Promise<void>`). You may use Activities, Timers, child Workflows, etc in Update
 * and Signal handlers, but this should be done cautiously: for example, note that if you await async operations such as
 * these in an Update or Signal handler, then you are responsible for ensuring that the workflow does not complete first.
 *
 * Query handlers may **not** be async functions, and may **not** mutate any variables or use Activities, Timers,
 * child Workflows, etc.
 *
 * #### Implementation
 *
 * <!--SNIPSTART typescript-workflow-update-signal-query-example-->
 * <!--SNIPEND-->
 *
 * ### More
 *
 * - [Deterministic built-ins](https://docs.temporal.io/typescript/determinism#sources-of-non-determinism)
 * - [Cancellation and scopes](https://docs.temporal.io/typescript/cancellation-scopes)
 *   - {@link CancellationScope}
 *   - {@link Trigger}
 * - [Sinks](https://docs.temporal.io/application-development/observability/?lang=ts#logging)
 *   - {@link Sinks}
 *
 * @module
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createNexusClient = exports.metricMeter = exports.Trigger = exports.log = exports.proxySinks = exports.ParentClosePolicy = exports.ContinueAsNew = exports.ChildWorkflowCancellationType = exports.CancellationScope = exports.AsyncLocalStorage = exports.TimeoutFailure = exports.TerminatedFailure = exports.TemporalFailure = exports.ServerFailure = exports.rootCause = exports.defaultPayloadConverter = exports.ChildWorkflowFailure = exports.CancelledFailure = exports.ApplicationFailure = exports.ActivityFailure = exports.ActivityCancellationType = void 0;
var common_1 = __webpack_require__(/*! @temporalio/common */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/index.js");
Object.defineProperty(exports, "ActivityCancellationType", ({ enumerable: true, get: function () { return common_1.ActivityCancellationType; } }));
Object.defineProperty(exports, "ActivityFailure", ({ enumerable: true, get: function () { return common_1.ActivityFailure; } }));
Object.defineProperty(exports, "ApplicationFailure", ({ enumerable: true, get: function () { return common_1.ApplicationFailure; } }));
Object.defineProperty(exports, "CancelledFailure", ({ enumerable: true, get: function () { return common_1.CancelledFailure; } }));
Object.defineProperty(exports, "ChildWorkflowFailure", ({ enumerable: true, get: function () { return common_1.ChildWorkflowFailure; } }));
Object.defineProperty(exports, "defaultPayloadConverter", ({ enumerable: true, get: function () { return common_1.defaultPayloadConverter; } }));
Object.defineProperty(exports, "rootCause", ({ enumerable: true, get: function () { return common_1.rootCause; } }));
Object.defineProperty(exports, "ServerFailure", ({ enumerable: true, get: function () { return common_1.ServerFailure; } }));
Object.defineProperty(exports, "TemporalFailure", ({ enumerable: true, get: function () { return common_1.TemporalFailure; } }));
Object.defineProperty(exports, "TerminatedFailure", ({ enumerable: true, get: function () { return common_1.TerminatedFailure; } }));
Object.defineProperty(exports, "TimeoutFailure", ({ enumerable: true, get: function () { return common_1.TimeoutFailure; } }));
__exportStar(__webpack_require__(/*! @temporalio/common/lib/errors */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/errors.js"), exports);
__exportStar(__webpack_require__(/*! @temporalio/common/lib/workflow-handle */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/workflow-handle.js"), exports);
__exportStar(__webpack_require__(/*! @temporalio/common/lib/workflow-options */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/workflow-options.js"), exports);
var cancellation_scope_1 = __webpack_require__(/*! ./cancellation-scope */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/cancellation-scope.js");
Object.defineProperty(exports, "AsyncLocalStorage", ({ enumerable: true, get: function () { return cancellation_scope_1.AsyncLocalStorage; } }));
Object.defineProperty(exports, "CancellationScope", ({ enumerable: true, get: function () { return cancellation_scope_1.CancellationScope; } }));
__exportStar(__webpack_require__(/*! ./errors */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/errors.js"), exports);
__exportStar(__webpack_require__(/*! ./interceptors */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/interceptors.js"), exports);
var interfaces_1 = __webpack_require__(/*! ./interfaces */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/interfaces.js");
Object.defineProperty(exports, "ChildWorkflowCancellationType", ({ enumerable: true, get: function () { return interfaces_1.ChildWorkflowCancellationType; } }));
Object.defineProperty(exports, "ContinueAsNew", ({ enumerable: true, get: function () { return interfaces_1.ContinueAsNew; } }));
Object.defineProperty(exports, "ParentClosePolicy", ({ enumerable: true, get: function () { return interfaces_1.ParentClosePolicy; } }));
var sinks_1 = __webpack_require__(/*! ./sinks */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/sinks.js");
Object.defineProperty(exports, "proxySinks", ({ enumerable: true, get: function () { return sinks_1.proxySinks; } }));
var logs_1 = __webpack_require__(/*! ./logs */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/logs.js");
Object.defineProperty(exports, "log", ({ enumerable: true, get: function () { return logs_1.log; } }));
var trigger_1 = __webpack_require__(/*! ./trigger */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/trigger.js");
Object.defineProperty(exports, "Trigger", ({ enumerable: true, get: function () { return trigger_1.Trigger; } }));
__exportStar(__webpack_require__(/*! ./workflow */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/workflow.js"), exports);
var metrics_1 = __webpack_require__(/*! ./metrics */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/metrics.js");
Object.defineProperty(exports, "metricMeter", ({ enumerable: true, get: function () { return metrics_1.metricMeter; } }));
var nexus_1 = __webpack_require__(/*! ./nexus */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/nexus.js");
Object.defineProperty(exports, "createNexusClient", ({ enumerable: true, get: function () { return nexus_1.createNexusClient; } }));


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/interceptors.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/interceptors.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Type definitions for Workflow interceptors.
 *
 * @module
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/interfaces.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/interfaces.js ***!
  \************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var _a, _b;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeParentClosePolicy = exports.encodeParentClosePolicy = exports.ParentClosePolicy = exports.decodeChildWorkflowCancellationType = exports.encodeChildWorkflowCancellationType = exports.ChildWorkflowCancellationType = exports.ContinueAsNew = void 0;
const type_helpers_1 = __webpack_require__(/*! @temporalio/common/lib/type-helpers */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/type-helpers.js");
const enums_helpers_1 = __webpack_require__(/*! @temporalio/common/lib/internal-workflow/enums-helpers */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/internal-workflow/enums-helpers.js");
/**
 * Not an actual error, used by the Workflow runtime to abort execution when {@link continueAsNew} is called
 */
let ContinueAsNew = class ContinueAsNew extends Error {
    command;
    constructor(command) {
        super('Workflow continued as new');
        this.command = command;
    }
};
exports.ContinueAsNew = ContinueAsNew;
exports.ContinueAsNew = ContinueAsNew = __decorate([
    (0, type_helpers_1.SymbolBasedInstanceOfError)('ContinueAsNew')
], ContinueAsNew);
exports.ChildWorkflowCancellationType = {
    /**
     * Don't send a cancellation request to the Child.
     */
    ABANDON: 'ABANDON',
    /**
     * Send a cancellation request to the Child. Immediately throw the error.
     */
    TRY_CANCEL: 'TRY_CANCEL',
    /**
     * Send a cancellation request to the Child. The Child may respect cancellation, in which case an error will be thrown
     * when cancellation has completed, and {@link isCancellation}(error) will be true. On the other hand, the Child may
     * ignore the cancellation request, in which case an error might be thrown with a different cause, or the Child may
     * complete successfully.
     *
     * @default
     */
    WAIT_CANCELLATION_COMPLETED: 'WAIT_CANCELLATION_COMPLETED',
    /**
     * Send a cancellation request to the Child. Throw the error once the Server receives the Child cancellation request.
     */
    WAIT_CANCELLATION_REQUESTED: 'WAIT_CANCELLATION_REQUESTED',
};
// ts-prune-ignore-next
_a = (0, enums_helpers_1.makeProtoEnumConverters)({
    [exports.ChildWorkflowCancellationType.ABANDON]: 0,
    [exports.ChildWorkflowCancellationType.TRY_CANCEL]: 1,
    [exports.ChildWorkflowCancellationType.WAIT_CANCELLATION_COMPLETED]: 2,
    [exports.ChildWorkflowCancellationType.WAIT_CANCELLATION_REQUESTED]: 3,
}, ''), exports.encodeChildWorkflowCancellationType = _a[0], exports.decodeChildWorkflowCancellationType = _a[1];
exports.ParentClosePolicy = {
    /**
     * When the Parent is Closed, the Child is Terminated.
     *
     * @default
     */
    TERMINATE: 'TERMINATE',
    /**
     * When the Parent is Closed, nothing is done to the Child.
     */
    ABANDON: 'ABANDON',
    /**
     * When the Parent is Closed, the Child is Cancelled.
     */
    REQUEST_CANCEL: 'REQUEST_CANCEL',
    /// Anything below this line has been deprecated
    /**
     * If a `ParentClosePolicy` is set to this, or is not set at all, the server default value will be used.
     *
     * @deprecated Either leave property `undefined`, or set an explicit policy instead.
     */
    PARENT_CLOSE_POLICY_UNSPECIFIED: undefined, // eslint-disable-line deprecation/deprecation
    /**
     * When the Parent is Closed, the Child is Terminated.
     *
     * @deprecated Use {@link ParentClosePolicy.TERMINATE} instead.
     */
    PARENT_CLOSE_POLICY_TERMINATE: 'TERMINATE', // eslint-disable-line deprecation/deprecation
    /**
     * When the Parent is Closed, nothing is done to the Child.
     *
     * @deprecated Use {@link ParentClosePolicy.ABANDON} instead.
     */
    PARENT_CLOSE_POLICY_ABANDON: 'ABANDON', // eslint-disable-line deprecation/deprecation
    /**
     * When the Parent is Closed, the Child is Cancelled.
     *
     * @deprecated Use {@link ParentClosePolicy.REQUEST_CANCEL} instead.
     */
    PARENT_CLOSE_POLICY_REQUEST_CANCEL: 'REQUEST_CANCEL', // eslint-disable-line deprecation/deprecation
};
// ts-prune-ignore-next
_b = (0, enums_helpers_1.makeProtoEnumConverters)({
    [exports.ParentClosePolicy.TERMINATE]: 1,
    [exports.ParentClosePolicy.ABANDON]: 2,
    [exports.ParentClosePolicy.REQUEST_CANCEL]: 3,
    UNSPECIFIED: 0,
}, 'PARENT_CLOSE_POLICY_'), exports.encodeParentClosePolicy = _b[0], exports.decodeParentClosePolicy = _b[1];


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/internals.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/internals.js ***!
  \***********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Activator = void 0;
const common_1 = __webpack_require__(/*! @temporalio/common */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/index.js");
const payload_search_attributes_1 = __webpack_require__(/*! @temporalio/common/lib/converter/payload-search-attributes */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/converter/payload-search-attributes.js");
const interceptors_1 = __webpack_require__(/*! @temporalio/common/lib/interceptors */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/interceptors.js");
const internal_workflow_1 = __webpack_require__(/*! @temporalio/common/lib/internal-workflow */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/internal-workflow/index.js");
const reserved_1 = __webpack_require__(/*! @temporalio/common/lib/reserved */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/reserved.js");
const alea_1 = __webpack_require__(/*! ./alea */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/alea.js");
const cancellation_scope_1 = __webpack_require__(/*! ./cancellation-scope */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/cancellation-scope.js");
const update_scope_1 = __webpack_require__(/*! ./update-scope */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/update-scope.js");
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/errors.js");
const interfaces_1 = __webpack_require__(/*! ./interfaces */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/interfaces.js");
const stack_helpers_1 = __webpack_require__(/*! ./stack-helpers */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/stack-helpers.js");
const pkg_1 = __importDefault(__webpack_require__(/*! ./pkg */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/pkg.js"));
const flags_1 = __webpack_require__(/*! ./flags */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/flags.js");
const logs_1 = __webpack_require__(/*! ./logs */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/logs.js");
const StartChildWorkflowExecutionFailedCause = {
    WORKFLOW_ALREADY_EXISTS: 'WORKFLOW_ALREADY_EXISTS',
};
const [_encodeStartChildWorkflowExecutionFailedCause, decodeStartChildWorkflowExecutionFailedCause] = (0, internal_workflow_1.makeProtoEnumConverters)({
    [StartChildWorkflowExecutionFailedCause.WORKFLOW_ALREADY_EXISTS]: 1,
    UNSPECIFIED: 0,
}, 'START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_');
/**
 * Keeps all of the Workflow runtime state like pending completions for activities and timers.
 *
 * Implements handlers for all workflow activation jobs.
 *
 * Note that most methods in this class are meant to be called only from within the VM.
 *
 * However, a few methods may be called directly from outside the VM (essentially from `vm-shared.ts`).
 * These methods are specifically marked with a comment and require careful consideration, as the
 * execution context may not properly reflect that of the target workflow execution (e.g.: with Reusable
 * VMs, the `global` may not have been swapped to those of that workflow execution; the active microtask
 * queue may be that of the thread/process, rather than the queue of that VM context; etc). Consequently,
 * methods that are meant to be called from outside of the VM must not do any of the following:
 *
 * - Access any global variable;
 * - Create Promise objects, use async/await, or otherwise schedule microtasks;
 * - Call user-defined functions, including any form of interceptor.
 */
class Activator {
    /**
     * Cache for modules - referenced in reusable-vm.ts
     */
    moduleCache = new Map();
    /**
     * Map of task sequence to a Completion
     */
    completions = {
        timer: new Map(),
        activity: new Map(),
        nexusOperationStart: new Map(),
        nexusOperationComplete: new Map(),
        childWorkflowStart: new Map(),
        childWorkflowComplete: new Map(),
        signalWorkflow: new Map(),
        cancelWorkflow: new Map(),
    };
    /**
     * Holds buffered Update calls until a handler is registered
     */
    bufferedUpdates = Array();
    /**
     * Holds buffered signal calls until a handler is registered
     */
    bufferedSignals = Array();
    /**
     * Mapping of update name to handler and validator
     */
    updateHandlers = new Map();
    /**
     * Mapping of signal name to handler
     */
    signalHandlers = new Map();
    /**
     * Mapping of in-progress updates to handler execution information.
     */
    inProgressUpdates = new Map();
    /**
     * Mapping of in-progress signals to handler execution information.
     */
    inProgressSignals = new Map();
    /**
     * A sequence number providing unique identifiers for signal handler executions.
     */
    signalHandlerExecutionSeq = 0;
    /**
     * A signal handler that catches calls for non-registered signal names.
     */
    defaultSignalHandler;
    /**
     * A update handler that catches calls for non-registered update names.
     */
    defaultUpdateHandler;
    /**
     * A query handler that catches calls for non-registered query names.
     */
    defaultQueryHandler;
    /**
     * Source map file for looking up the source files in response to __enhanced_stack_trace
     */
    sourceMap;
    /**
     * Whether or not to send the sources in enhanced stack trace query responses
     */
    showStackTraceSources;
    promiseStackStore = {
        promiseToStack: new Map(),
        childToParent: new Map(),
    };
    /**
     * The error that caused the current Workflow Task to fail. Sets if a non-`TemporalFailure`
     * error bubbles up out of the Workflow function, or out of a Signal or Update handler. We
     * capture errors this way because those functions are not technically awaited when started,
     * but left to run asynchronously. There is therefore no real "parent" function that can
     * directly handle those errors, and not capturing it would result in an Unhandled Promise
     * Rejection. So instead, we buffer the error here, to then be processed in the context
     * of our own synchronous Activation handling event loop.
     *
     * Our code does a best effort to stop processing the current activation as soon as possible
     * after this field is set:
     *  - If an error is thrown while executing code synchronously (e.g. anything before the
     *    first `await` statement in a Workflow function or a signal/update handler), the error
     *    will be _immediately_ rethrown, which will prevent execution of further jobs in the
     *    current activation. We know we're currently running code synchronously thanks to the
     *    `rethrowSynchronously` flag below.
     *  - It an error is thrown while executing microtasks, then the error will be rethrown on
     *    the next call to `tryUnblockConditions()`.
     *
     * Unfortunately, there's no way for us to prevent further execution of microtasks that have
     * already been scheduled, nor those that will be recursively scheduled from those microtasks.
     * Should more errors get thrown while settling microtasks, those will be ignored (i.e. only
     * the first captured error is preserved).
     */
    workflowTaskError;
    /**
     * Set to true when running synchronous code (e.g. while processing activation jobs and when calling
     * `tryUnblockConditions()`). While this flag is set, it is safe to let errors bubble up.
     */
    rethrowSynchronously = false;
    rootScope = new cancellation_scope_1.RootCancellationScope();
    /**
     * Mapping of query name to handler
     */
    queryHandlers = new Map([
        [
            reserved_1.STACK_TRACE_QUERY_NAME,
            {
                handler: () => {
                    return new common_1.RawValue(this.getStackTraces()
                        .map((s) => s.formatted)
                        .join('\n\n'));
                },
                description: 'Returns a sensible stack trace.',
            },
        ],
        [
            reserved_1.ENHANCED_STACK_TRACE_QUERY_NAME,
            {
                handler: () => {
                    const { sourceMap } = this;
                    const sdk = { name: 'typescript', version: pkg_1.default.version };
                    const stacks = this.getStackTraces().map(({ structured: locations }) => ({ locations }));
                    const sources = {};
                    if (this.showStackTraceSources) {
                        for (const { locations } of stacks) {
                            for (const { file_path } of locations) {
                                if (!file_path)
                                    continue;
                                const content = sourceMap?.sourcesContent?.[sourceMap?.sources.indexOf(file_path)];
                                if (!content)
                                    continue;
                                sources[file_path] = [
                                    {
                                        line_offset: 0,
                                        content,
                                    },
                                ];
                            }
                        }
                    }
                    return new common_1.RawValue({ sdk, stacks, sources });
                },
                description: 'Returns a stack trace annotated with source information.',
            },
        ],
        [
            '__temporal_workflow_metadata',
            {
                handler: () => {
                    const workflowType = this.info.workflowType;
                    const queryDefinitions = Array.from(this.queryHandlers.entries()).map(([name, value]) => ({
                        name,
                        description: value.description,
                    }));
                    const signalDefinitions = Array.from(this.signalHandlers.entries()).map(([name, value]) => ({
                        name,
                        description: value.description,
                    }));
                    const updateDefinitions = Array.from(this.updateHandlers.entries()).map(([name, value]) => ({
                        name,
                        description: value.description,
                    }));
                    return new common_1.RawValue({
                        definition: {
                            type: workflowType,
                            queryDefinitions,
                            signalDefinitions,
                            updateDefinitions,
                        },
                        currentDetails: this.currentDetails,
                    });
                },
                description: 'Returns metadata associated with this workflow.',
            },
        ],
    ]);
    /**
     * Loaded in {@link initRuntime}
     */
    interceptors = {
        inbound: [],
        outbound: [],
        internals: [],
    };
    /**
     * Buffer that stores all generated commands, reset after each activation
     */
    commands = [];
    /**
     * Stores all {@link condition}s that haven't been unblocked yet
     */
    blockedConditions = new Map();
    /**
     * Is this Workflow completed?
     *
     * A Workflow will be considered completed if it generates a command that the
     * system considers as a final Workflow command (e.g.
     * completeWorkflowExecution or failWorkflowExecution).
     */
    completed = false;
    /**
     * Was this Workflow cancelled?
     */
    cancelled = false;
    /**
     * The next (incremental) sequence to assign when generating completable commands
     */
    nextSeqs = {
        timer: 1,
        activity: 1,
        childWorkflow: 1,
        signalWorkflow: 1,
        cancelWorkflow: 1,
        condition: 1,
        nexusOperation: 1,
        // Used internally to keep track of active stack traces
        stack: 1,
    };
    /**
     * This is set every time the workflow executes an activation
     * May be accessed and modified from outside the VM.
     */
    now;
    /**
     * Reference to the current Workflow, initialized when a Workflow is started
     */
    workflow;
    /**
     * Information about the current Workflow
     * May be accessed from outside the VM.
     */
    info;
    /**
     * A deterministic RNG, used by the isolate's overridden Math.random
     */
    random;
    payloadConverter = common_1.defaultPayloadConverter;
    failureConverter = common_1.defaultFailureConverter;
    /**
     * Patches we know the status of for this workflow, as in {@link patched}
     */
    knownPresentPatches = new Set();
    /**
     * Patches we sent to core {@link patched}
     */
    sentPatches = new Set();
    knownFlags = new Set();
    /**
     * Buffered sink calls per activation
     */
    sinkCalls = Array();
    /**
     * A nanosecond resolution time function, externally injected. This is used to
     * precisely sort logs entries emitted from the Workflow Context vs those emitted
     * from other sources (e.g. main thread, Core, etc).
     */
    getTimeOfDay;
    registeredActivityNames;
    currentDetails = '';
    versioningBehavior;
    workflowDefinitionOptionsGetter;
    constructor({ info, now, showStackTraceSources, sourceMap, getTimeOfDay, randomnessSeed, registeredActivityNames, }) {
        this.getTimeOfDay = getTimeOfDay;
        this.info = info;
        this.now = now;
        this.showStackTraceSources = showStackTraceSources;
        this.sourceMap = sourceMap;
        this.random = (0, alea_1.alea)(randomnessSeed);
        this.registeredActivityNames = registeredActivityNames;
    }
    /**
     * May be invoked from outside the VM.
     */
    mutateWorkflowInfo(fn) {
        this.info = fn(this.info);
    }
    getStackTraces() {
        const { childToParent, promiseToStack } = this.promiseStackStore;
        const internalNodes = [...childToParent.values()].reduce((acc, curr) => {
            for (const p of curr) {
                acc.add(p);
            }
            return acc;
        }, new Set());
        const stacks = new Map();
        for (const child of childToParent.keys()) {
            if (!internalNodes.has(child)) {
                const stack = promiseToStack.get(child);
                if (!stack || !stack.formatted)
                    continue;
                stacks.set(stack.formatted, stack);
            }
        }
        // Not 100% sure where this comes from, just filter it out
        stacks.delete('    at Promise.then (<anonymous>)');
        stacks.delete('    at Promise.then (<anonymous>)\n');
        return [...stacks].map(([_, stack]) => stack);
    }
    /**
     * May be invoked from outside the VM.
     */
    getAndResetSinkCalls() {
        const { sinkCalls } = this;
        this.sinkCalls = [];
        return sinkCalls;
    }
    /**
     * Buffer a Workflow command to be collected at the end of the current activation.
     *
     * Prevents commands from being added after Workflow completion.
     */
    pushCommand(cmd, complete = false) {
        this.commands.push(cmd);
        if (complete) {
            this.completed = true;
        }
    }
    concludeActivation() {
        return {
            commands: this.commands.splice(0),
            usedInternalFlags: [...this.knownFlags],
            versioningBehavior: this.versioningBehavior,
        };
    }
    async startWorkflowNextHandler({ args }) {
        const { workflow } = this;
        if (workflow == null) {
            throw new common_1.IllegalStateError('Workflow uninitialized');
        }
        return await workflow(...args);
    }
    startWorkflow(activation) {
        const execute = (0, interceptors_1.composeInterceptors)(this.interceptors.inbound, 'execute', this.startWorkflowNextHandler.bind(this));
        (0, stack_helpers_1.untrackPromise)((0, logs_1.executeWithLifecycleLogging)(() => execute({
            headers: activation.headers ?? {},
            args: (0, common_1.arrayFromPayloads)(this.payloadConverter, activation.arguments),
        })).then(this.completeWorkflow.bind(this), this.handleWorkflowFailure.bind(this)));
    }
    initializeWorkflow(activation) {
        const { continuedFailure, lastCompletionResult, memo, searchAttributes } = activation;
        // Most things related to initialization have already been handled in the constructor
        this.mutateWorkflowInfo((info) => ({
            ...info,
            searchAttributes: (0, payload_search_attributes_1.decodeSearchAttributes)(searchAttributes?.indexedFields),
            typedSearchAttributes: (0, payload_search_attributes_1.decodeTypedSearchAttributes)(searchAttributes?.indexedFields),
            memo: (0, common_1.mapFromPayloads)(this.payloadConverter, memo?.fields),
            lastResult: (0, common_1.fromPayloadsAtIndex)(this.payloadConverter, 0, lastCompletionResult?.payloads),
            lastFailure: continuedFailure != null
                ? this.failureConverter.failureToError(continuedFailure, this.payloadConverter)
                : undefined,
        }));
        if (this.workflowDefinitionOptionsGetter) {
            this.versioningBehavior = this.workflowDefinitionOptionsGetter().versioningBehavior;
        }
    }
    cancelWorkflow(_activation) {
        this.cancelled = true;
        this.rootScope.cancel();
    }
    fireTimer(activation) {
        // Timers are a special case where their completion might not be in Workflow state,
        // this is due to immediate timer cancellation that doesn't go wait for Core.
        const completion = this.maybeConsumeCompletion('timer', getSeq(activation));
        completion?.resolve(undefined);
    }
    resolveActivity(activation) {
        if (!activation.result) {
            throw new TypeError('Got ResolveActivity activation with no result');
        }
        const { resolve, reject } = this.consumeCompletion('activity', getSeq(activation));
        if (activation.result.completed) {
            const completed = activation.result.completed;
            const result = completed.result ? this.payloadConverter.fromPayload(completed.result) : undefined;
            resolve(result);
        }
        else if (activation.result.failed) {
            const { failure } = activation.result.failed;
            if (failure == null) {
                throw new TypeError('Got failed result with no failure attribute');
            }
            reject(this.failureToError(failure));
        }
        else if (activation.result.cancelled) {
            const { failure } = activation.result.cancelled;
            if (failure == null) {
                throw new TypeError('Got cancelled result with no failure attribute');
            }
            reject(this.failureToError(failure));
        }
        else if (activation.result.backoff) {
            reject(new errors_1.LocalActivityDoBackoff(activation.result.backoff));
        }
    }
    resolveChildWorkflowExecutionStart(activation) {
        const { resolve, reject } = this.consumeCompletion('childWorkflowStart', getSeq(activation));
        if (activation.succeeded) {
            if (!activation.succeeded.runId) {
                throw new TypeError('Got ResolveChildWorkflowExecutionStart with no runId');
            }
            resolve(activation.succeeded.runId);
        }
        else if (activation.failed) {
            if (decodeStartChildWorkflowExecutionFailedCause(activation.failed.cause) !== 'WORKFLOW_ALREADY_EXISTS') {
                throw new common_1.IllegalStateError('Got unknown StartChildWorkflowExecutionFailedCause');
            }
            if (!(activation.seq && activation.failed.workflowId && activation.failed.workflowType)) {
                throw new TypeError('Missing attributes in activation job');
            }
            reject(new common_1.WorkflowExecutionAlreadyStartedError('Workflow execution already started', activation.failed.workflowId, activation.failed.workflowType));
        }
        else if (activation.cancelled) {
            if (!activation.cancelled.failure) {
                throw new TypeError('Got no failure in cancelled variant');
            }
            reject(this.failureToError(activation.cancelled.failure));
        }
        else {
            throw new TypeError('Got ResolveChildWorkflowExecutionStart with no status');
        }
    }
    resolveChildWorkflowExecution(activation) {
        if (!activation.result) {
            throw new TypeError('Got ResolveChildWorkflowExecution activation with no result');
        }
        const { resolve, reject } = this.consumeCompletion('childWorkflowComplete', getSeq(activation));
        if (activation.result.completed) {
            const completed = activation.result.completed;
            const result = completed.result ? this.payloadConverter.fromPayload(completed.result) : undefined;
            resolve(result);
        }
        else if (activation.result.failed) {
            const { failure } = activation.result.failed;
            if (failure == null) {
                throw new TypeError('Got failed result with no failure attribute');
            }
            reject(this.failureToError(failure));
        }
        else if (activation.result.cancelled) {
            const { failure } = activation.result.cancelled;
            if (failure == null) {
                throw new TypeError('Got cancelled result with no failure attribute');
            }
            reject(this.failureToError(failure));
        }
    }
    resolveNexusOperationStart(activation) {
        const seq = getSeq(activation);
        const { resolve, reject } = this.consumeCompletion('nexusOperationStart', seq);
        if (!activation.failed) {
            const completePromise = new Promise((resolve, reject) => {
                this.completions.nexusOperationComplete.set(seq, {
                    resolve,
                    reject,
                });
            });
            (0, stack_helpers_1.untrackPromise)(completePromise);
            (0, stack_helpers_1.untrackPromise)(completePromise.catch(() => undefined));
            resolve({ token: activation.operationToken, result: completePromise });
        }
        else {
            reject(this.failureToError(activation.failed));
        }
    }
    resolveNexusOperation(activation) {
        const seq = getSeq(activation);
        if (activation.result?.completed) {
            const result = this.payloadConverter.fromPayload(activation.result.completed);
            // It is possible for ResolveNexusOperation to be received without a prior ResolveNexusOperationStart,
            // e.g. because the handler completed the Operation synchronously.
            const startCompletion = this.maybeConsumeCompletion('nexusOperationStart', seq);
            if (startCompletion) {
                startCompletion.resolve({ result: Promise.resolve(result) });
            }
            else {
                this.consumeCompletion('nexusOperationComplete', seq).resolve(result);
            }
        }
        else {
            let err;
            if (activation.result?.failed) {
                err = this.failureToError(activation.result.failed);
            }
            else if (activation.result?.cancelled) {
                err = this.failureToError(activation.result.cancelled);
            }
            else if (activation.result?.timedOut) {
                err = this.failureToError(activation.result.timedOut);
            }
            const completion = this.maybeConsumeCompletion('nexusOperationStart', seq) ??
                this.consumeCompletion('nexusOperationComplete', seq);
            completion.reject(err);
        }
    }
    // Intentionally non-async function so this handler doesn't show up in the stack trace
    queryWorkflowNextHandler({ queryName, args }) {
        let fn = this.queryHandlers.get(queryName)?.handler;
        if (fn === undefined && this.defaultQueryHandler !== undefined) {
            fn = this.defaultQueryHandler.bind(undefined, queryName);
        }
        // No handler or default registered, fail.
        if (fn === undefined) {
            const knownQueryTypes = [...this.queryHandlers.keys()].join(' ');
            // Fail the query
            return Promise.reject(new ReferenceError(`Workflow did not register a handler for ${queryName}. Registered queries: [${knownQueryTypes}]`));
        }
        // Execute handler.
        try {
            const ret = fn(...args);
            if (ret instanceof Promise) {
                return Promise.reject(new errors_1.DeterminismViolationError('Query handlers should not return a Promise'));
            }
            return Promise.resolve(ret);
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
    queryWorkflow(activation) {
        const { queryType, queryId, headers } = activation;
        if (!(queryType && queryId)) {
            throw new TypeError('Missing query activation attributes');
        }
        // If query has __temporal_ prefix but no handler exists, throw error
        if (queryType.startsWith(reserved_1.TEMPORAL_RESERVED_PREFIX) && !this.queryHandlers.has(queryType)) {
            throw new TypeError(`Cannot use query name: '${queryType}', with reserved prefix: '${reserved_1.TEMPORAL_RESERVED_PREFIX}'`);
        }
        // Skip interceptors if it's an internal query.
        const isInternalQuery = queryType.startsWith(reserved_1.TEMPORAL_RESERVED_PREFIX) ||
            queryType === reserved_1.STACK_TRACE_QUERY_NAME ||
            queryType === reserved_1.ENHANCED_STACK_TRACE_QUERY_NAME;
        const interceptors = isInternalQuery ? [] : this.interceptors.inbound;
        const execute = (0, interceptors_1.composeInterceptors)(interceptors, 'handleQuery', this.queryWorkflowNextHandler.bind(this));
        execute({
            queryName: queryType,
            args: (0, common_1.arrayFromPayloads)(this.payloadConverter, activation.arguments),
            queryId,
            headers: headers ?? {},
        }).then((result) => this.completeQuery(queryId, result), (reason) => this.failQuery(queryId, reason));
    }
    doUpdate(activation) {
        const { id: updateId, protocolInstanceId, name, headers, runValidator } = activation;
        if (!updateId) {
            throw new TypeError('Missing activation update id');
        }
        if (!name) {
            throw new TypeError('Missing activation update name');
        }
        if (!protocolInstanceId) {
            throw new TypeError('Missing activation update protocolInstanceId');
        }
        // If update has __temporal_ prefix but no handler exists, throw error
        if (name.startsWith(reserved_1.TEMPORAL_RESERVED_PREFIX) && !this.updateHandlers.get(name)) {
            throw new TypeError(`Cannot use update name: '${name}', with reserved prefix: '${reserved_1.TEMPORAL_RESERVED_PREFIX}'`);
        }
        // Skip interceptors if it's an internal update.
        const isInternalUpdate = name.startsWith(reserved_1.TEMPORAL_RESERVED_PREFIX) ||
            name === reserved_1.STACK_TRACE_QUERY_NAME ||
            name === reserved_1.ENHANCED_STACK_TRACE_QUERY_NAME;
        const interceptors = isInternalUpdate ? [] : this.interceptors.inbound;
        const entry = this.updateHandlers.get(name) ??
            (this.defaultUpdateHandler
                ? {
                    handler: this.defaultUpdateHandler.bind(undefined, name),
                    validator: undefined,
                    // Default to a warning policy.
                    unfinishedPolicy: common_1.HandlerUnfinishedPolicy.WARN_AND_ABANDON,
                }
                : null);
        // If we don't have an entry from either source, buffer and return
        if (entry == null) {
            this.bufferedUpdates.push(activation);
            return;
        }
        const makeInput = () => ({
            updateId,
            args: (0, common_1.arrayFromPayloads)(this.payloadConverter, activation.input),
            name,
            headers: headers ?? {},
        });
        // The implementation below is responsible for upholding, and constrained
        // by, the following contract:
        //
        // 1. If no validator is present then validation interceptors will not be run.
        //
        // 2. During validation, any error must fail the Update; during the Update
        //    itself, Temporal errors fail the Update whereas other errors fail the
        //    activation.
        //
        // 3. The handler must not see any mutations of the arguments made by the
        //    validator.
        //
        // 4. Any error when decoding/deserializing input must be caught and result
        //    in rejection of the Update before it is accepted, even if there is no
        //    validator.
        //
        // 5. The initial synchronous portion of the (async) Update handler should
        //    be executed after the (sync) validator completes such that there is
        //    minimal opportunity for a different concurrent task to be scheduled
        //    between them.
        //
        // 6. The stack trace view provided in the Temporal UI must not be polluted
        //    by promises that do not derive from user code. This implies that
        //    async/await syntax may not be used.
        //
        // Note that there is a deliberately unhandled promise rejection below.
        // These are caught elsewhere and fail the corresponding activation.
        const doUpdateImpl = async () => {
            let input;
            try {
                if (runValidator && entry.validator) {
                    const validate = (0, interceptors_1.composeInterceptors)(interceptors, 'validateUpdate', this.validateUpdateNextHandler.bind(this, entry.validator));
                    validate(makeInput());
                }
                input = makeInput();
            }
            catch (error) {
                this.rejectUpdate(protocolInstanceId, error);
                return;
            }
            this.acceptUpdate(protocolInstanceId);
            const execute = (0, interceptors_1.composeInterceptors)(interceptors, 'handleUpdate', this.updateNextHandler.bind(this, entry.handler));
            const { unfinishedPolicy } = entry;
            this.inProgressUpdates.set(updateId, { name, unfinishedPolicy, id: updateId });
            const res = execute(input)
                .then((result) => this.completeUpdate(protocolInstanceId, result))
                .catch((error) => {
                if (error instanceof common_1.TemporalFailure) {
                    this.rejectUpdate(protocolInstanceId, error);
                }
                else {
                    this.handleWorkflowFailure(error);
                }
            })
                .finally(() => this.inProgressUpdates.delete(updateId));
            (0, stack_helpers_1.untrackPromise)(res);
            return res;
        };
        (0, stack_helpers_1.untrackPromise)(update_scope_1.UpdateScope.updateWithInfo(updateId, name, doUpdateImpl));
    }
    async updateNextHandler(handler, { args }) {
        return await handler(...args);
    }
    validateUpdateNextHandler(validator, { args }) {
        if (validator) {
            validator(...args);
        }
    }
    dispatchBufferedUpdates() {
        const bufferedUpdates = this.bufferedUpdates;
        while (bufferedUpdates.length) {
            // We have a default update handler, so all updates are dispatchable.
            if (this.defaultUpdateHandler) {
                const update = bufferedUpdates.shift();
                // Logically, this must be defined as we're in the loop.
                // But Typescript doesn't know that so we use a non-null assertion (!).
                this.doUpdate(update);
            }
            else {
                const foundIndex = bufferedUpdates.findIndex((update) => this.updateHandlers.has(update.name));
                if (foundIndex === -1) {
                    // No buffered Updates have a handler yet.
                    break;
                }
                const [update] = bufferedUpdates.splice(foundIndex, 1);
                this.doUpdate(update);
            }
        }
    }
    rejectBufferedUpdates() {
        while (this.bufferedUpdates.length) {
            const update = this.bufferedUpdates.shift();
            if (update) {
                this.rejectUpdate(
                /* eslint-disable @typescript-eslint/no-non-null-assertion */
                update.protocolInstanceId, common_1.ApplicationFailure.nonRetryable(`No registered handler for update: ${update.name}`));
            }
        }
    }
    async signalWorkflowNextHandler({ signalName, args }) {
        const fn = this.signalHandlers.get(signalName)?.handler;
        if (fn) {
            return await fn(...args);
        }
        else if (this.defaultSignalHandler) {
            return await this.defaultSignalHandler(signalName, ...args);
        }
        else {
            throw new common_1.IllegalStateError(`No registered signal handler for signal: ${signalName}`);
        }
    }
    signalWorkflow(activation) {
        const { signalName, headers } = activation;
        if (!signalName) {
            throw new TypeError('Missing activation signalName');
        }
        // If signal has __temporal_ prefix but no handler exists, throw error
        if (signalName.startsWith(reserved_1.TEMPORAL_RESERVED_PREFIX) && !this.signalHandlers.has(signalName)) {
            throw new TypeError(`Cannot use signal name: '${signalName}', with reserved prefix: '${reserved_1.TEMPORAL_RESERVED_PREFIX}'`);
        }
        // Skip interceptors if it's an internal signal.
        const isInternalSignal = signalName.startsWith(reserved_1.TEMPORAL_RESERVED_PREFIX) ||
            signalName === reserved_1.STACK_TRACE_QUERY_NAME ||
            signalName === reserved_1.ENHANCED_STACK_TRACE_QUERY_NAME;
        const interceptors = isInternalSignal ? [] : this.interceptors.inbound;
        if (!this.signalHandlers.has(signalName) && !this.defaultSignalHandler) {
            this.bufferedSignals.push(activation);
            return;
        }
        // If we fall through to the default signal handler then the unfinished
        // policy is WARN_AND_ABANDON; users currently have no way to silence any
        // ensuing warnings.
        const unfinishedPolicy = this.signalHandlers.get(signalName)?.unfinishedPolicy ?? common_1.HandlerUnfinishedPolicy.WARN_AND_ABANDON;
        const signalExecutionNum = this.signalHandlerExecutionSeq++;
        this.inProgressSignals.set(signalExecutionNum, { name: signalName, unfinishedPolicy });
        const execute = (0, interceptors_1.composeInterceptors)(interceptors, 'handleSignal', this.signalWorkflowNextHandler.bind(this));
        execute({
            args: (0, common_1.arrayFromPayloads)(this.payloadConverter, activation.input),
            signalName,
            headers: headers ?? {},
        })
            .catch(this.handleWorkflowFailure.bind(this))
            .finally(() => this.inProgressSignals.delete(signalExecutionNum));
    }
    dispatchBufferedSignals() {
        const bufferedSignals = this.bufferedSignals;
        while (bufferedSignals.length) {
            if (this.defaultSignalHandler) {
                // We have a default signal handler, so all signals are dispatchable
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.signalWorkflow(bufferedSignals.shift());
            }
            else {
                const foundIndex = bufferedSignals.findIndex((signal) => this.signalHandlers.has(signal.signalName));
                if (foundIndex === -1)
                    break;
                const [signal] = bufferedSignals.splice(foundIndex, 1);
                this.signalWorkflow(signal);
            }
        }
    }
    resolveSignalExternalWorkflow(activation) {
        const { resolve, reject } = this.consumeCompletion('signalWorkflow', getSeq(activation));
        if (activation.failure) {
            reject(this.failureToError(activation.failure));
        }
        else {
            resolve(undefined);
        }
    }
    resolveRequestCancelExternalWorkflow(activation) {
        const { resolve, reject } = this.consumeCompletion('cancelWorkflow', getSeq(activation));
        if (activation.failure) {
            reject(this.failureToError(activation.failure));
        }
        else {
            resolve(undefined);
        }
    }
    warnIfUnfinishedHandlers() {
        if (this.workflowTaskError)
            return;
        const getWarnable = (handlerExecutions) => {
            return Array.from(handlerExecutions).filter((ex) => ex.unfinishedPolicy === common_1.HandlerUnfinishedPolicy.WARN_AND_ABANDON);
        };
        const warnableUpdates = getWarnable(this.inProgressUpdates.values());
        if (warnableUpdates.length > 0) {
            logs_1.log.warn(makeUnfinishedUpdateHandlerMessage(warnableUpdates));
        }
        const warnableSignals = getWarnable(this.inProgressSignals.values());
        if (warnableSignals.length > 0) {
            logs_1.log.warn(makeUnfinishedSignalHandlerMessage(warnableSignals));
        }
    }
    updateRandomSeed(activation) {
        if (!activation.randomnessSeed) {
            throw new TypeError('Expected activation with randomnessSeed attribute');
        }
        this.random = (0, alea_1.alea)(activation.randomnessSeed.toBytes());
    }
    notifyHasPatch(activation) {
        if (!this.info.unsafe.isReplaying)
            throw new common_1.IllegalStateError('Unexpected notifyHasPatch job on non-replay activation');
        if (!activation.patchId)
            throw new TypeError('notifyHasPatch missing patch id');
        this.knownPresentPatches.add(activation.patchId);
    }
    patchInternal(patchId, deprecated) {
        if (this.workflow === undefined) {
            throw new common_1.IllegalStateError('Patches cannot be used before Workflow starts');
        }
        const usePatch = !this.info.unsafe.isReplaying || this.knownPresentPatches.has(patchId);
        // Avoid sending commands for patches core already knows about.
        // This optimization enables development of automatic patching tools.
        if (usePatch && !this.sentPatches.has(patchId)) {
            this.pushCommand({
                setPatchMarker: { patchId, deprecated },
            });
            this.sentPatches.add(patchId);
        }
        return usePatch;
    }
    /**
     * Called early while handling an activation to register known flags.
     * May be invoked from outside the VM.
     */
    addKnownFlags(flags) {
        for (const flag of flags) {
            (0, flags_1.assertValidFlag)(flag);
            this.knownFlags.add(flag);
        }
    }
    /**
     * Check if an SDK Flag may be considered as enabled for the current Workflow Task.
     *
     * SDK flags play a role similar to the `patched()` API, but are meant for internal usage by the
     * SDK itself. They make it possible for the SDK to evolve its behaviors over time, while still
     * maintaining compatibility with Workflow histories produced by older SDKs, without causing
     * determinism violations.
     *
     * May be invoked from outside the VM.
     */
    hasFlag(flag) {
        if (this.knownFlags.has(flag.id))
            return true;
        // If not replaying, enable the flag if it is configured to be enabled by default. Setting a
        // flag's default to false allows progressive rollout of new feature flags, with the possibility
        // of reverting back to a version of the SDK where the flag is supported but disabled by default.
        // It is also useful for testing purpose.
        if (!this.info.unsafe.isReplaying && flag.default) {
            this.knownFlags.add(flag.id);
            return true;
        }
        // When replaying, a flag is considered enabled if it was enabled during the original execution of
        // that Workflow Task; this is normally determined by the presence of the flag ID in the corresponding
        // WFT Completed's `sdkMetadata.langUsedFlags`.
        //
        // SDK Flag Alternate Condition provides an alternative way of determining whether a flag should
        // be considered as enabled for the current WFT; e.g. by looking at the version of the SDK that
        // emitted a WFT. The main use case for this is to retroactively turn on some flags for WFT emitted
        // by previous SDKs that contained a bug. Alt Conditions should only be used as a last resort.
        //
        // Note that conditions are only evaluated while replaying. Also, alternate conditions will not
        // cause the flag to be persisted to the "used flags" set, which means that further Workflow Tasks
        // may not reflect this flag if the condition no longer holds. This is so to avoid incorrect
        // behaviors in case where a Workflow Execution has gone through a newer SDK version then again
        // through an older one.
        if (this.info.unsafe.isReplaying && flag.alternativeConditions) {
            for (const cond of flag.alternativeConditions) {
                if (cond({ info: this.info }))
                    return true;
            }
        }
        return false;
    }
    removeFromCache() {
        throw new common_1.IllegalStateError('removeFromCache activation job should not reach workflow');
    }
    /**
     * Transforms failures into a command to be sent to the server.
     * Used to handle any failure emitted by the Workflow.
     */
    handleWorkflowFailure(error) {
        if (this.cancelled && (0, errors_1.isCancellation)(error)) {
            this.pushCommand({ cancelWorkflowExecution: {} }, true);
        }
        else if (error instanceof interfaces_1.ContinueAsNew) {
            this.pushCommand({ continueAsNewWorkflowExecution: error.command }, true);
        }
        else if (error instanceof common_1.TemporalFailure) {
            // Fail the workflow. We do not want to issue unfinishedHandlers warnings. To achieve that, we
            // mark all handlers as completed now.
            this.inProgressSignals.clear();
            this.inProgressUpdates.clear();
            this.pushCommand({
                failWorkflowExecution: {
                    failure: this.errorToFailure(error),
                },
            }, true);
        }
        else {
            this.recordWorkflowTaskError(error);
        }
    }
    recordWorkflowTaskError(error) {
        // Only keep the first error that bubbles up; subsequent errors will be ignored.
        if (this.workflowTaskError === undefined)
            this.workflowTaskError = error;
        // Immediately rethrow the error if we know it is safe to do so (i.e. we are not running async
        // microtasks). Otherwise, the error will be rethrown whenever we get an opportunity to do so,
        // e.g. the next time `tryUnblockConditions()` is called.
        if (this.rethrowSynchronously)
            this.maybeRethrowWorkflowTaskError();
    }
    /**
     * If a Workflow Task error was captured, and we are running in synchronous mode,
     * then bubble it up now. This is safe to call even if there is no error to rethrow.
     */
    maybeRethrowWorkflowTaskError() {
        if (this.workflowTaskError)
            throw this.workflowTaskError;
    }
    completeQuery(queryId, result) {
        this.pushCommand({
            respondToQuery: { queryId, succeeded: { response: this.payloadConverter.toPayload(result) } },
        });
    }
    failQuery(queryId, error) {
        this.pushCommand({
            respondToQuery: {
                queryId,
                failed: this.errorToFailure((0, common_1.ensureTemporalFailure)(error)),
            },
        });
    }
    acceptUpdate(protocolInstanceId) {
        this.pushCommand({ updateResponse: { protocolInstanceId, accepted: {} } });
    }
    completeUpdate(protocolInstanceId, result) {
        this.pushCommand({
            updateResponse: { protocolInstanceId, completed: this.payloadConverter.toPayload(result) },
        });
    }
    rejectUpdate(protocolInstanceId, error) {
        this.pushCommand({
            updateResponse: {
                protocolInstanceId,
                rejected: this.errorToFailure((0, common_1.ensureTemporalFailure)(error)),
            },
        });
    }
    /** Consume a completion if it exists in Workflow state */
    maybeConsumeCompletion(type, taskSeq) {
        const completion = this.completions[type].get(taskSeq);
        if (completion !== undefined) {
            this.completions[type].delete(taskSeq);
        }
        return completion;
    }
    /** Consume a completion if it exists in Workflow state, throws if it doesn't */
    consumeCompletion(type, taskSeq) {
        const completion = this.maybeConsumeCompletion(type, taskSeq);
        if (completion === undefined) {
            throw new common_1.IllegalStateError(`No completion for taskSeq ${taskSeq}`);
        }
        return completion;
    }
    completeWorkflow(result) {
        this.pushCommand({
            completeWorkflowExecution: {
                result: this.payloadConverter.toPayload(result),
            },
        }, true);
    }
    errorToFailure(err) {
        return this.failureConverter.errorToFailure(err, this.payloadConverter);
    }
    failureToError(failure) {
        return this.failureConverter.failureToError(failure, this.payloadConverter);
    }
}
exports.Activator = Activator;
function getSeq(activation) {
    const seq = activation.seq;
    if (seq == null) {
        throw new TypeError(`Got activation with no seq attribute`);
    }
    return seq;
}
function makeUnfinishedUpdateHandlerMessage(handlerExecutions) {
    const message = `
[TMPRL1102] Workflow finished while an update handler was still running. This may have interrupted work that the
update handler was doing, and the client that sent the update will receive a 'workflow execution
already completed' RPCError instead of the update result. You can wait for all update and signal
handlers to complete by using \`await workflow.condition(workflow.allHandlersFinished)\`.
Alternatively, if both you and the clients sending the update are okay with interrupting running handlers
when the workflow finishes, and causing clients to receive errors, then you can disable this warning by
passing an option when setting the handler:
\`workflow.setHandler(myUpdate, myUpdateHandler, {unfinishedPolicy: HandlerUnfinishedPolicy.ABANDON});\`.`
        .replace(/\n/g, ' ')
        .trim();
    return `${message} The following updates were unfinished (and warnings were not disabled for their handler): ${JSON.stringify(handlerExecutions.map((ex) => ({ name: ex.name, id: ex.id })))}`;
}
function makeUnfinishedSignalHandlerMessage(handlerExecutions) {
    const message = `
[TMPRL1102] Workflow finished while a signal handler was still running. This may have interrupted work that the
signal handler was doing. You can wait for all update and signal handlers to complete by using
\`await workflow.condition(workflow.allHandlersFinished)\`. Alternatively, if both you and the
clients sending the update are okay with interrupting running handlers when the workflow finishes,
then you can disable this warning by passing an option when setting the handler:
\`workflow.setHandler(mySignal, mySignalHandler, {unfinishedPolicy: HandlerUnfinishedPolicy.ABANDON});\`.`
        .replace(/\n/g, ' ')
        .trim();
    const names = new Map();
    for (const ex of handlerExecutions) {
        const count = names.get(ex.name) || 0;
        names.set(ex.name, count + 1);
    }
    return `${message} The following signals were unfinished (and warnings were not disabled for their handler): ${JSON.stringify(Array.from(names.entries()).map(([name, count]) => ({ name, count })))}`;
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/logs.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/logs.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.log = void 0;
exports.executeWithLifecycleLogging = executeWithLifecycleLogging;
exports.workflowLogAttributes = workflowLogAttributes;
const interceptors_1 = __webpack_require__(/*! @temporalio/common/lib/interceptors */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/interceptors.js");
const common_1 = __webpack_require__(/*! @temporalio/common */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/index.js");
const stack_helpers_1 = __webpack_require__(/*! ./stack-helpers */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/stack-helpers.js");
const sinks_1 = __webpack_require__(/*! ./sinks */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/sinks.js");
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/errors.js");
const interfaces_1 = __webpack_require__(/*! ./interfaces */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/interfaces.js");
const global_attributes_1 = __webpack_require__(/*! ./global-attributes */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/global-attributes.js");
const workflow_1 = __webpack_require__(/*! ./workflow */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/workflow.js");
const loggerSink = (0, sinks_1.proxySinks)().__temporal_logger;
/**
 * Symbol used by the SDK logger to extract a timestamp from log attributes.
 * Also defined in `worker/logger.ts` - intentionally not shared.
 */
const LogTimestamp = Symbol.for('log_timestamp');
/**
 * Default workflow logger.
 *
 * This logger is replay-aware and will omit log messages on workflow replay. Messages emitted by this logger are
 * funnelled through a sink that forwards them to the logger registered on {@link Runtime.logger}.
 *
 * Attributes from the current Workflow Execution context are automatically included as metadata on every log
 * entries. An extra `sdkComponent` metadata attribute is also added, with value `workflow`; this can be used for
 * fine-grained filtering of log entries further downstream.
 *
 * To customize log attributes, register a {@link WorkflowOutboundCallsInterceptor} that intercepts the
 * `getLogAttributes()` method.
 *
 * Notice that since sinks are used to power this logger, any log attributes must be transferable via the
 * {@link https://nodejs.org/api/worker_threads.html#worker_threads_port_postmessage_value_transferlist | postMessage}
 * API.
 *
 * NOTE: Specifying a custom logger through {@link defaultSink} or by manually registering a sink named
 * `defaultWorkerLogger` has been deprecated. Please use {@link Runtime.logger} instead.
 */
exports.log = Object.fromEntries(['trace', 'debug', 'info', 'warn', 'error'].map((level) => {
    return [
        level,
        (message, attrs) => {
            const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.log(...) may only be used from workflow context.');
            const getLogAttributes = (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'getLogAttributes', (a) => a);
            return loggerSink[level](message, {
                // Inject the call time in nanosecond resolution as expected by the worker logger.
                [LogTimestamp]: activator.getTimeOfDay(),
                sdkComponent: common_1.SdkComponent.workflow,
                ...getLogAttributes(workflowLogAttributes(activator.info)),
                ...attrs,
            });
        },
    ];
}));
function executeWithLifecycleLogging(fn) {
    exports.log.debug('Workflow started', { sdkComponent: common_1.SdkComponent.worker });
    const p = fn().then((res) => {
        exports.log.debug('Workflow completed', { sdkComponent: common_1.SdkComponent.worker });
        return res;
    }, (error) => {
        // Avoid using instanceof checks in case the modules they're defined in loaded more than once,
        // e.g. by jest or when multiple versions are installed.
        if (typeof error === 'object' && error != null) {
            if ((0, errors_1.isCancellation)(error)) {
                exports.log.debug('Workflow completed as cancelled', { sdkComponent: common_1.SdkComponent.worker });
                throw error;
            }
            else if (error instanceof interfaces_1.ContinueAsNew) {
                exports.log.debug('Workflow continued as new', { sdkComponent: common_1.SdkComponent.worker });
                throw error;
            }
        }
        exports.log.warn('Workflow failed', { error, sdkComponent: common_1.SdkComponent.worker });
        throw error;
    });
    // Avoid showing this interceptor in stack trace query
    (0, stack_helpers_1.untrackPromise)(p);
    return p;
}
/**
 * Returns a map of attributes to be set _by default_ on log messages for a given Workflow.
 * Note that this function may be called from outside of the Workflow context (eg. by the worker itself).
 */
function workflowLogAttributes(info) {
    const attributes = {
        namespace: info.namespace,
        taskQueue: info.taskQueue,
        workflowId: info.workflowId,
        runId: info.runId,
        workflowType: info.workflowType,
    };
    if ((0, workflow_1.inWorkflowContext)()) {
        const updateInfo = (0, workflow_1.currentUpdateInfo)();
        if (updateInfo) {
            // Add update info if it exists
            attributes['updateId'] = updateInfo.id;
            attributes['updateName'] = updateInfo.name;
        }
    }
    return attributes;
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/metrics.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/metrics.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.metricMeter = void 0;
const common_1 = __webpack_require__(/*! @temporalio/common */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/index.js");
const interceptors_1 = __webpack_require__(/*! @temporalio/common/lib/interceptors */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/interceptors.js");
const sinks_1 = __webpack_require__(/*! ./sinks */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/sinks.js");
const workflow_1 = __webpack_require__(/*! ./workflow */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/workflow.js");
const global_attributes_1 = __webpack_require__(/*! ./global-attributes */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/global-attributes.js");
class WorkflowMetricMeterImpl {
    constructor() { }
    createCounter(name, unit, description) {
        (0, global_attributes_1.assertInWorkflowContext)("Workflow's `metricMeter` can only be used while in Workflow Context");
        return new WorkflowMetricCounter(name, unit, description);
    }
    createHistogram(name, valueType = 'int', unit, description) {
        (0, global_attributes_1.assertInWorkflowContext)("Workflow's `metricMeter` can only be used while in Workflow Context");
        return new WorkflowMetricHistogram(name, valueType, unit, description);
    }
    createGauge(name, valueType = 'int', unit, description) {
        (0, global_attributes_1.assertInWorkflowContext)("Workflow's `metricMeter` can only be used while in Workflow Context");
        return new WorkflowMetricGauge(name, valueType, unit, description);
    }
    withTags(_tags) {
        (0, global_attributes_1.assertInWorkflowContext)("Workflow's `metricMeter` can only be used while in Workflow Context");
        // Tags composition is handled by a MetricMeterWithComposedTags wrapper over this one
        throw new Error(`withTags is not supported directly on WorkflowMetricMeter`);
    }
}
class WorkflowMetricCounter {
    name;
    unit;
    description;
    constructor(name, unit, description) {
        this.name = name;
        this.unit = unit;
        this.description = description;
    }
    add(value, extraTags = {}) {
        if (value < 0) {
            throw new Error(`MetricCounter value must be non-negative (got ${value})`);
        }
        if (!(0, workflow_1.workflowInfo)().unsafe.isReplaying) {
            metricSink.addMetricCounterValue(this.name, this.unit, this.description, value, extraTags);
        }
    }
    withTags(_tags) {
        // Tags composition is handled by a MetricMeterWithComposedTags wrapper over this one
        throw new Error(`withTags is not supported directly on WorkflowMetricCounter`);
    }
}
class WorkflowMetricHistogram {
    name;
    valueType;
    unit;
    description;
    constructor(name, valueType, unit, description) {
        this.name = name;
        this.valueType = valueType;
        this.unit = unit;
        this.description = description;
    }
    record(value, extraTags = {}) {
        if (value < 0) {
            throw new Error(`MetricHistogram value must be non-negative (got ${value})`);
        }
        if (!(0, workflow_1.workflowInfo)().unsafe.isReplaying) {
            metricSink.recordMetricHistogramValue(this.name, this.valueType, this.unit, this.description, value, extraTags);
        }
    }
    withTags(_tags) {
        // Tags composition is handled by a MetricMeterWithComposedTags wrapper over this one
        throw new Error(`withTags is not supported directly on WorkflowMetricHistogram`);
    }
}
class WorkflowMetricGauge {
    name;
    valueType;
    unit;
    description;
    constructor(name, valueType, unit, description) {
        this.name = name;
        this.valueType = valueType;
        this.unit = unit;
        this.description = description;
    }
    set(value, tags) {
        if (value < 0) {
            throw new Error(`MetricGauge value must be non-negative (got ${value})`);
        }
        if (!(0, workflow_1.workflowInfo)().unsafe.isReplaying) {
            metricSink.setMetricGaugeValue(this.name, this.valueType, this.unit, this.description, value, tags ?? {});
        }
    }
    withTags(_tags) {
        // Tags composition is handled by a MetricMeterWithComposedTags wrapper over this one
        throw new Error(`withTags is not supported directly on WorkflowMetricGauge`);
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////
// Note: given that forwarding metrics outside of the sanbox can be quite chatty and add non
// negligeable overhead, we eagerly check for `isReplaying` and completely skip doing sink
// calls if we are replaying.
const metricSink = (0, sinks_1.proxySinks)().__temporal_metrics;
/**
 * A MetricMeter that can be used to emit metrics from within a Workflow.
 *
 * @experimental The Metric API is an experimental feature and may be subject to change.
 */
exports.metricMeter = common_1.MetricMeterWithComposedTags.compose(new WorkflowMetricMeterImpl(), () => {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.metricMeter may only be used from workflow context.');
    const getMetricTags = (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'getMetricTags', (a) => a);
    const info = activator.info;
    return getMetricTags({
        // namespace and taskQueue will be added by the Worker
        workflowType: info.workflowType,
    });
}, true);


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/nexus.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/nexus.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createNexusClient = createNexusClient;
const time_1 = __webpack_require__(/*! @temporalio/common/lib/time */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/time.js");
const user_metadata_1 = __webpack_require__(/*! @temporalio/common/lib/user-metadata */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/user-metadata.js");
const interceptors_1 = __webpack_require__(/*! @temporalio/common/lib/interceptors */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/interceptors.js");
const cancellation_scope_1 = __webpack_require__(/*! ./cancellation-scope */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/cancellation-scope.js");
const global_attributes_1 = __webpack_require__(/*! ./global-attributes */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/global-attributes.js");
const stack_helpers_1 = __webpack_require__(/*! ./stack-helpers */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/stack-helpers.js");
/**
 * Create a Nexus client for invoking Nexus Operations from a Workflow.
 *
 * @experimental Nexus support in Temporal SDK is experimental.
 */
function createNexusClient(options) {
    class NexusClientImpl {
        async executeOperation(operation, input, operationOptions) {
            const handle = await this.startOperation(operation, input, operationOptions);
            return await handle.result();
        }
        async startOperation(operation, input, operationOptions) {
            const opName = typeof operation === 'string' ? options.service.operations[operation]?.name : operation.name;
            const activator = (0, global_attributes_1.getActivator)();
            const seq = activator.nextSeqs.nexusOperation++;
            const execute = (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'startNexusOperation', startNexusOperationNextHandler);
            // TODO: Do we want to make the interceptor async like we do for child workflow? That seems redundant.
            // REVIEW: I ended up changing this so that the interceptor returns a Promise<StartNexusOperationOutput>,
            //         and the result promise is contained in that Output object. As a consequence of this,
            //         the result promise/completion does not exist until the StartNexusOperation event is received.
            //         That's totally different from what we did in ChildWorkflow, but I think that's cleaner from
            //         interceptors point of view, and will make it easier to extend the API in the future.
            const { token, result: resultPromise } = await execute({
                endpoint: options.endpoint,
                service: options.service.name,
                operation: opName,
                options: operationOptions ?? {},
                headers: {},
                seq,
                input,
            });
            return {
                service: options.service.name,
                operation: opName,
                token,
                async result() {
                    return resultPromise;
                },
            };
        }
    }
    return new NexusClientImpl();
}
function startNexusOperationNextHandler({ input, endpoint, service, options, operation, seq, headers, }) {
    const activator = (0, global_attributes_1.getActivator)();
    return new Promise((resolve, reject) => {
        const scope = cancellation_scope_1.CancellationScope.current();
        if (scope.consideredCancelled) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(reject));
            return;
        }
        if (scope.cancellable) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(() => {
                const completed = !activator.completions.nexusOperationStart.has(seq) &&
                    !activator.completions.nexusOperationComplete.has(seq);
                if (!completed) {
                    activator.pushCommand({
                        requestCancelNexusOperation: { seq },
                    });
                }
                // Nothing to cancel otherwise
            }));
        }
        activator.pushCommand({
            scheduleNexusOperation: {
                seq,
                endpoint,
                service,
                operation,
                nexusHeader: headers,
                input: activator.payloadConverter.toPayload(input),
                scheduleToCloseTimeout: (0, time_1.msOptionalToTs)(options?.scheduleToCloseTimeout),
                // FIXME(nexus-post-initial-release): cancellationType is not supported yet
            },
            userMetadata: (0, user_metadata_1.userMetadataToPayload)(activator.payloadConverter, options?.summary, undefined),
        });
        activator.completions.nexusOperationStart.set(seq, {
            resolve,
            reject,
        });
    });
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/pkg.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/pkg.js ***!
  \*****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// ../package.json is outside of the TS project rootDir which causes TS to complain about this import.
// We do not want to change the rootDir because it messes up the output structure.
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
const package_json_1 = __importDefault(__webpack_require__(/*! ../package.json */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/package.json"));
exports["default"] = package_json_1.default;


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/sinks.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/sinks.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Type definitions for the Workflow end of the sinks mechanism.
 *
 * Sinks are a mechanism for exporting data from the Workflow isolate to the
 * Node.js environment, they are necessary because the Workflow has no way to
 * communicate with the outside World.
 *
 * Sinks are typically used for exporting logs, metrics and traces out from the
 * Workflow.
 *
 * Sink functions may not return values to the Workflow in order to prevent
 * breaking determinism.
 *
 * @module
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.proxySinks = proxySinks;
const global_attributes_1 = __webpack_require__(/*! ./global-attributes */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/global-attributes.js");
/**
 * Get a reference to Sinks for exporting data out of the Workflow.
 *
 * These Sinks **must** be registered with the Worker in order for this
 * mechanism to work.
 *
 * @example
 * ```ts
 * import { proxySinks, Sinks } from '@temporalio/workflow';
 *
 * interface MySinks extends Sinks {
 *   logger: {
 *     info(message: string): void;
 *     error(message: string): void;
 *   };
 * }
 *
 * const { logger } = proxySinks<MyDependencies>();
 * logger.info('setting up');
 *
 * export function myWorkflow() {
 *   return {
 *     async execute() {
 *       logger.info("hey ho");
 *       logger.error("lets go");
 *     }
 *   };
 * }
 * ```
 */
function proxySinks() {
    return new Proxy({}, {
        get(_, ifaceName) {
            return new Proxy({}, {
                get(_, fnName) {
                    return (...args) => {
                        const activator = (0, global_attributes_1.assertInWorkflowContext)('Proxied sinks functions may only be used from a Workflow Execution.');
                        activator.sinkCalls.push({
                            ifaceName: ifaceName,
                            fnName: fnName,
                            // Sink function doesn't get called immediately. Make a clone of the sink's args, so that further mutations
                            // to these objects don't corrupt the args that the sink function will receive. Only available from node 17.
                            args: globalThis.structuredClone ? globalThis.structuredClone(args) : args,
                            // activator.info is internally copy-on-write. This ensure that any further mutations
                            // to the workflow state in the context of the present activation will not corrupt the
                            // workflowInfo state that gets passed when the sink function actually gets called.
                            workflowInfo: activator.info,
                        });
                    };
                },
            });
        },
    });
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/stack-helpers.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/stack-helpers.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.untrackPromise = untrackPromise;
const global_attributes_1 = __webpack_require__(/*! ./global-attributes */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/global-attributes.js");
/**
 * Helper function to remove a promise from being tracked for stack trace query purposes
 */
function untrackPromise(promise) {
    const store = (0, global_attributes_1.maybeGetActivatorUntyped)()?.promiseStackStore;
    if (!store)
        return;
    store.childToParent.delete(promise);
    store.promiseToStack.delete(promise);
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/trigger.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/trigger.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Trigger = void 0;
const cancellation_scope_1 = __webpack_require__(/*! ./cancellation-scope */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/cancellation-scope.js");
const stack_helpers_1 = __webpack_require__(/*! ./stack-helpers */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/stack-helpers.js");
/**
 * A `PromiseLike` helper which exposes its `resolve` and `reject` methods.
 *
 * Trigger is CancellationScope-aware: it is linked to the current scope on
 * construction and throws when that scope is cancelled.
 *
 * Useful for e.g. waiting for unblocking a Workflow from a Signal.
 *
 * @example
 * <!--SNIPSTART typescript-trigger-workflow-->
 * <!--SNIPEND-->
 */
class Trigger {
    // Typescript does not realize that the promise executor is run synchronously in the constructor
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    resolve;
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    reject;
    promise;
    constructor() {
        this.promise = new Promise((resolve, reject) => {
            const scope = cancellation_scope_1.CancellationScope.current();
            if (scope.cancellable) {
                (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(reject));
            }
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            this.resolve = resolve;
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            this.reject = reject;
        });
        // Avoid unhandled rejections
        (0, stack_helpers_1.untrackPromise)(this.promise.catch(() => undefined));
    }
    then(onfulfilled, onrejected) {
        return this.promise.then(onfulfilled, onrejected);
    }
}
exports.Trigger = Trigger;


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/update-scope.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/update-scope.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateScope = exports.AsyncLocalStorage = void 0;
exports.disableUpdateStorage = disableUpdateStorage;
// AsyncLocalStorage is injected via vm module into global scope.
// In case Workflow code is imported in Node.js context, replace with an empty class.
exports.AsyncLocalStorage = globalThis.AsyncLocalStorage ?? class {
};
class UpdateScope {
    /**
     *  A workflow-unique identifier for this update.
     */
    id;
    /**
     *  The update type name.
     */
    name;
    constructor(options) {
        this.id = options.id;
        this.name = options.name;
    }
    /**
     * Activate the scope as current and run the update handler `fn`.
     *
     * @return the result of `fn`
     */
    run(fn) {
        return storage.run(this, fn);
    }
    /**
     * Get the current "active" update scope.
     */
    static current() {
        return storage.getStore();
    }
    /** Alias to `new UpdateScope({ id, name }).run(fn)` */
    static updateWithInfo(id, name, fn) {
        return new this({ id, name }).run(fn);
    }
}
exports.UpdateScope = UpdateScope;
const storage = new exports.AsyncLocalStorage();
/**
 * Disable the async local storage for updates.
 */
function disableUpdateStorage() {
    storage.disable();
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/worker-interface.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/worker-interface.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initRuntime = initRuntime;
exports.initialize = initialize;
exports.activate = activate;
exports.concludeActivation = concludeActivation;
exports.tryUnblockConditions = tryUnblockConditions;
exports.dispose = dispose;
/**
 * Exported functions for the Worker to interact with the Workflow isolate
 *
 * @module
 */
const common_1 = __webpack_require__(/*! @temporalio/common */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/index.js");
const interceptors_1 = __webpack_require__(/*! @temporalio/common/lib/interceptors */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/interceptors.js");
const cancellation_scope_1 = __webpack_require__(/*! ./cancellation-scope */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/cancellation-scope.js");
const update_scope_1 = __webpack_require__(/*! ./update-scope */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/update-scope.js");
const internals_1 = __webpack_require__(/*! ./internals */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/internals.js");
const global_attributes_1 = __webpack_require__(/*! ./global-attributes */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/global-attributes.js");
const global = globalThis;
const OriginalDate = globalThis.Date;
/**
 * Initialize the isolate runtime.
 *
 * Sets required internal state and instantiates the workflow and interceptors.
 */
function initRuntime(options) {
    const activator = new internals_1.Activator({
        ...options,
        info: fixPrototypes({
            ...options.info,
            unsafe: { ...options.info.unsafe, now: OriginalDate.now },
        }),
    });
    // There's one activator per workflow instance, set it globally on the context.
    // We do this before importing any user code so user code can statically reference @temporalio/workflow functions
    // as well as Date and Math.random.
    (0, global_attributes_1.setActivatorUntyped)(activator);
    activator.rethrowSynchronously = true;
    try {
        // webpack alias to payloadConverterPath
        // eslint-disable-next-line @typescript-eslint/no-require-imports
        const customPayloadConverter = (__webpack_require__(/*! __temporal_custom_payload_converter */ "?7d68").payloadConverter);
        // The `payloadConverter` export is validated in the Worker
        if (customPayloadConverter != null) {
            activator.payloadConverter = customPayloadConverter;
        }
        // webpack alias to failureConverterPath
        // eslint-disable-next-line @typescript-eslint/no-require-imports
        const customFailureConverter = (__webpack_require__(/*! __temporal_custom_failure_converter */ "?4181").failureConverter);
        // The `failureConverter` export is validated in the Worker
        if (customFailureConverter != null) {
            activator.failureConverter = customFailureConverter;
        }
        const { importWorkflows, importInterceptors } = global.__TEMPORAL__;
        if (importWorkflows === undefined || importInterceptors === undefined) {
            throw new common_1.IllegalStateError('Workflow bundle did not register import hooks');
        }
        const interceptors = importInterceptors();
        for (const mod of interceptors) {
            const factory = mod.interceptors;
            if (factory !== undefined) {
                if (typeof factory !== 'function') {
                    throw new TypeError(`Failed to initialize workflows interceptors: expected a function, but got: '${factory}'`);
                }
                const interceptors = factory();
                activator.interceptors.inbound.push(...(interceptors.inbound ?? []));
                activator.interceptors.outbound.push(...(interceptors.outbound ?? []));
                activator.interceptors.internals.push(...(interceptors.internals ?? []));
            }
        }
        const mod = importWorkflows();
        const workflowFn = mod[activator.info.workflowType];
        const defaultWorkflowFn = mod['default'];
        if (typeof workflowFn === 'function') {
            activator.workflow = workflowFn;
        }
        else if (typeof defaultWorkflowFn === 'function') {
            activator.workflow = defaultWorkflowFn;
        }
        else {
            const details = workflowFn === undefined
                ? 'no such function is exported by the workflow bundle'
                : `expected a function, but got: '${typeof workflowFn}'`;
            throw new TypeError(`Failed to initialize workflow of type '${activator.info.workflowType}': ${details}`);
        }
        if (isWorkflowFunctionWithOptions(activator.workflow)) {
            if (typeof activator.workflow.workflowDefinitionOptions === 'object') {
                activator.versioningBehavior = activator.workflow.workflowDefinitionOptions.versioningBehavior;
            }
            else {
                activator.workflowDefinitionOptionsGetter = activator.workflow.workflowDefinitionOptions;
            }
        }
    }
    finally {
        activator.rethrowSynchronously = false;
    }
}
/**
 * Objects transfered to the VM from outside have prototypes belonging to the
 * outer context, which means that instanceof won't work inside the VM. This
 * function recursively walks over the content of an object, and recreate some
 * of these objects (notably Array, Date and Objects).
 */
function fixPrototypes(obj) {
    if (obj != null && typeof obj === 'object') {
        switch (Object.getPrototypeOf(obj)?.constructor?.name) {
            case 'Array':
                return Array.from(obj.map(fixPrototypes));
            case 'Date':
                return new Date(obj);
            default:
                return Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, fixPrototypes(v)]));
        }
    }
    else
        return obj;
}
/**
 * Initialize the workflow. Or to be exact, _complete_ initialization, as most part has been done in constructor).
 */
function initialize(initializeWorkflowJob) {
    const activator = (0, global_attributes_1.getActivator)();
    activator.rethrowSynchronously = true;
    try {
        activator.initializeWorkflow(initializeWorkflowJob);
    }
    finally {
        activator.rethrowSynchronously = false;
    }
}
/**
 * Run a chunk of activation jobs.
 *
 * Notice that this function is not async and runs _inside_ the VM context. Therefore, no microtask
 * will get executed _while_ this function is active; they will however get executed _after_ this
 * function returns (i.e. all outstanding microtasks in the VM will get executed before execution
 * resumes out of the VM, in `vm-shared.ts:activate()`).
 */
function activate(activation, batchIndex = 0) {
    const activator = (0, global_attributes_1.getActivator)();
    activator.rethrowSynchronously = true;
    try {
        const intercept = (0, interceptors_1.composeInterceptors)(activator.interceptors.internals, 'activate', ({ activation }) => {
            // Cast from the interface to the class which has the `variant` attribute.
            // This is safe because we know that activation is a proto class.
            const jobs = activation.jobs;
            // Initialization will have been handled already, but we might still need to start the workflow function
            const startWorkflowJob = jobs[0].variant === 'initializeWorkflow' ? jobs.shift()?.initializeWorkflow : undefined;
            for (const job of jobs) {
                if (job.variant === undefined)
                    throw new TypeError('Expected job.variant to be defined');
                const variant = job[job.variant];
                if (!variant)
                    throw new TypeError(`Expected job.${job.variant} to be set`);
                activator[job.variant](variant /* TS can't infer this type */);
                if (job.variant !== 'queryWorkflow')
                    tryUnblockConditions();
            }
            if (startWorkflowJob) {
                const safeJobTypes = [
                    'initializeWorkflow',
                    'signalWorkflow',
                    'doUpdate',
                    'cancelWorkflow',
                    'updateRandomSeed',
                ];
                if (jobs.some((job) => !safeJobTypes.includes(job.variant))) {
                    throw new TypeError('Received both initializeWorkflow and non-signal/non-update jobs in the same activation: ' +
                        JSON.stringify(jobs.map((job) => job.variant)));
                }
                activator.startWorkflow(startWorkflowJob);
                tryUnblockConditions();
            }
        });
        intercept({ activation, batchIndex });
    }
    finally {
        activator.rethrowSynchronously = false;
    }
}
/**
 * Conclude a single activation.
 * Should be called after processing all activation jobs and queued microtasks.
 *
 * Activation failures are handled in the main Node.js isolate.
 */
function concludeActivation() {
    const activator = (0, global_attributes_1.getActivator)();
    activator.rethrowSynchronously = true;
    try {
        activator.rejectBufferedUpdates();
        const intercept = (0, interceptors_1.composeInterceptors)(activator.interceptors.internals, 'concludeActivation', (input) => input);
        const activationCompletion = activator.concludeActivation();
        const { commands } = intercept({ commands: activationCompletion.commands });
        if (activator.completed) {
            activator.warnIfUnfinishedHandlers();
        }
        return {
            runId: activator.info.runId,
            successful: {
                ...activationCompletion,
                commands,
                versioningBehavior: (0, common_1.encodeVersioningBehavior)(activationCompletion.versioningBehavior),
            },
        };
    }
    finally {
        activator.rethrowSynchronously = false;
    }
}
/**
 * Loop through all blocked conditions, evaluate and unblock if possible.
 *
 * @returns number of unblocked conditions.
 */
function tryUnblockConditions() {
    const activator = (0, global_attributes_1.getActivator)();
    activator.rethrowSynchronously = true;
    try {
        let numUnblocked = 0;
        for (;;) {
            activator.maybeRethrowWorkflowTaskError();
            const prevUnblocked = numUnblocked;
            for (const [seq, cond] of activator.blockedConditions.entries()) {
                if (cond.fn()) {
                    cond.resolve();
                    numUnblocked++;
                    // It is safe to delete elements during map iteration
                    activator.blockedConditions.delete(seq);
                }
            }
            if (prevUnblocked === numUnblocked) {
                break;
            }
        }
        return numUnblocked;
    }
    finally {
        activator.rethrowSynchronously = false;
    }
}
function dispose() {
    const activator = (0, global_attributes_1.getActivator)();
    activator.rethrowSynchronously = true;
    try {
        const dispose = (0, interceptors_1.composeInterceptors)(activator.interceptors.internals, 'dispose', async () => {
            (0, cancellation_scope_1.disableStorage)();
            (0, update_scope_1.disableUpdateStorage)();
        });
        dispose({});
    }
    finally {
        activator.rethrowSynchronously = false;
    }
}
function isWorkflowFunctionWithOptions(obj) {
    if (obj == null)
        return false;
    return Object.hasOwn(obj, 'workflowDefinitionOptions');
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/workflow.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/workflow.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.workflowMetadataQuery = exports.enhancedStackTraceQuery = exports.stackTraceQuery = exports.NotAnActivityMethod = void 0;
exports.addDefaultWorkflowOptions = addDefaultWorkflowOptions;
exports.sleep = sleep;
exports.scheduleActivity = scheduleActivity;
exports.scheduleLocalActivity = scheduleLocalActivity;
exports.proxyActivities = proxyActivities;
exports.proxyLocalActivities = proxyLocalActivities;
exports.getExternalWorkflowHandle = getExternalWorkflowHandle;
exports.startChild = startChild;
exports.executeChild = executeChild;
exports.workflowInfo = workflowInfo;
exports.currentUpdateInfo = currentUpdateInfo;
exports.inWorkflowContext = inWorkflowContext;
exports.makeContinueAsNewFunc = makeContinueAsNewFunc;
exports.continueAsNew = continueAsNew;
exports.uuid4 = uuid4;
exports.patched = patched;
exports.deprecatePatch = deprecatePatch;
exports.condition = condition;
exports.defineUpdate = defineUpdate;
exports.defineSignal = defineSignal;
exports.defineQuery = defineQuery;
exports.setHandler = setHandler;
exports.setDefaultSignalHandler = setDefaultSignalHandler;
exports.setDefaultUpdateHandler = setDefaultUpdateHandler;
exports.setDefaultQueryHandler = setDefaultQueryHandler;
exports.upsertSearchAttributes = upsertSearchAttributes;
exports.upsertMemo = upsertMemo;
exports.allHandlersFinished = allHandlersFinished;
exports.setWorkflowOptions = setWorkflowOptions;
exports.getCurrentDetails = getCurrentDetails;
exports.setCurrentDetails = setCurrentDetails;
const common_1 = __webpack_require__(/*! @temporalio/common */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/index.js");
const user_metadata_1 = __webpack_require__(/*! @temporalio/common/lib/user-metadata */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/user-metadata.js");
const payload_search_attributes_1 = __webpack_require__(/*! @temporalio/common/lib/converter/payload-search-attributes */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/converter/payload-search-attributes.js");
const versioning_intent_enum_1 = __webpack_require__(/*! @temporalio/common/lib/versioning-intent-enum */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/versioning-intent-enum.js");
const time_1 = __webpack_require__(/*! @temporalio/common/lib/time */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/time.js");
const interceptors_1 = __webpack_require__(/*! @temporalio/common/lib/interceptors */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/interceptors.js");
const internal_workflow_1 = __webpack_require__(/*! @temporalio/common/lib/internal-workflow */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/internal-workflow/index.js");
const reserved_1 = __webpack_require__(/*! @temporalio/common/lib/reserved */ "./node_modules/.pnpm/@temporalio+common@1.13.1/node_modules/@temporalio/common/lib/reserved.js");
const cancellation_scope_1 = __webpack_require__(/*! ./cancellation-scope */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/cancellation-scope.js");
const update_scope_1 = __webpack_require__(/*! ./update-scope */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/update-scope.js");
const interfaces_1 = __webpack_require__(/*! ./interfaces */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/interfaces.js");
const errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/errors.js");
const global_attributes_1 = __webpack_require__(/*! ./global-attributes */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/global-attributes.js");
const stack_helpers_1 = __webpack_require__(/*! ./stack-helpers */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/stack-helpers.js");
// Avoid a circular dependency
(0, cancellation_scope_1.registerSleepImplementation)(sleep);
/**
 * Adds default values of `workflowId` and `cancellationType` to given workflow options.
 */
function addDefaultWorkflowOptions(opts) {
    const { args, workflowId, ...rest } = opts;
    return {
        workflowId: workflowId ?? uuid4(),
        args: (args ?? []),
        cancellationType: interfaces_1.ChildWorkflowCancellationType.WAIT_CANCELLATION_COMPLETED,
        ...rest,
    };
}
/**
 * Push a startTimer command into state accumulator and register completion
 */
function timerNextHandler({ seq, durationMs, options }) {
    const activator = (0, global_attributes_1.getActivator)();
    return new Promise((resolve, reject) => {
        const scope = cancellation_scope_1.CancellationScope.current();
        if (scope.consideredCancelled) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(reject));
            return;
        }
        if (scope.cancellable) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch((err) => {
                if (!activator.completions.timer.delete(seq)) {
                    return; // Already resolved or never scheduled
                }
                activator.pushCommand({
                    cancelTimer: {
                        seq,
                    },
                });
                reject(err);
            }));
        }
        activator.pushCommand({
            startTimer: {
                seq,
                startToFireTimeout: (0, time_1.msToTs)(durationMs),
            },
            userMetadata: (0, user_metadata_1.userMetadataToPayload)(activator.payloadConverter, options?.summary, undefined),
        });
        activator.completions.timer.set(seq, {
            resolve,
            reject,
        });
    });
}
/**
 * Asynchronous sleep.
 *
 * Schedules a timer on the Temporal service.
 *
 * @param ms sleep duration - number of milliseconds or {@link https://www.npmjs.com/package/ms | ms-formatted string}.
 * If given a negative number or 0, value will be set to 1.
 * @param options optional timer options for additional configuration
 */
function sleep(ms, options) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.sleep(...) may only be used from a Workflow Execution');
    const seq = activator.nextSeqs.timer++;
    const durationMs = Math.max(1, (0, time_1.msToNumber)(ms));
    const execute = (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'startTimer', timerNextHandler);
    return execute({
        durationMs,
        seq,
        options,
    });
}
function validateActivityOptions(options) {
    if (options.scheduleToCloseTimeout === undefined && options.startToCloseTimeout === undefined) {
        throw new TypeError('Required either scheduleToCloseTimeout or startToCloseTimeout');
    }
}
// Use same validation we use for normal activities
const validateLocalActivityOptions = validateActivityOptions;
/**
 * Push a scheduleActivity command into activator accumulator and register completion
 */
function scheduleActivityNextHandler({ options, args, headers, seq, activityType }) {
    const activator = (0, global_attributes_1.getActivator)();
    validateActivityOptions(options);
    return new Promise((resolve, reject) => {
        const scope = cancellation_scope_1.CancellationScope.current();
        if (scope.consideredCancelled) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(reject));
            return;
        }
        if (scope.cancellable) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(() => {
                if (!activator.completions.activity.has(seq)) {
                    return; // Already resolved or never scheduled
                }
                activator.pushCommand({
                    requestCancelActivity: {
                        seq,
                    },
                });
            }));
        }
        activator.pushCommand({
            scheduleActivity: {
                seq,
                activityId: options.activityId ?? `${seq}`,
                activityType,
                arguments: (0, common_1.toPayloads)(activator.payloadConverter, ...args),
                retryPolicy: options.retry ? (0, common_1.compileRetryPolicy)(options.retry) : undefined,
                taskQueue: options.taskQueue || activator.info.taskQueue,
                heartbeatTimeout: (0, time_1.msOptionalToTs)(options.heartbeatTimeout),
                scheduleToCloseTimeout: (0, time_1.msOptionalToTs)(options.scheduleToCloseTimeout),
                startToCloseTimeout: (0, time_1.msOptionalToTs)(options.startToCloseTimeout),
                scheduleToStartTimeout: (0, time_1.msOptionalToTs)(options.scheduleToStartTimeout),
                headers,
                cancellationType: (0, common_1.encodeActivityCancellationType)(options.cancellationType),
                doNotEagerlyExecute: !(options.allowEagerDispatch ?? true),
                versioningIntent: (0, versioning_intent_enum_1.versioningIntentToProto)(options.versioningIntent), // eslint-disable-line deprecation/deprecation
                priority: options.priority ? (0, common_1.compilePriority)(options.priority) : undefined,
            },
            userMetadata: (0, user_metadata_1.userMetadataToPayload)(activator.payloadConverter, options.summary, undefined),
        });
        activator.completions.activity.set(seq, {
            resolve,
            reject,
        });
    });
}
/**
 * Push a scheduleActivity command into state accumulator and register completion
 */
async function scheduleLocalActivityNextHandler({ options, args, headers, seq, activityType, attempt, originalScheduleTime, }) {
    const activator = (0, global_attributes_1.getActivator)();
    // Eagerly fail the local activity (which will in turn fail the workflow task.
    // Do not fail on replay where the local activities may not be registered on the replay worker.
    if (!activator.info.unsafe.isReplaying && !activator.registeredActivityNames.has(activityType)) {
        throw new ReferenceError(`Local activity of type '${activityType}' not registered on worker`);
    }
    validateLocalActivityOptions(options);
    return new Promise((resolve, reject) => {
        const scope = cancellation_scope_1.CancellationScope.current();
        if (scope.consideredCancelled) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(reject));
            return;
        }
        if (scope.cancellable) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(() => {
                if (!activator.completions.activity.has(seq)) {
                    return; // Already resolved or never scheduled
                }
                activator.pushCommand({
                    requestCancelLocalActivity: {
                        seq,
                    },
                });
            }));
        }
        activator.pushCommand({
            scheduleLocalActivity: {
                seq,
                attempt,
                originalScheduleTime,
                // Intentionally not exposing activityId as an option
                activityId: `${seq}`,
                activityType,
                arguments: (0, common_1.toPayloads)(activator.payloadConverter, ...args),
                retryPolicy: options.retry ? (0, common_1.compileRetryPolicy)(options.retry) : undefined,
                scheduleToCloseTimeout: (0, time_1.msOptionalToTs)(options.scheduleToCloseTimeout),
                startToCloseTimeout: (0, time_1.msOptionalToTs)(options.startToCloseTimeout),
                scheduleToStartTimeout: (0, time_1.msOptionalToTs)(options.scheduleToStartTimeout),
                localRetryThreshold: (0, time_1.msOptionalToTs)(options.localRetryThreshold),
                headers,
                cancellationType: (0, common_1.encodeActivityCancellationType)(options.cancellationType),
            },
            userMetadata: (0, user_metadata_1.userMetadataToPayload)(activator.payloadConverter, options.summary, undefined),
        });
        activator.completions.activity.set(seq, {
            resolve,
            reject,
        });
    });
}
/**
 * Schedule an activity and run outbound interceptors
 * @hidden
 */
function scheduleActivity(activityType, args, options) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.scheduleActivity(...) may only be used from a Workflow Execution');
    if (options === undefined) {
        throw new TypeError('Got empty activity options');
    }
    const seq = activator.nextSeqs.activity++;
    const execute = (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'scheduleActivity', scheduleActivityNextHandler);
    return execute({
        activityType,
        headers: {},
        options,
        args,
        seq,
    });
}
/**
 * Schedule an activity and run outbound interceptors
 * @hidden
 */
async function scheduleLocalActivity(activityType, args, options) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.scheduleLocalActivity(...) may only be used from a Workflow Execution');
    if (options === undefined) {
        throw new TypeError('Got empty activity options');
    }
    let attempt = 1;
    let originalScheduleTime = undefined;
    for (;;) {
        const seq = activator.nextSeqs.activity++;
        const execute = (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'scheduleLocalActivity', scheduleLocalActivityNextHandler);
        try {
            return (await execute({
                activityType,
                headers: {},
                options,
                args,
                seq,
                attempt,
                originalScheduleTime,
            }));
        }
        catch (err) {
            if (err instanceof errors_1.LocalActivityDoBackoff) {
                await sleep((0, time_1.requiredTsToMs)(err.backoff.backoffDuration, 'backoffDuration'));
                if (typeof err.backoff.attempt !== 'number') {
                    throw new TypeError('Invalid backoff attempt type');
                }
                attempt = err.backoff.attempt;
                originalScheduleTime = err.backoff.originalScheduleTime ?? undefined;
            }
            else {
                throw err;
            }
        }
    }
}
function startChildWorkflowExecutionNextHandler({ options, headers, workflowType, seq, }) {
    const activator = (0, global_attributes_1.getActivator)();
    const workflowId = options.workflowId ?? uuid4();
    const startPromise = new Promise((resolve, reject) => {
        const scope = cancellation_scope_1.CancellationScope.current();
        if (scope.consideredCancelled) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(reject));
            return;
        }
        if (scope.cancellable) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(() => {
                const complete = !activator.completions.childWorkflowComplete.has(seq);
                if (!complete) {
                    activator.pushCommand({
                        cancelChildWorkflowExecution: { childWorkflowSeq: seq },
                    });
                }
                // Nothing to cancel otherwise
            }));
        }
        activator.pushCommand({
            startChildWorkflowExecution: {
                seq,
                workflowId,
                workflowType,
                input: (0, common_1.toPayloads)(activator.payloadConverter, ...options.args),
                retryPolicy: options.retry ? (0, common_1.compileRetryPolicy)(options.retry) : undefined,
                taskQueue: options.taskQueue || activator.info.taskQueue,
                workflowExecutionTimeout: (0, time_1.msOptionalToTs)(options.workflowExecutionTimeout),
                workflowRunTimeout: (0, time_1.msOptionalToTs)(options.workflowRunTimeout),
                workflowTaskTimeout: (0, time_1.msOptionalToTs)(options.workflowTaskTimeout),
                namespace: activator.info.namespace, // Not configurable
                headers,
                cancellationType: (0, interfaces_1.encodeChildWorkflowCancellationType)(options.cancellationType),
                workflowIdReusePolicy: (0, common_1.encodeWorkflowIdReusePolicy)(options.workflowIdReusePolicy),
                parentClosePolicy: (0, interfaces_1.encodeParentClosePolicy)(options.parentClosePolicy),
                cronSchedule: options.cronSchedule,
                searchAttributes: options.searchAttributes || options.typedSearchAttributes // eslint-disable-line deprecation/deprecation
                    ? (0, payload_search_attributes_1.encodeUnifiedSearchAttributes)(options.searchAttributes, options.typedSearchAttributes) // eslint-disable-line deprecation/deprecation
                    : undefined,
                memo: options.memo && (0, common_1.mapToPayloads)(activator.payloadConverter, options.memo),
                versioningIntent: (0, versioning_intent_enum_1.versioningIntentToProto)(options.versioningIntent), // eslint-disable-line deprecation/deprecation
                priority: options.priority ? (0, common_1.compilePriority)(options.priority) : undefined,
            },
            userMetadata: (0, user_metadata_1.userMetadataToPayload)(activator.payloadConverter, options?.staticSummary, options?.staticDetails),
        });
        activator.completions.childWorkflowStart.set(seq, {
            resolve,
            reject,
        });
    });
    // We construct a Promise for the completion of the child Workflow before we know
    // if the Workflow code will await it to capture the result in case it does.
    const completePromise = new Promise((resolve, reject) => {
        // Chain start Promise rejection to the complete Promise.
        (0, stack_helpers_1.untrackPromise)(startPromise.catch(reject));
        activator.completions.childWorkflowComplete.set(seq, {
            resolve,
            reject,
        });
    });
    (0, stack_helpers_1.untrackPromise)(startPromise);
    (0, stack_helpers_1.untrackPromise)(completePromise);
    // Prevent unhandled rejection because the completion might not be awaited
    (0, stack_helpers_1.untrackPromise)(completePromise.catch(() => undefined));
    const ret = new Promise((resolve) => resolve([startPromise, completePromise]));
    (0, stack_helpers_1.untrackPromise)(ret);
    return ret;
}
function signalWorkflowNextHandler({ seq, signalName, args, target, headers }) {
    const activator = (0, global_attributes_1.getActivator)();
    return new Promise((resolve, reject) => {
        const scope = cancellation_scope_1.CancellationScope.current();
        if (scope.consideredCancelled) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(reject));
            return;
        }
        if (scope.cancellable) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(() => {
                if (!activator.completions.signalWorkflow.has(seq)) {
                    return;
                }
                activator.pushCommand({ cancelSignalWorkflow: { seq } });
            }));
        }
        activator.pushCommand({
            signalExternalWorkflowExecution: {
                seq,
                args: (0, common_1.toPayloads)(activator.payloadConverter, ...args),
                headers,
                signalName,
                ...(target.type === 'external'
                    ? {
                        workflowExecution: {
                            namespace: activator.info.namespace,
                            ...target.workflowExecution,
                        },
                    }
                    : {
                        childWorkflowId: target.childWorkflowId,
                    }),
            },
        });
        activator.completions.signalWorkflow.set(seq, { resolve, reject });
    });
}
/**
 * Symbol used in the return type of proxy methods to mark that an attribute on the source type is not a method.
 *
 * @see {@link ActivityInterfaceFor}
 * @see {@link proxyActivities}
 * @see {@link proxyLocalActivities}
 */
exports.NotAnActivityMethod = Symbol.for('__TEMPORAL_NOT_AN_ACTIVITY_METHOD');
/**
 * Configure Activity functions with given {@link ActivityOptions}.
 *
 * This method may be called multiple times to setup Activities with different options.
 *
 * @return a {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy | Proxy} for
 *         which each attribute is a callable Activity function
 *
 * @example
 * ```ts
 * import { proxyActivities } from '@temporalio/workflow';
 * import * as activities from '../activities';
 *
 * // Setup Activities from module exports
 * const { httpGet, otherActivity } = proxyActivities<typeof activities>({
 *   startToCloseTimeout: '30 minutes',
 * });
 *
 * // Use activities with default options
 * const result1 = await httpGet('http://example.com');
 *
 * // Override options for specific activity calls
 * const result2 = await httpGet.executeWithOptions({
 *   staticSummary: 'Fetches data from external API',
 *   scheduleToCloseTimeout: '5m'
 * }, ['http://api.example.com']);
 *
 * const result3 = await otherActivity.executeWithOptions({
 *   staticSummary: 'Processes the fetched data',
 *   taskQueue: 'special-task-queue'
 * }, [data]);
 *
 * // Setup Activities from an explicit interface (e.g. when defined by another SDK)
 * interface JavaActivities {
 *   httpGetFromJava(url: string): Promise<string>
 *   someOtherJavaActivity(arg1: number, arg2: string): Promise<string>;
 * }
 *
 * const {
 *   httpGetFromJava,
 *   someOtherJavaActivity
 * } = proxyActivities<JavaActivities>({
 *   taskQueue: 'java-worker-taskQueue',
 *   startToCloseTimeout: '5m',
 * });
 *
 * export function execute(): Promise<void> {
 *   const response = await httpGet("http://example.com");
 *   // Or with custom options:
 *   const response2 = await httpGetFromJava.executeWithOptions({
 *     staticSummary: 'Java HTTP call with timeout override',
 *     startToCloseTimeout: '2m'
 *   }, ["http://fast-api.example.com"]);
 *   // ...
 * }
 * ```
 */
function proxyActivities(options) {
    if (options === undefined) {
        throw new TypeError('options must be defined');
    }
    // Validate as early as possible for immediate user feedback
    validateActivityOptions(options);
    return new Proxy({}, {
        get(_, activityType) {
            if (typeof activityType !== 'string') {
                throw new TypeError(`Only strings are supported for Activity types, got: ${String(activityType)}`);
            }
            function activityProxyFunction(...args) {
                return scheduleActivity(activityType, args, options);
            }
            activityProxyFunction.executeWithOptions = function (overrideOptions, args) {
                return scheduleActivity(activityType, args, (0, internal_workflow_1.deepMerge)(options, overrideOptions));
            };
            return activityProxyFunction;
        },
    });
}
/**
 * Configure Local Activity functions with given {@link LocalActivityOptions}.
 *
 * This method may be called multiple times to setup Activities with different options.
 *
 * @return a {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy | Proxy}
 *         for which each attribute is a callable Activity function
 *
 * @see {@link proxyActivities} for examples
 */
function proxyLocalActivities(options) {
    if (options === undefined) {
        throw new TypeError('options must be defined');
    }
    // Validate as early as possible for immediate user feedback
    validateLocalActivityOptions(options);
    return new Proxy({}, {
        get(_, activityType) {
            if (typeof activityType !== 'string') {
                throw new TypeError(`Only strings are supported for Activity types, got: ${String(activityType)}`);
            }
            function localActivityProxyFunction(...args) {
                return scheduleLocalActivity(activityType, args, options);
            }
            localActivityProxyFunction.executeWithOptions = function (overrideOptions, args) {
                return scheduleLocalActivity(activityType, args, (0, internal_workflow_1.deepMerge)(options, overrideOptions));
            };
            return localActivityProxyFunction;
        },
    });
}
// TODO: deprecate this patch after "enough" time has passed
const EXTERNAL_WF_CANCEL_PATCH = '__temporal_internal_connect_external_handle_cancel_to_scope';
// The name of this patch comes from an attempt to build a generic internal patching mechanism.
// That effort has been abandoned in favor of a newer WorkflowTaskCompletedMetadata based mechanism.
const CONDITION_0_PATCH = '__sdk_internal_patch_number:1';
/**
 * Returns a client-side handle that can be used to signal and cancel an existing Workflow execution.
 * It takes a Workflow ID and optional run ID.
 */
function getExternalWorkflowHandle(workflowId, runId) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.getExternalWorkflowHandle(...) may only be used from a Workflow Execution. Consider using Client.workflow.getHandle(...) instead.)');
    return {
        workflowId,
        runId,
        cancel() {
            return new Promise((resolve, reject) => {
                // Connect this cancel operation to the current cancellation scope.
                // This is behavior was introduced after v0.22.0 and is incompatible
                // with histories generated with previous SDK versions and thus requires
                // patching.
                //
                // We try to delay patching as much as possible to avoid polluting
                // histories unless strictly required.
                const scope = cancellation_scope_1.CancellationScope.current();
                if (scope.cancellable) {
                    (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch((err) => {
                        if (patched(EXTERNAL_WF_CANCEL_PATCH)) {
                            reject(err);
                        }
                    }));
                }
                if (scope.consideredCancelled) {
                    if (patched(EXTERNAL_WF_CANCEL_PATCH)) {
                        return;
                    }
                }
                const seq = activator.nextSeqs.cancelWorkflow++;
                activator.pushCommand({
                    requestCancelExternalWorkflowExecution: {
                        seq,
                        workflowExecution: {
                            namespace: activator.info.namespace,
                            workflowId,
                            runId,
                        },
                    },
                });
                activator.completions.cancelWorkflow.set(seq, { resolve, reject });
            });
        },
        signal(def, ...args) {
            return (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'signalWorkflow', signalWorkflowNextHandler)({
                seq: activator.nextSeqs.signalWorkflow++,
                signalName: typeof def === 'string' ? def : def.name,
                args,
                target: {
                    type: 'external',
                    workflowExecution: { workflowId, runId },
                },
                headers: {},
            });
        },
    };
}
async function startChild(workflowTypeOrFunc, options) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.startChild(...) may only be used from a Workflow Execution. Consider using Client.workflow.start(...) instead.)');
    const optionsWithDefaults = addDefaultWorkflowOptions(options ?? {});
    const workflowType = (0, common_1.extractWorkflowType)(workflowTypeOrFunc);
    const execute = (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'startChildWorkflowExecution', startChildWorkflowExecutionNextHandler);
    const [started, completed] = await execute({
        seq: activator.nextSeqs.childWorkflow++,
        options: optionsWithDefaults,
        headers: {},
        workflowType,
    });
    const firstExecutionRunId = await started;
    return {
        workflowId: optionsWithDefaults.workflowId,
        firstExecutionRunId,
        async result() {
            return (await completed);
        },
        async signal(def, ...args) {
            return (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'signalWorkflow', signalWorkflowNextHandler)({
                seq: activator.nextSeqs.signalWorkflow++,
                signalName: typeof def === 'string' ? def : def.name,
                args,
                target: {
                    type: 'child',
                    childWorkflowId: optionsWithDefaults.workflowId,
                },
                headers: {},
            });
        },
    };
}
async function executeChild(workflowTypeOrFunc, options) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.executeChild(...) may only be used from a Workflow Execution. Consider using Client.workflow.execute(...) instead.');
    const optionsWithDefaults = addDefaultWorkflowOptions(options ?? {});
    const workflowType = (0, common_1.extractWorkflowType)(workflowTypeOrFunc);
    const execute = (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'startChildWorkflowExecution', startChildWorkflowExecutionNextHandler);
    const execPromise = execute({
        seq: activator.nextSeqs.childWorkflow++,
        options: optionsWithDefaults,
        headers: {},
        workflowType,
    });
    (0, stack_helpers_1.untrackPromise)(execPromise);
    const completedPromise = execPromise.then(([_started, completed]) => completed);
    (0, stack_helpers_1.untrackPromise)(completedPromise);
    return completedPromise;
}
/**
 * Get information about the current Workflow.
 *
 * WARNING: This function returns a frozen copy of WorkflowInfo, at the point where this method has been called.
 * Changes happening at later point in workflow execution will not be reflected in the returned object.
 *
 * For this reason, we recommend calling `workflowInfo()` on every access to {@link WorkflowInfo}'s fields,
 * rather than caching the `WorkflowInfo` object (or part of it) in a local variable. For example:
 *
 * ```ts
 * // GOOD
 * function myWorkflow() {
 *   doSomething(workflowInfo().searchAttributes)
 *   ...
 *   doSomethingElse(workflowInfo().searchAttributes)
 * }
 * ```
 *
 * vs
 *
 * ```ts
 * // BAD
 * function myWorkflow() {
 *   const attributes = workflowInfo().searchAttributes
 *   doSomething(attributes)
 *   ...
 *   doSomethingElse(attributes)
 * }
 * ```
 */
function workflowInfo() {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.workflowInfo(...) may only be used from a Workflow Execution.');
    return activator.info;
}
/**
 * Get information about the current update if any.
 *
 * @return Info for the current update handler the code calling this is executing
 * within if any.
 */
function currentUpdateInfo() {
    (0, global_attributes_1.assertInWorkflowContext)('Workflow.currentUpdateInfo(...) may only be used from a Workflow Execution.');
    return update_scope_1.UpdateScope.current();
}
/**
 * Returns whether or not code is executing in workflow context
 */
function inWorkflowContext() {
    return (0, global_attributes_1.maybeGetActivator)() !== undefined;
}
/**
 * Returns a function `f` that will cause the current Workflow to ContinueAsNew when called.
 *
 * `f` takes the same arguments as the Workflow function supplied to typeparam `F`.
 *
 * Once `f` is called, Workflow Execution immediately completes.
 */
function makeContinueAsNewFunc(options) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.continueAsNew(...) and Workflow.makeContinueAsNewFunc(...) may only be used from a Workflow Execution.');
    const info = activator.info;
    const { workflowType, taskQueue, ...rest } = options ?? {};
    const requiredOptions = {
        workflowType: workflowType ?? info.workflowType,
        taskQueue: taskQueue ?? info.taskQueue,
        ...rest,
    };
    return (...args) => {
        const fn = (0, interceptors_1.composeInterceptors)(activator.interceptors.outbound, 'continueAsNew', async (input) => {
            const { headers, args, options } = input;
            throw new interfaces_1.ContinueAsNew({
                workflowType: options.workflowType,
                arguments: (0, common_1.toPayloads)(activator.payloadConverter, ...args),
                headers,
                taskQueue: options.taskQueue,
                memo: options.memo && (0, common_1.mapToPayloads)(activator.payloadConverter, options.memo),
                searchAttributes: options.searchAttributes || options.typedSearchAttributes // eslint-disable-line deprecation/deprecation
                    ? (0, payload_search_attributes_1.encodeUnifiedSearchAttributes)(options.searchAttributes, options.typedSearchAttributes) // eslint-disable-line deprecation/deprecation
                    : undefined,
                workflowRunTimeout: (0, time_1.msOptionalToTs)(options.workflowRunTimeout),
                workflowTaskTimeout: (0, time_1.msOptionalToTs)(options.workflowTaskTimeout),
                versioningIntent: (0, versioning_intent_enum_1.versioningIntentToProto)(options.versioningIntent), // eslint-disable-line deprecation/deprecation
            });
        });
        return fn({
            args,
            headers: {},
            options: requiredOptions,
        });
    };
}
/**
 * {@link https://docs.temporal.io/concepts/what-is-continue-as-new/ | Continues-As-New} the current Workflow Execution
 * with default options.
 *
 * Shorthand for `makeContinueAsNewFunc<F>()(...args)`. (See: {@link makeContinueAsNewFunc}.)
 *
 * @example
 *
 * ```ts
 * import { continueAsNew } from '@temporalio/workflow';
 * import { SearchAttributeType } from '@temporalio/common';
 *
 * export async function myWorkflow(n: number): Promise<void> {
 *   // ... Workflow logic
 *   await continueAsNew<typeof myWorkflow>(n + 1);
 * }
 * ```
 */
function continueAsNew(...args) {
    return makeContinueAsNewFunc()(...args);
}
/**
 * Generate an RFC compliant V4 uuid.
 * Uses the workflow's deterministic PRNG making it safe for use within a workflow.
 * This function is cryptographically insecure.
 * See the {@link https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid | stackoverflow discussion}.
 */
function uuid4() {
    // Return the hexadecimal text representation of number `n`, padded with zeroes to be of length `p`
    const ho = (n, p) => n.toString(16).padStart(p, '0');
    // Create a view backed by a 16-byte buffer
    const view = new DataView(new ArrayBuffer(16));
    // Fill buffer with random values
    view.setUint32(0, (Math.random() * 0x100000000) >>> 0);
    view.setUint32(4, (Math.random() * 0x100000000) >>> 0);
    view.setUint32(8, (Math.random() * 0x100000000) >>> 0);
    view.setUint32(12, (Math.random() * 0x100000000) >>> 0);
    // Patch the 6th byte to reflect a version 4 UUID
    view.setUint8(6, (view.getUint8(6) & 0xf) | 0x40);
    // Patch the 8th byte to reflect a variant 1 UUID (version 4 UUIDs are)
    view.setUint8(8, (view.getUint8(8) & 0x3f) | 0x80);
    // Compile the canonical textual form from the array data
    return `${ho(view.getUint32(0), 8)}-${ho(view.getUint16(4), 4)}-${ho(view.getUint16(6), 4)}-${ho(view.getUint16(8), 4)}-${ho(view.getUint32(10), 8)}${ho(view.getUint16(14), 4)}`;
}
/**
 * Patch or upgrade workflow code by checking or stating that this workflow has a certain patch.
 *
 * See {@link https://docs.temporal.io/typescript/versioning | docs page} for info.
 *
 * If the workflow is replaying an existing history, then this function returns true if that
 * history was produced by a worker which also had a `patched` call with the same `patchId`.
 * If the history was produced by a worker *without* such a call, then it will return false.
 *
 * If the workflow is not currently replaying, then this call *always* returns true.
 *
 * Your workflow code should run the "new" code if this returns true, if it returns false, you
 * should run the "old" code. By doing this, you can maintain determinism.
 *
 * @param patchId An identifier that should be unique to this patch. It is OK to use multiple
 * calls with the same ID, which means all such calls will always return the same value.
 */
function patched(patchId) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.patch(...) and Workflow.deprecatePatch may only be used from a Workflow Execution.');
    return activator.patchInternal(patchId, false);
}
/**
 * Indicate that a patch is being phased out.
 *
 * See {@link https://docs.temporal.io/typescript/versioning | docs page} for info.
 *
 * Workflows with this call may be deployed alongside workflows with a {@link patched} call, but
 * they must *not* be deployed while any workers still exist running old code without a
 * {@link patched} call, or any runs with histories produced by such workers exist. If either kind
 * of worker encounters a history produced by the other, their behavior is undefined.
 *
 * Once all live workflow runs have been produced by workers with this call, you can deploy workers
 * which are free of either kind of patch call for this ID. Workers with and without this call
 * may coexist, as long as they are both running the "new" code.
 *
 * @param patchId An identifier that should be unique to this patch. It is OK to use multiple
 * calls with the same ID, which means all such calls will always return the same value.
 */
function deprecatePatch(patchId) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.patch(...) and Workflow.deprecatePatch may only be used from a Workflow Execution.');
    activator.patchInternal(patchId, true);
}
async function condition(fn, timeout, opts) {
    (0, global_attributes_1.assertInWorkflowContext)('Workflow.condition(...) may only be used from a Workflow Execution.');
    // Prior to 1.5.0, `condition(fn, 0)` was treated as equivalent to `condition(fn, undefined)`
    if (timeout === 0 && !patched(CONDITION_0_PATCH)) {
        return conditionInner(fn);
    }
    if (typeof timeout === 'number' || typeof timeout === 'string') {
        return cancellation_scope_1.CancellationScope.cancellable(async () => {
            try {
                return await Promise.race([sleep(timeout, opts).then(() => false), conditionInner(fn).then(() => true)]);
            }
            finally {
                cancellation_scope_1.CancellationScope.current().cancel();
            }
        });
    }
    return conditionInner(fn);
}
function conditionInner(fn) {
    const activator = (0, global_attributes_1.getActivator)();
    return new Promise((resolve, reject) => {
        const scope = cancellation_scope_1.CancellationScope.current();
        if (scope.consideredCancelled) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch(reject));
            return;
        }
        const seq = activator.nextSeqs.condition++;
        if (scope.cancellable) {
            (0, stack_helpers_1.untrackPromise)(scope.cancelRequested.catch((err) => {
                activator.blockedConditions.delete(seq);
                reject(err);
            }));
        }
        // Eager evaluation
        if (fn()) {
            resolve();
            return;
        }
        activator.blockedConditions.set(seq, { fn, resolve });
    });
}
/**
 * Define an update method for a Workflow.
 *
 * A definition is used to register a handler in the Workflow via {@link setHandler} and to update a Workflow using a {@link WorkflowHandle}, {@link ChildWorkflowHandle} or {@link ExternalWorkflowHandle}.
 * A definition can be reused in multiple Workflows.
 */
function defineUpdate(name) {
    return {
        type: 'update',
        name,
    };
}
/**
 * Define a signal method for a Workflow.
 *
 * A definition is used to register a handler in the Workflow via {@link setHandler} and to signal a Workflow using a {@link WorkflowHandle}, {@link ChildWorkflowHandle} or {@link ExternalWorkflowHandle}.
 * A definition can be reused in multiple Workflows.
 */
function defineSignal(name) {
    return {
        type: 'signal',
        name,
    };
}
/**
 * Define a query method for a Workflow.
 *
 * A definition is used to register a handler in the Workflow via {@link setHandler} and to query a Workflow using a {@link WorkflowHandle}.
 * A definition can be reused in multiple Workflows.
 */
function defineQuery(name) {
    return {
        type: 'query',
        name,
    };
}
// For Updates and Signals we want to make a public guarantee something like the
// following:
//
//   "If a WFT contains a Signal/Update, and if a handler is available for that
//   Signal/Update, then the handler will be executed.""
//
// However, that statement is not well-defined, leaving several questions open:
//
// 1. What does it mean for a handler to be "available"? What happens if the
//    handler is not present initially but is set at some point during the
//    Workflow code that is executed in that WFT? What happens if the handler is
//    set and then deleted, or replaced with a different handler?
//
// 2. When is the handler executed? (When it first becomes available? At the end
//    of the activation?) What are the execution semantics of Workflow and
//    Signal/Update handler code given that they are concurrent? Can the user
//    rely on Signal/Update side effects being reflected in the Workflow return
//    value, or in the value passed to Continue-As-New? If the handler is an
//    async function / coroutine, how much of it is executed and when is the
//    rest executed?
//
// 3. What happens if the handler is not executed? (i.e. because it wasn't
//    available in the sense defined by (1))
//
// 4. In the case of Update, when is the validation function executed?
//
// The implementation for Typescript is as follows:
//
// 1. sdk-core sorts Signal and Update jobs (and Patches) ahead of all other
//    jobs. Thus if the handler is available at the start of the Activation then
//    the Signal/Update will be executed before Workflow code is executed. If it
//    is not, then the Signal/Update calls are pushed to a buffer.
//
// 2. On each call to setHandler for a given Signal/Update, we make a pass
//    through the buffer list. If a buffered job is associated with the just-set
//    handler, then the job is removed from the buffer and the initial
//    synchronous portion of the handler is invoked on that input (i.e.
//    preempting workflow code).
//
// Thus in the case of Typescript the questions above are answered as follows:
//
// 1. A handler is "available" if it is set at the start of the Activation or
//    becomes set at any point during the Activation. If the handler is not set
//    initially then it is executed as soon as it is set. Subsequent deletion or
//    replacement by a different handler has no impact because the jobs it was
//    handling have already been handled and are no longer in the buffer.
//
// 2. The handler is executed as soon as it becomes available. I.e. if the
//    handler is set at the start of the Activation then it is executed when
//    first attempting to process the Signal/Update job; alternatively, if it is
//    set by a setHandler call made by Workflow code, then it is executed as
//    part of that call (preempting Workflow code). Therefore, a user can rely
//    on Signal/Update side effects being reflected in e.g. the Workflow return
//    value, and in the value passed to Continue-As-New. Activation jobs are
//    processed in the order supplied by sdk-core, i.e. Signals, then Updates,
//    then other jobs. Within each group, the order sent by the server is
//    preserved. If the handler is async, it is executed up to its first yield
//    point.
//
// 3. Signal case: If a handler does not become available for a Signal job then
//    the job remains in the buffer. If a handler for the Signal becomes
//    available in a subsequent Activation (of the same or a subsequent WFT)
//    then the handler will be executed. If not, then the Signal will never be
//    responded to and this causes no error.
//
//    Update case: If a handler does not become available for an Update job then
//    the Update is rejected at the end of the Activation. Thus, if a user does
//    not want an Update to be rejected for this reason, then it is their
//    responsibility to ensure that their application and workflow code interact
//    such that a handler is available for the Update during any Activation
//    which might contain their Update job. (Note that the user often has
//    uncertainty about which WFT their Signal/Update will appear in. For
//    example, if they call startWorkflow() followed by startUpdate(), then they
//    will typically not know whether these will be delivered in one or two
//    WFTs. On the other hand there are situations where they would have reason
//    to believe they are in the same WFT, for example if they do not start
//    Worker polling until after they have verified that both requests have
//    succeeded.)
//
// 4. If an Update has a validation function then it is executed immediately
//    prior to the handler. (Note that the validation function is required to be
//    synchronous).
function setHandler(def, handler, options) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.setHandler(...) may only be used from a Workflow Execution.');
    // Cannot register handler for reserved names
    (0, reserved_1.throwIfReservedName)(def.type, def.name);
    const description = options?.description;
    if (def.type === 'update') {
        if (typeof handler === 'function') {
            const updateOptions = options;
            const validator = updateOptions?.validator;
            const unfinishedPolicy = updateOptions?.unfinishedPolicy ?? common_1.HandlerUnfinishedPolicy.WARN_AND_ABANDON;
            activator.updateHandlers.set(def.name, { handler, validator, description, unfinishedPolicy });
            activator.dispatchBufferedUpdates();
        }
        else if (handler == null) {
            activator.updateHandlers.delete(def.name);
        }
        else {
            throw new TypeError(`Expected handler to be either a function or 'undefined'. Got: '${typeof handler}'`);
        }
    }
    else if (def.type === 'signal') {
        if (typeof handler === 'function') {
            const signalOptions = options;
            const unfinishedPolicy = signalOptions?.unfinishedPolicy ?? common_1.HandlerUnfinishedPolicy.WARN_AND_ABANDON;
            activator.signalHandlers.set(def.name, { handler: handler, description, unfinishedPolicy });
            activator.dispatchBufferedSignals();
        }
        else if (handler == null) {
            activator.signalHandlers.delete(def.name);
        }
        else {
            throw new TypeError(`Expected handler to be either a function or 'undefined'. Got: '${typeof handler}'`);
        }
    }
    else if (def.type === 'query') {
        if (typeof handler === 'function') {
            activator.queryHandlers.set(def.name, { handler: handler, description });
        }
        else if (handler == null) {
            activator.queryHandlers.delete(def.name);
        }
        else {
            throw new TypeError(`Expected handler to be either a function or 'undefined'. Got: '${typeof handler}'`);
        }
    }
    else {
        throw new TypeError(`Invalid definition type: ${def.type}`);
    }
}
/**
 * Set a signal handler function that will handle signals calls for non-registered signal names.
 *
 * Signals are dispatched to the default signal handler in the order that they were accepted by the server.
 *
 * If this function is called multiple times for a given signal name the last handler will overwrite any previous calls.
 *
 * @param handler a function that will handle signals for non-registered signal names, or `undefined` to unset the handler.
 */
function setDefaultSignalHandler(handler) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.setDefaultSignalHandler(...) may only be used from a Workflow Execution.');
    if (typeof handler === 'function') {
        activator.defaultSignalHandler = handler;
        activator.dispatchBufferedSignals();
    }
    else if (handler == null) {
        activator.defaultSignalHandler = undefined;
    }
    else {
        throw new TypeError(`Expected handler to be either a function or 'undefined'. Got: '${typeof handler}'`);
    }
}
/**
 * Set a update handler function that will handle updates calls for non-registered update names.
 *
 * Updates are dispatched to the default update handler in the order that they were accepted by the server.
 *
 * If this function is called multiple times for a given update name the last handler will overwrite any previous calls.
 *
 * @param handler a function that will handle updates for non-registered update names, or `undefined` to unset the handler.
 */
function setDefaultUpdateHandler(handler) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.setDefaultUpdateHandler(...) may only be used from a Workflow Execution.');
    if (typeof handler === 'function') {
        activator.defaultUpdateHandler = handler;
        activator.dispatchBufferedUpdates();
    }
    else if (handler == null) {
        activator.defaultUpdateHandler = undefined;
    }
    else {
        throw new TypeError(`Expected handler to be either a function or 'undefined'. Got: '${typeof handler}'`);
    }
}
/**
 * Set a query handler function that will handle query calls for non-registered query names.
 *
 * Queries are dispatched to the default query handler in the order that they were accepted by the server.
 *
 * If this function is called multiple times for a given query name the last handler will overwrite any previous calls.
 *
 * @param handler a function that will handle queries for non-registered query names, or `undefined` to unset the handler.
 */
function setDefaultQueryHandler(handler) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.setDefaultQueryHandler(...) may only be used from a Workflow Execution.');
    if (typeof handler === 'function' || handler === undefined) {
        activator.defaultQueryHandler = handler;
    }
    else {
        throw new TypeError(`Expected handler to be either a function or 'undefined'. Got: '${typeof handler}'`);
    }
}
/**
 * Updates this Workflow's Search Attributes by merging the provided `searchAttributes` with the existing Search
 * Attributes, `workflowInfo().searchAttributes`.
 *
 * Search attributes can be upserted using either SearchAttributes (deprecated) or SearchAttributeUpdatePair[] (preferred)
 *
 * Upserting a workflow's search attributes using SearchAttributeUpdatePair[]:
 *
 * ```ts
 * const intKey = defineSearchKey('CustomIntField', 'INT');
 * const boolKey = defineSearchKey('CustomBoolField', 'BOOL');
 * const keywordListKey = defineSearchKey('CustomKeywordField', 'KEYWORD_LIST');
 *
 * upsertSearchAttributes([
 *  defineSearchAttribute(intKey, 1),
 *  defineSearchAttribute(boolKey, true)
 * ]);
 * upsertSearchAttributes([
 *  defineSearchAttribute(intKey, 42),
 *  defineSearchAttribute(keywordListKey, ['durable code', 'is great'])
 * ]);
 * ```
 *
 * Would result in the Workflow having these Search Attributes:
 *
 * ```ts
 * {
 *   CustomIntField: [42],
 *   CustomBoolField: [true],
 *   CustomKeywordField: ['durable code', 'is great']
 * }
 * ```
 *
 * @param searchAttributes The Record to merge.
 * If using SearchAttributeUpdatePair[] (preferred), set a value to null to remove the search attribute.
 * If using SearchAttributes (deprecated), set a value to undefined or an empty list to remove the search attribute.
 */
// eslint-disable-next-line deprecation/deprecation
function upsertSearchAttributes(searchAttributes) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.upsertSearchAttributes(...) may only be used from a Workflow Execution.');
    if (searchAttributes == null) {
        throw new Error('searchAttributes must be a non-null SearchAttributes');
    }
    if (Array.isArray(searchAttributes)) {
        // Typed search attributes
        activator.pushCommand({
            upsertWorkflowSearchAttributes: {
                searchAttributes: (0, payload_search_attributes_1.encodeUnifiedSearchAttributes)(undefined, searchAttributes),
            },
        });
        activator.mutateWorkflowInfo((info) => {
            // Create a copy of the current state.
            const newSearchAttributes = { ...info.searchAttributes }; // eslint-disable-line deprecation/deprecation
            for (const pair of searchAttributes) {
                if (pair.value == null) {
                    // If the value is null, remove the search attribute.
                    // We don't mutate the existing state (just the new map) so this is safe.
                    delete newSearchAttributes[pair.key.name];
                }
                else {
                    newSearchAttributes[pair.key.name] = Array.isArray(pair.value)
                        ? pair.value
                        : [pair.value]; // eslint-disable-line deprecation/deprecation
                }
            }
            return {
                ...info,
                searchAttributes: newSearchAttributes,
                // Create an empty copy and apply existing and new updates. Keep in mind the order matters here (existing first, new second - to possibly overwrite existing).
                typedSearchAttributes: info.typedSearchAttributes.updateCopy([...searchAttributes]),
            };
        });
    }
    else {
        // Legacy search attributes
        activator.pushCommand({
            upsertWorkflowSearchAttributes: {
                searchAttributes: (0, common_1.mapToPayloads)(payload_search_attributes_1.searchAttributePayloadConverter, searchAttributes),
            },
        });
        activator.mutateWorkflowInfo((info) => {
            // Create a new copy of the current state.
            let typedSearchAttributes = info.typedSearchAttributes.updateCopy([]);
            const newSearchAttributes = { ...info.searchAttributes }; // eslint-disable-line deprecation/deprecation
            // Upsert legacy search attributes into typedSearchAttributes.
            for (const [k, v] of Object.entries(searchAttributes)) {
                if (v !== undefined && !Array.isArray(v)) {
                    throw new Error(`Search attribute value must be an array or undefined, got ${v}`);
                }
                // The value is undefined or an empty list, this signifies deletion.
                // Remove from both untyped & typed search attributes.
                if (v == null || (Array.isArray(v) && v.length === 0)) {
                    // We cannot discern a valid key typing from these values.
                    // Instead, we do a "best effort" deletion from typed search attributes:
                    // - check if a matching key name exists, if so, remove it.
                    const matchingPair = typedSearchAttributes.getAll().find((pair) => pair.key.name === k);
                    if (matchingPair) {
                        typedSearchAttributes = typedSearchAttributes.updateCopy([
                            { key: matchingPair.key, value: null },
                        ]);
                    }
                    delete newSearchAttributes[k];
                    continue;
                }
                // Attempt to discern a valid key typing for the update.
                const typedKey = common_1.TypedSearchAttributes.getKeyFromUntyped(k, v);
                // Unable to discern a valid key typing (no valid type for defined value).
                // Skip applying this update (no-op).
                if (typedKey === undefined) {
                    continue;
                }
                // TEXT type is inferred from a string value, but it could also be KEYWORD.
                // If a matching pair exists with KEYWORD type, use that instead.
                if (typedKey.type === 'TEXT') {
                    const matchingPair = typedSearchAttributes.getAll().find((pair) => pair.key.name === typedKey.name);
                    if (matchingPair) {
                        typedKey.type = matchingPair.key.type;
                    }
                }
                let newValue = v;
                // Unpack value if it is a single-element array.
                if (v.length === 1) {
                    newValue = v[0];
                    // Convert value back to Date.
                    if (typedKey.type === 'DATETIME') {
                        newValue = new Date(newValue);
                    }
                }
                // We have a defined value with valid type. Apply the update.
                typedSearchAttributes = typedSearchAttributes.updateCopy([
                    { key: typedKey, value: newValue },
                ]);
                newSearchAttributes[k] = v;
            }
            return {
                ...info,
                searchAttributes: newSearchAttributes,
                typedSearchAttributes,
            };
        });
    }
}
/**
 * Updates this Workflow's Memos by merging the provided `memo` with existing
 * Memos (as returned by `workflowInfo().memo`).
 *
 * New memo is merged by replacing properties of the same name _at the first
 * level only_. Setting a property to value `undefined` or `null` clears that
 * key from the Memo.
 *
 * For example:
 *
 * ```ts
 * upsertMemo({
 *   key1: value,
 *   key3: { subkey1: value }
 *   key4: value,
 * });
 * upsertMemo({
 *   key2: value
 *   key3: { subkey2: value }
 *   key4: undefined,
 * });
 * ```
 *
 * would result in the Workflow having these Memo:
 *
 * ```ts
 * {
 *   key1: value,
 *   key2: value,
 *   key3: { subkey2: value }  // Note this object was completely replaced
 *   // Note that key4 was completely removed
 * }
 * ```
 *
 * @param memo The Record to merge.
 */
function upsertMemo(memo) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('Workflow.upsertMemo(...) may only be used from a Workflow Execution.');
    if (memo == null) {
        throw new Error('memo must be a non-null Record');
    }
    activator.pushCommand({
        modifyWorkflowProperties: {
            upsertedMemo: {
                fields: (0, common_1.mapToPayloads)(activator.payloadConverter, 
                // Convert null to undefined
                Object.fromEntries(Object.entries(memo).map(([k, v]) => [k, v ?? undefined]))),
            },
        },
    });
    activator.mutateWorkflowInfo((info) => {
        return {
            ...info,
            memo: Object.fromEntries(Object.entries({
                ...info.memo,
                ...memo,
            }).filter(([_, v]) => v != null)),
        };
    });
}
/**
 * Whether update and signal handlers have finished executing.
 *
 * Consider waiting on this condition before workflow return or continue-as-new, to prevent
 * interruption of in-progress handlers by workflow exit:
 *
 * ```ts
 * await workflow.condition(workflow.allHandlersFinished)
 * ```
 *
 * @returns true if there are no in-progress update or signal handler executions.
 */
function allHandlersFinished() {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('allHandlersFinished() may only be used from a Workflow Execution.');
    return activator.inProgressSignals.size === 0 && activator.inProgressUpdates.size === 0;
}
/**
 * Can be used to alter workflow functions with certain options specified at definition time.
 *
 * @example
 * For example:
 * ```ts
 * setWorkflowOptions({ versioningBehavior: 'PINNED' }, myWorkflow);
 * export async function myWorkflow(): Promise<string> {
 *   // Workflow code here
 *   return "hi";
 * }
 * ```
 *
 * @example
 * To annotate a default or dynamic workflow:
 * ```ts
 * export default async function (): Promise<string> {
 *   // Workflow code here
 *   return "hi";
 * }
 * setWorkflowOptions({ versioningBehavior: 'PINNED' }, module.exports.default);
 * ```
 *
 * @param options Options for the workflow defintion, or a function that returns options. If a
 * function is provided, it will be called once just before the workflow function is called for the
 * first time. It is safe to call {@link workflowInfo} inside such a function.
 * @param fn The workflow function.
 */
function setWorkflowOptions(options, fn) {
    Object.assign(fn, {
        workflowDefinitionOptions: options,
    });
}
exports.stackTraceQuery = defineQuery('__stack_trace');
exports.enhancedStackTraceQuery = defineQuery('__enhanced_stack_trace');
exports.workflowMetadataQuery = defineQuery('__temporal_workflow_metadata');
function getCurrentDetails() {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('getCurrentDetails() may only be used from a Workflow Execution.');
    return activator.currentDetails;
}
function setCurrentDetails(details) {
    const activator = (0, global_attributes_1.assertInWorkflowContext)('getCurrentDetails() may only be used from a Workflow Execution.');
    activator.currentDetails = details;
}


/***/ }),

/***/ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/package.json":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/package.json ***!
  \*******************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"@temporalio/workflow","version":"1.13.1","description":"Temporal.io SDK Workflow sub-package","keywords":["temporal","workflow","isolate"],"bugs":{"url":"https://github.com/temporalio/sdk-typescript/issues"},"repository":{"type":"git","url":"git+https://github.com/temporalio/sdk-typescript.git","directory":"packages/workflow"},"homepage":"https://github.com/temporalio/sdk-typescript/tree/main/packages/workflow","license":"MIT","author":"Temporal Technologies Inc. <sdk@temporal.io>","main":"lib/index.js","types":"lib/index.d.ts","scripts":{},"dependencies":{"@temporalio/common":"1.13.1","@temporalio/proto":"1.13.1","nexus-rpc":"^0.0.1"},"devDependencies":{"source-map":"^0.7.4"},"publishConfig":{"access":"public"},"engines":{"node":">= 18.0.0"},"files":["src","lib"],"gitHead":"7904e19bc72dcdf9eb0275ecaa585a2ff2fec072"}');

/***/ }),

/***/ "./node_modules/.pnpm/long@5.3.2/node_modules/long/umd/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/long@5.3.2/node_modules/long/umd/index.js ***!
  \**********************************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// GENERATED FILE. DO NOT EDIT.
(function (global, factory) {
  function preferDefault(exports) {
    return exports.default || exports;
  }
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      var exports = {};
      factory(exports);
      return preferDefault(exports);
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else // removed by dead control flow
{}
})(
  typeof globalThis !== "undefined"
    ? globalThis
    : typeof self !== "undefined"
      ? self
      : this,
  function (_exports) {
    "use strict";

    Object.defineProperty(_exports, "__esModule", {
      value: true,
    });
    _exports.default = void 0;
    /**
     * @license
     * Copyright 2009 The Closure Library Authors
     * Copyright 2020 Daniel Wirtz / The long.js Authors.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * SPDX-License-Identifier: Apache-2.0
     */

    // WebAssembly optimizations to do native i64 multiplication and divide
    var wasm = null;
    try {
      wasm = new WebAssembly.Instance(
        new WebAssembly.Module(
          new Uint8Array([
            // \0asm
            0, 97, 115, 109,
            // version 1
            1, 0, 0, 0,
            // section "type"
            1, 13, 2,
            // 0, () => i32
            96, 0, 1, 127,
            // 1, (i32, i32, i32, i32) => i32
            96, 4, 127, 127, 127, 127, 1, 127,
            // section "function"
            3, 7, 6,
            // 0, type 0
            0,
            // 1, type 1
            1,
            // 2, type 1
            1,
            // 3, type 1
            1,
            // 4, type 1
            1,
            // 5, type 1
            1,
            // section "global"
            6, 6, 1,
            // 0, "high", mutable i32
            127, 1, 65, 0, 11,
            // section "export"
            7, 50, 6,
            // 0, "mul"
            3, 109, 117, 108, 0, 1,
            // 1, "div_s"
            5, 100, 105, 118, 95, 115, 0, 2,
            // 2, "div_u"
            5, 100, 105, 118, 95, 117, 0, 3,
            // 3, "rem_s"
            5, 114, 101, 109, 95, 115, 0, 4,
            // 4, "rem_u"
            5, 114, 101, 109, 95, 117, 0, 5,
            // 5, "get_high"
            8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0,
            // section "code"
            10, 191, 1, 6,
            // 0, "get_high"
            4, 0, 35, 0, 11,
            // 1, "mul"
            36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173,
            32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0,
            32, 4, 167, 11,
            // 2, "div_s"
            36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173,
            32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0,
            32, 4, 167, 11,
            // 3, "div_u"
            36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173,
            32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0,
            32, 4, 167, 11,
            // 4, "rem_s"
            36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173,
            32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0,
            32, 4, 167, 11,
            // 5, "rem_u"
            36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173,
            32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0,
            32, 4, 167, 11,
          ]),
        ),
        {},
      ).exports;
    } catch {
      // no wasm support :(
    }

    /**
     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
     *  See the from* functions below for more convenient ways of constructing Longs.
     * @exports Long
     * @class A Long class for representing a 64 bit two's-complement integer value.
     * @param {number} low The low (signed) 32 bits of the long
     * @param {number} high The high (signed) 32 bits of the long
     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
     * @constructor
     */
    function Long(low, high, unsigned) {
      /**
       * The low 32 bits as a signed value.
       * @type {number}
       */
      this.low = low | 0;

      /**
       * The high 32 bits as a signed value.
       * @type {number}
       */
      this.high = high | 0;

      /**
       * Whether unsigned or not.
       * @type {boolean}
       */
      this.unsigned = !!unsigned;
    }

    // The internal representation of a long is the two given signed, 32-bit values.
    // We use 32-bit pieces because these are the size of integers on which
    // Javascript performs bit-operations.  For operations like addition and
    // multiplication, we split each number into 16 bit pieces, which can easily be
    // multiplied within Javascript's floating-point representation without overflow
    // or change in sign.
    //
    // In the algorithms below, we frequently reduce the negative case to the
    // positive case by negating the input(s) and then post-processing the result.
    // Note that we must ALWAYS check specially whether those values are MIN_VALUE
    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
    // a positive number, it overflows back into a negative).  Not handling this
    // case would often result in infinite recursion.
    //
    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
    // methods on which they depend.

    /**
     * An indicator used to reliably determine if an object is a Long or not.
     * @type {boolean}
     * @const
     * @private
     */
    Long.prototype.__isLong__;
    Object.defineProperty(Long.prototype, "__isLong__", {
      value: true,
    });

    /**
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     * @inner
     */
    function isLong(obj) {
      return (obj && obj["__isLong__"]) === true;
    }

    /**
     * @function
     * @param {*} value number
     * @returns {number}
     * @inner
     */
    function ctz32(value) {
      var c = Math.clz32(value & -value);
      return value ? 31 - c : c;
    }

    /**
     * Tests if the specified object is a Long.
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     */
    Long.isLong = isLong;

    /**
     * A cache of the Long representations of small integer values.
     * @type {!Object}
     * @inner
     */
    var INT_CACHE = {};

    /**
     * A cache of the Long representations of small unsigned integer values.
     * @type {!Object}
     * @inner
     */
    var UINT_CACHE = {};

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromInt(value, unsigned) {
      var obj, cachedObj, cache;
      if (unsigned) {
        value >>>= 0;
        if ((cache = 0 <= value && value < 256)) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj) return cachedObj;
        }
        obj = fromBits(value, 0, true);
        if (cache) UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if ((cache = -128 <= value && value < 128)) {
          cachedObj = INT_CACHE[value];
          if (cachedObj) return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache) INT_CACHE[value] = obj;
        return obj;
      }
    }

    /**
     * Returns a Long representing the given 32 bit integer value.
     * @function
     * @param {number} value The 32 bit integer in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromInt = fromInt;

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromNumber(value, unsigned) {
      if (isNaN(value)) return unsigned ? UZERO : ZERO;
      if (unsigned) {
        if (value < 0) return UZERO;
        if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
      }
      if (value < 0) return fromNumber(-value, unsigned).neg();
      return fromBits(
        value % TWO_PWR_32_DBL | 0,
        (value / TWO_PWR_32_DBL) | 0,
        unsigned,
      );
    }

    /**
     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
     * @function
     * @param {number} value The number in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromNumber = fromNumber;

    /**
     * @param {number} lowBits
     * @param {number} highBits
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromBits(lowBits, highBits, unsigned) {
      return new Long(lowBits, highBits, unsigned);
    }

    /**
     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
     *  assumed to use 32 bits.
     * @function
     * @param {number} lowBits The low 32 bits
     * @param {number} highBits The high 32 bits
     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromBits = fromBits;

    /**
     * @function
     * @param {number} base
     * @param {number} exponent
     * @returns {number}
     * @inner
     */
    var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

    /**
     * @param {string} str
     * @param {(boolean|number)=} unsigned
     * @param {number=} radix
     * @returns {!Long}
     * @inner
     */
    function fromString(str, unsigned, radix) {
      if (str.length === 0) throw Error("empty string");
      if (typeof unsigned === "number") {
        // For goog.math.long compatibility
        radix = unsigned;
        unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      if (
        str === "NaN" ||
        str === "Infinity" ||
        str === "+Infinity" ||
        str === "-Infinity"
      )
        return unsigned ? UZERO : ZERO;
      radix = radix || 10;
      if (radix < 2 || 36 < radix) throw RangeError("radix");
      var p;
      if ((p = str.indexOf("-")) > 0) throw Error("interior hyphen");
      else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
      }

      // Do several (8) digits each time through the loop, so as to
      // minimize the calls to the very expensive emulated div.
      var radixToPower = fromNumber(pow_dbl(radix, 8));
      var result = ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
          value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = fromNumber(pow_dbl(radix, size));
          result = result.mul(power).add(fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }

    /**
     * Returns a Long representation of the given string, written using the specified radix.
     * @function
     * @param {string} str The textual representation of the Long
     * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
     * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
     * @returns {!Long} The corresponding Long value
     */
    Long.fromString = fromString;

    /**
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromValue(val, unsigned) {
      if (typeof val === "number") return fromNumber(val, unsigned);
      if (typeof val === "string") return fromString(val, unsigned);
      // Throws for non-objects, converts non-instanceof Long:
      return fromBits(
        val.low,
        val.high,
        typeof unsigned === "boolean" ? unsigned : val.unsigned,
      );
    }

    /**
     * Converts the specified value to a Long using the appropriate from* function for its type.
     * @function
     * @param {!Long|number|bigint|string|!{low: number, high: number, unsigned: boolean}} val Value
     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
     * @returns {!Long}
     */
    Long.fromValue = fromValue;

    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
    // no runtime penalty for these.

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_16_DBL = 1 << 16;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_24_DBL = 1 << 24;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

    /**
     * @type {!Long}
     * @const
     * @inner
     */
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

    /**
     * @type {!Long}
     * @inner
     */
    var ZERO = fromInt(0);

    /**
     * Signed zero.
     * @type {!Long}
     */
    Long.ZERO = ZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var UZERO = fromInt(0, true);

    /**
     * Unsigned zero.
     * @type {!Long}
     */
    Long.UZERO = UZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var ONE = fromInt(1);

    /**
     * Signed one.
     * @type {!Long}
     */
    Long.ONE = ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var UONE = fromInt(1, true);

    /**
     * Unsigned one.
     * @type {!Long}
     */
    Long.UONE = UONE;

    /**
     * @type {!Long}
     * @inner
     */
    var NEG_ONE = fromInt(-1);

    /**
     * Signed negative one.
     * @type {!Long}
     */
    Long.NEG_ONE = NEG_ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_VALUE = fromBits(0xffffffff | 0, 0x7fffffff | 0, false);

    /**
     * Maximum signed value.
     * @type {!Long}
     */
    Long.MAX_VALUE = MAX_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_UNSIGNED_VALUE = fromBits(0xffffffff | 0, 0xffffffff | 0, true);

    /**
     * Maximum unsigned value.
     * @type {!Long}
     */
    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);

    /**
     * Minimum signed value.
     * @type {!Long}
     */
    Long.MIN_VALUE = MIN_VALUE;

    /**
     * @alias Long.prototype
     * @inner
     */
    var LongPrototype = Long.prototype;

    /**
     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
     * @this {!Long}
     * @returns {number}
     */
    LongPrototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };

    /**
     * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
     * @this {!Long}
     * @returns {number}
     */
    LongPrototype.toNumber = function toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };

    /**
     * Converts the Long to a string written in the specified radix.
     * @this {!Long}
     * @param {number=} radix Radix (2-36), defaults to 10
     * @returns {string}
     * @override
     * @throws {RangeError} If `radix` is out of range
     */
    LongPrototype.toString = function toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix) throw RangeError("radix");
      if (this.isZero()) return "0";
      if (this.isNegative()) {
        // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
          // We need to change the Long value before it can be negated, so we remove
          // the bottom-most digit in this base and then recurse to do the rest.
          var radixLong = fromNumber(radix),
            div = this.div(radixLong),
            rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else return "-" + this.neg().toString(radix);
      }

      // Do several (6) digits each time through the loop, so as to
      // minimize the calls to the very expensive emulated div.
      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
      var result = "";
      while (true) {
        var remDiv = rem.div(radixToPower),
          intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
          digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero()) return digits + result;
        else {
          while (digits.length < 6) digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    };

    /**
     * Gets the high 32 bits as a signed integer.
     * @this {!Long}
     * @returns {number} Signed high bits
     */
    LongPrototype.getHighBits = function getHighBits() {
      return this.high;
    };

    /**
     * Gets the high 32 bits as an unsigned integer.
     * @this {!Long}
     * @returns {number} Unsigned high bits
     */
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
    };

    /**
     * Gets the low 32 bits as a signed integer.
     * @this {!Long}
     * @returns {number} Signed low bits
     */
    LongPrototype.getLowBits = function getLowBits() {
      return this.low;
    };

    /**
     * Gets the low 32 bits as an unsigned integer.
     * @this {!Long}
     * @returns {number} Unsigned low bits
     */
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
    };

    /**
     * Gets the number of bits needed to represent the absolute value of this Long.
     * @this {!Long}
     * @returns {number}
     */
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative())
        // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--) if ((val & (1 << bit)) != 0) break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };

    /**
     * Tests if this Long can be safely represented as a JavaScript number.
     * @this {!Long}
     * @returns {boolean}
     */
    LongPrototype.isSafeInteger = function isSafeInteger() {
      // 2^53-1 is the maximum safe value
      var top11Bits = this.high >> 21;
      // [0, 2^53-1]
      if (!top11Bits) return true;
      // > 2^53-1
      if (this.unsigned) return false;
      // [-2^53, -1] except -2^53
      return top11Bits === -1 && !(this.low === 0 && this.high === -0x200000);
    };

    /**
     * Tests if this Long's value equals zero.
     * @this {!Long}
     * @returns {boolean}
     */
    LongPrototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
    };

    /**
     * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
     * @returns {boolean}
     */
    LongPrototype.eqz = LongPrototype.isZero;

    /**
     * Tests if this Long's value is negative.
     * @this {!Long}
     * @returns {boolean}
     */
    LongPrototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
    };

    /**
     * Tests if this Long's value is positive or zero.
     * @this {!Long}
     * @returns {boolean}
     */
    LongPrototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
    };

    /**
     * Tests if this Long's value is odd.
     * @this {!Long}
     * @returns {boolean}
     */
    LongPrototype.isOdd = function isOdd() {
      return (this.low & 1) === 1;
    };

    /**
     * Tests if this Long's value is even.
     * @this {!Long}
     * @returns {boolean}
     */
    LongPrototype.isEven = function isEven() {
      return (this.low & 1) === 0;
    };

    /**
     * Tests if this Long's value equals the specified's.
     * @this {!Long}
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.equals = function equals(other) {
      if (!isLong(other)) other = fromValue(other);
      if (
        this.unsigned !== other.unsigned &&
        this.high >>> 31 === 1 &&
        other.high >>> 31 === 1
      )
        return false;
      return this.high === other.high && this.low === other.low;
    };

    /**
     * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
     * @function
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.eq = LongPrototype.equals;

    /**
     * Tests if this Long's value differs from the specified's.
     * @this {!Long}
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.notEquals = function notEquals(other) {
      return !this.eq(/* validates */ other);
    };

    /**
     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
     * @function
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.neq = LongPrototype.notEquals;

    /**
     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
     * @function
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.ne = LongPrototype.notEquals;

    /**
     * Tests if this Long's value is less than the specified's.
     * @this {!Long}
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lessThan = function lessThan(other) {
      return this.comp(/* validates */ other) < 0;
    };

    /**
     * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
     * @function
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lt = LongPrototype.lessThan;

    /**
     * Tests if this Long's value is less than or equal the specified's.
     * @this {!Long}
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.comp(/* validates */ other) <= 0;
    };

    /**
     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
     * @function
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lte = LongPrototype.lessThanOrEqual;

    /**
     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
     * @function
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.le = LongPrototype.lessThanOrEqual;

    /**
     * Tests if this Long's value is greater than the specified's.
     * @this {!Long}
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.greaterThan = function greaterThan(other) {
      return this.comp(/* validates */ other) > 0;
    };

    /**
     * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
     * @function
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.gt = LongPrototype.greaterThan;

    /**
     * Tests if this Long's value is greater than or equal the specified's.
     * @this {!Long}
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.comp(/* validates */ other) >= 0;
    };

    /**
     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
     * @function
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;

    /**
     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
     * @function
     * @param {!Long|number|bigint|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.ge = LongPrototype.greaterThanOrEqual;

    /**
     * Compares this Long's value with the specified's.
     * @this {!Long}
     * @param {!Long|number|bigint|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     */
    LongPrototype.compare = function compare(other) {
      if (!isLong(other)) other = fromValue(other);
      if (this.eq(other)) return 0;
      var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
      if (thisNeg && !otherNeg) return -1;
      if (!thisNeg && otherNeg) return 1;
      // At this point the sign bits are the same
      if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
      // Both are positive if at least one is unsigned
      return other.high >>> 0 > this.high >>> 0 ||
        (other.high === this.high && other.low >>> 0 > this.low >>> 0)
        ? -1
        : 1;
    };

    /**
     * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
     * @function
     * @param {!Long|number|bigint|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     */
    LongPrototype.comp = LongPrototype.compare;

    /**
     * Negates this Long's value.
     * @this {!Long}
     * @returns {!Long} Negated Long
     */
    LongPrototype.negate = function negate() {
      if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
      return this.not().add(ONE);
    };

    /**
     * Negates this Long's value. This is an alias of {@link Long#negate}.
     * @function
     * @returns {!Long} Negated Long
     */
    LongPrototype.neg = LongPrototype.negate;

    /**
     * Returns the sum of this and the specified Long.
     * @this {!Long}
     * @param {!Long|number|bigint|string} addend Addend
     * @returns {!Long} Sum
     */
    LongPrototype.add = function add(addend) {
      if (!isLong(addend)) addend = fromValue(addend);

      // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

      var a48 = this.high >>> 16;
      var a32 = this.high & 0xffff;
      var a16 = this.low >>> 16;
      var a00 = this.low & 0xffff;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 0xffff;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 0xffff;
      var c48 = 0,
        c32 = 0,
        c16 = 0,
        c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 0xffff;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 0xffff;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c48 += a48 + b48;
      c48 &= 0xffff;
      return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the difference of this and the specified Long.
     * @this {!Long}
     * @param {!Long|number|bigint|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     */
    LongPrototype.subtract = function subtract(subtrahend) {
      if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
      return this.add(subtrahend.neg());
    };

    /**
     * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
     * @function
     * @param {!Long|number|bigint|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     */
    LongPrototype.sub = LongPrototype.subtract;

    /**
     * Returns the product of this and the specified Long.
     * @this {!Long}
     * @param {!Long|number|bigint|string} multiplier Multiplier
     * @returns {!Long} Product
     */
    LongPrototype.multiply = function multiply(multiplier) {
      if (this.isZero()) return this;
      if (!isLong(multiplier)) multiplier = fromValue(multiplier);

      // use wasm support if present
      if (wasm) {
        var low = wasm["mul"](
          this.low,
          this.high,
          multiplier.low,
          multiplier.high,
        );
        return fromBits(low, wasm["get_high"](), this.unsigned);
      }
      if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
      if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
      if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());
        else return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

      // If both longs are small, use float multiplication
      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(
          this.toNumber() * multiplier.toNumber(),
          this.unsigned,
        );

      // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
      // We can skip products that would overflow.

      var a48 = this.high >>> 16;
      var a32 = this.high & 0xffff;
      var a16 = this.low >>> 16;
      var a00 = this.low & 0xffff;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 0xffff;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 0xffff;
      var c48 = 0,
        c32 = 0,
        c16 = 0,
        c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 0xffff;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 0xffff;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 0xffff;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 0xffff;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 0xffff;
      return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
     * @function
     * @param {!Long|number|bigint|string} multiplier Multiplier
     * @returns {!Long} Product
     */
    LongPrototype.mul = LongPrototype.multiply;

    /**
     * Returns this Long divided by the specified. The result is signed if this Long is signed or
     *  unsigned if this Long is unsigned.
     * @this {!Long}
     * @param {!Long|number|bigint|string} divisor Divisor
     * @returns {!Long} Quotient
     */
    LongPrototype.divide = function divide(divisor) {
      if (!isLong(divisor)) divisor = fromValue(divisor);
      if (divisor.isZero()) throw Error("division by zero");

      // use wasm support if present
      if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (
          !this.unsigned &&
          this.high === -0x80000000 &&
          divisor.low === -1 &&
          divisor.high === -1
        ) {
          // be consistent with non-wasm code path
          return this;
        }
        var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
          this.low,
          this.high,
          divisor.low,
          divisor.high,
        );
        return fromBits(low, wasm["get_high"](), this.unsigned);
      }
      if (this.isZero()) return this.unsigned ? UZERO : ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
          if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
            return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
          else if (divisor.eq(MIN_VALUE)) return ONE;
          else {
            // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO)) {
              return divisor.isNegative() ? ONE : NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative()) return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
        res = ZERO;
      } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned) divisor = divisor.toUnsigned();
        if (divisor.gt(this)) return UZERO;
        if (divisor.gt(this.shru(1)))
          // 15 >>> 1 = 7 ; with divisor = 8 ; true
          return UONE;
        res = UZERO;
      }

      // Repeat the following until the remainder is less than other:  find a
      // floating-point that approximates remainder / other *from below*, add this
      // into the result, and subtract it from the remainder.  It is critical that
      // the approximate value is less than or equal to the real value so that the
      // remainder never becomes negative.
      rem = this;
      while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
          delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),
          // Decrease the approximation until it is smaller than the remainder.  Note
          // that if it is too large, the product overflows and is negative.
          approxRes = fromNumber(approx),
          approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero()) approxRes = ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };

    /**
     * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
     * @function
     * @param {!Long|number|bigint|string} divisor Divisor
     * @returns {!Long} Quotient
     */
    LongPrototype.div = LongPrototype.divide;

    /**
     * Returns this Long modulo the specified.
     * @this {!Long}
     * @param {!Long|number|bigint|string} divisor Divisor
     * @returns {!Long} Remainder
     */
    LongPrototype.modulo = function modulo(divisor) {
      if (!isLong(divisor)) divisor = fromValue(divisor);

      // use wasm support if present
      if (wasm) {
        var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
          this.low,
          this.high,
          divisor.low,
          divisor.high,
        );
        return fromBits(low, wasm["get_high"](), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };

    /**
     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
     * @function
     * @param {!Long|number|bigint|string} divisor Divisor
     * @returns {!Long} Remainder
     */
    LongPrototype.mod = LongPrototype.modulo;

    /**
     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
     * @function
     * @param {!Long|number|bigint|string} divisor Divisor
     * @returns {!Long} Remainder
     */
    LongPrototype.rem = LongPrototype.modulo;

    /**
     * Returns the bitwise NOT of this Long.
     * @this {!Long}
     * @returns {!Long}
     */
    LongPrototype.not = function not() {
      return fromBits(~this.low, ~this.high, this.unsigned);
    };

    /**
     * Returns count leading zeros of this Long.
     * @this {!Long}
     * @returns {!number}
     */
    LongPrototype.countLeadingZeros = function countLeadingZeros() {
      return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
    };

    /**
     * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.
     * @function
     * @param {!Long}
     * @returns {!number}
     */
    LongPrototype.clz = LongPrototype.countLeadingZeros;

    /**
     * Returns count trailing zeros of this Long.
     * @this {!Long}
     * @returns {!number}
     */
    LongPrototype.countTrailingZeros = function countTrailingZeros() {
      return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
    };

    /**
     * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.
     * @function
     * @param {!Long}
     * @returns {!number}
     */
    LongPrototype.ctz = LongPrototype.countTrailingZeros;

    /**
     * Returns the bitwise AND of this Long and the specified.
     * @this {!Long}
     * @param {!Long|number|bigint|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.and = function and(other) {
      if (!isLong(other)) other = fromValue(other);
      return fromBits(
        this.low & other.low,
        this.high & other.high,
        this.unsigned,
      );
    };

    /**
     * Returns the bitwise OR of this Long and the specified.
     * @this {!Long}
     * @param {!Long|number|bigint|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.or = function or(other) {
      if (!isLong(other)) other = fromValue(other);
      return fromBits(
        this.low | other.low,
        this.high | other.high,
        this.unsigned,
      );
    };

    /**
     * Returns the bitwise XOR of this Long and the given one.
     * @this {!Long}
     * @param {!Long|number|bigint|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.xor = function xor(other) {
      if (!isLong(other)) other = fromValue(other);
      return fromBits(
        this.low ^ other.low,
        this.high ^ other.high,
        this.unsigned,
      );
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount.
     * @this {!Long}
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
      if (isLong(numBits)) numBits = numBits.toInt();
      if ((numBits &= 63) === 0) return this;
      else if (numBits < 32)
        return fromBits(
          this.low << numBits,
          (this.high << numBits) | (this.low >>> (32 - numBits)),
          this.unsigned,
        );
      else return fromBits(0, this.low << (numBits - 32), this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shl = LongPrototype.shiftLeft;

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount.
     * @this {!Long}
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftRight = function shiftRight(numBits) {
      if (isLong(numBits)) numBits = numBits.toInt();
      if ((numBits &= 63) === 0) return this;
      else if (numBits < 32)
        return fromBits(
          (this.low >>> numBits) | (this.high << (32 - numBits)),
          this.high >> numBits,
          this.unsigned,
        );
      else
        return fromBits(
          this.high >> (numBits - 32),
          this.high >= 0 ? 0 : -1,
          this.unsigned,
        );
    };

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shr = LongPrototype.shiftRight;

    /**
     * Returns this Long with bits logically shifted to the right by the given amount.
     * @this {!Long}
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (isLong(numBits)) numBits = numBits.toInt();
      if ((numBits &= 63) === 0) return this;
      if (numBits < 32)
        return fromBits(
          (this.low >>> numBits) | (this.high << (32 - numBits)),
          this.high >>> numBits,
          this.unsigned,
        );
      if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
      return fromBits(this.high >>> (numBits - 32), 0, this.unsigned);
    };

    /**
     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;

    /**
     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

    /**
     * Returns this Long with bits rotated to the left by the given amount.
     * @this {!Long}
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Rotated Long
     */
    LongPrototype.rotateLeft = function rotateLeft(numBits) {
      var b;
      if (isLong(numBits)) numBits = numBits.toInt();
      if ((numBits &= 63) === 0) return this;
      if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
      if (numBits < 32) {
        b = 32 - numBits;
        return fromBits(
          (this.low << numBits) | (this.high >>> b),
          (this.high << numBits) | (this.low >>> b),
          this.unsigned,
        );
      }
      numBits -= 32;
      b = 32 - numBits;
      return fromBits(
        (this.high << numBits) | (this.low >>> b),
        (this.low << numBits) | (this.high >>> b),
        this.unsigned,
      );
    };
    /**
     * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Rotated Long
     */
    LongPrototype.rotl = LongPrototype.rotateLeft;

    /**
     * Returns this Long with bits rotated to the right by the given amount.
     * @this {!Long}
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Rotated Long
     */
    LongPrototype.rotateRight = function rotateRight(numBits) {
      var b;
      if (isLong(numBits)) numBits = numBits.toInt();
      if ((numBits &= 63) === 0) return this;
      if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
      if (numBits < 32) {
        b = 32 - numBits;
        return fromBits(
          (this.high << b) | (this.low >>> numBits),
          (this.low << b) | (this.high >>> numBits),
          this.unsigned,
        );
      }
      numBits -= 32;
      b = 32 - numBits;
      return fromBits(
        (this.low << b) | (this.high >>> numBits),
        (this.high << b) | (this.low >>> numBits),
        this.unsigned,
      );
    };
    /**
     * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Rotated Long
     */
    LongPrototype.rotr = LongPrototype.rotateRight;

    /**
     * Converts this Long to signed.
     * @this {!Long}
     * @returns {!Long} Signed long
     */
    LongPrototype.toSigned = function toSigned() {
      if (!this.unsigned) return this;
      return fromBits(this.low, this.high, false);
    };

    /**
     * Converts this Long to unsigned.
     * @this {!Long}
     * @returns {!Long} Unsigned long
     */
    LongPrototype.toUnsigned = function toUnsigned() {
      if (this.unsigned) return this;
      return fromBits(this.low, this.high, true);
    };

    /**
     * Converts this Long to its byte representation.
     * @param {boolean=} le Whether little or big endian, defaults to big endian
     * @this {!Long}
     * @returns {!Array.<number>} Byte representation
     */
    LongPrototype.toBytes = function toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    };

    /**
     * Converts this Long to its little endian byte representation.
     * @this {!Long}
     * @returns {!Array.<number>} Little endian byte representation
     */
    LongPrototype.toBytesLE = function toBytesLE() {
      var hi = this.high,
        lo = this.low;
      return [
        lo & 0xff,
        (lo >>> 8) & 0xff,
        (lo >>> 16) & 0xff,
        lo >>> 24,
        hi & 0xff,
        (hi >>> 8) & 0xff,
        (hi >>> 16) & 0xff,
        hi >>> 24,
      ];
    };

    /**
     * Converts this Long to its big endian byte representation.
     * @this {!Long}
     * @returns {!Array.<number>} Big endian byte representation
     */
    LongPrototype.toBytesBE = function toBytesBE() {
      var hi = this.high,
        lo = this.low;
      return [
        hi >>> 24,
        (hi >>> 16) & 0xff,
        (hi >>> 8) & 0xff,
        hi & 0xff,
        lo >>> 24,
        (lo >>> 16) & 0xff,
        (lo >>> 8) & 0xff,
        lo & 0xff,
      ];
    };

    /**
     * Creates a Long from its byte representation.
     * @param {!Array.<number>} bytes Byte representation
     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
     * @param {boolean=} le Whether little or big endian, defaults to big endian
     * @returns {Long} The corresponding Long value
     */
    Long.fromBytes = function fromBytes(bytes, unsigned, le) {
      return le
        ? Long.fromBytesLE(bytes, unsigned)
        : Long.fromBytesBE(bytes, unsigned);
    };

    /**
     * Creates a Long from its little endian byte representation.
     * @param {!Array.<number>} bytes Little endian byte representation
     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
     * @returns {Long} The corresponding Long value
     */
    Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
      return new Long(
        bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24),
        bytes[4] | (bytes[5] << 8) | (bytes[6] << 16) | (bytes[7] << 24),
        unsigned,
      );
    };

    /**
     * Creates a Long from its big endian byte representation.
     * @param {!Array.<number>} bytes Big endian byte representation
     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
     * @returns {Long} The corresponding Long value
     */
    Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
      return new Long(
        (bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7],
        (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3],
        unsigned,
      );
    };

    // Support conversion to/from BigInt where available
    if (typeof BigInt === "function") {
      /**
       * Returns a Long representing the given big integer.
       * @function
       * @param {number} value The big integer value
       * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
       * @returns {!Long} The corresponding Long value
       */
      Long.fromBigInt = function fromBigInt(value, unsigned) {
        var lowBits = Number(BigInt.asIntN(32, value));
        var highBits = Number(BigInt.asIntN(32, value >> BigInt(32)));
        return fromBits(lowBits, highBits, unsigned);
      };

      // Override
      Long.fromValue = function fromValueWithBigInt(value, unsigned) {
        if (typeof value === "bigint") return Long.fromBigInt(value, unsigned);
        return fromValue(value, unsigned);
      };

      /**
       * Converts the Long to its big integer representation.
       * @this {!Long}
       * @returns {bigint}
       */
      LongPrototype.toBigInt = function toBigInt() {
        var lowBigInt = BigInt(this.low >>> 0);
        var highBigInt = BigInt(this.unsigned ? this.high >>> 0 : this.high);
        return (highBigInt << BigInt(32)) | lowBigInt;
      };
    }
    var _default = (_exports.default = Long);
  },
);


/***/ }),

/***/ "./node_modules/.pnpm/ms@3.0.0-canary.1/node_modules/ms/dist/index.cjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/.pnpm/ms@3.0.0-canary.1/node_modules/ms/dist/index.cjs ***!
  \*****************************************************************************/
/***/ ((module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// Helpers.
const s = 1000;
const m = s * 60;
const h = m * 60;
const d = h * 24;
const w = d * 7;
const y = d * 365.25;
function ms(value, options) {
    try {
        if (typeof value === 'string' && value.length > 0) {
            return parse(value);
        }
        else if (typeof value === 'number' && isFinite(value)) {
            return options?.long ? fmtLong(value) : fmtShort(value);
        }
        throw new Error('Value is not a string or number.');
    }
    catch (error) {
        const message = isError(error)
            ? `${error.message}. value=${JSON.stringify(value)}`
            : 'An unknown error has occured.';
        throw new Error(message);
    }
}
/**
 * Parse the given `str` and return milliseconds.
 */
function parse(str) {
    str = String(str);
    if (str.length > 100) {
        throw new Error('Value exceeds the maximum length of 100 characters.');
    }
    const match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
        return NaN;
    }
    const n = parseFloat(match[1]);
    const type = (match[2] || 'ms').toLowerCase();
    switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
            return n * y;
        case 'weeks':
        case 'week':
        case 'w':
            return n * w;
        case 'days':
        case 'day':
        case 'd':
            return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
            return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
            return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
            return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
            return n;
        default:
            // This should never occur.
            throw new Error(`The unit ${type} was matched, but no matching case exists.`);
    }
}
exports["default"] = ms;
/**
 * Short format for `ms`.
 */
function fmtShort(ms) {
    const msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return `${Math.round(ms / d)}d`;
    }
    if (msAbs >= h) {
        return `${Math.round(ms / h)}h`;
    }
    if (msAbs >= m) {
        return `${Math.round(ms / m)}m`;
    }
    if (msAbs >= s) {
        return `${Math.round(ms / s)}s`;
    }
    return `${ms}ms`;
}
/**
 * Long format for `ms`.
 */
function fmtLong(ms) {
    const msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
    }
    return `${ms} ms`;
}
/**
 * Pluralization helper.
 */
function plural(ms, msAbs, n, name) {
    const isPlural = msAbs >= n * 1.5;
    return `${Math.round(ms / n)} ${name}${isPlural ? 's' : ''}`;
}
/**
 * A type guard for errors.
 */
function isError(error) {
    return typeof error === 'object' && error !== null && 'message' in error;
}
module.exports = exports.default;
module.exports["default"] = exports.default;


/***/ }),

/***/ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/common/handler-error.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/common/handler-error.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HandlerErrorType = exports.HandlerError = void 0;
const symbol_instanceof_1 = __webpack_require__(/*! ../internal/symbol-instanceof */ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/internal/symbol-instanceof.js");
/**
 * A Nexus handler error.
 *
 * This error class represents an error that occurred during the handling of a
 * Nexus operation that should be reported to the caller as a handler error.
 *
 * Example:
 *
 * ```ts
 *     import { HandlerError } from "nexus-rpc";
 *
 *     // Throw a bad request error
 *     throw new HandlerError("BAD_REQUEST", "Invalid input provided");
 *
 *     // Throw a bad request error, with a cause
 *     throw new HandlerError("BAD_REQUEST", "Invalid input provided", { cause });
 *
 *     // Throw a retryable internal error
 *     throw new HandlerError("INTERNAL", "Database unavailable", { retryableOverride: true });
 * ```
 *
 * @experimental
 */
class HandlerError extends Error {
    /**
     * One of the predefined error types.
     *
     * @see {@link HandlerErrorType}
     */
    type;
    /**
     * Whether this error should be considered retryable.
     *
     * By default, the retry behavior is determined from the error type.
     * For example, by default, `INTERNAL` is retryable, but `UNAVAILABLE` is non-retryable.
     *
     * If specified, `retryableOverride` overrides the default retry behavior determined based on
     * the error type. Use {@link retryable} to determine the effective retry behavior.
     *
     * @see {@link retryable}.
     */
    retryableOverride;
    /**
     * Constructs a new {@link HandlerError}.
     *
     * @param type - The type of the error.
     * @param message - The message of the error.
     * @param options - Extra options for the error, including the cause and retryable override.
     *
     * @experimental
     */
    constructor(type, message, options) {
        const actualMessage = message || `Handler error: ${type}`;
        super(actualMessage, { cause: options?.cause });
        this.type = type;
        this.retryableOverride = options?.retryableOverride;
    }
    /**
     * Whether this error is retryable.
     *
     * This differs from the {@link retryableOverride} property in that `retryable` takes into
     * account the default behavior resulting from the error type, if no override is provided.
     *
     * @see {@link retryableOverride}.
     */
    get retryable() {
        if (typeof this.retryableOverride === "boolean")
            return this.retryableOverride;
        switch (this.type) {
            case "BAD_REQUEST":
            case "UNAUTHENTICATED":
            case "UNAUTHORIZED":
            case "NOT_FOUND":
            case "NOT_IMPLEMENTED":
                return false;
            case "UNAVAILABLE":
            case "UPSTREAM_TIMEOUT":
            case "RESOURCE_EXHAUSTED":
            case "INTERNAL":
                return true;
            default: {
                // Force a compile time error if missing a case
                const _noMissingCase = this.type;
                return true;
            }
        }
    }
}
exports.HandlerError = HandlerError;
(0, symbol_instanceof_1.injectSymbolBasedInstanceOf)(HandlerError, "HandlerError");
exports.HandlerErrorType = {
    /**
     * The handler cannot or will not process the request due to an apparent client error.
     *
     * Clients should not retry this request unless advised otherwise.
     */
    BAD_REQUEST: "BAD_REQUEST",
    /**
     * The client did not supply valid authentication credentials for this request.
     *
     * Clients should not retry this request unless advised otherwise.
     */
    UNAUTHENTICATED: "UNAUTHENTICATED",
    /**
     * The caller does not have permission to execute the specified operation.
     *
     * Clients should not retry this request unless advised otherwise.
     */
    UNAUTHORIZED: "UNAUTHORIZED",
    /**
     * The requested resource could not be found but may be available in the future.
     */
    NOT_FOUND: "NOT_FOUND",
    /**
     * Some resource has been exhausted, perhaps a per-user quota, or perhaps the entire file system
     * is out of space.
     *
     * Subsequent requests by the client are permissible.
     */
    RESOURCE_EXHAUSTED: "RESOURCE_EXHAUSTED",
    /**
     * An internal error occured.
     *
     * Subsequent requests by the client are permissible.
     */
    INTERNAL: "INTERNAL",
    /**
     * The server either does not recognize the request method, or it lacks the ability to fulfill the
     * request. Clients should not retry this request unless advised otherwise.
     */
    NOT_IMPLEMENTED: "NOT_IMPLEMENTED",
    /**
     * The service is currently unavailable.
     *
     * Subsequent requests by the client are permissible.
     */
    UNAVAILABLE: "UNAVAILABLE",
    /**
     * Used by gateways to report that a request to an upstream server has timed out.
     *
     * Subsequent requests by the client are permissible.
     */
    UPSTREAM_TIMEOUT: "UPSTREAM_TIMEOUT",
};


/***/ }),

/***/ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/common/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/common/index.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OperationStillRunningError = exports.OperationError = exports.HandlerError = void 0;
var handler_error_1 = __webpack_require__(/*! ./handler-error */ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/common/handler-error.js");
Object.defineProperty(exports, "HandlerError", ({ enumerable: true, get: function () { return handler_error_1.HandlerError; } }));
var operation_error_1 = __webpack_require__(/*! ./operation-error */ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/common/operation-error.js");
Object.defineProperty(exports, "OperationError", ({ enumerable: true, get: function () { return operation_error_1.OperationError; } }));
var operation_still_running_error_1 = __webpack_require__(/*! ./operation-still-running-error */ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/common/operation-still-running-error.js");
Object.defineProperty(exports, "OperationStillRunningError", ({ enumerable: true, get: function () { return operation_still_running_error_1.OperationStillRunningError; } }));


/***/ }),

/***/ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/common/operation-error.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/common/operation-error.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OperationError = void 0;
const symbol_instanceof_1 = __webpack_require__(/*! ../internal/symbol-instanceof */ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/internal/symbol-instanceof.js");
/**
 * A Nexus operation error.
 *
 * This error class represents the abnormal completion of a Nexus operation,
 * that should be reported to the caller as an operation error.
 *
 * Example:
 *
 * ```ts
 *     import { OperationError } from "nexus-rpc";
 *
 *     // Throw a failed operation error
 *     throw new OperationError("failed", "Not enough inventory");
 *
 *     // Throw a failed operation error, with a cause
 *     throw new OperationError("failed", "Not enough inventory", { cause });
 *
 *     // Throw a canceled operation error
 *     throw new OperationError("canceled", "User canceled the operation");
 * ```
 *
 * @experimental
 */
class OperationError extends Error {
    /**
     * State of the operation.
     */
    state;
    /**
     * Constructs a new {@link OperationError}.
     *
     * @param state - The state of the operation.
     * @param message - The message of the error.
     * @param options - Extra options for the error, e.g. the cause.
     *
     * @experimental
     */
    constructor(state, message, options) {
        const defaultMessage = state === "canceled" ? `Operation canceled` : `Operation failed`;
        const actualMessage = message || defaultMessage;
        super(actualMessage, { cause: options?.cause });
        this.state = state;
    }
}
exports.OperationError = OperationError;
(0, symbol_instanceof_1.injectSymbolBasedInstanceOf)(OperationError, "OperationError");


/***/ }),

/***/ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/common/operation-still-running-error.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/common/operation-still-running-error.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OperationStillRunningError = void 0;
const symbol_instanceof_1 = __webpack_require__(/*! ../internal/symbol-instanceof */ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/internal/symbol-instanceof.js");
/**
 * An operation result was requested, but the operation is still running.
 *
 * @experimental
 */
class OperationStillRunningError extends Error {
    /**
     * Construct a new {@link OperationStillRunningError}.
     *
     * @experimental
     */
    constructor() {
        super("Operation still running");
    }
}
exports.OperationStillRunningError = OperationStillRunningError;
(0, symbol_instanceof_1.injectSymbolBasedInstanceOf)(OperationStillRunningError, "OperationStillRunningError");


/***/ }),

/***/ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/handler/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/handler/index.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceRegistry = exports.serviceHandler = exports.ServiceHandler = exports.HandlerStartOperationResult = void 0;
var start_operation_result_1 = __webpack_require__(/*! ./start-operation-result */ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/handler/start-operation-result.js");
Object.defineProperty(exports, "HandlerStartOperationResult", ({ enumerable: true, get: function () { return start_operation_result_1.HandlerStartOperationResult; } }));
var service_handler_1 = __webpack_require__(/*! ./service-handler */ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/handler/service-handler.js");
Object.defineProperty(exports, "ServiceHandler", ({ enumerable: true, get: function () { return service_handler_1.ServiceHandler; } }));
Object.defineProperty(exports, "serviceHandler", ({ enumerable: true, get: function () { return service_handler_1.serviceHandler; } }));
var service_registry_1 = __webpack_require__(/*! ./service-registry */ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/handler/service-registry.js");
Object.defineProperty(exports, "ServiceRegistry", ({ enumerable: true, get: function () { return service_registry_1.ServiceRegistry; } }));


/***/ }),

/***/ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/handler/operation-handler.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/handler/operation-handler.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compileOperationHandler = compileOperationHandler;
const common_1 = __webpack_require__(/*! ../common */ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/common/index.js");
const start_operation_result_1 = __webpack_require__(/*! ./start-operation-result */ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/handler/start-operation-result.js");
/**
 * Compiles an operation handler into a {@link CompiledOperationHandler}. A compiled operation
 * handler is a single object that is both an operation definition and a full-fledged operation
 * handler for that operation.
 *
 * @hidden
 * @internal
 */
function compileOperationHandler(definition, handler) {
    if (handler == null) {
        throw new TypeError(`No handler registered for operation '${definition.name}' (expected property name '${definition.name}')`);
    }
    if (typeof handler === "function") {
        // Operation handler is declared using the shortcut syntax. Wrap it into a full-fledged handler.
        return {
            ...definition,
            start: async (ctx, input) => {
                return start_operation_result_1.HandlerStartOperationResult.sync(await handler(ctx, input));
            },
            getInfo: notImplemented,
            getResult: notImplemented,
            cancel: notImplemented,
        };
    }
    if (typeof handler.start !== "function") {
        throw new TypeError(`Handler for operation '${definition.name}' has no start method`);
    }
    return {
        ...definition,
        // Defensively ensure that the handler has all the required methods,
        // defaulting to throwing a not implemented error if some methods are missing.
        start: handler.start.bind(handler),
        getInfo: handler.getInfo?.bind(handler) ?? notImplemented,
        getResult: handler.getResult?.bind(handler) ?? notImplemented,
        cancel: handler.cancel?.bind(handler) ?? notImplemented,
    };
}
/**
 * @internal
 * @hidden
 */
function notImplemented() {
    throw new common_1.HandlerError("NOT_IMPLEMENTED", "Not implemented");
}


/***/ }),

/***/ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/handler/service-handler.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/handler/service-handler.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceHandler = void 0;
exports.serviceHandler = serviceHandler;
const common_1 = __webpack_require__(/*! ../common */ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/common/index.js");
const operation_handler_1 = __webpack_require__(/*! ./operation-handler */ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/handler/operation-handler.js");
/**
 * A Nexus Service implementation, that provides handlers for each of its operations.
 *
 * @experimental
 */
class ServiceHandler {
    definition;
    handlers;
    operationsMap;
    /**
     * Build a `ServiceHandler` from a service definition and a collection of operation handlers.
     *
     * There must be an operation handler for every operation in the service definition.
     *
     * @param service The service definition
     * @param handlers The collection of handlers
     * @returns The compiled service handler
     *
     * @internal
     * @hidden
     */
    static build(service, handlers) {
        const operations = new Map();
        for (const [propName, definition] of Object.entries(service.operations)) {
            const compiledOpHandler = (0, operation_handler_1.compileOperationHandler)(definition, handlers[propName]);
            const operationName = compiledOpHandler.name;
            if (operations.has(operationName)) {
                throw new TypeError(`Operation with name '${operationName}' already registered for service '${service.name}'`);
            }
            operations.set(operationName, compiledOpHandler);
        }
        return new ServiceHandler(service, handlers, operations);
    }
    constructor(definition, handlers, operationsMap) {
        this.definition = definition;
        this.handlers = handlers;
        this.operationsMap = operationsMap;
    }
    /**
     * Returns the definition and handler for a given operation.
     *
     * @param operationName
     */
    getOperationHandler(operationName) {
        const entry = this.operationsMap.get(operationName);
        if (entry == null) {
            throw new common_1.HandlerError("NOT_FOUND", `Operation handler not registered for operation '${operationName}' in service '${this.definition.name}'`);
        }
        return entry;
    }
}
exports.ServiceHandler = ServiceHandler;
/**
 * Constructs a service handler for a given service contract.
 *
 * @experimental
 */
function serviceHandler(service, handlers) {
    return ServiceHandler.build(service, handlers);
}


/***/ }),

/***/ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/handler/service-registry.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/handler/service-registry.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceRegistry = void 0;
const common_1 = __webpack_require__(/*! ../common */ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/common/index.js");
/**
 * The root Nexus handler, which dispatches Nexus requests to a collection of registered service
 * implementations.
 *
 * @experimental
 */
class ServiceRegistry {
    services;
    /**
     * Constructs a new {@link ServiceRegistry}.
     *
     * @experimental
     */
    static create(services) {
        const serviceMap = new Map();
        for (const s of services) {
            const name = s.definition.name;
            if (!name) {
                throw new TypeError("Tried to register a Nexus service with no name");
            }
            if (serviceMap.has(name)) {
                throw new TypeError(`Duplicate registration of nexus service '${name}'`);
            }
            serviceMap.set(name, s);
        }
        return new ServiceRegistry(serviceMap);
    }
    constructor(
    /**
     * Registered service handlers to which this registry dispatches requests.
     */
    services = new Map()) {
        this.services = services;
    }
    getOperationHandler(ctx) {
        const { service, operation } = ctx;
        const serviceHandler = this.services.get(service);
        if (serviceHandler == null) {
            throw new common_1.HandlerError("NOT_FOUND", `No service handler registered for service name '${service}'`);
        }
        return serviceHandler.getOperationHandler(operation);
    }
    async start(ctx, lv) {
        const handler = this.getOperationHandler(ctx);
        const input = await lv.consume();
        return await handler.start(ctx, input);
    }
    async getInfo(ctx, token) {
        return await this.getOperationHandler(ctx).getInfo(ctx, token);
    }
    async getResult(ctx, token) {
        return await this.getOperationHandler(ctx).getResult(ctx, token);
    }
    async cancel(ctx, token) {
        return await this.getOperationHandler(ctx).cancel(ctx, token);
    }
}
exports.ServiceRegistry = ServiceRegistry;


/***/ }),

/***/ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/handler/start-operation-result.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/handler/start-operation-result.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/** @import { OperationHandler } from "./operation-handler" */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HandlerStartOperationResult = void 0;
/**
 * An internal symbol, used to prevent direct implementation of interfaces.
 *
 * @hidden
 * @internal
 */
const isHandlerStartOperationResultSymbol = Symbol("__nexus_isHandlerStartOperationResult");
/**
 * The return type from the {@link OperationHandler.start} method.
 *
 * Use either {@link HandlerStartOperationResult.sync} or {@link HandlerStartOperationResult.async}
 * to create a result object. Do not implement this interface directly.
 *
 * @experimental
 */
exports.HandlerStartOperationResult = {
    /**
     * Create a result that indicates that an operation has been accepted and will complete asynchronously.
     */
    async(token) {
        return {
            isAsync: true,
            token,
            [isHandlerStartOperationResultSymbol]: true,
        };
    },
    /**
     * Create a result that indicates that an operation completed successfully.
     */
    sync(value) {
        return {
            isAsync: false,
            value,
            [isHandlerStartOperationResultSymbol]: true,
        };
    },
    [Symbol.hasInstance]: function (value) {
        return (typeof value === "object" &&
            value !== null &&
            value[isHandlerStartOperationResultSymbol] === true);
    },
};


/***/ }),

/***/ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/index.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./common */ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/common/index.js"), exports);
__exportStar(__webpack_require__(/*! ./service */ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/service/index.js"), exports);
__exportStar(__webpack_require__(/*! ./handler */ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/handler/index.js"), exports);
__exportStar(__webpack_require__(/*! ./serialization */ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/serialization/index.js"), exports);


/***/ }),

/***/ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/internal/object-utils.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/internal/object-utils.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapKeyValues = mapKeyValues;
/**
 * Creates a new object by mapping all string properties (keys and values) of an existing object
 * through a mapper function.
 *
 * @param obj - The source object, whose properties will be mapped.
 * @param fn - The mapper function.
 *
 * @returns A new object with the properties mapped to the new type.
 *
 * @internal
 * @hidden
 */
function mapKeyValues(obj, fn) {
    return Object.fromEntries(Object.entries(obj).map(([key, value]) => [key, fn(key, value)]));
}


/***/ }),

/***/ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/internal/symbol-instanceof.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/internal/symbol-instanceof.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.injectSymbolBasedInstanceOf = injectSymbolBasedInstanceOf;
/**
 * Inject a custom 'instanceof' handler on the given class, that works correctly across execution contexts.
 *
 * ### Details ###
 *
 * According to the EcmaScript's spec, the default behavior of JavaScript's `x instanceof Y` operator is to walk up the
 * prototype chain of object 'x', checking if any constructor in that hierarchy is _exactly the same object_ as the
 * constructor function 'Y'.
 *
 * Unfortunately, it happens in various situations that different constructor function objects get created for what
 * appears to be the very same class. This leads to surprising behavior where `instanceof` returns false though it is
 * known that the object is indeed an instance of that class. One particular case where this happens is when constructor
 * 'Y' belongs to a different realm than the constuctor with which 'x' was instantiated. Another case is when two copies
 * of the same library gets loaded in the same realm.
 *
 * In practice, this tends to cause issues when crossing the workflow-sandboxing boundary (since Node's vm module
 * really creates new execution realms), as well as when running tests using Jest (see https://github.com/jestjs/jest/issues/2549
 * for some details on that one).
 *
 * This function injects a custom 'instanceof' handler into the prototype of 'clazz', which is both cross-realm safe and
 * cross-copies-of-the-same-lib safe. It works by adding a special symbol property to the prototype of 'clazz', and then
 * checking for the presence of that symbol.
 *
 * @internal
 * @hidden
 */
function injectSymbolBasedInstanceOf(clazz, markerName) {
    // It may seem redundant to have an explicit markerName argument here. Can't we simply use the class
    // function name for that? Unfortunately, no, as the class name may get mangled if the file gets minified.
    const marker = Symbol.for(`__nexus_is${markerName}`);
    Object.defineProperty(clazz.prototype, "name", { value: markerName, enumerable: true });
    Object.defineProperty(clazz.prototype, marker, { value: true, enumerable: false });
    Object.defineProperty(clazz, Symbol.hasInstance, {
        value: function (value) {
            if (this === clazz) {
                return typeof value === "object" && value !== null && value[marker] === true;
            }
            else {
                // 'this' must be a _subclass_ of clazz that doesn't redefined [Symbol.hasInstance], so that it inherited
                // from clazz's [Symbol.hasInstance]. If we don't handle this particular situation, then
                // `x instanceof SubclassOfParent` would return true for any instance of 'Parent', which is clearly wrong.
                //
                // Ideally, it'd be preferable to avoid this case entirely, by making sure that all subclasses of 'clazz'
                // redefine [Symbol.hasInstance], but we can't enforce that. We therefore fallback to the default instanceof
                // behavior (which is NOT cross-realm safe).
                return this.prototype.isPrototypeOf(value); // eslint-disable-line no-prototype-builtins
            }
        },
    });
}


/***/ }),

/***/ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/serialization/index.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/serialization/index.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LazyValue = void 0;
var lazy_value_1 = __webpack_require__(/*! ./lazy-value */ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/serialization/lazy-value.js");
Object.defineProperty(exports, "LazyValue", ({ enumerable: true, get: function () { return lazy_value_1.LazyValue; } }));


/***/ }),

/***/ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/serialization/lazy-value.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/serialization/lazy-value.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LazyValue = void 0;
const symbol_instanceof_1 = __webpack_require__(/*! ../internal/symbol-instanceof */ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/internal/symbol-instanceof.js");
/**
 * A container for a value encoded in an underlying stream.
 * It is used to stream inputs and outputs in the various client and server APIs.
 *
 * @experimental
 */
class LazyValue {
    serializer;
    headers;
    stream;
    /**
     * @experimental
     */
    constructor(serializer, 
    /**
     * Headers that should include information on how to process the stream's content.
     * Headers constructed by the framework always have lower case keys.
     * User provided keys are considered case-insensitive by the framework.
     */
    headers, 
    /**
     * ReadableStream that contains request or response data. May be undefined for empty data.
     */
    stream) {
        this.serializer = serializer;
        this.headers = headers;
        this.stream = stream;
    }
    /**
     * Consume the underlying reader stream, deserializing via the embedded serializer.
     */
    async consume() {
        if (this.stream == null) {
            // Return a default value from the serializer.
            return this.serializer.deserialize({ headers: this.headers });
        }
        const reader = this.stream.getReader();
        const chunks = Array();
        let length = 0;
        while (true) {
            const { value, done } = await reader.read();
            if (done)
                break;
            chunks.push(value);
            length += value.length;
        }
        const data = new Uint8Array(length);
        let offset = 0;
        for (const chunk of chunks) {
            data.set(chunk, offset);
            offset += chunk.length;
        }
        return this.serializer.deserialize({ headers: this.headers, data });
    }
}
exports.LazyValue = LazyValue;
(0, symbol_instanceof_1.injectSymbolBasedInstanceOf)(LazyValue, "LazyValue");


/***/ }),

/***/ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/service/helpers.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/service/helpers.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.service = service;
exports.operation = operation;
const object_utils_1 = __webpack_require__(/*! ../internal/object-utils */ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/internal/object-utils.js");
const service_definition_1 = __webpack_require__(/*! ./service-definition */ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/service/service-definition.js");
/**
 * Construct a service definition for a collection of operations.
 *
 * @experimental
 */
function service(name, operations) {
    const service = {
        name,
        operations: (0, object_utils_1.mapKeyValues)(operations, (key, op) => ({
            ...op,
            name: op.name || key,
        })),
    };
    (0, service_definition_1.validateServiceDefinition)(service);
    return service;
}
/**
 * Construct an operation definition as part of a service contract.
 *
 * @experimental
 */
function operation(op) {
    return { ...op };
}


/***/ }),

/***/ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/service/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/service/index.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.operation = exports.service = void 0;
var helpers_1 = __webpack_require__(/*! ./helpers */ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/service/helpers.js");
Object.defineProperty(exports, "service", ({ enumerable: true, get: function () { return helpers_1.service; } }));
Object.defineProperty(exports, "operation", ({ enumerable: true, get: function () { return helpers_1.operation; } }));


/***/ }),

/***/ "./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/service/service-definition.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/nexus-rpc@0.0.1/node_modules/nexus-rpc/lib/service/service-definition.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateServiceDefinition = validateServiceDefinition;
/**
 * Confirm that a service definition is valid.
 *
 * @param service - The service definition to validate.
 *
 * @throws {TypeError} If the service definition is invalid.
 *
 * @experimental
 */
function validateServiceDefinition(service) {
    if (typeof service.name !== "string" || !service.name) {
        throw new TypeError("Service name must be a non-empty string");
    }
    const operationNames = new Set();
    for (const [propName, operation] of Object.entries(service.operations)) {
        const operationName = operation.name;
        if (typeof operationName !== "string" || !operationName) {
            throw new TypeError(`Operation name must be a non-empty string, for property '${propName}'`);
        }
        if (operationNames.has(operationName)) {
            throw new TypeError(`Duplicate operation definition for name: '${operationName}'`);
        }
        operationNames.add(operationName);
    }
}


/***/ }),

/***/ "?4181":
/*!*****************************************************!*\
  !*** __temporal_custom_failure_converter (ignored) ***!
  \*****************************************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?7d68":
/*!*****************************************************!*\
  !*** __temporal_custom_payload_converter (ignored) ***!
  \*****************************************************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = globalThis.__webpack_module_cache__;
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;
/*!*******************************************************************************************!*\
  !*** ./libs/orchestrator/src/workflows/clone/clone.workflow-autogenerated-entrypoint.cjs ***!
  \*******************************************************************************************/

const api = __webpack_require__(/*! @temporalio/workflow/lib/worker-interface.js */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/worker-interface.js");
exports.api = api;

const { overrideGlobals } = __webpack_require__(/*! @temporalio/workflow/lib/global-overrides.js */ "./node_modules/.pnpm/@temporalio+workflow@1.13.1/node_modules/@temporalio/workflow/lib/global-overrides.js");
overrideGlobals();

exports.importWorkflows = function importWorkflows() {
  return __webpack_require__(/* webpackMode: "eager" */ /*! ./libs/orchestrator/src/workflows/clone/clone.workflow.ts */ "./libs/orchestrator/src/workflows/clone/clone.workflow.ts");
}

exports.importInterceptors = function importInterceptors() {
  return [
    
  ];
}

})();

__TEMPORAL__ = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid29ya2Zsb3ctYnVuZGxlLWM3MzU4NzIxM2YwNzQwZGQxZTFiLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVEO0FBSXZELE1BQU0sRUFBRUMsYUFBYSxFQUFFQyxhQUFhLEVBQUUsR0FBR0YscUVBQWVBLENBQW9CO0lBQzFFRyxxQkFBcUI7SUFDckJDLE9BQU87UUFDSkMsaUJBQWlCO1FBQ2pCQyxpQkFBaUI7SUFDcEI7QUFDRjtBQUdPLGVBQWVDLGtCQUNwQkMsS0FBaUI7SUFHakJDLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHNCQUFzQixFQUFFRixNQUFNRyxPQUFPLENBQUMsR0FBRyxFQUFFSCxNQUFNSSxHQUFHLENBQUMsQ0FBQztJQUVuRSxNQUFNQyxNQUFNLE1BQU1aLGNBQWNPLE1BQU1HLE9BQU8sRUFBRUgsTUFBTUksR0FBRztJQUV4REgsUUFBUUMsR0FBRyxDQUFDLENBQUMsY0FBYyxFQUFFRyxJQUFJLENBQUM7SUFFbEMsTUFBTSxFQUFFQyxJQUFJLEVBQUUsR0FBRyxNQUFNWixjQUFjTSxNQUFNRyxPQUFPLEVBQUVFO0lBRXBESixRQUFRQyxHQUFHLENBQUMsQ0FBQyxxQkFBcUIsRUFBRUksS0FBSyxDQUFDO0lBRTFDLE9BQU87UUFBRUQ7UUFBS0M7SUFBSztBQUNyQjs7Ozs7Ozs7Ozs7Ozs7O0FDWkE7O0dBRUc7QUFDSCxNQUFhLDJCQUEyQjtJQUM3QixRQUFRLENBQVU7SUFDbEIsZUFBZSxDQUFVO0lBQ3pCLE1BQU0sQ0FBVTtJQUNoQixRQUFRLENBQVU7SUFDbEIsY0FBYyxDQUFVO0lBQ3hCLEtBQUssQ0FBVTtJQUV4QixZQUFtQixVQUE4QyxFQUFFO1FBQ2pFLElBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDLFFBQVEsSUFBSSxLQUFLLENBQUM7UUFDMUMsSUFBSSxDQUFDLGVBQWUsR0FBRyxPQUFPLENBQUMsZUFBZSxJQUFJLEtBQUssQ0FBQztRQUN4RCxJQUFJLENBQUMsTUFBTSxHQUFHLE9BQU8sQ0FBQyxNQUFNLElB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RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFF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O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQjtBQUNqQjtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O1VBQ0E7Ozs7O1dDdEJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxpQ0FBaUMsV0FBVztXQUM1QztXQUNBLEU7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQSxFOzs7OztXQ1BBLHdGOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RCxFOzs7Ozs7Ozs7Ozs7QUNMQSxZQUFZLG1CQUFPLENBQUMsZ0tBQThDO0FBQ2xFLFdBQVc7O0FBRVgsUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLGdLQUE4QztBQUNsRjs7QUFFQSx1QkFBdUI7QUFDdkIsU0FBUyxtQkFBTyw0QkFBNEIsNEhBQWtGO0FBQzlIOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL2xpYnMvb3JjaGVzdHJhdG9yL3NyYy93b3JrZmxvd3MvY2xvbmUvY2xvbmUud29ya2Zsb3cudHMiLCIvaG9tZS9tb2hhbWVkL3Byb2plY3QtMTEvbm9kZV9tb2R1bGVzLy5wbnBtL0B0ZW1wb3JhbGlvK2NvbW1vbkAxLjEzLjEvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9zcmMvYWN0aXZpdHktY2FuY2VsbGF0aW9uLWRldGFpbHMudHMiLCIvaG9tZS9tb2hhbWVkL3Byb2plY3QtMTEvbm9kZV9tb2R1bGVzLy5wbnBtL0B0ZW1wb3JhbGlvK2NvbW1vbkAxLjEzLjEvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9zcmMvYWN0aXZpdHktb3B0aW9ucy50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vQHRlbXBvcmFsaW8rY29tbW9uQDEuMTMuMS9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy9jb252ZXJ0ZXIvZGF0YS1jb252ZXJ0ZXIudHMiLCIvaG9tZS9tb2hhbWVkL3Byb2plY3QtMTEvbm9kZV9tb2R1bGVzLy5wbnBtL0B0ZW1wb3JhbGlvK2NvbW1vbkAxLjEzLjEvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9zcmMvY29udmVydGVyL2ZhaWx1cmUtY29udmVydGVyLnRzIiwiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9AdGVtcG9yYWxpbytjb21tb25AMS4xMy4xL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL2NvbnZlcnRlci9wYXlsb2FkLWNvZGVjLnRzIiwiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9AdGVtcG9yYWxpbytjb21tb25AMS4xMy4xL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL2NvbnZlcnRlci9wYXlsb2FkLWNvbnZlcnRlci50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vQHRlbXBvcmFsaW8rY29tbW9uQDEuMTMuMS9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy9jb252ZXJ0ZXIvcGF5bG9hZC1zZWFyY2gtYXR0cmlidXRlcy50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vQHRlbXBvcmFsaW8rY29tbW9uQDEuMTMuMS9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy9jb252ZXJ0ZXIvdHlwZXMudHMiLCIvaG9tZS9tb2hhbWVkL3Byb2plY3QtMTEvbm9kZV9tb2R1bGVzLy5wbnBtL0B0ZW1wb3JhbGlvK2NvbW1vbkAxLjEzLjEvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9zcmMvZGVwcmVjYXRlZC10aW1lLnRzIiwiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9AdGVtcG9yYWxpbytjb21tb25AMS4xMy4xL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL2VuY29kaW5nLnRzIiwiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9AdGVtcG9yYWxpbytjb21tb25AMS4xMy4xL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL2Vycm9ycy50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vQHRlbXBvcmFsaW8rY29tbW9uQDEuMTMuMS9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy9mYWlsdXJlLnRzIiwiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9AdGVtcG9yYWxpbytjb21tb25AMS4xMy4xL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL2luZGV4LnRzIiwiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9AdGVtcG9yYWxpbytjb21tb25AMS4xMy4xL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL2ludGVyY2VwdG9ycy50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vQHRlbXBvcmFsaW8rY29tbW9uQDEuMTMuMS9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy9pbnRlcmZhY2VzLnRzIiwiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9AdGVtcG9yYWxpbytjb21tb25AMS4xMy4xL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL2ludGVybmFsLXdvcmtmbG93L2VudW1zLWhlbHBlcnMudHMiLCIvaG9tZS9tb2hhbWVkL3Byb2plY3QtMTEvbm9kZV9tb2R1bGVzLy5wbnBtL0B0ZW1wb3JhbGlvK2NvbW1vbkAxLjEzLjEvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9zcmMvaW50ZXJuYWwtd29ya2Zsb3cvaW5kZXgudHMiLCIvaG9tZS9tb2hhbWVkL3Byb2plY3QtMTEvbm9kZV9tb2R1bGVzLy5wbnBtL0B0ZW1wb3JhbGlvK2NvbW1vbkAxLjEzLjEvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9zcmMvaW50ZXJuYWwtd29ya2Zsb3cvb2JqZWN0cy1oZWxwZXJzLnRzIiwiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9AdGVtcG9yYWxpbytjb21tb25AMS4xMy4xL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL2xvZ2dlci50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vQHRlbXBvcmFsaW8rY29tbW9uQDEuMTMuMS9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy9tZXRyaWNzLnRzIiwiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9AdGVtcG9yYWxpbytjb21tb25AMS4xMy4xL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL3ByaW9yaXR5LnRzIiwiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9AdGVtcG9yYWxpbytjb21tb25AMS4xMy4xL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL3Jlc2VydmVkLnRzIiwiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9AdGVtcG9yYWxpbytjb21tb25AMS4xMy4xL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL3JldHJ5LXBvbGljeS50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vQHRlbXBvcmFsaW8rY29tbW9uQDEuMTMuMS9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy9zZWFyY2gtYXR0cmlidXRlcy50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vQHRlbXBvcmFsaW8rY29tbW9uQDEuMTMuMS9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy90aW1lLnRzIiwiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9AdGVtcG9yYWxpbytjb21tb25AMS4xMy4xL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL3R5cGUtaGVscGVycy50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vQHRlbXBvcmFsaW8rY29tbW9uQDEuMTMuMS9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy91c2VyLW1ldGFkYXRhLnRzIiwiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9AdGVtcG9yYWxpbytjb21tb25AMS4xMy4xL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL3ZlcnNpb25pbmctaW50ZW50LWVudW0udHMiLCIvaG9tZS9tb2hhbWVkL3Byb2plY3QtMTEvbm9kZV9tb2R1bGVzLy5wbnBtL0B0ZW1wb3JhbGlvK2NvbW1vbkAxLjEzLjEvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9zcmMvdmVyc2lvbmluZy1pbnRlbnQudHMiLCIvaG9tZS9tb2hhbWVkL3Byb2plY3QtMTEvbm9kZV9tb2R1bGVzLy5wbnBtL0B0ZW1wb3JhbGlvK2NvbW1vbkAxLjEzLjEvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9zcmMvd29ya2VyLWRlcGxveW1lbnRzLnRzIiwiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9AdGVtcG9yYWxpbytjb21tb25AMS4xMy4xL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby9jb21tb24vc3JjL3dvcmtmbG93LWRlZmluaXRpb24tb3B0aW9ucy50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vQHRlbXBvcmFsaW8rY29tbW9uQDEuMTMuMS9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vY29tbW9uL3NyYy93b3JrZmxvdy1oYW5kbGUudHMiLCIvaG9tZS9tb2hhbWVkL3Byb2plY3QtMTEvbm9kZV9tb2R1bGVzLy5wbnBtL0B0ZW1wb3JhbGlvK2NvbW1vbkAxLjEzLjEvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL2NvbW1vbi9zcmMvd29ya2Zsb3ctb3B0aW9ucy50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vQHRlbXBvcmFsaW8rd29ya2Zsb3dAMS4xMy4xL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9zcmMvYWxlYS50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vQHRlbXBvcmFsaW8rd29ya2Zsb3dAMS4xMy4xL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9zcmMvY2FuY2VsbGF0aW9uLXNjb3BlLnRzIiwiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9AdGVtcG9yYWxpbyt3b3JrZmxvd0AxLjEzLjEvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L3NyYy9lcnJvcnMudHMiLCIvaG9tZS9tb2hhbWVkL3Byb2plY3QtMTEvbm9kZV9tb2R1bGVzLy5wbnBtL0B0ZW1wb3JhbGlvK3dvcmtmbG93QDEuMTMuMS9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvc3JjL2ZsYWdzLnRzIiwiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9AdGVtcG9yYWxpbyt3b3JrZmxvd0AxLjEzLjEvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L3NyYy9nbG9iYWwtYXR0cmlidXRlcy50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vQHRlbXBvcmFsaW8rd29ya2Zsb3dAMS4xMy4xL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9zcmMvZ2xvYmFsLW92ZXJyaWRlcy50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vQHRlbXBvcmFsaW8rd29ya2Zsb3dAMS4xMy4xL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9zcmMvaW5kZXgudHMiLCIvaG9tZS9tb2hhbWVkL3Byb2plY3QtMTEvbm9kZV9tb2R1bGVzLy5wbnBtL0B0ZW1wb3JhbGlvK3dvcmtmbG93QDEuMTMuMS9ub2RlX21vZHVsZXMvQHRlbXBvcmFsaW8vd29ya2Zsb3cvc3JjL2ludGVyY2VwdG9ycy50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vQHRlbXBvcmFsaW8rd29ya2Zsb3dAMS4xMy4xL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9zcmMvaW50ZXJmYWNlcy50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vQHRlbXBvcmFsaW8rd29ya2Zsb3dAMS4xMy4xL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9zcmMvaW50ZXJuYWxzLnRzIiwiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9AdGVtcG9yYWxpbyt3b3JrZmxvd0AxLjEzLjEvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L3NyYy9sb2dzLnRzIiwiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9AdGVtcG9yYWxpbyt3b3JrZmxvd0AxLjEzLjEvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L3NyYy9tZXRyaWNzLnRzIiwiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9AdGVtcG9yYWxpbyt3b3JrZmxvd0AxLjEzLjEvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L3NyYy9uZXh1cy50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vQHRlbXBvcmFsaW8rd29ya2Zsb3dAMS4xMy4xL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9zcmMvcGtnLnRzIiwiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9AdGVtcG9yYWxpbyt3b3JrZmxvd0AxLjEzLjEvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L3NyYy9zaW5rcy50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vQHRlbXBvcmFsaW8rd29ya2Zsb3dAMS4xMy4xL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9zcmMvc3RhY2staGVscGVycy50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vQHRlbXBvcmFsaW8rd29ya2Zsb3dAMS4xMy4xL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9zcmMvdHJpZ2dlci50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vQHRlbXBvcmFsaW8rd29ya2Zsb3dAMS4xMy4xL25vZGVfbW9kdWxlcy9AdGVtcG9yYWxpby93b3JrZmxvdy9zcmMvdXBkYXRlLXNjb3BlLnRzIiwiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9AdGVtcG9yYWxpbyt3b3JrZmxvd0AxLjEzLjEvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L3NyYy93b3JrZXItaW50ZXJmYWNlLnRzIiwiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9AdGVtcG9yYWxpbyt3b3JrZmxvd0AxLjEzLjEvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L3NyYy93b3JrZmxvdy50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vbG9uZ0A1LjMuMi9ub2RlX21vZHVsZXMvbG9uZy91bWQvaW5kZXguanMiLCIvaG9tZS9tb2hhbWVkL3Byb2plY3QtMTEvbm9kZV9tb2R1bGVzLy5wbnBtL21zQDMuMC4wLWNhbmFyeS4xL25vZGVfbW9kdWxlcy9tcy9kaXN0L2luZGV4LmNqcyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vbmV4dXMtcnBjQDAuMC4xL25vZGVfbW9kdWxlcy9uZXh1cy1ycGMvc3JjL2NvbW1vbi9oYW5kbGVyLWVycm9yLnRzIiwiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh1cy1ycGNAMC4wLjEvbm9kZV9tb2R1bGVzL25leHVzLXJwYy9zcmMvY29tbW9uL2luZGV4LnRzIiwiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh1cy1ycGNAMC4wLjEvbm9kZV9tb2R1bGVzL25leHVzLXJwYy9zcmMvY29tbW9uL29wZXJhdGlvbi1lcnJvci50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vbmV4dXMtcnBjQDAuMC4xL25vZGVfbW9kdWxlcy9uZXh1cy1ycGMvc3JjL2NvbW1vbi9vcGVyYXRpb24tc3RpbGwtcnVubmluZy1lcnJvci50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vbmV4dXMtcnBjQDAuMC4xL25vZGVfbW9kdWxlcy9uZXh1cy1ycGMvc3JjL2hhbmRsZXIvaW5kZXgudHMiLCIvaG9tZS9tb2hhbWVkL3Byb2plY3QtMTEvbm9kZV9tb2R1bGVzLy5wbnBtL25leHVzLXJwY0AwLjAuMS9ub2RlX21vZHVsZXMvbmV4dXMtcnBjL3NyYy9oYW5kbGVyL29wZXJhdGlvbi1oYW5kbGVyLnRzIiwiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh1cy1ycGNAMC4wLjEvbm9kZV9tb2R1bGVzL25leHVzLXJwYy9zcmMvaGFuZGxlci9zZXJ2aWNlLWhhbmRsZXIudHMiLCIvaG9tZS9tb2hhbWVkL3Byb2plY3QtMTEvbm9kZV9tb2R1bGVzLy5wbnBtL25leHVzLXJwY0AwLjAuMS9ub2RlX21vZHVsZXMvbmV4dXMtcnBjL3NyYy9oYW5kbGVyL3NlcnZpY2UtcmVnaXN0cnkudHMiLCIvaG9tZS9tb2hhbWVkL3Byb2plY3QtMTEvbm9kZV9tb2R1bGVzLy5wbnBtL25leHVzLXJwY0AwLjAuMS9ub2RlX21vZHVsZXMvbmV4dXMtcnBjL3NyYy9oYW5kbGVyL3N0YXJ0LW9wZXJhdGlvbi1yZXN1bHQudHMiLCIvaG9tZS9tb2hhbWVkL3Byb2plY3QtMTEvbm9kZV9tb2R1bGVzLy5wbnBtL25leHVzLXJwY0AwLjAuMS9ub2RlX21vZHVsZXMvbmV4dXMtcnBjL3NyYy9pbmRleC50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vbmV4dXMtcnBjQDAuMC4xL25vZGVfbW9kdWxlcy9uZXh1cy1ycGMvc3JjL2ludGVybmFsL29iamVjdC11dGlscy50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vbmV4dXMtcnBjQDAuMC4xL25vZGVfbW9kdWxlcy9uZXh1cy1ycGMvc3JjL2ludGVybmFsL3N5bWJvbC1pbnN0YW5jZW9mLnRzIiwiL2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh1cy1ycGNAMC4wLjEvbm9kZV9tb2R1bGVzL25leHVzLXJwYy9zcmMvc2VyaWFsaXphdGlvbi9pbmRleC50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vbmV4dXMtcnBjQDAuMC4xL25vZGVfbW9kdWxlcy9uZXh1cy1ycGMvc3JjL3NlcmlhbGl6YXRpb24vbGF6eS12YWx1ZS50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vbmV4dXMtcnBjQDAuMC4xL25vZGVfbW9kdWxlcy9uZXh1cy1ycGMvc3JjL3NlcnZpY2UvaGVscGVycy50cyIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9ub2RlX21vZHVsZXMvLnBucG0vbmV4dXMtcnBjQDAuMC4xL25vZGVfbW9kdWxlcy9uZXh1cy1ycGMvc3JjL3NlcnZpY2UvaW5kZXgudHMiLCIvaG9tZS9tb2hhbWVkL3Byb2plY3QtMTEvbm9kZV9tb2R1bGVzLy5wbnBtL25leHVzLXJwY0AwLjAuMS9ub2RlX21vZHVsZXMvbmV4dXMtcnBjL3NyYy9zZXJ2aWNlL3NlcnZpY2UtZGVmaW5pdGlvbi50cyIsImlnbm9yZWR8L2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9AdGVtcG9yYWxpbyt3b3JrZmxvd0AxLjEzLjEvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L2xpYnxfX3RlbXBvcmFsX2N1c3RvbV9mYWlsdXJlX2NvbnZlcnRlciIsImlnbm9yZWR8L2hvbWUvbW9oYW1lZC9wcm9qZWN0LTExL25vZGVfbW9kdWxlcy8ucG5wbS9AdGVtcG9yYWxpbyt3b3JrZmxvd0AxLjEzLjEvbm9kZV9tb2R1bGVzL0B0ZW1wb3JhbGlvL3dvcmtmbG93L2xpYnxfX3RlbXBvcmFsX2N1c3RvbV9wYXlsb2FkX2NvbnZlcnRlciIsIndlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIi9ob21lL21vaGFtZWQvcHJvamVjdC0xMS9saWJzL29yY2hlc3RyYXRvci9zcmMvd29ya2Zsb3dzL2Nsb25lL2Nsb25lLndvcmtmbG93LWF1dG9nZW5lcmF0ZWQtZW50cnlwb2ludC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcHJveHlBY3Rpdml0aWVzIH0gZnJvbSBcIkB0ZW1wb3JhbGlvL3dvcmtmbG93XCI7XG4gaW1wb3J0IHR5cGUgeyBjbG9uZUlucHV0LCBjbG9uZVJlc3VsdCB9IGZyb20gXCIuL2Nsb25lLnR5cGVzLnRzXCI7XG5cbmltcG9ydCAqIGFzIGFjdGl2aXRpZXMgZnJvbSBcIi4vY2xvbmUuYWN0aXZpdGllc1wiO1xuY29uc3QgeyByZXNvbHZlQ29tbWl0LCBmZXRjaFNuYXBzaG90IH0gPSBwcm94eUFjdGl2aXRpZXM8dHlwZW9mIGFjdGl2aXRpZXM+KHtcbiAgc3RhcnRUb0Nsb3NlVGltZW91dDogXCI1IG1pbnV0ZVwiLCBcbiAgcmV0cnk6IHsgXG4gICAgIG1heGltdW1BdHRlbXB0czogMyxcbiAgICAgaW5pdGlhbEludGVydmFsOiBcIjJzXCIgXG4gIH1cbn0pO1xuXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjbG9uZVJlcG9Xb3JrZmxvdyhcbiAgaW5wdXQ6IGNsb25lSW5wdXRcbik6IFByb21pc2U8Y2xvbmVSZXN1bHQ+IHtcblxuICBjb25zb2xlLmxvZyhgU3RhcnRpbmcgd29ya2Zsb3cgZm9yICR7aW5wdXQucmVwb1VybH0gQCAke2lucHV0LnJlZn1gKTtcblxuICBjb25zdCBzaGEgPSBhd2FpdCByZXNvbHZlQ29tbWl0KGlucHV0LnJlcG9VcmwsIGlucHV0LnJlZik7XG5cbiAgY29uc29sZS5sb2coYFJlc29sdmVkIFNIQTogJHtzaGF9YCk7XG5cbiAgY29uc3QgeyBwYXRoIH0gPSBhd2FpdCBmZXRjaFNuYXBzaG90KGlucHV0LnJlcG9VcmwsIHNoYSk7XG5cbiAgY29uc29sZS5sb2coYFNuYXBzaG90IGZldGNoZWQgdG86ICR7cGF0aH1gKTtcblxuICByZXR1cm4geyBzaGEsIHBhdGggfTtcbn0iLCJpbXBvcnQgdHlwZSB7IGNvcmVzZGsgfSBmcm9tICdAdGVtcG9yYWxpby9wcm90byc7XG5cbi8vIHRzLXBydW5lLWlnbm9yZS1uZXh0XG5leHBvcnQgaW50ZXJmYWNlIEFjdGl2aXR5Q2FuY2VsbGF0aW9uRGV0YWlsc0hvbGRlciB7XG4gIGRldGFpbHM/OiBBY3Rpdml0eUNhbmNlbGxhdGlvbkRldGFpbHM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWN0aXZpdHlDYW5jZWxsYXRpb25EZXRhaWxzT3B0aW9ucyB7XG4gIG5vdEZvdW5kPzogYm9vbGVhbjtcbiAgY2FuY2VsUmVxdWVzdGVkPzogYm9vbGVhbjtcbiAgcGF1c2VkPzogYm9vbGVhbjtcbiAgdGltZWRPdXQ/OiBib29sZWFuO1xuICB3b3JrZXJTaHV0ZG93bj86IGJvb2xlYW47XG4gIHJlc2V0PzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyB0aGUgcmVhc29ucyBmb3IgdGhlIGFjdGl2aXR5J3MgY2FuY2VsbGF0aW9uLiBDYW5jZWxsYXRpb24gZGV0YWlscyBhcmUgc2V0IG9uY2UgYW5kIGRvIG5vdCBjaGFuZ2Ugb25jZSBzZXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBBY3Rpdml0eUNhbmNlbGxhdGlvbkRldGFpbHMge1xuICByZWFkb25seSBub3RGb3VuZDogYm9vbGVhbjtcbiAgcmVhZG9ubHkgY2FuY2VsUmVxdWVzdGVkOiBib29sZWFuO1xuICByZWFkb25seSBwYXVzZWQ6IGJvb2xlYW47XG4gIHJlYWRvbmx5IHRpbWVkT3V0OiBib29sZWFuO1xuICByZWFkb25seSB3b3JrZXJTaHV0ZG93bjogYm9vbGVhbjtcbiAgcmVhZG9ubHkgcmVzZXQ6IGJvb2xlYW47XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKG9wdGlvbnM6IEFjdGl2aXR5Q2FuY2VsbGF0aW9uRGV0YWlsc09wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMubm90Rm91bmQgPSBvcHRpb25zLm5vdEZvdW5kID8/IGZhbHNlO1xuICAgIHRoaXMuY2FuY2VsUmVxdWVzdGVkID0gb3B0aW9ucy5jYW5jZWxSZXF1ZXN0ZWQgPz8gZmFsc2U7XG4gICAgdGhpcy5wYXVzZWQgPSBvcHRpb25zLnBhdXNlZCA/PyBmYWxzZTtcbiAgICB0aGlzLnRpbWVkT3V0ID0gb3B0aW9ucy50aW1lZE91dCA/PyBmYWxzZTtcbiAgICB0aGlzLndvcmtlclNodXRkb3duID0gb3B0aW9ucy53b3JrZXJTaHV0ZG93biA/PyBmYWxzZTtcbiAgICB0aGlzLnJlc2V0ID0gb3B0aW9ucy5yZXNldCA/PyBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tUHJvdG8oXG4gICAgcHJvdG86IGNvcmVzZGsuYWN0aXZpdHlfdGFzay5JQWN0aXZpdHlDYW5jZWxsYXRpb25EZXRhaWxzIHwgbnVsbCB8IHVuZGVmaW5lZFxuICApOiBBY3Rpdml0eUNhbmNlbGxhdGlvbkRldGFpbHMge1xuICAgIGlmIChwcm90byA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbmV3IEFjdGl2aXR5Q2FuY2VsbGF0aW9uRGV0YWlscygpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFjdGl2aXR5Q2FuY2VsbGF0aW9uRGV0YWlscyh7XG4gICAgICBub3RGb3VuZDogcHJvdG8uaXNOb3RGb3VuZCA/PyBmYWxzZSxcbiAgICAgIGNhbmNlbFJlcXVlc3RlZDogcHJvdG8uaXNDYW5jZWxsZWQgPz8gZmFsc2UsXG4gICAgICBwYXVzZWQ6IHByb3RvLmlzUGF1c2VkID8/IGZhbHNlLFxuICAgICAgdGltZWRPdXQ6IHByb3RvLmlzVGltZWRPdXQgPz8gZmFsc2UsXG4gICAgICB3b3JrZXJTaHV0ZG93bjogcHJvdG8uaXNXb3JrZXJTaHV0ZG93biA/PyBmYWxzZSxcbiAgICAgIHJlc2V0OiBwcm90by5pc1Jlc2V0ID8/IGZhbHNlLFxuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgdHlwZSB7IGNvcmVzZGsgfSBmcm9tICdAdGVtcG9yYWxpby9wcm90byc7XG5pbXBvcnQgeyBSZXRyeVBvbGljeSB9IGZyb20gJy4vcmV0cnktcG9saWN5JztcbmltcG9ydCB7IER1cmF0aW9uIH0gZnJvbSAnLi90aW1lJztcbmltcG9ydCB7IFZlcnNpb25pbmdJbnRlbnQgfSBmcm9tICcuL3ZlcnNpb25pbmctaW50ZW50JztcbmltcG9ydCB7IG1ha2VQcm90b0VudW1Db252ZXJ0ZXJzIH0gZnJvbSAnLi9pbnRlcm5hbC13b3JrZmxvdyc7XG5pbXBvcnQgeyBQcmlvcml0eSB9IGZyb20gJy4vcHJpb3JpdHknO1xuXG5leHBvcnQgY29uc3QgQWN0aXZpdHlDYW5jZWxsYXRpb25UeXBlID0ge1xuICBUUllfQ0FOQ0VMOiAnVFJZX0NBTkNFTCcsXG4gIFdBSVRfQ0FOQ0VMTEFUSU9OX0NPTVBMRVRFRDogJ1dBSVRfQ0FOQ0VMTEFUSU9OX0NPTVBMRVRFRCcsXG4gIEFCQU5ET046ICdBQkFORE9OJyxcbn0gYXMgY29uc3Q7XG5leHBvcnQgdHlwZSBBY3Rpdml0eUNhbmNlbGxhdGlvblR5cGUgPSAodHlwZW9mIEFjdGl2aXR5Q2FuY2VsbGF0aW9uVHlwZSlba2V5b2YgdHlwZW9mIEFjdGl2aXR5Q2FuY2VsbGF0aW9uVHlwZV07XG5cbmV4cG9ydCBjb25zdCBbZW5jb2RlQWN0aXZpdHlDYW5jZWxsYXRpb25UeXBlLCBkZWNvZGVBY3Rpdml0eUNhbmNlbGxhdGlvblR5cGVdID0gbWFrZVByb3RvRW51bUNvbnZlcnRlcnM8XG4gIGNvcmVzZGsud29ya2Zsb3dfY29tbWFuZHMuQWN0aXZpdHlDYW5jZWxsYXRpb25UeXBlLFxuICB0eXBlb2YgY29yZXNkay53b3JrZmxvd19jb21tYW5kcy5BY3Rpdml0eUNhbmNlbGxhdGlvblR5cGUsXG4gIGtleW9mIHR5cGVvZiBjb3Jlc2RrLndvcmtmbG93X2NvbW1hbmRzLkFjdGl2aXR5Q2FuY2VsbGF0aW9uVHlwZSxcbiAgdHlwZW9mIEFjdGl2aXR5Q2FuY2VsbGF0aW9uVHlwZSxcbiAgJydcbj4oXG4gIHtcbiAgICBbQWN0aXZpdHlDYW5jZWxsYXRpb25UeXBlLlRSWV9DQU5DRUxdOiAwLFxuICAgIFtBY3Rpdml0eUNhbmNlbGxhdGlvblR5cGUuV0FJVF9DQU5DRUxMQVRJT05fQ09NUExFVEVEXTogMSxcbiAgICBbQWN0aXZpdHlDYW5jZWxsYXRpb25UeXBlLkFCQU5ET05dOiAyLFxuICB9IGFzIGNvbnN0LFxuICAnJ1xuKTtcblxuLyoqXG4gKiBPcHRpb25zIGZvciByZW1vdGUgYWN0aXZpdHkgaW52b2NhdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFjdGl2aXR5T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBJZGVudGlmaWVyIHRvIHVzZSBmb3IgdHJhY2tpbmcgdGhlIGFjdGl2aXR5IGluIFdvcmtmbG93IGhpc3RvcnkuXG4gICAqIFRoZSBgYWN0aXZpdHlJZGAgY2FuIGJlIGFjY2Vzc2VkIGJ5IHRoZSBhY3Rpdml0eSBmdW5jdGlvbi5cbiAgICogRG9lcyBub3QgbmVlZCB0byBiZSB1bmlxdWUuXG4gICAqXG4gICAqIEBkZWZhdWx0IGFuIGluY3JlbWVudGFsIHNlcXVlbmNlIG51bWJlclxuICAgKi9cbiAgYWN0aXZpdHlJZD86IHN0cmluZztcblxuICAvKipcbiAgICogVGFzayBxdWV1ZSBuYW1lLlxuICAgKlxuICAgKiBAZGVmYXVsdCBjdXJyZW50IHdvcmtlciB0YXNrIHF1ZXVlXG4gICAqL1xuICB0YXNrUXVldWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEhlYXJ0YmVhdCBpbnRlcnZhbC4gQWN0aXZpdHkgbXVzdCBoZWFydGJlYXQgYmVmb3JlIHRoaXMgaW50ZXJ2YWwgcGFzc2VzIGFmdGVyIGEgbGFzdCBoZWFydGJlYXQgb3IgYWN0aXZpdHkgc3RhcnQuXG4gICAqIEBmb3JtYXQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvciB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXMgfCBtcy1mb3JtYXR0ZWQgc3RyaW5nfVxuICAgKi9cbiAgaGVhcnRiZWF0VGltZW91dD86IER1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBSZXRyeVBvbGljeSB0aGF0IGRlZmluZSBob3cgYWN0aXZpdHkgaXMgcmV0cmllZCBpbiBjYXNlIG9mIGZhaWx1cmUuIElmIHRoaXMgaXMgbm90IHNldCwgdGhlbiB0aGUgc2VydmVyLWRlZmluZWQgZGVmYXVsdCBhY3Rpdml0eSByZXRyeSBwb2xpY3kgd2lsbCBiZSB1c2VkLiBUbyBlbnN1cmUgemVybyByZXRyaWVzLCBzZXQgbWF4aW11bSBhdHRlbXB0cyB0byAxLlxuICAgKi9cbiAgcmV0cnk/OiBSZXRyeVBvbGljeTtcblxuICAvKipcbiAgICogTWF4aW11bSB0aW1lIG9mIGEgc2luZ2xlIEFjdGl2aXR5IGV4ZWN1dGlvbiBhdHRlbXB0LiBOb3RlIHRoYXQgdGhlIFRlbXBvcmFsIFNlcnZlciBkb2Vzbid0IGRldGVjdCBXb3JrZXIgcHJvY2Vzc1xuICAgKiBmYWlsdXJlcyBkaXJlY3RseTogaW5zdGVhZCwgaXQgcmVsaWVzIG9uIHRoaXMgdGltZW91dCB0byBkZXRlY3QgdGhhdCBhbiBBY3Rpdml0eSBkaWRuJ3QgY29tcGxldGUgb24gdGltZS4gVGhlcmVmb3JlLCB0aGlzXG4gICAqIHRpbWVvdXQgc2hvdWxkIGJlIGFzIHNob3J0IGFzIHRoZSBsb25nZXN0IHBvc3NpYmxlIGV4ZWN1dGlvbiBvZiB0aGUgQWN0aXZpdHkgYm9keS4gUG90ZW50aWFsbHkgbG9uZy1ydW5uaW5nXG4gICAqIEFjdGl2aXRpZXMgbXVzdCBzcGVjaWZ5IHtAbGluayBoZWFydGJlYXRUaW1lb3V0fSBhbmQgY2FsbCB7QGxpbmsgYWN0aXZpdHkuQ29udGV4dC5oZWFydGJlYXR9IHBlcmlvZGljYWxseSBmb3JcbiAgICogdGltZWx5IGZhaWx1cmUgZGV0ZWN0aW9uLlxuICAgKlxuICAgKiBFaXRoZXIgdGhpcyBvcHRpb24gb3Ige0BsaW5rIHNjaGVkdWxlVG9DbG9zZVRpbWVvdXR9IGlzIHJlcXVpcmVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCBgc2NoZWR1bGVUb0Nsb3NlVGltZW91dGAgb3IgdW5saW1pdGVkXG4gICAqIEBmb3JtYXQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvciB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXMgfCBtcy1mb3JtYXR0ZWQgc3RyaW5nfVxuICAgKi9cbiAgc3RhcnRUb0Nsb3NlVGltZW91dD86IER1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBUaW1lIHRoYXQgdGhlIEFjdGl2aXR5IFRhc2sgY2FuIHN0YXkgaW4gdGhlIFRhc2sgUXVldWUgYmVmb3JlIGl0IGlzIHBpY2tlZCB1cCBieSBhIFdvcmtlci4gRG8gbm90IHNwZWNpZnkgdGhpcyB0aW1lb3V0IHVubGVzcyB1c2luZyBob3N0LXNwZWNpZmljIFRhc2sgUXVldWVzIGZvciBBY3Rpdml0eSBUYXNrcyBhcmUgYmVpbmcgdXNlZCBmb3Igcm91dGluZy5cbiAgICogYHNjaGVkdWxlVG9TdGFydFRpbWVvdXRgIGlzIGFsd2F5cyBub24tcmV0cnlhYmxlLiBSZXRyeWluZyBhZnRlciB0aGlzIHRpbWVvdXQgZG9lc24ndCBtYWtlIHNlbnNlIGFzIGl0IHdvdWxkIGp1c3QgcHV0IHRoZSBBY3Rpdml0eSBUYXNrIGJhY2sgaW50byB0aGUgc2FtZSBUYXNrIFF1ZXVlLlxuICAgKlxuICAgKiBAZGVmYXVsdCBgc2NoZWR1bGVUb0Nsb3NlVGltZW91dGAgb3IgdW5saW1pdGVkXG4gICAqIEBmb3JtYXQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvciB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXMgfCBtcy1mb3JtYXR0ZWQgc3RyaW5nfVxuICAgKi9cbiAgc2NoZWR1bGVUb1N0YXJ0VGltZW91dD86IER1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBUb3RhbCB0aW1lIHRoYXQgYSB3b3JrZmxvdyBpcyB3aWxsaW5nIHRvIHdhaXQgZm9yIHRoZSBBY3Rpdml0eSB0byBjb21wbGV0ZS5cbiAgICogYHNjaGVkdWxlVG9DbG9zZVRpbWVvdXRgIGxpbWl0cyB0aGUgdG90YWwgdGltZSBvZiBhbiBBY3Rpdml0eSdzIGV4ZWN1dGlvbiBpbmNsdWRpbmcgcmV0cmllcyAodXNlIHtAbGluayBzdGFydFRvQ2xvc2VUaW1lb3V0fSB0byBsaW1pdCB0aGUgdGltZSBvZiBhIHNpbmdsZSBhdHRlbXB0KS5cbiAgICpcbiAgICogRWl0aGVyIHRoaXMgb3B0aW9uIG9yIHtAbGluayBzdGFydFRvQ2xvc2VUaW1lb3V0fSBpcyByZXF1aXJlZC5cbiAgICpcbiAgICogQGRlZmF1bHQgdW5saW1pdGVkXG4gICAqIEBmb3JtYXQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvciB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXMgfCBtcy1mb3JtYXR0ZWQgc3RyaW5nfVxuICAgKi9cbiAgc2NoZWR1bGVUb0Nsb3NlVGltZW91dD86IER1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoYXQgdGhlIFNESyBkb2VzIHdoZW4gdGhlIEFjdGl2aXR5IGlzIGNhbmNlbGxlZC5cbiAgICogLSBgVFJZX0NBTkNFTGAgLSBJbml0aWF0ZSBhIGNhbmNlbGxhdGlvbiByZXF1ZXN0IGFuZCBpbW1lZGlhdGVseSByZXBvcnQgY2FuY2VsbGF0aW9uIHRvIHRoZSB3b3JrZmxvdy5cbiAgICogLSBgV0FJVF9DQU5DRUxMQVRJT05fQ09NUExFVEVEYCAtIFdhaXQgZm9yIGFjdGl2aXR5IGNhbmNlbGxhdGlvbiBjb21wbGV0aW9uLiBOb3RlIHRoYXQgYWN0aXZpdHkgbXVzdCBoZWFydGJlYXQgdG8gcmVjZWl2ZSBhXG4gICAqICAgY2FuY2VsbGF0aW9uIG5vdGlmaWNhdGlvbi4gVGhpcyBjYW4gYmxvY2sgdGhlIGNhbmNlbGxhdGlvbiBmb3IgYSBsb25nIHRpbWUgaWYgYWN0aXZpdHkgZG9lc24ndFxuICAgKiAgIGhlYXJ0YmVhdCBvciBjaG9vc2VzIHRvIGlnbm9yZSB0aGUgY2FuY2VsbGF0aW9uIHJlcXVlc3QuXG4gICAqIC0gYEFCQU5ET05gIC0gRG8gbm90IHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIHRoZSBhY3Rpdml0eSBhbmQgaW1tZWRpYXRlbHkgcmVwb3J0IGNhbmNlbGxhdGlvbiB0byB0aGUgd29ya2Zsb3cuXG4gICAqL1xuICBjYW5jZWxsYXRpb25UeXBlPzogQWN0aXZpdHlDYW5jZWxsYXRpb25UeXBlO1xuXG4gIC8qKlxuICAgKiBFYWdlciBkaXNwYXRjaCBpcyBhbiBvcHRpbWl6YXRpb24gdGhhdCBpbXByb3ZlcyB0aGUgdGhyb3VnaHB1dCBhbmQgbG9hZCBvbiB0aGUgc2VydmVyIGZvciBzY2hlZHVsaW5nIEFjdGl2aXRpZXMuXG4gICAqIFdoZW4gdXNlZCwgdGhlIHNlcnZlciB3aWxsIGhhbmQgb3V0IEFjdGl2aXR5IHRhc2tzIGJhY2sgdG8gdGhlIFdvcmtlciB3aGVuIGl0IGNvbXBsZXRlcyBhIFdvcmtmbG93IHRhc2suXG4gICAqIEl0IGlzIGF2YWlsYWJsZSBmcm9tIHNlcnZlciB2ZXJzaW9uIDEuMTcgYmVoaW5kIHRoZSBgc3lzdGVtLmVuYWJsZUFjdGl2aXR5RWFnZXJFeGVjdXRpb25gIGZlYXR1cmUgZmxhZy5cbiAgICpcbiAgICogRWFnZXIgZGlzcGF0Y2ggd2lsbCBvbmx5IGJlIHVzZWQgaWYgYGFsbG93RWFnZXJEaXNwYXRjaGAgaXMgZW5hYmxlZCAodGhlIGRlZmF1bHQpIGFuZCB7QGxpbmsgdGFza1F1ZXVlfSBpcyBlaXRoZXJcbiAgICogb21pdHRlZCBvciB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCBXb3JrZmxvdy5cbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgYWxsb3dFYWdlckRpc3BhdGNoPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogV2hlbiB1c2luZyB0aGUgV29ya2VyIFZlcnNpb25pbmcgZmVhdHVyZSwgc3BlY2lmaWVzIHdoZXRoZXIgdGhpcyBBY3Rpdml0eSBzaG91bGQgcnVuIG9uIGFcbiAgICogd29ya2VyIHdpdGggYSBjb21wYXRpYmxlIEJ1aWxkIElkIG9yIG5vdC4gU2VlIHtAbGluayBWZXJzaW9uaW5nSW50ZW50fS5cbiAgICpcbiAgICogQGRlZmF1bHQgJ0NPTVBBVElCTEUnXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEluIGZhdm9yIG9mIHRoZSBuZXcgV29ya2VyIERlcGxveW1lbnQgQVBJLlxuICAgKiBAZXhwZXJpbWVudGFsIFRoZSBXb3JrZXIgVmVyc2lvbmluZyBBUEkgaXMgc3RpbGwgYmVpbmcgZGVzaWduZWQuIE1ham9yIGNoYW5nZXMgYXJlIGV4cGVjdGVkLlxuICAgKi9cbiAgdmVyc2lvbmluZ0ludGVudD86IFZlcnNpb25pbmdJbnRlbnQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cblxuICAvKipcbiAgICogQSBmaXhlZCwgc2luZ2xlLWxpbmUgc3VtbWFyeSBmb3IgdGhpcyB3b3JrZmxvdyBleGVjdXRpb24gdGhhdCBtYXkgYXBwZWFyIGluIHRoZSBVSS9DTEkuXG4gICAqIFRoaXMgY2FuIGJlIGluIHNpbmdsZS1saW5lIFRlbXBvcmFsIG1hcmtkb3duIGZvcm1hdC5cbiAgICpcbiAgICogQGV4cGVyaW1lbnRhbCBVc2VyIG1ldGFkYXRhIGlzIGEgbmV3IEFQSSBhbmQgc3VzY2VwdGlibGUgdG8gY2hhbmdlLlxuICAgKi9cbiAgc3VtbWFyeT86IHN0cmluZztcblxuICAvKipcbiAgICogUHJpb3JpdHkgb2YgdGhpcyBhY3Rpdml0eVxuICAgKi9cbiAgcHJpb3JpdHk/OiBQcmlvcml0eTtcbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBsb2NhbCBhY3Rpdml0eSBpbnZvY2F0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9jYWxBY3Rpdml0eU9wdGlvbnMge1xuICAvKipcbiAgICogUmV0cnlQb2xpY3kgdGhhdCBkZWZpbmVzIGhvdyBhbiBhY3Rpdml0eSBpcyByZXRyaWVkIGluIGNhc2Ugb2YgZmFpbHVyZS4gSWYgdGhpcyBpcyBub3Qgc2V0LCB0aGVuIHRoZSBTREstZGVmaW5lZCBkZWZhdWx0IGFjdGl2aXR5IHJldHJ5IHBvbGljeSB3aWxsIGJlIHVzZWQuXG4gICAqIE5vdGUgdGhhdCBsb2NhbCBhY3Rpdml0aWVzIGFyZSBhbHdheXMgZXhlY3V0ZWQgYXQgbGVhc3Qgb25jZSwgZXZlbiBpZiBtYXhpbXVtIGF0dGVtcHRzIGlzIHNldCB0byAxIGR1ZSB0byBXb3JrZmxvdyB0YXNrIHJldHJpZXMuXG4gICAqL1xuICByZXRyeT86IFJldHJ5UG9saWN5O1xuXG4gIC8qKlxuICAgKiBNYXhpbXVtIHRpbWUgdGhlIGxvY2FsIGFjdGl2aXR5IGlzIGFsbG93ZWQgdG8gZXhlY3V0ZSBhZnRlciB0aGUgdGFzayBpcyBkaXNwYXRjaGVkLiBUaGlzXG4gICAqIHRpbWVvdXQgaXMgYWx3YXlzIHJldHJ5YWJsZS5cbiAgICpcbiAgICogRWl0aGVyIHRoaXMgb3B0aW9uIG9yIHtAbGluayBzY2hlZHVsZVRvQ2xvc2VUaW1lb3V0fSBpcyByZXF1aXJlZC5cbiAgICogSWYgc2V0LCB0aGlzIG11c3QgYmUgPD0ge0BsaW5rIHNjaGVkdWxlVG9DbG9zZVRpbWVvdXR9LCBvdGhlcndpc2UsIGl0IHdpbGwgYmUgY2xhbXBlZCBkb3duLlxuICAgKlxuICAgKiBAZm9ybWF0IG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3Ige0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ31cbiAgICovXG4gIHN0YXJ0VG9DbG9zZVRpbWVvdXQ/OiBEdXJhdGlvbjtcblxuICAvKipcbiAgICogTGltaXRzIHRpbWUgdGhlIGxvY2FsIGFjdGl2aXR5IGNhbiBpZGxlIGludGVybmFsbHkgYmVmb3JlIGJlaW5nIGV4ZWN1dGVkLiBUaGF0IGNhbiBoYXBwZW4gaWZcbiAgICogdGhlIHdvcmtlciBpcyBjdXJyZW50bHkgYXQgbWF4IGNvbmN1cnJlbnQgbG9jYWwgYWN0aXZpdHkgZXhlY3V0aW9ucy4gVGhpcyB0aW1lb3V0IGlzIGFsd2F5c1xuICAgKiBub24gcmV0cnlhYmxlIGFzIGFsbCBhIHJldHJ5IHdvdWxkIGFjaGlldmUgaXMgdG8gcHV0IGl0IGJhY2sgaW50byB0aGUgc2FtZSBxdWV1ZS4gRGVmYXVsdHNcbiAgICogdG8ge0BsaW5rIHNjaGVkdWxlVG9DbG9zZVRpbWVvdXR9IGlmIG5vdCBzcGVjaWZpZWQgYW5kIHRoYXQgaXMgc2V0LiBNdXN0IGJlIDw9XG4gICAqIHtAbGluayBzY2hlZHVsZVRvQ2xvc2VUaW1lb3V0fSB3aGVuIHNldCwgb3RoZXJ3aXNlLCBpdCB3aWxsIGJlIGNsYW1wZWQgZG93bi5cbiAgICpcbiAgICogQGRlZmF1bHQgdW5saW1pdGVkXG4gICAqIEBmb3JtYXQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvciB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXMgfCBtcy1mb3JtYXR0ZWQgc3RyaW5nfVxuICAgKi9cbiAgc2NoZWR1bGVUb1N0YXJ0VGltZW91dD86IER1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgaG93IGxvbmcgdGhlIGNhbGxlciBpcyB3aWxsaW5nIHRvIHdhaXQgZm9yIGxvY2FsIGFjdGl2aXR5IGNvbXBsZXRpb24uIExpbWl0cyBob3dcbiAgICogbG9uZyByZXRyaWVzIHdpbGwgYmUgYXR0ZW1wdGVkLlxuICAgKlxuICAgKiBFaXRoZXIgdGhpcyBvcHRpb24gb3Ige0BsaW5rIHN0YXJ0VG9DbG9zZVRpbWVvdXR9IGlzIHJlcXVpcmVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCB1bmxpbWl0ZWRcbiAgICogQGZvcm1hdCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9yIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tcyB8IG1zLWZvcm1hdHRlZCBzdHJpbmd9XG4gICAqL1xuICBzY2hlZHVsZVRvQ2xvc2VUaW1lb3V0PzogRHVyYXRpb247XG5cbiAgLyoqXG4gICAqIElmIHRoZSBhY3Rpdml0eSBpcyByZXRyeWluZyBhbmQgYmFja29mZiB3b3VsZCBleGNlZWQgdGhpcyB2YWx1ZSwgYSBzZXJ2ZXIgc2lkZSB0aW1lciB3aWxsIGJlIHNjaGVkdWxlZCBmb3IgdGhlIG5leHQgYXR0ZW1wdC5cbiAgICogT3RoZXJ3aXNlLCBiYWNrb2ZmIHdpbGwgaGFwcGVuIGludGVybmFsbHkgaW4gdGhlIFNESy5cbiAgICpcbiAgICogQGRlZmF1bHQgMSBtaW51dGVcbiAgICogQGZvcm1hdCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9yIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tcyB8IG1zLWZvcm1hdHRlZCBzdHJpbmd9XG4gICAqKi9cbiAgbG9jYWxSZXRyeVRocmVzaG9sZD86IER1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoYXQgdGhlIFNESyBkb2VzIHdoZW4gdGhlIEFjdGl2aXR5IGlzIGNhbmNlbGxlZC5cbiAgICogLSBgVFJZX0NBTkNFTGAgLSBJbml0aWF0ZSBhIGNhbmNlbGxhdGlvbiByZXF1ZXN0IGFuZCBpbW1lZGlhdGVseSByZXBvcnQgY2FuY2VsbGF0aW9uIHRvIHRoZSB3b3JrZmxvdy5cbiAgICogLSBgV0FJVF9DQU5DRUxMQVRJT05fQ09NUExFVEVEYCAtIFdhaXQgZm9yIGFjdGl2aXR5IGNhbmNlbGxhdGlvbiBjb21wbGV0aW9uLiBOb3RlIHRoYXQgYWN0aXZpdHkgbXVzdCBoZWFydGJlYXQgdG8gcmVjZWl2ZSBhXG4gICAqICAgY2FuY2VsbGF0aW9uIG5vdGlmaWNhdGlvbi4gVGhpcyBjYW4gYmxvY2sgdGhlIGNhbmNlbGxhdGlvbiBmb3IgYSBsb25nIHRpbWUgaWYgYWN0aXZpdHkgZG9lc24ndFxuICAgKiAgIGhlYXJ0YmVhdCBvciBjaG9vc2VzIHRvIGlnbm9yZSB0aGUgY2FuY2VsbGF0aW9uIHJlcXVlc3QuXG4gICAqIC0gYEFCQU5ET05gIC0gRG8gbm90IHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIHRoZSBhY3Rpdml0eSBhbmQgaW1tZWRpYXRlbHkgcmVwb3J0IGNhbmNlbGxhdGlvbiB0byB0aGUgd29ya2Zsb3cuXG4gICAqL1xuICBjYW5jZWxsYXRpb25UeXBlPzogQWN0aXZpdHlDYW5jZWxsYXRpb25UeXBlO1xuXG4gIC8qKlxuICAgKiBBIGZpeGVkLCBzaW5nbGUtbGluZSBzdW1tYXJ5IGZvciB0aGlzIHdvcmtmbG93IGV4ZWN1dGlvbiB0aGF0IG1heSBhcHBlYXIgaW4gdGhlIFVJL0NMSS5cbiAgICogVGhpcyBjYW4gYmUgaW4gc2luZ2xlLWxpbmUgVGVtcG9yYWwgbWFya2Rvd24gZm9ybWF0LlxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsIFVzZXIgbWV0YWRhdGEgaXMgYSBuZXcgQVBJIGFuZCBzdXNjZXB0aWJsZSB0byBjaGFuZ2UuXG4gICAqL1xuICBzdW1tYXJ5Pzogc3RyaW5nO1xufVxuIiwiaW1wb3J0IHsgRGVmYXVsdEZhaWx1cmVDb252ZXJ0ZXIsIEZhaWx1cmVDb252ZXJ0ZXIgfSBmcm9tICcuL2ZhaWx1cmUtY29udmVydGVyJztcbmltcG9ydCB7IFBheWxvYWRDb2RlYyB9IGZyb20gJy4vcGF5bG9hZC1jb2RlYyc7XG5pbXBvcnQgeyBkZWZhdWx0UGF5bG9hZENvbnZlcnRlciwgUGF5bG9hZENvbnZlcnRlciB9IGZyb20gJy4vcGF5bG9hZC1jb252ZXJ0ZXInO1xuXG4vKipcbiAqIFdoZW4geW91ciBkYXRhIChhcmd1bWVudHMgYW5kIHJldHVybiB2YWx1ZXMpIGlzIHNlbnQgb3ZlciB0aGUgd2lyZSBhbmQgc3RvcmVkIGJ5IFRlbXBvcmFsIFNlcnZlciwgaXQgaXMgZW5jb2RlZCBpblxuICogYmluYXJ5IGluIGEge0BsaW5rIFBheWxvYWR9IFByb3RvYnVmIG1lc3NhZ2UuXG4gKlxuICogVGhlIGRlZmF1bHQgYERhdGFDb252ZXJ0ZXJgIHN1cHBvcnRzIGB1bmRlZmluZWRgLCBgVWludDhBcnJheWAsIGFuZCBKU09OIHNlcmlhbGl6YWJsZXMgKHNvIGlmXG4gKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSlNPTi9zdHJpbmdpZnkjZGVzY3JpcHRpb24gfCBgSlNPTi5zdHJpbmdpZnkoeW91ckFyZ09yUmV0dmFsKWB9XG4gKiB3b3JrcywgdGhlIGRlZmF1bHQgZGF0YSBjb252ZXJ0ZXIgd2lsbCB3b3JrKS4gUHJvdG9idWZzIGFyZSBzdXBwb3J0ZWQgdmlhXG4gKiB7QGxpbmsgaHR0cHM6Ly9kb2NzLnRlbXBvcmFsLmlvL3R5cGVzY3JpcHQvZGF0YS1jb252ZXJ0ZXJzI3Byb3RvYnVmcyB8IHRoaXMgQVBJfS5cbiAqXG4gKiBVc2UgYSBjdXN0b20gYERhdGFDb252ZXJ0ZXJgIHRvIGNvbnRyb2wgdGhlIGNvbnRlbnRzIG9mIHlvdXIge0BsaW5rIFBheWxvYWR9cy4gQ29tbW9uIHJlYXNvbnMgZm9yIHVzaW5nIGEgY3VzdG9tXG4gKiBgRGF0YUNvbnZlcnRlcmAgYXJlOlxuICogLSBDb252ZXJ0aW5nIHZhbHVlcyB0aGF0IGFyZSBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBkZWZhdWx0IGBEYXRhQ29udmVydGVyYCAoZm9yIGV4YW1wbGUsIGBKU09OLnN0cmluZ2lmeSgpYCBkb2Vzbid0XG4gKiAgIGhhbmRsZSBgQmlnSW50YHMsIHNvIGlmIHlvdSB3YW50IHRvIHJldHVybiBgeyB0b3RhbDogMTAwMG4gfWAgZnJvbSBhIFdvcmtmbG93LCBTaWduYWwsIG9yIEFjdGl2aXR5LCB5b3UgbmVlZCB5b3VyXG4gKiAgIG93biBgRGF0YUNvbnZlcnRlcmApLlxuICogLSBFbmNyeXB0aW5nIHZhbHVlcyB0aGF0IG1heSBjb250YWluIHByaXZhdGUgaW5mb3JtYXRpb24gdGhhdCB5b3UgZG9uJ3Qgd2FudCBzdG9yZWQgaW4gcGxhaW50ZXh0IGluIFRlbXBvcmFsIFNlcnZlcidzXG4gKiAgIGRhdGFiYXNlLlxuICogLSBDb21wcmVzc2luZyB2YWx1ZXMgdG8gcmVkdWNlIGRpc2sgb3IgbmV0d29yayB1c2FnZS5cbiAqXG4gKiBUbyB1c2UgeW91ciBjdXN0b20gYERhdGFDb252ZXJ0ZXJgLCBwcm92aWRlIGl0IHRvIHRoZSB7QGxpbmsgV29ya2Zsb3dDbGllbnR9LCB7QGxpbmsgV29ya2VyfSwgYW5kXG4gKiB7QGxpbmsgYnVuZGxlV29ya2Zsb3dDb2RlfSAoaWYgeW91IHVzZSBpdCk6XG4gKiAtIGBuZXcgV29ya2Zsb3dDbGllbnQoeyAuLi4sIGRhdGFDb252ZXJ0ZXIgfSlgXG4gKiAtIGBXb3JrZXIuY3JlYXRlKHsgLi4uLCBkYXRhQ29udmVydGVyIH0pYFxuICogLSBgYnVuZGxlV29ya2Zsb3dDb2RlKHsgLi4uLCBwYXlsb2FkQ29udmVydGVyUGF0aCB9KWBcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEYXRhQ29udmVydGVyIHtcbiAgLyoqXG4gICAqIFBhdGggb2YgYSBmaWxlIHRoYXQgaGFzIGEgYHBheWxvYWRDb252ZXJ0ZXJgIG5hbWVkIGV4cG9ydC5cbiAgICogYHBheWxvYWRDb252ZXJ0ZXJgIHNob3VsZCBiZSBhbiBvYmplY3QgdGhhdCBpbXBsZW1lbnRzIHtAbGluayBQYXlsb2FkQ29udmVydGVyfS5cbiAgICogSWYgbm8gcGF0aCBpcyBwcm92aWRlZCwge0BsaW5rIGRlZmF1bHRQYXlsb2FkQ29udmVydGVyfSBpcyB1c2VkLlxuICAgKi9cbiAgcGF5bG9hZENvbnZlcnRlclBhdGg/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFBhdGggb2YgYSBmaWxlIHRoYXQgaGFzIGEgYGZhaWx1cmVDb252ZXJ0ZXJgIG5hbWVkIGV4cG9ydC5cbiAgICogYGZhaWx1cmVDb252ZXJ0ZXJgIHNob3VsZCBiZSBhbiBvYmplY3QgdGhhdCBpbXBsZW1lbnRzIHtAbGluayBGYWlsdXJlQ29udmVydGVyfS5cbiAgICogSWYgbm8gcGF0aCBpcyBwcm92aWRlZCwge0BsaW5rIGRlZmF1bHRGYWlsdXJlQ29udmVydGVyfSBpcyB1c2VkLlxuICAgKi9cbiAgZmFpbHVyZUNvbnZlcnRlclBhdGg/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIHtAbGluayBQYXlsb2FkQ29kZWN9IGluc3RhbmNlcy5cbiAgICpcbiAgICogUGF5bG9hZHMgYXJlIGVuY29kZWQgaW4gdGhlIG9yZGVyIG9mIHRoZSBhcnJheSBhbmQgZGVjb2RlZCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuIEZvciBleGFtcGxlLCBpZiB5b3UgaGF2ZSBhXG4gICAqIGNvbXByZXNzaW9uIGNvZGVjIGFuZCBhbiBlbmNyeXB0aW9uIGNvZGVjLCB0aGVuIHlvdSB3YW50IGRhdGEgdG8gYmUgZW5jb2RlZCB3aXRoIHRoZSBjb21wcmVzc2lvbiBjb2RlYyBmaXJzdCwgc29cbiAgICogeW91J2QgZG8gYHBheWxvYWRDb2RlY3M6IFtjb21wcmVzc2lvbkNvZGVjLCBlbmNyeXB0aW9uQ29kZWNdYC5cbiAgICovXG4gIHBheWxvYWRDb2RlY3M/OiBQYXlsb2FkQ29kZWNbXTtcbn1cblxuLyoqXG4gKiBBIHtAbGluayBEYXRhQ29udmVydGVyfSB0aGF0IGhhcyBiZWVuIGxvYWRlZCB2aWEge0BsaW5rIGxvYWREYXRhQ29udmVydGVyfS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMb2FkZWREYXRhQ29udmVydGVyIHtcbiAgcGF5bG9hZENvbnZlcnRlcjogUGF5bG9hZENvbnZlcnRlcjtcbiAgZmFpbHVyZUNvbnZlcnRlcjogRmFpbHVyZUNvbnZlcnRlcjtcbiAgcGF5bG9hZENvZGVjczogUGF5bG9hZENvZGVjW107XG59XG5cbi8qKlxuICogVGhlIGRlZmF1bHQge0BsaW5rIEZhaWx1cmVDb252ZXJ0ZXJ9IHVzZWQgYnkgdGhlIFNESy5cbiAqXG4gKiBFcnJvciBtZXNzYWdlcyBhbmQgc3RhY2sgdHJhY2VzIGFyZSBzZXJpemFsaXplZCBhcyBwbGFpbiB0ZXh0LlxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdEZhaWx1cmVDb252ZXJ0ZXI6IEZhaWx1cmVDb252ZXJ0ZXIgPSBuZXcgRGVmYXVsdEZhaWx1cmVDb252ZXJ0ZXIoKTtcblxuLyoqXG4gKiBBIFwibG9hZGVkXCIgZGF0YSBjb252ZXJ0ZXIgdGhhdCB1c2VzIHRoZSBkZWZhdWx0IHNldCBvZiBmYWlsdXJlIGFuZCBwYXlsb2FkIGNvbnZlcnRlcnMuXG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0RGF0YUNvbnZlcnRlcjogTG9hZGVkRGF0YUNvbnZlcnRlciA9IHtcbiAgcGF5bG9hZENvbnZlcnRlcjogZGVmYXVsdFBheWxvYWRDb252ZXJ0ZXIsXG4gIGZhaWx1cmVDb252ZXJ0ZXI6IGRlZmF1bHRGYWlsdXJlQ29udmVydGVyLFxuICBwYXlsb2FkQ29kZWNzOiBbXSxcbn07XG4iLCJpbXBvcnQgKiBhcyBuZXh1cyBmcm9tICduZXh1cy1ycGMnO1xuaW1wb3J0IExvbmcgZnJvbSAnbG9uZyc7XG5pbXBvcnQgdHlwZSB7IHRlbXBvcmFsIH0gZnJvbSAnQHRlbXBvcmFsaW8vcHJvdG8nO1xuaW1wb3J0IHtcbiAgQWN0aXZpdHlGYWlsdXJlLFxuICBBcHBsaWNhdGlvbkZhaWx1cmUsXG4gIENhbmNlbGxlZEZhaWx1cmUsXG4gIENoaWxkV29ya2Zsb3dGYWlsdXJlLFxuICBkZWNvZGVBcHBsaWNhdGlvbkZhaWx1cmVDYXRlZ29yeSxcbiAgZGVjb2RlUmV0cnlTdGF0ZSxcbiAgZGVjb2RlVGltZW91dFR5cGUsXG4gIGVuY29kZUFwcGxpY2F0aW9uRmFpbHVyZUNhdGVnb3J5LFxuICBlbmNvZGVSZXRyeVN0YXRlLFxuICBlbmNvZGVUaW1lb3V0VHlwZSxcbiAgRkFJTFVSRV9TT1VSQ0UsXG4gIE5leHVzT3BlcmF0aW9uRmFpbHVyZSxcbiAgUHJvdG9GYWlsdXJlLFxuICBTZXJ2ZXJGYWlsdXJlLFxuICBUZW1wb3JhbEZhaWx1cmUsXG4gIFRlcm1pbmF0ZWRGYWlsdXJlLFxuICBUaW1lb3V0RmFpbHVyZSxcbn0gZnJvbSAnLi4vZmFpbHVyZSc7XG5pbXBvcnQgeyBtYWtlUHJvdG9FbnVtQ29udmVydGVycyB9IGZyb20gJy4uL2ludGVybmFsLXdvcmtmbG93JztcbmltcG9ydCB7IGlzRXJyb3IgfSBmcm9tICcuLi90eXBlLWhlbHBlcnMnO1xuaW1wb3J0IHsgbXNPcHRpb25hbFRvVHMgfSBmcm9tICcuLi90aW1lJztcbmltcG9ydCB7IGFycmF5RnJvbVBheWxvYWRzLCBmcm9tUGF5bG9hZHNBdEluZGV4LCBQYXlsb2FkQ29udmVydGVyLCB0b1BheWxvYWRzIH0gZnJvbSAnLi9wYXlsb2FkLWNvbnZlcnRlcic7XG5cbi8vIENhbid0IGltcG9ydCBwcm90byBlbnVtcyBpbnRvIHRoZSB3b3JrZmxvdyBzYW5kYm94LCB1c2UgdGhpcyBoZWxwZXIgdHlwZSBhbmQgZW51bSBjb252ZXJ0ZXIgaW5zdGVhZC5cbmNvbnN0IE5leHVzSGFuZGxlckVycm9yUmV0cnlCZWhhdmlvciA9IHtcbiAgUkVUUllBQkxFOiAnUkVUUllBQkxFJyxcbiAgTk9OX1JFVFJZQUJMRTogJ05PTl9SRVRSWUFCTEUnLFxufSBhcyBjb25zdDtcblxudHlwZSBOZXh1c0hhbmRsZXJFcnJvclJldHJ5QmVoYXZpb3IgPVxuICAodHlwZW9mIE5leHVzSGFuZGxlckVycm9yUmV0cnlCZWhhdmlvcilba2V5b2YgdHlwZW9mIE5leHVzSGFuZGxlckVycm9yUmV0cnlCZWhhdmlvcl07XG5cbmNvbnN0IFtlbmNvZGVOZXh1c0hhbmRsZXJFcnJvclJldHJ5QmVoYXZpb3IsIGRlY29kZU5leHVzSGFuZGxlckVycm9yUmV0cnlCZWhhdmlvcl0gPSBtYWtlUHJvdG9FbnVtQ29udmVydGVyczxcbiAgdGVtcG9yYWwuYXBpLmVudW1zLnYxLk5leHVzSGFuZGxlckVycm9yUmV0cnlCZWhhdmlvcixcbiAgdHlwZW9mIHRlbXBvcmFsLmFwaS5lbnVtcy52MS5OZXh1c0hhbmRsZXJFcnJvclJldHJ5QmVoYXZpb3IsXG4gIGtleW9mIHR5cGVvZiB0ZW1wb3JhbC5hcGkuZW51bXMudjEuTmV4dXNIYW5kbGVyRXJyb3JSZXRyeUJlaGF2aW9yLFxuICB0eXBlb2YgTmV4dXNIYW5kbGVyRXJyb3JSZXRyeUJlaGF2aW9yLFxuICAnTkVYVVNfSEFORExFUl9FUlJPUl9SRVRSWV9CRUhBVklPUl8nXG4+KFxuICB7XG4gICAgVU5TUEVDSUZJRUQ6IDAsXG4gICAgW05leHVzSGFuZGxlckVycm9yUmV0cnlCZWhhdmlvci5SRVRSWUFCTEVdOiAxLFxuICAgIFtOZXh1c0hhbmRsZXJFcnJvclJldHJ5QmVoYXZpb3IuTk9OX1JFVFJZQUJMRV06IDIsXG4gIH0gYXMgY29uc3QsXG4gICdORVhVU19IQU5ETEVSX0VSUk9SX1JFVFJZX0JFSEFWSU9SXydcbik7XG5cbmZ1bmN0aW9uIGNvbWJpbmVSZWdFeHAoLi4ucmVnZXhwczogUmVnRXhwW10pOiBSZWdFeHAge1xuICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleHBzLm1hcCgoeCkgPT4gYCg/OiR7eC5zb3VyY2V9KWApLmpvaW4oJ3wnKSk7XG59XG5cbi8qKlxuICogU3RhY2sgdHJhY2VzIHdpbGwgYmUgY3V0b2ZmIHdoZW4gb24gb2YgdGhlc2UgcGF0dGVybnMgaXMgbWF0Y2hlZFxuICovXG5jb25zdCBDVVRPRkZfU1RBQ0tfUEFUVEVSTlMgPSBjb21iaW5lUmVnRXhwKFxuICAvKiogQWN0aXZpdHkgZXhlY3V0aW9uICovXG4gIC9cXHMrYXQgQWN0aXZpdHlcXC5leGVjdXRlIFxcKC4qW1xcXFwvXXdvcmtlcltcXFxcL10oPzpzcmN8bGliKVtcXFxcL11hY3Rpdml0eVxcLltqdF1zOlxcZCs6XFxkK1xcKS8sXG4gIC8qKiBOZXh1cyBleGVjdXRpb24gKi9cbiAgL1xccythdCggYXN5bmMpPyBOZXh1c0hhbmRsZXJcXC5pbnZva2VVc2VyQ29kZSBcXCguKltcXFxcL113b3JrZXJbXFxcXC9dKD86c3JjfGxpYilbXFxcXC9dbmV4dXNbXFxcXC9daW5kZXhcXC5banRdczpcXGQrOlxcZCtcXCkvLFxuICAvKiogV29ya2Zsb3cgYWN0aXZhdGlvbiAqL1xuICAvXFxzK2F0IEFjdGl2YXRvclxcLlxcUytOZXh0SGFuZGxlciBcXCguKltcXFxcL113b3JrZmxvd1tcXFxcL10oPzpzcmN8bGliKVtcXFxcL11pbnRlcm5hbHNcXC5banRdczpcXGQrOlxcZCtcXCkvLFxuICAvKiogV29ya2Zsb3cgcnVuIGFueXRoaW5nIGluIGNvbnRleHQgKi9cbiAgL1xccythdCBTY3JpcHRcXC5ydW5JbkNvbnRleHQgXFwoKD86bm9kZTp2bXx2bVxcLmpzKTpcXGQrOlxcZCtcXCkvXG4pO1xuXG4vKipcbiAqIEFueSBzdGFjayB0cmFjZSBmcmFtZXMgdGhhdCBtYXRjaCBhbnkgb2YgdGhvc2Ugd2lsIGJlIGRvcHBlZC5cbiAqIFRoZSBcIm51bGwuXCIgcHJlZml4IG9uIHNvbWUgY2FzZXMgaXMgdG8gYXZvaWQgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy80MjQxN1xuICovXG5jb25zdCBEUk9QUEVEX1NUQUNLX0ZSQU1FU19QQVRURVJOUyA9IGNvbWJpbmVSZWdFeHAoXG4gIC8qKiBJbnRlcm5hbCBmdW5jdGlvbnMgdXNlZCB0byByZWN1cnNpdmVseSBjaGFpbiBpbnRlcmNlcHRvcnMgKi9cbiAgL1xccythdCAobnVsbFxcLik/bmV4dCBcXCguKltcXFxcL11jb21tb25bXFxcXC9dKD86c3JjfGxpYilbXFxcXC9daW50ZXJjZXB0b3JzXFwuW2p0XXM6XFxkKzpcXGQrXFwpLyxcbiAgLyoqIEludGVybmFsIGZ1bmN0aW9ucyB1c2VkIHRvIHJlY3Vyc2l2ZWx5IGNoYWluIGludGVyY2VwdG9ycyAqL1xuICAvXFxzK2F0IChudWxsXFwuKT9leGVjdXRlTmV4dEhhbmRsZXIgXFwoLipbXFxcXC9dd29ya2VyW1xcXFwvXSg/OnNyY3xsaWIpW1xcXFwvXWFjdGl2aXR5XFwuW2p0XXM6XFxkKzpcXGQrXFwpL1xuKTtcblxuLyoqXG4gKiBDdXRzIG91dCB0aGUgZnJhbWV3b3JrIHBhcnQgb2YgYSBzdGFjayB0cmFjZSwgbGVhdmluZyBvbmx5IHVzZXIgY29kZSBlbnRyaWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjdXRvZmZTdGFja1RyYWNlKHN0YWNrPzogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgbGluZXMgPSAoc3RhY2sgPz8gJycpLnNwbGl0KC9cXHI/XFxuLyk7XG4gIGNvbnN0IGFjYyA9IEFycmF5PHN0cmluZz4oKTtcbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgaWYgKENVVE9GRl9TVEFDS19QQVRURVJOUy50ZXN0KGxpbmUpKSBicmVhaztcbiAgICBpZiAoIURST1BQRURfU1RBQ0tfRlJBTUVTX1BBVFRFUk5TLnRlc3QobGluZSkpIGFjYy5wdXNoKGxpbmUpO1xuICB9XG4gIHJldHVybiBhY2Muam9pbignXFxuJyk7XG59XG5cbi8qKlxuICogQSBgRmFpbHVyZUNvbnZlcnRlcmAgaXMgcmVzcG9uc2libGUgZm9yIGNvbnZlcnRpbmcgZnJvbSBwcm90byBgRmFpbHVyZWAgaW5zdGFuY2VzIHRvIEpTIGBFcnJvcnNgIGFuZCBiYWNrLlxuICpcbiAqIFdlIHJlY29tbWVuZGVkIHVzaW5nIHRoZSB7QGxpbmsgRGVmYXVsdEZhaWx1cmVDb252ZXJ0ZXJ9IGluc3RlYWQgb2YgY3VzdG9taXppbmcgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaW4gb3JkZXJcbiAqIHRvIG1haW50YWluIGNyb3NzLWxhbmd1YWdlIEZhaWx1cmUgc2VyaWFsaXphdGlvbiBjb21wYXRpYmlsaXR5LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZhaWx1cmVDb252ZXJ0ZXIge1xuICAvKipcbiAgICogQ29udmVydHMgYSBjYXVnaHQgZXJyb3IgdG8gYSBGYWlsdXJlIHByb3RvIG1lc3NhZ2UuXG4gICAqL1xuICBlcnJvclRvRmFpbHVyZShlcnI6IHVua25vd24sIHBheWxvYWRDb252ZXJ0ZXI6IFBheWxvYWRDb252ZXJ0ZXIpOiBQcm90b0ZhaWx1cmU7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgRmFpbHVyZSBwcm90byBtZXNzYWdlIHRvIGEgSlMgRXJyb3Igb2JqZWN0LlxuICAgKlxuICAgKiBUaGUgcmV0dXJuZWQgZXJyb3IgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBgVGVtcG9yYWxGYWlsdXJlYC5cbiAgICovXG4gIGZhaWx1cmVUb0Vycm9yKGVycjogUHJvdG9GYWlsdXJlLCBwYXlsb2FkQ29udmVydGVyOiBQYXlsb2FkQ29udmVydGVyKTogRXJyb3I7XG59XG5cbi8qKlxuICogVGhlIFwic2hhcGVcIiBvZiB0aGUgYXR0cmlidXRlcyBzZXQgYXMgdGhlIHtAbGluayBQcm90b0ZhaWx1cmUuZW5jb2RlZEF0dHJpYnV0ZXN9IHBheWxvYWQgaW4gY2FzZVxuICoge0BsaW5rIERlZmF1bHRFbmNvZGVkRmFpbHVyZUF0dHJpYnV0ZXMuZW5jb2RlQ29tbW9uQXR0cmlidXRlc30gaXMgc2V0IHRvIGB0cnVlYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEZWZhdWx0RW5jb2RlZEZhaWx1cmVBdHRyaWJ1dGVzIHtcbiAgbWVzc2FnZTogc3RyaW5nO1xuICBzdGFja190cmFjZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHRoZSB7QGxpbmsgRGVmYXVsdEZhaWx1cmVDb252ZXJ0ZXJ9IGNvbnN0cnVjdG9yLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIERlZmF1bHRGYWlsdXJlQ29udmVydGVyT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuY29kZSBlcnJvciBtZXNzYWdlcyBhbmQgc3RhY2sgdHJhY2VzIChmb3IgZW5jcnlwdGluZyB0aGVzZSBhdHRyaWJ1dGVzIHVzZSBhIHtAbGluayBQYXlsb2FkQ29kZWN9KS5cbiAgICovXG4gIGVuY29kZUNvbW1vbkF0dHJpYnV0ZXM6IGJvb2xlYW47XG59XG5cbi8qKlxuICogRGVmYXVsdCwgY3Jvc3MtbGFuZ3VhZ2UtY29tcGF0aWJsZSBGYWlsdXJlIGNvbnZlcnRlci5cbiAqXG4gKiBCeSBkZWZhdWx0LCBpdCB3aWxsIGxlYXZlIGVycm9yIG1lc3NhZ2VzIGFuZCBzdGFjayB0cmFjZXMgYXMgcGxhaW4gdGV4dC4gSW4gb3JkZXIgdG8gZW5jcnlwdCB0aGVtLCBzZXRcbiAqIGBlbmNvZGVDb21tb25BdHRyaWJ1dGVzYCB0byBgdHJ1ZWAgaW4gdGhlIGNvbnN0cnVjdG9yIG9wdGlvbnMgYW5kIHVzZSBhIHtAbGluayBQYXlsb2FkQ29kZWN9IHRoYXQgY2FuIGVuY3J5cHQgL1xuICogZGVjcnlwdCBQYXlsb2FkcyBpbiB5b3VyIHtAbGluayBXb3JrZXJPcHRpb25zLmRhdGFDb252ZXJ0ZXIgfCBXb3JrZXJ9IGFuZFxuICoge0BsaW5rIENsaWVudE9wdGlvbnMuZGF0YUNvbnZlcnRlciB8IENsaWVudCBvcHRpb25zfS5cbiAqL1xuZXhwb3J0IGNsYXNzIERlZmF1bHRGYWlsdXJlQ29udmVydGVyIGltcGxlbWVudHMgRmFpbHVyZUNvbnZlcnRlciB7XG4gIHB1YmxpYyByZWFkb25seSBvcHRpb25zOiBEZWZhdWx0RmFpbHVyZUNvbnZlcnRlck9wdGlvbnM7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucz86IFBhcnRpYWw8RGVmYXVsdEZhaWx1cmVDb252ZXJ0ZXJPcHRpb25zPikge1xuICAgIGNvbnN0IHsgZW5jb2RlQ29tbW9uQXR0cmlidXRlcyB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBlbmNvZGVDb21tb25BdHRyaWJ1dGVzOiBlbmNvZGVDb21tb25BdHRyaWJ1dGVzID8/IGZhbHNlLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBGYWlsdXJlIHByb3RvIG1lc3NhZ2UgdG8gYSBKUyBFcnJvciBvYmplY3QuXG4gICAqXG4gICAqIERvZXMgbm90IHNldCBjb21tb24gcHJvcGVydGllcywgdGhhdCBpcyBkb25lIGluIHtAbGluayBmYWlsdXJlVG9FcnJvcn0uXG4gICAqL1xuICBmYWlsdXJlVG9FcnJvcklubmVyKGZhaWx1cmU6IFByb3RvRmFpbHVyZSwgcGF5bG9hZENvbnZlcnRlcjogUGF5bG9hZENvbnZlcnRlcik6IEVycm9yIHtcbiAgICBpZiAoZmFpbHVyZS5hcHBsaWNhdGlvbkZhaWx1cmVJbmZvKSB7XG4gICAgICByZXR1cm4gbmV3IEFwcGxpY2F0aW9uRmFpbHVyZShcbiAgICAgICAgZmFpbHVyZS5tZXNzYWdlID8/IHVuZGVmaW5lZCxcbiAgICAgICAgZmFpbHVyZS5hcHBsaWNhdGlvbkZhaWx1cmVJbmZvLnR5cGUsXG4gICAgICAgIEJvb2xlYW4oZmFpbHVyZS5hcHBsaWNhdGlvbkZhaWx1cmVJbmZvLm5vblJldHJ5YWJsZSksXG4gICAgICAgIGFycmF5RnJvbVBheWxvYWRzKHBheWxvYWRDb252ZXJ0ZXIsIGZhaWx1cmUuYXBwbGljYXRpb25GYWlsdXJlSW5mby5kZXRhaWxzPy5wYXlsb2FkcyksXG4gICAgICAgIHRoaXMub3B0aW9uYWxGYWlsdXJlVG9PcHRpb25hbEVycm9yKGZhaWx1cmUuY2F1c2UsIHBheWxvYWRDb252ZXJ0ZXIpLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIGRlY29kZUFwcGxpY2F0aW9uRmFpbHVyZUNhdGVnb3J5KGZhaWx1cmUuYXBwbGljYXRpb25GYWlsdXJlSW5mby5jYXRlZ29yeSlcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChmYWlsdXJlLnNlcnZlckZhaWx1cmVJbmZvKSB7XG4gICAgICByZXR1cm4gbmV3IFNlcnZlckZhaWx1cmUoXG4gICAgICAgIGZhaWx1cmUubWVzc2FnZSA/PyB1bmRlZmluZWQsXG4gICAgICAgIEJvb2xlYW4oZmFpbHVyZS5zZXJ2ZXJGYWlsdXJlSW5mby5ub25SZXRyeWFibGUpLFxuICAgICAgICB0aGlzLm9wdGlvbmFsRmFpbHVyZVRvT3B0aW9uYWxFcnJvcihmYWlsdXJlLmNhdXNlLCBwYXlsb2FkQ29udmVydGVyKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGZhaWx1cmUudGltZW91dEZhaWx1cmVJbmZvKSB7XG4gICAgICByZXR1cm4gbmV3IFRpbWVvdXRGYWlsdXJlKFxuICAgICAgICBmYWlsdXJlLm1lc3NhZ2UgPz8gdW5kZWZpbmVkLFxuICAgICAgICBmcm9tUGF5bG9hZHNBdEluZGV4KHBheWxvYWRDb252ZXJ0ZXIsIDAsIGZhaWx1cmUudGltZW91dEZhaWx1cmVJbmZvLmxhc3RIZWFydGJlYXREZXRhaWxzPy5wYXlsb2FkcyksXG4gICAgICAgIGRlY29kZVRpbWVvdXRUeXBlKGZhaWx1cmUudGltZW91dEZhaWx1cmVJbmZvLnRpbWVvdXRUeXBlKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGZhaWx1cmUudGVybWluYXRlZEZhaWx1cmVJbmZvKSB7XG4gICAgICByZXR1cm4gbmV3IFRlcm1pbmF0ZWRGYWlsdXJlKFxuICAgICAgICBmYWlsdXJlLm1lc3NhZ2UgPz8gdW5kZWZpbmVkLFxuICAgICAgICB0aGlzLm9wdGlvbmFsRmFpbHVyZVRvT3B0aW9uYWxFcnJvcihmYWlsdXJlLmNhdXNlLCBwYXlsb2FkQ29udmVydGVyKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGZhaWx1cmUuY2FuY2VsZWRGYWlsdXJlSW5mbykge1xuICAgICAgcmV0dXJuIG5ldyBDYW5jZWxsZWRGYWlsdXJlKFxuICAgICAgICBmYWlsdXJlLm1lc3NhZ2UgPz8gdW5kZWZpbmVkLFxuICAgICAgICBhcnJheUZyb21QYXlsb2FkcyhwYXlsb2FkQ29udmVydGVyLCBmYWlsdXJlLmNhbmNlbGVkRmFpbHVyZUluZm8uZGV0YWlscz8ucGF5bG9hZHMpLFxuICAgICAgICB0aGlzLm9wdGlvbmFsRmFpbHVyZVRvT3B0aW9uYWxFcnJvcihmYWlsdXJlLmNhdXNlLCBwYXlsb2FkQ29udmVydGVyKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGZhaWx1cmUucmVzZXRXb3JrZmxvd0ZhaWx1cmVJbmZvKSB7XG4gICAgICByZXR1cm4gbmV3IEFwcGxpY2F0aW9uRmFpbHVyZShcbiAgICAgICAgZmFpbHVyZS5tZXNzYWdlID8/IHVuZGVmaW5lZCxcbiAgICAgICAgJ1Jlc2V0V29ya2Zsb3cnLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgYXJyYXlGcm9tUGF5bG9hZHMocGF5bG9hZENvbnZlcnRlciwgZmFpbHVyZS5yZXNldFdvcmtmbG93RmFpbHVyZUluZm8ubGFzdEhlYXJ0YmVhdERldGFpbHM/LnBheWxvYWRzKSxcbiAgICAgICAgdGhpcy5vcHRpb25hbEZhaWx1cmVUb09wdGlvbmFsRXJyb3IoZmFpbHVyZS5jYXVzZSwgcGF5bG9hZENvbnZlcnRlcilcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChmYWlsdXJlLmNoaWxkV29ya2Zsb3dFeGVjdXRpb25GYWlsdXJlSW5mbykge1xuICAgICAgY29uc3QgeyBuYW1lc3BhY2UsIHdvcmtmbG93VHlwZSwgd29ya2Zsb3dFeGVjdXRpb24sIHJldHJ5U3RhdGUgfSA9IGZhaWx1cmUuY2hpbGRXb3JrZmxvd0V4ZWN1dGlvbkZhaWx1cmVJbmZvO1xuICAgICAgaWYgKCEod29ya2Zsb3dUeXBlPy5uYW1lICYmIHdvcmtmbG93RXhlY3V0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNaXNzaW5nIGF0dHJpYnV0ZXMgb24gY2hpbGRXb3JrZmxvd0V4ZWN1dGlvbkZhaWx1cmVJbmZvJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IENoaWxkV29ya2Zsb3dGYWlsdXJlKFxuICAgICAgICBuYW1lc3BhY2UgPz8gdW5kZWZpbmVkLFxuICAgICAgICB3b3JrZmxvd0V4ZWN1dGlvbixcbiAgICAgICAgd29ya2Zsb3dUeXBlLm5hbWUsXG4gICAgICAgIGRlY29kZVJldHJ5U3RhdGUocmV0cnlTdGF0ZSksXG4gICAgICAgIHRoaXMub3B0aW9uYWxGYWlsdXJlVG9PcHRpb25hbEVycm9yKGZhaWx1cmUuY2F1c2UsIHBheWxvYWRDb252ZXJ0ZXIpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZmFpbHVyZS5hY3Rpdml0eUZhaWx1cmVJbmZvKSB7XG4gICAgICBpZiAoIWZhaWx1cmUuYWN0aXZpdHlGYWlsdXJlSW5mby5hY3Rpdml0eVR5cGU/Lm5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyBhY3Rpdml0eVR5cGU/Lm5hbWUgb24gYWN0aXZpdHlGYWlsdXJlSW5mbycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBBY3Rpdml0eUZhaWx1cmUoXG4gICAgICAgIGZhaWx1cmUubWVzc2FnZSA/PyB1bmRlZmluZWQsXG4gICAgICAgIGZhaWx1cmUuYWN0aXZpdHlGYWlsdXJlSW5mby5hY3Rpdml0eVR5cGUubmFtZSxcbiAgICAgICAgZmFpbHVyZS5hY3Rpdml0eUZhaWx1cmVJbmZvLmFjdGl2aXR5SWQgPz8gdW5kZWZpbmVkLFxuICAgICAgICBkZWNvZGVSZXRyeVN0YXRlKGZhaWx1cmUuYWN0aXZpdHlGYWlsdXJlSW5mby5yZXRyeVN0YXRlKSxcbiAgICAgICAgZmFpbHVyZS5hY3Rpdml0eUZhaWx1cmVJbmZvLmlkZW50aXR5ID8/IHVuZGVmaW5lZCxcbiAgICAgICAgdGhpcy5vcHRpb25hbEZhaWx1cmVUb09wdGlvbmFsRXJyb3IoZmFpbHVyZS5jYXVzZSwgcGF5bG9hZENvbnZlcnRlcilcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChmYWlsdXJlLm5leHVzSGFuZGxlckZhaWx1cmVJbmZvKSB7XG4gICAgICBsZXQgcmV0cnlhYmxlT3ZlcnJpZGU6IGJvb2xlYW4gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgICBjb25zdCByZXRyeUJlaGF2aW9yID0gZGVjb2RlTmV4dXNIYW5kbGVyRXJyb3JSZXRyeUJlaGF2aW9yKGZhaWx1cmUubmV4dXNIYW5kbGVyRmFpbHVyZUluZm8ucmV0cnlCZWhhdmlvcik7XG4gICAgICBzd2l0Y2ggKHJldHJ5QmVoYXZpb3IpIHtcbiAgICAgICAgY2FzZSAnUkVUUllBQkxFJzpcbiAgICAgICAgICByZXRyeWFibGVPdmVycmlkZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ05PTl9SRVRSWUFCTEUnOlxuICAgICAgICAgIHJldHJ5YWJsZU92ZXJyaWRlID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgbmV4dXMuSGFuZGxlckVycm9yKFxuICAgICAgICAoZmFpbHVyZS5uZXh1c0hhbmRsZXJGYWlsdXJlSW5mby50eXBlIGFzIG5leHVzLkhhbmRsZXJFcnJvclR5cGUpID8/ICdJTlRFUk5BTCcsXG4gICAgICAgIC8vIFRPRE8obmV4dXMvZXJyb3IpOiBNYXliZSBzZXQgYSBkZWZhdWx0IG1lc3NhZ2UgaGVyZSwgb25jZSB3ZSd2ZSBkZWNpZGVkIG9uIGVycm9yIGhhbmRsaW5nLlxuICAgICAgICBmYWlsdXJlLm1lc3NhZ2UgPz8gdW5kZWZpbmVkLFxuICAgICAgICB7XG4gICAgICAgICAgY2F1c2U6IHRoaXMub3B0aW9uYWxGYWlsdXJlVG9PcHRpb25hbEVycm9yKGZhaWx1cmUuY2F1c2UsIHBheWxvYWRDb252ZXJ0ZXIpLFxuICAgICAgICAgIHJldHJ5YWJsZU92ZXJyaWRlLFxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZmFpbHVyZS5uZXh1c09wZXJhdGlvbkV4ZWN1dGlvbkZhaWx1cmVJbmZvKSB7XG4gICAgICByZXR1cm4gbmV3IE5leHVzT3BlcmF0aW9uRmFpbHVyZShcbiAgICAgICAgLy8gVE9ETyhuZXh1cy9lcnJvcik6IE1heWJlIHNldCBhIGRlZmF1bHQgbWVzc2FnZSBoZXJlLCBvbmNlIHdlJ3ZlIGRlY2lkZWQgb24gZXJyb3IgaGFuZGxpbmcuXG4gICAgICAgIGZhaWx1cmUubWVzc2FnZSA/PyB1bmRlZmluZWQsXG4gICAgICAgIGZhaWx1cmUubmV4dXNPcGVyYXRpb25FeGVjdXRpb25GYWlsdXJlSW5mby5zY2hlZHVsZWRFdmVudElkPy50b051bWJlcigpLFxuICAgICAgICAvLyBXZSBhc3N1bWUgdGhlc2Ugd2lsbCBhbHdheXMgYmUgc2V0IG9yIGdyYWNlZnVsbHkgc2V0IHRvIGVtcHR5IHN0cmluZ3MuXG4gICAgICAgIGZhaWx1cmUubmV4dXNPcGVyYXRpb25FeGVjdXRpb25GYWlsdXJlSW5mby5lbmRwb2ludCA/PyAnJyxcbiAgICAgICAgZmFpbHVyZS5uZXh1c09wZXJhdGlvbkV4ZWN1dGlvbkZhaWx1cmVJbmZvLnNlcnZpY2UgPz8gJycsXG4gICAgICAgIGZhaWx1cmUubmV4dXNPcGVyYXRpb25FeGVjdXRpb25GYWlsdXJlSW5mby5vcGVyYXRpb24gPz8gJycsXG4gICAgICAgIGZhaWx1cmUubmV4dXNPcGVyYXRpb25FeGVjdXRpb25GYWlsdXJlSW5mby5vcGVyYXRpb25Ub2tlbiA/PyB1bmRlZmluZWQsXG4gICAgICAgIHRoaXMub3B0aW9uYWxGYWlsdXJlVG9PcHRpb25hbEVycm9yKGZhaWx1cmUuY2F1c2UsIHBheWxvYWRDb252ZXJ0ZXIpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlbXBvcmFsRmFpbHVyZShcbiAgICAgIGZhaWx1cmUubWVzc2FnZSA/PyB1bmRlZmluZWQsXG4gICAgICB0aGlzLm9wdGlvbmFsRmFpbHVyZVRvT3B0aW9uYWxFcnJvcihmYWlsdXJlLmNhdXNlLCBwYXlsb2FkQ29udmVydGVyKVxuICAgICk7XG4gIH1cblxuICBmYWlsdXJlVG9FcnJvcihmYWlsdXJlOiBQcm90b0ZhaWx1cmUsIHBheWxvYWRDb252ZXJ0ZXI6IFBheWxvYWRDb252ZXJ0ZXIpOiBFcnJvciB7XG4gICAgaWYgKGZhaWx1cmUuZW5jb2RlZEF0dHJpYnV0ZXMpIHtcbiAgICAgIGNvbnN0IGF0dHJzID0gcGF5bG9hZENvbnZlcnRlci5mcm9tUGF5bG9hZDxEZWZhdWx0RW5jb2RlZEZhaWx1cmVBdHRyaWJ1dGVzPihmYWlsdXJlLmVuY29kZWRBdHRyaWJ1dGVzKTtcbiAgICAgIC8vIERvbid0IGFwcGx5IGVuY29kZWRBdHRyaWJ1dGVzIHVubGVzcyB0aGV5IGNvbmZvcm0gdG8gYW4gZXhwZWN0ZWQgc2NoZW1hXG4gICAgICBpZiAodHlwZW9mIGF0dHJzID09PSAnb2JqZWN0JyAmJiBhdHRycyAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2UsIHN0YWNrX3RyYWNlIH0gPSBhdHRycztcbiAgICAgICAgLy8gQXZvaWQgbXV0YXRpbmcgdGhlIGFyZ3VtZW50XG4gICAgICAgIGZhaWx1cmUgPSB7IC4uLmZhaWx1cmUgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGZhaWx1cmUubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzdGFja190cmFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBmYWlsdXJlLnN0YWNrVHJhY2UgPSBzdGFja190cmFjZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlcnIgPSB0aGlzLmZhaWx1cmVUb0Vycm9ySW5uZXIoZmFpbHVyZSwgcGF5bG9hZENvbnZlcnRlcik7XG4gICAgZXJyLnN0YWNrID0gZmFpbHVyZS5zdGFja1RyYWNlID8/ICcnO1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBUZW1wb3JhbEZhaWx1cmUpIHtcbiAgICAgIGVyci5mYWlsdXJlID0gZmFpbHVyZTtcbiAgICB9XG4gICAgcmV0dXJuIGVycjtcbiAgfVxuXG4gIGVycm9yVG9GYWlsdXJlKGVycjogdW5rbm93biwgcGF5bG9hZENvbnZlcnRlcjogUGF5bG9hZENvbnZlcnRlcik6IFByb3RvRmFpbHVyZSB7XG4gICAgY29uc3QgZmFpbHVyZSA9IHRoaXMuZXJyb3JUb0ZhaWx1cmVJbm5lcihlcnIsIHBheWxvYWRDb252ZXJ0ZXIpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZW5jb2RlQ29tbW9uQXR0cmlidXRlcykge1xuICAgICAgY29uc3QgeyBtZXNzYWdlLCBzdGFja1RyYWNlIH0gPSBmYWlsdXJlO1xuICAgICAgZmFpbHVyZS5tZXNzYWdlID0gJ0VuY29kZWQgZmFpbHVyZSc7XG4gICAgICBmYWlsdXJlLnN0YWNrVHJhY2UgPSAnJztcbiAgICAgIGZhaWx1cmUuZW5jb2RlZEF0dHJpYnV0ZXMgPSBwYXlsb2FkQ29udmVydGVyLnRvUGF5bG9hZCh7IG1lc3NhZ2UsIHN0YWNrX3RyYWNlOiBzdGFja1RyYWNlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmFpbHVyZTtcbiAgfVxuXG4gIGVycm9yVG9GYWlsdXJlSW5uZXIoZXJyOiB1bmtub3duLCBwYXlsb2FkQ29udmVydGVyOiBQYXlsb2FkQ29udmVydGVyKTogUHJvdG9GYWlsdXJlIHtcbiAgICAvLyBUT0RPKG5leHVzL2Vycm9yKTogSWYgd2UgZGVjaWRlIG5vdCB0byBoYXZlIGEgTmV4dXNIYW5kbGVyRmFpbHVyZSwgd2UgY291bGQgc3RpbGwgYXR0YWNoIHRoZVxuICAgIC8vICAgICAgICAgICAgICAgICAgICBmYWlsdXJlIHByb3RvIHRvIHRoZSBOZXh1cyBIYW5kbGVyRXJyb3Igb2JqZWN0LCBieSB1c2luZyBhIHByaXZhdGUgc3ltYm9sXG4gICAgLy8gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LiBUbyBiZSBjb25zaWRlcmVkIG9uY2Ugd2UgaGF2ZSBhIGRlY2lzaW9uIG9uIGVycm9yIGhhbmRsaW5nLlxuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBUZW1wb3JhbEZhaWx1cmUgfHwgZXJyIGluc3RhbmNlb2YgbmV4dXMuSGFuZGxlckVycm9yKSB7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVGVtcG9yYWxGYWlsdXJlICYmIGVyci5mYWlsdXJlKSByZXR1cm4gZXJyLmZhaWx1cmU7XG4gICAgICBjb25zdCBiYXNlID0ge1xuICAgICAgICBtZXNzYWdlOiBlcnIubWVzc2FnZSxcbiAgICAgICAgc3RhY2tUcmFjZTogY3V0b2ZmU3RhY2tUcmFjZShlcnIuc3RhY2spLFxuICAgICAgICBjYXVzZTogdGhpcy5vcHRpb25hbEVycm9yVG9PcHRpb25hbEZhaWx1cmUoZXJyLmNhdXNlLCBwYXlsb2FkQ29udmVydGVyKSxcbiAgICAgICAgc291cmNlOiBGQUlMVVJFX1NPVVJDRSxcbiAgICAgIH07XG5cbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBBY3Rpdml0eUZhaWx1cmUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5iYXNlLFxuICAgICAgICAgIGFjdGl2aXR5RmFpbHVyZUluZm86IHtcbiAgICAgICAgICAgIC4uLmVycixcbiAgICAgICAgICAgIHJldHJ5U3RhdGU6IGVuY29kZVJldHJ5U3RhdGUoZXJyLnJldHJ5U3RhdGUpLFxuICAgICAgICAgICAgYWN0aXZpdHlUeXBlOiB7IG5hbWU6IGVyci5hY3Rpdml0eVR5cGUgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIENoaWxkV29ya2Zsb3dGYWlsdXJlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uYmFzZSxcbiAgICAgICAgICBjaGlsZFdvcmtmbG93RXhlY3V0aW9uRmFpbHVyZUluZm86IHtcbiAgICAgICAgICAgIC4uLmVycixcbiAgICAgICAgICAgIHJldHJ5U3RhdGU6IGVuY29kZVJldHJ5U3RhdGUoZXJyLnJldHJ5U3RhdGUpLFxuICAgICAgICAgICAgd29ya2Zsb3dFeGVjdXRpb246IGVyci5leGVjdXRpb24sXG4gICAgICAgICAgICB3b3JrZmxvd1R5cGU6IHsgbmFtZTogZXJyLndvcmtmbG93VHlwZSB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQXBwbGljYXRpb25GYWlsdXJlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uYmFzZSxcbiAgICAgICAgICBhcHBsaWNhdGlvbkZhaWx1cmVJbmZvOiB7XG4gICAgICAgICAgICB0eXBlOiBlcnIudHlwZSxcbiAgICAgICAgICAgIG5vblJldHJ5YWJsZTogZXJyLm5vblJldHJ5YWJsZSxcbiAgICAgICAgICAgIGRldGFpbHM6XG4gICAgICAgICAgICAgIGVyci5kZXRhaWxzICYmIGVyci5kZXRhaWxzLmxlbmd0aFxuICAgICAgICAgICAgICAgID8geyBwYXlsb2FkczogdG9QYXlsb2FkcyhwYXlsb2FkQ29udmVydGVyLCAuLi5lcnIuZGV0YWlscykgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbmV4dFJldHJ5RGVsYXk6IG1zT3B0aW9uYWxUb1RzKGVyci5uZXh0UmV0cnlEZWxheSksXG4gICAgICAgICAgICBjYXRlZ29yeTogZW5jb2RlQXBwbGljYXRpb25GYWlsdXJlQ2F0ZWdvcnkoZXJyLmNhdGVnb3J5KSxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIENhbmNlbGxlZEZhaWx1cmUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5iYXNlLFxuICAgICAgICAgIGNhbmNlbGVkRmFpbHVyZUluZm86IHtcbiAgICAgICAgICAgIGRldGFpbHM6XG4gICAgICAgICAgICAgIGVyci5kZXRhaWxzICYmIGVyci5kZXRhaWxzLmxlbmd0aFxuICAgICAgICAgICAgICAgID8geyBwYXlsb2FkczogdG9QYXlsb2FkcyhwYXlsb2FkQ29udmVydGVyLCAuLi5lcnIuZGV0YWlscykgfVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVGltZW91dEZhaWx1cmUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5iYXNlLFxuICAgICAgICAgIHRpbWVvdXRGYWlsdXJlSW5mbzoge1xuICAgICAgICAgICAgdGltZW91dFR5cGU6IGVuY29kZVRpbWVvdXRUeXBlKGVyci50aW1lb3V0VHlwZSksXG4gICAgICAgICAgICBsYXN0SGVhcnRiZWF0RGV0YWlsczogZXJyLmxhc3RIZWFydGJlYXREZXRhaWxzXG4gICAgICAgICAgICAgID8geyBwYXlsb2FkczogdG9QYXlsb2FkcyhwYXlsb2FkQ29udmVydGVyLCBlcnIubGFzdEhlYXJ0YmVhdERldGFpbHMpIH1cbiAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBTZXJ2ZXJGYWlsdXJlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uYmFzZSxcbiAgICAgICAgICBzZXJ2ZXJGYWlsdXJlSW5mbzogeyBub25SZXRyeWFibGU6IGVyci5ub25SZXRyeWFibGUgfSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBUZXJtaW5hdGVkRmFpbHVyZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLmJhc2UsXG4gICAgICAgICAgdGVybWluYXRlZEZhaWx1cmVJbmZvOiB7fSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBuZXh1cy5IYW5kbGVyRXJyb3IpIHtcbiAgICAgICAgbGV0IHJldHJ5QmVoYXZpb3I6IHRlbXBvcmFsLmFwaS5lbnVtcy52MS5OZXh1c0hhbmRsZXJFcnJvclJldHJ5QmVoYXZpb3IgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHN3aXRjaCAoZXJyLnJldHJ5YWJsZU92ZXJyaWRlKSB7XG4gICAgICAgICAgY2FzZSB0cnVlOlxuICAgICAgICAgICAgcmV0cnlCZWhhdmlvciA9IGVuY29kZU5leHVzSGFuZGxlckVycm9yUmV0cnlCZWhhdmlvcignUkVUUllBQkxFJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGZhbHNlOlxuICAgICAgICAgICAgcmV0cnlCZWhhdmlvciA9IGVuY29kZU5leHVzSGFuZGxlckVycm9yUmV0cnlCZWhhdmlvcignTk9OX1JFVFJZQUJMRScpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC8vIFRPRE8obmV4dXMvZXJyb3IpOiBNYXliZSBzZXQgYSBkZWZhdWx0IG1lc3NhZ2UgaGVyZSwgb25jZSB3ZSd2ZSBkZWNpZGVkIG9uIGVycm9yIGhhbmRsaW5nLlxuICAgICAgICAgIC4uLmJhc2UsXG4gICAgICAgICAgbmV4dXNIYW5kbGVyRmFpbHVyZUluZm86IHtcbiAgICAgICAgICAgIHR5cGU6IGVyci50eXBlLFxuICAgICAgICAgICAgcmV0cnlCZWhhdmlvcixcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIE5leHVzT3BlcmF0aW9uRmFpbHVyZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC8vIFRPRE8obmV4dXMvZXJyb3IpOiBNYXliZSBzZXQgYSBkZWZhdWx0IG1lc3NhZ2UgaGVyZSwgb25jZSB3ZSd2ZSBkZWNpZGVkIG9uIGVycm9yIGhhbmRsaW5nLlxuICAgICAgICAgIC4uLmJhc2UsXG4gICAgICAgICAgbmV4dXNPcGVyYXRpb25FeGVjdXRpb25GYWlsdXJlSW5mbzoge1xuICAgICAgICAgICAgc2NoZWR1bGVkRXZlbnRJZDogZXJyLnNjaGVkdWxlZEV2ZW50SWQgPyBMb25nLmZyb21OdW1iZXIoZXJyLnNjaGVkdWxlZEV2ZW50SWQpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZW5kcG9pbnQ6IGVyci5lbmRwb2ludCxcbiAgICAgICAgICAgIHNlcnZpY2U6IGVyci5zZXJ2aWNlLFxuICAgICAgICAgICAgb3BlcmF0aW9uOiBlcnIub3BlcmF0aW9uLFxuICAgICAgICAgICAgb3BlcmF0aW9uVG9rZW46IGVyci5vcGVyYXRpb25Ub2tlbixcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLy8gSnVzdCBhIFRlbXBvcmFsRmFpbHVyZVxuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuXG4gICAgY29uc3QgYmFzZSA9IHtcbiAgICAgIHNvdXJjZTogRkFJTFVSRV9TT1VSQ0UsXG4gICAgfTtcblxuICAgIGlmIChpc0Vycm9yKGVycikpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmJhc2UsXG4gICAgICAgIG1lc3NhZ2U6IFN0cmluZyhlcnIubWVzc2FnZSkgPz8gJycsXG4gICAgICAgIHN0YWNrVHJhY2U6IGN1dG9mZlN0YWNrVHJhY2UoZXJyLnN0YWNrKSxcbiAgICAgICAgY2F1c2U6IHRoaXMub3B0aW9uYWxFcnJvclRvT3B0aW9uYWxGYWlsdXJlKChlcnIgYXMgYW55KS5jYXVzZSwgcGF5bG9hZENvbnZlcnRlciksXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHJlY29tbWVuZGF0aW9uID0gYCBbQSBub24tRXJyb3IgdmFsdWUgd2FzIHRocm93biBmcm9tIHlvdXIgY29kZS4gV2UgcmVjb21tZW5kIHRocm93aW5nIEVycm9yIG9iamVjdHMgc28gdGhhdCB3ZSBjYW4gcHJvdmlkZSBhIHN0YWNrIHRyYWNlXWA7XG5cbiAgICBpZiAodHlwZW9mIGVyciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB7IC4uLmJhc2UsIG1lc3NhZ2U6IGVyciArIHJlY29tbWVuZGF0aW9uIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZXJyID09PSAnb2JqZWN0Jykge1xuICAgICAgbGV0IG1lc3NhZ2UgPSAnJztcbiAgICAgIHRyeSB7XG4gICAgICAgIG1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeShlcnIpO1xuICAgICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgICBtZXNzYWdlID0gU3RyaW5nKGVycik7XG4gICAgICB9XG4gICAgICByZXR1cm4geyAuLi5iYXNlLCBtZXNzYWdlOiBtZXNzYWdlICsgcmVjb21tZW5kYXRpb24gfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyAuLi5iYXNlLCBtZXNzYWdlOiBTdHJpbmcoZXJyKSArIHJlY29tbWVuZGF0aW9uIH07XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBGYWlsdXJlIHByb3RvIG1lc3NhZ2UgdG8gYSBKUyBFcnJvciBvYmplY3QgaWYgZGVmaW5lZCBvciByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICovXG4gIG9wdGlvbmFsRmFpbHVyZVRvT3B0aW9uYWxFcnJvcihcbiAgICBmYWlsdXJlOiBQcm90b0ZhaWx1cmUgfCB1bmRlZmluZWQgfCBudWxsLFxuICAgIHBheWxvYWRDb252ZXJ0ZXI6IFBheWxvYWRDb252ZXJ0ZXJcbiAgKTogRXJyb3IgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBmYWlsdXJlID8gdGhpcy5mYWlsdXJlVG9FcnJvcihmYWlsdXJlLCBwYXlsb2FkQ29udmVydGVyKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBlcnJvciB0byBhIEZhaWx1cmUgcHJvdG8gbWVzc2FnZSBpZiBkZWZpbmVkIG9yIHJldHVybnMgdW5kZWZpbmVkXG4gICAqL1xuICBvcHRpb25hbEVycm9yVG9PcHRpb25hbEZhaWx1cmUoZXJyOiB1bmtub3duLCBwYXlsb2FkQ29udmVydGVyOiBQYXlsb2FkQ29udmVydGVyKTogUHJvdG9GYWlsdXJlIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gZXJyID8gdGhpcy5lcnJvclRvRmFpbHVyZShlcnIsIHBheWxvYWRDb252ZXJ0ZXIpIDogdW5kZWZpbmVkO1xuICB9XG59XG4iLCJpbXBvcnQgeyBQYXlsb2FkIH0gZnJvbSAnLi4vaW50ZXJmYWNlcyc7XG5cbi8qKlxuICogYFBheWxvYWRDb2RlY2AgaXMgYW4gb3B0aW9uYWwgc3RlcCB0aGF0IGhhcHBlbnMgYmV0d2VlbiB0aGUgd2lyZSBhbmQgdGhlIHtAbGluayBQYXlsb2FkQ29udmVydGVyfTpcbiAqXG4gKiBUZW1wb3JhbCBTZXJ2ZXIgPC0tPiBXaXJlIDwtLT4gYFBheWxvYWRDb2RlY2AgPC0tPiBgUGF5bG9hZENvbnZlcnRlcmAgPC0tPiBVc2VyIGNvZGVcbiAqXG4gKiBJbXBsZW1lbnQgdGhpcyB0byB0cmFuc2Zvcm0gYW4gYXJyYXkgb2Yge0BsaW5rIFBheWxvYWR9cyB0by9mcm9tIHRoZSBmb3JtYXQgc2VudCBvdmVyIHRoZSB3aXJlIGFuZCBzdG9yZWQgYnkgVGVtcG9yYWwgU2VydmVyLlxuICogQ29tbW9uIHRyYW5zZm9ybWF0aW9ucyBhcmUgZW5jcnlwdGlvbiBhbmQgY29tcHJlc3Npb24uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGF5bG9hZENvZGVjIHtcbiAgLyoqXG4gICAqIEVuY29kZSBhbiBhcnJheSBvZiB7QGxpbmsgUGF5bG9hZH1zIGZvciBzZW5kaW5nIG92ZXIgdGhlIHdpcmUuXG4gICAqIEBwYXJhbSBwYXlsb2FkcyBNYXkgaGF2ZSBsZW5ndGggMC5cbiAgICovXG4gIGVuY29kZShwYXlsb2FkczogUGF5bG9hZFtdKTogUHJvbWlzZTxQYXlsb2FkW10+O1xuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYXJyYXkgb2Yge0BsaW5rIFBheWxvYWR9cyByZWNlaXZlZCBmcm9tIHRoZSB3aXJlLlxuICAgKi9cbiAgZGVjb2RlKHBheWxvYWRzOiBQYXlsb2FkW10pOiBQcm9taXNlPFBheWxvYWRbXT47XG59XG4iLCJpbXBvcnQgeyBkZWNvZGUsIGVuY29kZSB9IGZyb20gJy4uL2VuY29kaW5nJztcbmltcG9ydCB7IFBheWxvYWRDb252ZXJ0ZXJFcnJvciwgVmFsdWVFcnJvciB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBQYXlsb2FkIH0gZnJvbSAnLi4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBlbmNvZGluZ0tleXMsIGVuY29kaW5nVHlwZXMsIE1FVEFEQVRBX0VOQ09ESU5HX0tFWSB9IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIFVzZWQgYnkgdGhlIGZyYW1ld29yayB0byBzZXJpYWxpemUvZGVzZXJpYWxpemUgZGF0YSBsaWtlIHBhcmFtZXRlcnMgYW5kIHJldHVybiB2YWx1ZXMuXG4gKlxuICogVGhpcyBpcyBjYWxsZWQgaW5zaWRlIHRoZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLnRlbXBvcmFsLmlvL3R5cGVzY3JpcHQvZGV0ZXJtaW5pc20gfCBXb3JrZmxvdyBpc29sYXRlfS5cbiAqIFRvIHdyaXRlIGFzeW5jIGNvZGUgb3IgdXNlIE5vZGUgQVBJcyAob3IgdXNlIHBhY2thZ2VzIHRoYXQgdXNlIE5vZGUgQVBJcyksIHVzZSBhIHtAbGluayBQYXlsb2FkQ29kZWN9LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBheWxvYWRDb252ZXJ0ZXIge1xuICAvKipcbiAgICogQ29udmVydHMgYSB2YWx1ZSB0byBhIHtAbGluayBQYXlsb2FkfS5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LiBFeGFtcGxlIHZhbHVlcyBpbmNsdWRlIHRoZSBXb3JrZmxvdyBhcmdzIHNlbnQgZnJvbSB0aGUgQ2xpZW50IGFuZCB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IGEgV29ya2Zsb3cgb3IgQWN0aXZpdHkuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSB7QGxpbmsgUGF5bG9hZH0uXG4gICAqXG4gICAqIFNob3VsZCB0aHJvdyB7QGxpbmsgVmFsdWVFcnJvcn0gaWYgdW5hYmxlIHRvIGNvbnZlcnQuXG4gICAqL1xuICB0b1BheWxvYWQ8VD4odmFsdWU6IFQpOiBQYXlsb2FkO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHtAbGluayBQYXlsb2FkfSBiYWNrIHRvIGEgdmFsdWUuXG4gICAqL1xuICBmcm9tUGF5bG9hZDxUPihwYXlsb2FkOiBQYXlsb2FkKTogVDtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGNvbnZlcnNpb24gb2YgYSBsaXN0IG9mIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0gY29udmVydGVyXG4gKiBAcGFyYW0gdmFsdWVzIEpTIHZhbHVlcyB0byBjb252ZXJ0IHRvIFBheWxvYWRzXG4gKiBAcmV0dXJuIGxpc3Qgb2Yge0BsaW5rIFBheWxvYWR9c1xuICogQHRocm93cyB7QGxpbmsgVmFsdWVFcnJvcn0gaWYgY29udmVyc2lvbiBvZiB0aGUgdmFsdWUgcGFzc2VkIGFzIHBhcmFtZXRlciBmYWlsZWQgZm9yIGFueVxuICogICAgIHJlYXNvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUGF5bG9hZHMoY29udmVydGVyOiBQYXlsb2FkQ29udmVydGVyLCAuLi52YWx1ZXM6IHVua25vd25bXSk6IFBheWxvYWRbXSB8IHVuZGVmaW5lZCB7XG4gIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZXMubWFwKCh2YWx1ZSkgPT4gY29udmVydGVyLnRvUGF5bG9hZCh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFJ1biB7QGxpbmsgUGF5bG9hZENvbnZlcnRlci50b1BheWxvYWR9IG9uIGFuIG9wdGlvbmFsIHZhbHVlLCBhbmQgdGhlbiBlbmNvZGUgaXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0T3B0aW9uYWxUb1BheWxvYWQoXG4gIHBheWxvYWRDb252ZXJ0ZXI6IFBheWxvYWRDb252ZXJ0ZXIsXG4gIHZhbHVlOiB1bmtub3duXG4pOiBQYXlsb2FkIHwgbnVsbCB8IHVuZGVmaW5lZCB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdmFsdWU7XG5cbiAgcmV0dXJuIHBheWxvYWRDb252ZXJ0ZXIudG9QYXlsb2FkKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBSdW4ge0BsaW5rIFBheWxvYWRDb252ZXJ0ZXIudG9QYXlsb2FkfSBvbiBlYWNoIHZhbHVlIGluIHRoZSBtYXAuXG4gKlxuICogQHRocm93cyB7QGxpbmsgVmFsdWVFcnJvcn0gaWYgY29udmVyc2lvbiBvZiBhbnkgdmFsdWUgaW4gdGhlIG1hcCBmYWlsc1xuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwVG9QYXlsb2FkczxLIGV4dGVuZHMgc3RyaW5nLCBUID0gYW55PihcbiAgY29udmVydGVyOiBQYXlsb2FkQ29udmVydGVyLFxuICBtYXA6IFJlY29yZDxLLCBUPlxuKTogUmVjb3JkPEssIFBheWxvYWQ+IHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhtYXApLm1hcCgoW2ssIHZdKTogW0ssIFBheWxvYWRdID0+IFtrIGFzIEssIGNvbnZlcnRlci50b1BheWxvYWQodildKVxuICApIGFzIFJlY29yZDxLLCBQYXlsb2FkPjtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGNvbnZlcnNpb24gb2YgYW4gYXJyYXkgb2YgdmFsdWVzIG9mIGRpZmZlcmVudCB0eXBlcy4gVXNlZnVsIGZvciBkZXNlcmlhbGl6aW5nXG4gKiBhcmd1bWVudHMgb2YgZnVuY3Rpb24gaW52b2NhdGlvbnMuXG4gKlxuICogQHBhcmFtIGNvbnZlcnRlclxuICogQHBhcmFtIGluZGV4IGluZGV4IG9mIHRoZSB2YWx1ZSBpbiB0aGUgcGF5bG9hZHNcbiAqIEBwYXJhbSBwYXlsb2FkcyBzZXJpYWxpemVkIHZhbHVlIHRvIGNvbnZlcnQgdG8gSlMgdmFsdWVzLlxuICogQHJldHVybiBjb252ZXJ0ZWQgSlMgdmFsdWVcbiAqIEB0aHJvd3Mge0BsaW5rIFBheWxvYWRDb252ZXJ0ZXJFcnJvcn0gaWYgY29udmVyc2lvbiBvZiB0aGUgZGF0YSBwYXNzZWQgYXMgcGFyYW1ldGVyIGZhaWxlZCBmb3IgYW55XG4gKiAgICAgcmVhc29uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVBheWxvYWRzQXRJbmRleDxUPihjb252ZXJ0ZXI6IFBheWxvYWRDb252ZXJ0ZXIsIGluZGV4OiBudW1iZXIsIHBheWxvYWRzPzogUGF5bG9hZFtdIHwgbnVsbCk6IFQge1xuICAvLyBUbyBtYWtlIGFkZGluZyBhcmd1bWVudHMgYSBiYWNrd2FyZHMgY29tcGF0aWJsZSBjaGFuZ2VcbiAgaWYgKHBheWxvYWRzID09PSB1bmRlZmluZWQgfHwgcGF5bG9hZHMgPT09IG51bGwgfHwgaW5kZXggPj0gcGF5bG9hZHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZCBhcyBhbnk7XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnRlci5mcm9tUGF5bG9hZChwYXlsb2Fkc1tpbmRleF0pO1xufVxuXG4vKipcbiAqIFJ1biB7QGxpbmsgUGF5bG9hZENvbnZlcnRlci5mcm9tUGF5bG9hZH0gb24gZWFjaCB2YWx1ZSBpbiB0aGUgYXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcnJheUZyb21QYXlsb2Fkcyhjb252ZXJ0ZXI6IFBheWxvYWRDb252ZXJ0ZXIsIHBheWxvYWRzPzogUGF5bG9hZFtdIHwgbnVsbCk6IHVua25vd25bXSB7XG4gIGlmICghcGF5bG9hZHMpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIHBheWxvYWRzLm1hcCgocGF5bG9hZDogUGF5bG9hZCkgPT4gY29udmVydGVyLmZyb21QYXlsb2FkKHBheWxvYWQpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcEZyb21QYXlsb2FkczxLIGV4dGVuZHMgc3RyaW5nLCBUID0gdW5rbm93bj4oXG4gIGNvbnZlcnRlcjogUGF5bG9hZENvbnZlcnRlcixcbiAgbWFwPzogUmVjb3JkPEssIFBheWxvYWQ+IHwgbnVsbCB8IHVuZGVmaW5lZFxuKTogUmVjb3JkPEssIFQ+IHwgdW5kZWZpbmVkIHtcbiAgaWYgKG1hcCA9PSBudWxsKSByZXR1cm4gdW5kZWZpbmVkO1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKG1hcCkubWFwKChbaywgcGF5bG9hZF0pOiBbSywgdW5rbm93bl0gPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBjb252ZXJ0ZXIuZnJvbVBheWxvYWQocGF5bG9hZCBhcyBQYXlsb2FkKTtcbiAgICAgIHJldHVybiBbayBhcyBLLCB2YWx1ZV07XG4gICAgfSlcbiAgKSBhcyBSZWNvcmQ8SywgVD47XG59XG5cbmV4cG9ydCBkZWNsYXJlIGNvbnN0IHJhd1BheWxvYWRUeXBlQnJhbmQ6IHVuaXF1ZSBzeW1ib2w7XG4vKipcbiAqIFJhd1ZhbHVlIGlzIGEgd3JhcHBlciBvdmVyIGEgcGF5bG9hZC5cbiAqIEEgcGF5bG9hZCB0aGF0IGJlbG9uZ3MgdG8gYSBSYXdWYWx1ZSBpcyBzcGVjaWFsIGluIHRoYXQgaXQgYnlwYXNzZXMgdXNlci1kZWZpbmVkIHBheWxvYWQgY29udmVydGVycyxcbiAqIGluc3RlYWQgdXNpbmcgdGhlIGRlZmF1bHQgcGF5bG9hZCBjb252ZXJ0ZXIuIFRoZSBwYXlsb2FkIHN0aWxsIHVuZGVyZ29lcyBjb2RlYyBjb252ZXJzaW9uLlxuICovXG5leHBvcnQgY2xhc3MgUmF3VmFsdWU8VCA9IHVua25vd24+IHtcbiAgcHJpdmF0ZSByZWFkb25seSBfcGF5bG9hZDogUGF5bG9hZDtcbiAgcHJpdmF0ZSByZWFkb25seSBbcmF3UGF5bG9hZFR5cGVCcmFuZF06IFQgPSB1bmRlZmluZWQgYXMgVDtcblxuICBjb25zdHJ1Y3Rvcih2YWx1ZTogVCwgcGF5bG9hZENvbnZlcnRlcjogUGF5bG9hZENvbnZlcnRlciA9IGRlZmF1bHRQYXlsb2FkQ29udmVydGVyKSB7XG4gICAgdGhpcy5fcGF5bG9hZCA9IHBheWxvYWRDb252ZXJ0ZXIudG9QYXlsb2FkKHZhbHVlKTtcbiAgfVxuXG4gIGdldCBwYXlsb2FkKCk6IFBheWxvYWQge1xuICAgIHJldHVybiB0aGlzLl9wYXlsb2FkO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGF5bG9hZENvbnZlcnRlcldpdGhFbmNvZGluZyB7XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHZhbHVlIHRvIGEge0BsaW5rIFBheWxvYWR9LlxuICAgKlxuICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuIEV4YW1wbGUgdmFsdWVzIGluY2x1ZGUgdGhlIFdvcmtmbG93IGFyZ3Mgc2VudCBmcm9tIHRoZSBDbGllbnQgYW5kIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgYSBXb3JrZmxvdyBvciBBY3Rpdml0eS5cbiAgICogQHJldHVybnMgVGhlIHtAbGluayBQYXlsb2FkfSwgb3IgYHVuZGVmaW5lZGAgaWYgdW5hYmxlIHRvIGNvbnZlcnQuXG4gICAqL1xuICB0b1BheWxvYWQ8VD4odmFsdWU6IFQpOiBQYXlsb2FkIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHtAbGluayBQYXlsb2FkfSBiYWNrIHRvIGEgdmFsdWUuXG4gICAqL1xuICBmcm9tUGF5bG9hZDxUPihwYXlsb2FkOiBQYXlsb2FkKTogVDtcblxuICByZWFkb25seSBlbmNvZGluZ1R5cGU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBUcmllcyB0byBjb252ZXJ0IHZhbHVlcyB0byB7QGxpbmsgUGF5bG9hZH1zIHVzaW5nIHRoZSB7QGxpbmsgUGF5bG9hZENvbnZlcnRlcldpdGhFbmNvZGluZ31zIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3RvciwgaW4gdGhlIG9yZGVyIHByb3ZpZGVkLlxuICpcbiAqIENvbnZlcnRzIFBheWxvYWRzIHRvIHZhbHVlcyBiYXNlZCBvbiB0aGUgYFBheWxvYWQubWV0YWRhdGEuZW5jb2RpbmdgIGZpZWxkLCB3aGljaCBtYXRjaGVzIHRoZSB7QGxpbmsgUGF5bG9hZENvbnZlcnRlcldpdGhFbmNvZGluZy5lbmNvZGluZ1R5cGV9XG4gKiBvZiB0aGUgY29udmVydGVyIHRoYXQgY3JlYXRlZCB0aGUgUGF5bG9hZC5cbiAqL1xuZXhwb3J0IGNsYXNzIENvbXBvc2l0ZVBheWxvYWRDb252ZXJ0ZXIgaW1wbGVtZW50cyBQYXlsb2FkQ29udmVydGVyIHtcbiAgcmVhZG9ubHkgY29udmVydGVyczogUGF5bG9hZENvbnZlcnRlcldpdGhFbmNvZGluZ1tdO1xuICByZWFkb25seSBjb252ZXJ0ZXJCeUVuY29kaW5nOiBNYXA8c3RyaW5nLCBQYXlsb2FkQ29udmVydGVyV2l0aEVuY29kaW5nPiA9IG5ldyBNYXAoKTtcblxuICBjb25zdHJ1Y3RvciguLi5jb252ZXJ0ZXJzOiBQYXlsb2FkQ29udmVydGVyV2l0aEVuY29kaW5nW10pIHtcbiAgICBpZiAoY29udmVydGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBQYXlsb2FkQ29udmVydGVyRXJyb3IoJ011c3QgcHJvdmlkZSBhdCBsZWFzdCBvbmUgUGF5bG9hZENvbnZlcnRlcldpdGhFbmNvZGluZycpO1xuICAgIH1cblxuICAgIHRoaXMuY29udmVydGVycyA9IGNvbnZlcnRlcnM7XG4gICAgZm9yIChjb25zdCBjb252ZXJ0ZXIgb2YgY29udmVydGVycykge1xuICAgICAgdGhpcy5jb252ZXJ0ZXJCeUVuY29kaW5nLnNldChjb252ZXJ0ZXIuZW5jb2RpbmdUeXBlLCBjb252ZXJ0ZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmllcyB0byBydW4gYC50b1BheWxvYWQodmFsdWUpYCBvbiBlYWNoIGNvbnZlcnRlciBpbiB0aGUgb3JkZXIgcHJvdmlkZWQgYXQgY29uc3RydWN0aW9uLlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBzdWNjZXNzZnVsIHJlc3VsdCwgdGhyb3dzIHtAbGluayBWYWx1ZUVycm9yfSBpZiB0aGVyZSBpcyBubyBjb252ZXJ0ZXIgdGhhdCBjYW4gaGFuZGxlIHRoZSB2YWx1ZS5cbiAgICovXG4gIHB1YmxpYyB0b1BheWxvYWQ8VD4odmFsdWU6IFQpOiBQYXlsb2FkIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBSYXdWYWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnBheWxvYWQ7XG4gICAgfVxuICAgIGZvciAoY29uc3QgY29udmVydGVyIG9mIHRoaXMuY29udmVydGVycykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY29udmVydGVyLnRvUGF5bG9hZCh2YWx1ZSk7XG4gICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihgVW5hYmxlIHRvIGNvbnZlcnQgJHt2YWx1ZX0gdG8gcGF5bG9hZGApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biB7QGxpbmsgUGF5bG9hZENvbnZlcnRlcldpdGhFbmNvZGluZy5mcm9tUGF5bG9hZH0gYmFzZWQgb24gdGhlIGBlbmNvZGluZ2AgbWV0YWRhdGEgb2YgdGhlIHtAbGluayBQYXlsb2FkfS5cbiAgICovXG4gIHB1YmxpYyBmcm9tUGF5bG9hZDxUPihwYXlsb2FkOiBQYXlsb2FkKTogVCB7XG4gICAgaWYgKHBheWxvYWQubWV0YWRhdGEgPT09IHVuZGVmaW5lZCB8fCBwYXlsb2FkLm1ldGFkYXRhID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcignTWlzc2luZyBwYXlsb2FkIG1ldGFkYXRhJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZW5jb2RpbmcgPSBkZWNvZGUocGF5bG9hZC5tZXRhZGF0YVtNRVRBREFUQV9FTkNPRElOR19LRVldKTtcbiAgICBjb25zdCBjb252ZXJ0ZXIgPSB0aGlzLmNvbnZlcnRlckJ5RW5jb2RpbmcuZ2V0KGVuY29kaW5nKTtcbiAgICBpZiAoY29udmVydGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKGBVbmtub3duIGVuY29kaW5nOiAke2VuY29kaW5nfWApO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydGVyLmZyb21QYXlsb2FkKHBheWxvYWQpO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYmV0d2VlbiBKUyB1bmRlZmluZWQgYW5kIE5VTEwgUGF5bG9hZFxuICovXG5leHBvcnQgY2xhc3MgVW5kZWZpbmVkUGF5bG9hZENvbnZlcnRlciBpbXBsZW1lbnRzIFBheWxvYWRDb252ZXJ0ZXJXaXRoRW5jb2Rpbmcge1xuICBwdWJsaWMgZW5jb2RpbmdUeXBlID0gZW5jb2RpbmdUeXBlcy5NRVRBREFUQV9FTkNPRElOR19OVUxMO1xuXG4gIHB1YmxpYyB0b1BheWxvYWQodmFsdWU6IHVua25vd24pOiBQYXlsb2FkIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgW01FVEFEQVRBX0VOQ09ESU5HX0tFWV06IGVuY29kaW5nS2V5cy5NRVRBREFUQV9FTkNPRElOR19OVUxMLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGZyb21QYXlsb2FkPFQ+KF9jb250ZW50OiBQYXlsb2FkKTogVCB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZCBhcyBhbnk7IC8vIEp1c3QgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYmV0d2VlbiBiaW5hcnkgZGF0YSB0eXBlcyBhbmQgUkFXIFBheWxvYWRcbiAqL1xuZXhwb3J0IGNsYXNzIEJpbmFyeVBheWxvYWRDb252ZXJ0ZXIgaW1wbGVtZW50cyBQYXlsb2FkQ29udmVydGVyV2l0aEVuY29kaW5nIHtcbiAgcHVibGljIGVuY29kaW5nVHlwZSA9IGVuY29kaW5nVHlwZXMuTUVUQURBVEFfRU5DT0RJTkdfUkFXO1xuXG4gIHB1YmxpYyB0b1BheWxvYWQodmFsdWU6IHVua25vd24pOiBQYXlsb2FkIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICBbTUVUQURBVEFfRU5DT0RJTkdfS0VZXTogZW5jb2RpbmdLZXlzLk1FVEFEQVRBX0VOQ09ESU5HX1JBVyxcbiAgICAgIH0sXG4gICAgICBkYXRhOiB2YWx1ZSxcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGZyb21QYXlsb2FkPFQ+KGNvbnRlbnQ6IFBheWxvYWQpOiBUIHtcbiAgICByZXR1cm4gKFxuICAgICAgLy8gV3JhcCB3aXRoIFVpbnQ4QXJyYXkgZnJvbSB0aGlzIGNvbnRleHQgdG8gZW5zdXJlIGBpbnN0YW5jZW9mYCB3b3Jrc1xuICAgICAgKFxuICAgICAgICBjb250ZW50LmRhdGEgPyBuZXcgVWludDhBcnJheShjb250ZW50LmRhdGEuYnVmZmVyLCBjb250ZW50LmRhdGEuYnl0ZU9mZnNldCwgY29udGVudC5kYXRhLmxlbmd0aCkgOiBjb250ZW50LmRhdGFcbiAgICAgICkgYXMgYW55XG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGJldHdlZW4gbm9uLXVuZGVmaW5lZCB2YWx1ZXMgYW5kIHNlcmlhbGl6ZWQgSlNPTiBQYXlsb2FkXG4gKi9cbmV4cG9ydCBjbGFzcyBKc29uUGF5bG9hZENvbnZlcnRlciBpbXBsZW1lbnRzIFBheWxvYWRDb252ZXJ0ZXJXaXRoRW5jb2Rpbmcge1xuICBwdWJsaWMgZW5jb2RpbmdUeXBlID0gZW5jb2RpbmdUeXBlcy5NRVRBREFUQV9FTkNPRElOR19KU09OO1xuXG4gIHB1YmxpYyB0b1BheWxvYWQodmFsdWU6IHVua25vd24pOiBQYXlsb2FkIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBsZXQganNvbjtcbiAgICB0cnkge1xuICAgICAganNvbiA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9IGNhdGNoIChfZXJyKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICBbTUVUQURBVEFfRU5DT0RJTkdfS0VZXTogZW5jb2RpbmdLZXlzLk1FVEFEQVRBX0VOQ09ESU5HX0pTT04sXG4gICAgICB9LFxuICAgICAgZGF0YTogZW5jb2RlKGpzb24pLFxuICAgIH07XG4gIH1cblxuICBwdWJsaWMgZnJvbVBheWxvYWQ8VD4oY29udGVudDogUGF5bG9hZCk6IFQge1xuICAgIGlmIChjb250ZW50LmRhdGEgPT09IHVuZGVmaW5lZCB8fCBjb250ZW50LmRhdGEgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKCdHb3QgcGF5bG9hZCB3aXRoIG5vIGRhdGEnKTtcbiAgICB9XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlKGNvbnRlbnQuZGF0YSkpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBEZWZhdWx0UGF5bG9hZENvbnZlcnRlciBleHRlbmRzIENvbXBvc2l0ZVBheWxvYWRDb252ZXJ0ZXIge1xuICAvLyBNYXRjaCB0aGUgb3JkZXIgdXNlZCBpbiBvdGhlciBTREtzLCBidXQgZXhjbHVkZSBQcm90b2J1ZiBjb252ZXJ0ZXJzIHNvIHRoYXQgdGhlIGNvZGUsIGluY2x1ZGluZ1xuICAvLyBgcHJvdG8zLWpzb24tc2VyaWFsaXplcmAsIGRvZXNuJ3QgdGFrZSBzcGFjZSBpbiBXb3JrZmxvdyBidW5kbGVzIHRoYXQgZG9uJ3QgdXNlIFByb3RvYnVmcy4gVG8gdXNlIFByb3RvYnVmcywgdXNlXG4gIC8vIHtAbGluayBEZWZhdWx0UGF5bG9hZENvbnZlcnRlcldpdGhQcm90b2J1ZnN9LlxuICAvL1xuICAvLyBHbyBTREs6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90ZW1wb3JhbGlvL3Nkay1nby9ibG9iLzVlNTY0NWYwYzU1MGRjZjcxN2MwOTVhZTMyYzc2YTcwODdkMmU5ODUvY29udmVydGVyL2RlZmF1bHRfZGF0YV9jb252ZXJ0ZXIuZ28jTDI4XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKG5ldyBVbmRlZmluZWRQYXlsb2FkQ29udmVydGVyKCksIG5ldyBCaW5hcnlQYXlsb2FkQ29udmVydGVyKCksIG5ldyBKc29uUGF5bG9hZENvbnZlcnRlcigpKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHtAbGluayBQYXlsb2FkQ29udmVydGVyfSB1c2VkIGJ5IHRoZSBTREsuIFN1cHBvcnRzIGBVaW50OEFycmF5YCBhbmQgSlNPTiBzZXJpYWxpemFibGVzIChzbyBpZlxuICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0pTT04vc3RyaW5naWZ5I2Rlc2NyaXB0aW9uIHwgYEpTT04uc3RyaW5naWZ5KHlvdXJBcmdPclJldHZhbClgfVxuICogd29ya3MsIHRoZSBkZWZhdWx0IHBheWxvYWQgY29udmVydGVyIHdpbGwgd29yaykuXG4gKlxuICogVG8gYWxzbyBzdXBwb3J0IFByb3RvYnVmcywgY3JlYXRlIGEgY3VzdG9tIHBheWxvYWQgY29udmVydGVyIHdpdGgge0BsaW5rIERlZmF1bHRQYXlsb2FkQ29udmVydGVyfTpcbiAqXG4gKiBgY29uc3QgbXlDb252ZXJ0ZXIgPSBuZXcgRGVmYXVsdFBheWxvYWRDb252ZXJ0ZXIoeyBwcm90b2J1ZlJvb3QgfSlgXG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0UGF5bG9hZENvbnZlcnRlciA9IG5ldyBEZWZhdWx0UGF5bG9hZENvbnZlcnRlcigpO1xuIiwiaW1wb3J0IHsgZGVjb2RlLCBlbmNvZGUgfSBmcm9tICcuLi9lbmNvZGluZyc7XG5pbXBvcnQgeyBWYWx1ZUVycm9yIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IFBheWxvYWQgfSBmcm9tICcuLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7XG4gIFR5cGVkU2VhcmNoQXR0cmlidXRlcyxcbiAgU2VhcmNoQXR0cmlidXRlVHlwZSxcbiAgU2VhcmNoQXR0cmlidXRlcyxcbiAgaXNWYWxpZFZhbHVlRm9yVHlwZSxcbiAgVHlwZWRTZWFyY2hBdHRyaWJ1dGVWYWx1ZSxcbiAgU2VhcmNoQXR0cmlidXRlUGFpcixcbiAgU2VhcmNoQXR0cmlidXRlVXBkYXRlUGFpcixcbiAgVHlwZWRTZWFyY2hBdHRyaWJ1dGVVcGRhdGVWYWx1ZSxcbn0gZnJvbSAnLi4vc2VhcmNoLWF0dHJpYnV0ZXMnO1xuaW1wb3J0IHsgUGF5bG9hZENvbnZlcnRlciwgSnNvblBheWxvYWRDb252ZXJ0ZXIsIG1hcEZyb21QYXlsb2FkcywgbWFwVG9QYXlsb2FkcyB9IGZyb20gJy4vcGF5bG9hZC1jb252ZXJ0ZXInO1xuXG4vKipcbiAqIENvbnZlcnRzIFNlYXJjaCBBdHRyaWJ1dGUgdmFsdWVzIHVzaW5nIEpzb25QYXlsb2FkQ29udmVydGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBTZWFyY2hBdHRyaWJ1dGVQYXlsb2FkQ29udmVydGVyIGltcGxlbWVudHMgUGF5bG9hZENvbnZlcnRlciB7XG4gIGpzb25Db252ZXJ0ZXIgPSBuZXcgSnNvblBheWxvYWRDb252ZXJ0ZXIoKTtcbiAgdmFsaWROb25EYXRlVHlwZXMgPSBbJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddO1xuXG4gIHB1YmxpYyB0b1BheWxvYWQodmFsdWVzOiB1bmtub3duKTogUGF5bG9hZCB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKGBTZWFyY2hBdHRyaWJ1dGUgdmFsdWUgbXVzdCBiZSBhbiBhcnJheWApO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IHZhbHVlc1swXTtcbiAgICAgIGNvbnN0IGZpcnN0VHlwZSA9IHR5cGVvZiBmaXJzdFZhbHVlO1xuICAgICAgaWYgKGZpcnN0VHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yIChjb25zdCBbaWR4LCB2YWx1ZV0gb2YgdmFsdWVzLmVudHJpZXMoKSkge1xuICAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgICBgU2VhcmNoQXR0cmlidXRlIHZhbHVlcyBtdXN0IGFycmF5cyBvZiBzdHJpbmdzLCBudW1iZXJzLCBib29sZWFucywgb3IgRGF0ZXMuIFRoZSB2YWx1ZSAke3ZhbHVlfSBhdCBpbmRleCAke2lkeH0gaXMgb2YgdHlwZSAke3R5cGVvZiB2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkTm9uRGF0ZVR5cGVzLmluY2x1ZGVzKGZpcnN0VHlwZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihgU2VhcmNoQXR0cmlidXRlIGFycmF5IHZhbHVlcyBtdXN0IGJlOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZWApO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBbaWR4LCB2YWx1ZV0gb2YgdmFsdWVzLmVudHJpZXMoKSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IGZpcnN0VHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICAgIGBBbGwgU2VhcmNoQXR0cmlidXRlIGFycmF5IHZhbHVlcyBtdXN0IGJlIG9mIHRoZSBzYW1lIHR5cGUuIFRoZSBmaXJzdCB2YWx1ZSAke2ZpcnN0VmFsdWV9IG9mIHR5cGUgJHtmaXJzdFR5cGV9IGRvZXNuJ3QgbWF0Y2ggdmFsdWUgJHt2YWx1ZX0gb2YgdHlwZSAke3R5cGVvZiB2YWx1ZX0gYXQgaW5kZXggJHtpZHh9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBKU09OLnN0cmluZ2lmeSB0YWtlcyBjYXJlIG9mIGNvbnZlcnRpbmcgRGF0ZXMgdG8gSVNPIHN0cmluZ3NcbiAgICBjb25zdCByZXQgPSB0aGlzLmpzb25Db252ZXJ0ZXIudG9QYXlsb2FkKHZhbHVlcyk7XG4gICAgaWYgKHJldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcignQ291bGQgbm90IGNvbnZlcnQgc2VhcmNoIGF0dHJpYnV0ZXMgdG8gcGF5bG9hZHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEYXRldGltZSBTZWFyY2ggQXR0cmlidXRlIHZhbHVlcyBhcmUgY29udmVydGVkIHRvIGBEYXRlYHNcbiAgICovXG4gIHB1YmxpYyBmcm9tUGF5bG9hZDxUPihwYXlsb2FkOiBQYXlsb2FkKTogVCB7XG4gICAgaWYgKHBheWxvYWQubWV0YWRhdGEgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoJ01pc3NpbmcgcGF5bG9hZCBtZXRhZGF0YScpO1xuICAgIH1cblxuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5qc29uQ29udmVydGVyLmZyb21QYXlsb2FkKHBheWxvYWQpO1xuICAgIGxldCBhcnJheVdyYXBwZWRWYWx1ZSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgIGNvbnN0IHNlYXJjaEF0dHJpYnV0ZVR5cGUgPSBkZWNvZGUocGF5bG9hZC5tZXRhZGF0YS50eXBlKTtcbiAgICBpZiAoc2VhcmNoQXR0cmlidXRlVHlwZSA9PT0gJ0RhdGV0aW1lJykge1xuICAgICAgYXJyYXlXcmFwcGVkVmFsdWUgPSBhcnJheVdyYXBwZWRWYWx1ZS5tYXAoKGRhdGVTdHJpbmcpID0+IG5ldyBEYXRlKGRhdGVTdHJpbmcpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5V3JhcHBlZFZhbHVlIGFzIHVua25vd24gYXMgVDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc2VhcmNoQXR0cmlidXRlUGF5bG9hZENvbnZlcnRlciA9IG5ldyBTZWFyY2hBdHRyaWJ1dGVQYXlsb2FkQ29udmVydGVyKCk7XG5cbmV4cG9ydCBjbGFzcyBUeXBlZFNlYXJjaEF0dHJpYnV0ZVBheWxvYWRDb252ZXJ0ZXIgaW1wbGVtZW50cyBQYXlsb2FkQ29udmVydGVyIHtcbiAganNvbkNvbnZlcnRlciA9IG5ldyBKc29uUGF5bG9hZENvbnZlcnRlcigpO1xuXG4gIHB1YmxpYyB0b1BheWxvYWQ8VD4oYXR0cjogVCk6IFBheWxvYWQge1xuICAgIGlmICghKGF0dHIgaW5zdGFuY2VvZiBUeXBlZFNlYXJjaEF0dHJpYnV0ZVZhbHVlIHx8IGF0dHIgaW5zdGFuY2VvZiBUeXBlZFNlYXJjaEF0dHJpYnV0ZVVwZGF0ZVZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgIGBFeHBlY3QgaW5wdXQgdG8gYmUgaW5zdGFuY2Ugb2YgVHlwZWRTZWFyY2hBdHRyaWJ1dGVWYWx1ZSBvciBUeXBlZFNlYXJjaEF0dHJpYnV0ZVVwZGF0ZVZhbHVlLCBnb3Q6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgYXR0clxuICAgICAgICApfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gV2UgY2hlY2sgZm9yIGRlbGV0aW9uIGFzIHdlbGwgYXMgcmVndWxhciB0eXBlZCBzZWFyY2ggYXR0cmlidXRlcy5cbiAgICBpZiAoYXR0ci52YWx1ZSAhPT0gbnVsbCAmJiAhaXNWYWxpZFZhbHVlRm9yVHlwZShhdHRyLnR5cGUsIGF0dHIudmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihgSW52YWxpZCBzZWFyY2ggYXR0cmlidXRlIHZhbHVlICR7YXR0ci52YWx1ZX0gZm9yIGdpdmVuIHR5cGUgJHthdHRyLnR5cGV9YCk7XG4gICAgfVxuXG4gICAgLy8gRm9yIHNlcnZlciBzZWFyY2ggYXR0cmlidXRlcyB0byB3b3JrIHByb3Blcmx5LCB3ZSBjYW5ub3Qgc2V0IHRoZSBtZXRhZGF0YVxuICAgIC8vIHR5cGUgd2hlbiB3ZSBzZXQgbnVsbFxuICAgIGlmIChhdHRyLnZhbHVlID09PSBudWxsKSB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gdGhpcy5qc29uQ29udmVydGVyLnRvUGF5bG9hZChhdHRyLnZhbHVlKTtcbiAgICAgIGlmIChwYXlsb2FkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IHR5cGVkIHNlYXJjaCBhdHRyaWJ1dGUgdG8gcGF5bG9hZCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfVxuXG4gICAgLy8gSlNPTi5zdHJpbmdpZnkgdGFrZXMgY2FyZSBvZiBjb252ZXJ0aW5nIERhdGVzIHRvIElTTyBzdHJpbmdzXG4gICAgY29uc3QgcGF5bG9hZCA9IHRoaXMuanNvbkNvbnZlcnRlci50b1BheWxvYWQoYXR0ci52YWx1ZSk7XG4gICAgaWYgKHBheWxvYWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IHR5cGVkIHNlYXJjaCBhdHRyaWJ1dGUgdG8gcGF5bG9hZCcpO1xuICAgIH1cblxuICAgIC8vIE5vdGU6IHRoaXMgc2hvdWxkbid0IGJlIHRoZSBjYXNlIGJ1dCB0aGUgY29tcGlsZXIgY29tcGxhaW5zIHdpdGhvdXQgdGhpcyBjaGVjay5cbiAgICBpZiAocGF5bG9hZC5tZXRhZGF0YSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcignTWlzc2luZyBwYXlsb2FkIG1ldGFkYXRhJyk7XG4gICAgfVxuICAgIC8vIEFkZCBlbmNvZGVkIHR5cGUgb2Ygc2VhcmNoIGF0dHJpYnV0ZSB0byBtZXRhdGRhdGFcbiAgICBwYXlsb2FkLm1ldGFkYXRhWyd0eXBlJ10gPSBlbmNvZGUoVHlwZWRTZWFyY2hBdHRyaWJ1dGVzLnRvTWV0YWRhdGFUeXBlKGF0dHIudHlwZSkpO1xuICAgIHJldHVybiBwYXlsb2FkO1xuICB9XG5cbiAgLy8gTm90ZTogdHlwZSBjYXN0aW5nIHVuZGVmaW5lZCB2YWx1ZXMgaXMgbm90IGNsZWFyIHRvIGNhbGxlci5cbiAgLy8gV2UgY2FuJ3QgY2hhbmdlIHRoZSB0eXBpbmcgb2YgdGhlIG1ldGhvZCB0byByZXR1cm4gdW5kZWZpbmVkLCBpdCdzIG5vdCBhbGxvd2VkIGJ5IHRoZSBpbnRlcmZhY2UuXG4gIHB1YmxpYyBmcm9tUGF5bG9hZDxUPihwYXlsb2FkOiBQYXlsb2FkKTogVCB7XG4gICAgaWYgKHBheWxvYWQubWV0YWRhdGEgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoJ01pc3NpbmcgcGF5bG9hZCBtZXRhZGF0YScpO1xuICAgIH1cblxuICAgIC8vIElmIG5vICd0eXBlJyBtZXRhZGF0YSBmaWVsZCBvciBubyBnaXZlbiB2YWx1ZSwgd2Ugc2tpcC5cbiAgICBpZiAocGF5bG9hZC5tZXRhZGF0YS50eXBlID09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQgYXMgVDtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IFR5cGVkU2VhcmNoQXR0cmlidXRlcy50b1NlYXJjaEF0dHJpYnV0ZVR5cGUoZGVjb2RlKHBheWxvYWQubWV0YWRhdGEudHlwZSkpO1xuICAgIC8vIFVucmVjb2duaXplZCBtZXRhZGF0YSB0eXBlIChzYW5pdHkgY2hlY2spLlxuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQgYXMgVDtcbiAgICB9XG5cbiAgICBsZXQgdmFsdWUgPSB0aGlzLmpzb25Db252ZXJ0ZXIuZnJvbVBheWxvYWQocGF5bG9hZCk7XG5cbiAgICAvLyBIYW5kbGUgbGVnYWN5IHZhbHVlcyB3aXRob3V0IEtFWVdPUkRfTElTVCB0eXBlLlxuICAgIGlmICh0eXBlICE9PSBTZWFyY2hBdHRyaWJ1dGVUeXBlLktFWVdPUkRfTElTVCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgLy8gQ2Fubm90IGhhdmUgYW4gYXJyYXkgd2l0aCBtdWx0aXBsZSB2YWx1ZXMgZm9yIG5vbi1LRVlXT1JEX0xJU1QgdHlwZS5cbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQgYXMgVDtcbiAgICAgIH1cbiAgICAgIC8vIFVucGFjayBzaW5nbGUgdmFsdWUgYXJyYXkuXG4gICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gU2VhcmNoQXR0cmlidXRlVHlwZS5EQVRFVElNRSAmJiB2YWx1ZSkge1xuICAgICAgdmFsdWUgPSBuZXcgRGF0ZSh2YWx1ZSBhcyBzdHJpbmcpO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiB0aGUgdmFsdWUgaXMgYSB2YWxpZCBmb3IgdGhlIGdpdmVuIHR5cGUuIElmIG5vdCwgc2tpcC5cbiAgICBpZiAoIWlzVmFsaWRWYWx1ZUZvclR5cGUodHlwZSwgdmFsdWUpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkIGFzIFQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHlwZWRTZWFyY2hBdHRyaWJ1dGVWYWx1ZSh0eXBlLCB2YWx1ZSkgYXMgVDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdHlwZWRTZWFyY2hBdHRyaWJ1dGVQYXlsb2FkQ29udmVydGVyID0gbmV3IFR5cGVkU2VhcmNoQXR0cmlidXRlUGF5bG9hZENvbnZlcnRlcigpO1xuXG4vLyBJZiBib3RoIHBhcmFtcyBhcmUgcHJvdmlkZWQsIGNvbmZsaWN0aW5nIGtleXMgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0eXBlZFNlYXJjaEF0dHJpYnV0ZXMuXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlVW5pZmllZFNlYXJjaEF0dHJpYnV0ZXMoXG4gIHNlYXJjaEF0dHJpYnV0ZXM/OiBTZWFyY2hBdHRyaWJ1dGVzLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIHR5cGVkU2VhcmNoQXR0cmlidXRlcz86IFR5cGVkU2VhcmNoQXR0cmlidXRlcyB8IFNlYXJjaEF0dHJpYnV0ZVVwZGF0ZVBhaXJbXVxuKTogUmVjb3JkPHN0cmluZywgUGF5bG9hZD4ge1xuICByZXR1cm4ge1xuICAgIC4uLihzZWFyY2hBdHRyaWJ1dGVzID8gbWFwVG9QYXlsb2FkcyhzZWFyY2hBdHRyaWJ1dGVQYXlsb2FkQ29udmVydGVyLCBzZWFyY2hBdHRyaWJ1dGVzKSA6IHt9KSxcbiAgICAuLi4odHlwZWRTZWFyY2hBdHRyaWJ1dGVzXG4gICAgICA/IG1hcFRvUGF5bG9hZHM8c3RyaW5nLCBUeXBlZFNlYXJjaEF0dHJpYnV0ZVVwZGF0ZVZhbHVlPFNlYXJjaEF0dHJpYnV0ZVR5cGU+PihcbiAgICAgICAgICB0eXBlZFNlYXJjaEF0dHJpYnV0ZVBheWxvYWRDb252ZXJ0ZXIsXG4gICAgICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkodHlwZWRTZWFyY2hBdHRyaWJ1dGVzKSA/IHR5cGVkU2VhcmNoQXR0cmlidXRlcyA6IHR5cGVkU2VhcmNoQXR0cmlidXRlcy5nZXRBbGwoKSkubWFwKFxuICAgICAgICAgICAgICAocGFpcikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBbcGFpci5rZXkubmFtZSwgbmV3IFR5cGVkU2VhcmNoQXR0cmlidXRlVXBkYXRlVmFsdWUocGFpci5rZXkudHlwZSwgcGFpci52YWx1ZSldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICA6IHt9KSxcbiAgfTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlU2VhcmNoQXR0cmlidXRlcyhpbmRleGVkRmllbGRzOiBSZWNvcmQ8c3RyaW5nLCBQYXlsb2FkPiB8IHVuZGVmaW5lZCB8IG51bGwpOiBTZWFyY2hBdHRyaWJ1dGVzIHtcbiAgaWYgKCFpbmRleGVkRmllbGRzKSByZXR1cm4ge307XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgT2JqZWN0LmVudHJpZXMobWFwRnJvbVBheWxvYWRzKHNlYXJjaEF0dHJpYnV0ZVBheWxvYWRDb252ZXJ0ZXIsIGluZGV4ZWRGaWVsZHMpIGFzIFNlYXJjaEF0dHJpYnV0ZXMpLmZpbHRlcihcbiAgICAgIChbXywgdl0pID0+IHYgJiYgdi5sZW5ndGggPiAwXG4gICAgKSAvLyBGaWx0ZXIgb3V0IGVtcHR5IGFycmF5cyByZXR1cm5lZCBieSBwcmUgMS4xOCBzZXJ2ZXJzXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUeXBlZFNlYXJjaEF0dHJpYnV0ZXMoXG4gIGluZGV4ZWRGaWVsZHM6IFJlY29yZDxzdHJpbmcsIFBheWxvYWQ+IHwgdW5kZWZpbmVkIHwgbnVsbFxuKTogVHlwZWRTZWFyY2hBdHRyaWJ1dGVzIHtcbiAgcmV0dXJuIG5ldyBUeXBlZFNlYXJjaEF0dHJpYnV0ZXMoXG4gICAgT2JqZWN0LmVudHJpZXMoXG4gICAgICBtYXBGcm9tUGF5bG9hZHM8c3RyaW5nLCBUeXBlZFNlYXJjaEF0dHJpYnV0ZVZhbHVlPFNlYXJjaEF0dHJpYnV0ZVR5cGU+IHwgdW5kZWZpbmVkPihcbiAgICAgICAgdHlwZWRTZWFyY2hBdHRyaWJ1dGVQYXlsb2FkQ29udmVydGVyLFxuICAgICAgICBpbmRleGVkRmllbGRzXG4gICAgICApID8/IHt9XG4gICAgKS5yZWR1Y2U8U2VhcmNoQXR0cmlidXRlUGFpcltdPigoYWNjLCBbaywgYXR0cl0pID0+IHtcbiAgICAgIC8vIEZpbHRlciBvdXQgdW5kZWZpbmVkIHZhbHVlcyBmcm9tIGNvbnZlcnRlci5cbiAgICAgIGlmICghYXR0cikge1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgICAgY29uc3Qga2V5ID0geyBuYW1lOiBrLCB0eXBlOiBhdHRyLnR5cGUgfTtcbiAgICAgIC8vIEVuc3VyZSBpcyB2YWxpZCBwYWlyLlxuICAgICAgaWYgKGlzVmFsaWRWYWx1ZUZvclR5cGUoa2V5LnR5cGUsIGF0dHIudmFsdWUpKSB7XG4gICAgICAgIGFjYy5wdXNoKHsga2V5LCB2YWx1ZTogYXR0ci52YWx1ZSB9IGFzIFNlYXJjaEF0dHJpYnV0ZVBhaXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSlcbiAgKTtcbn1cbiIsImltcG9ydCB7IGVuY29kZSB9IGZyb20gJy4uL2VuY29kaW5nJztcblxuZXhwb3J0IGNvbnN0IE1FVEFEQVRBX0VOQ09ESU5HX0tFWSA9ICdlbmNvZGluZyc7XG5leHBvcnQgY29uc3QgZW5jb2RpbmdUeXBlcyA9IHtcbiAgTUVUQURBVEFfRU5DT0RJTkdfTlVMTDogJ2JpbmFyeS9udWxsJyxcbiAgTUVUQURBVEFfRU5DT0RJTkdfUkFXOiAnYmluYXJ5L3BsYWluJyxcbiAgTUVUQURBVEFfRU5DT0RJTkdfSlNPTjogJ2pzb24vcGxhaW4nLFxuICBNRVRBREFUQV9FTkNPRElOR19QUk9UT0JVRl9KU09OOiAnanNvbi9wcm90b2J1ZicsXG4gIE1FVEFEQVRBX0VOQ09ESU5HX1BST1RPQlVGOiAnYmluYXJ5L3Byb3RvYnVmJyxcbn0gYXMgY29uc3Q7XG5leHBvcnQgdHlwZSBFbmNvZGluZ1R5cGUgPSAodHlwZW9mIGVuY29kaW5nVHlwZXMpW2tleW9mIHR5cGVvZiBlbmNvZGluZ1R5cGVzXTtcblxuZXhwb3J0IGNvbnN0IGVuY29kaW5nS2V5cyA9IHtcbiAgTUVUQURBVEFfRU5DT0RJTkdfTlVMTDogZW5jb2RlKGVuY29kaW5nVHlwZXMuTUVUQURBVEFfRU5DT0RJTkdfTlVMTCksXG4gIE1FVEFEQVRBX0VOQ09ESU5HX1JBVzogZW5jb2RlKGVuY29kaW5nVHlwZXMuTUVUQURBVEFfRU5DT0RJTkdfUkFXKSxcbiAgTUVUQURBVEFfRU5DT0RJTkdfSlNPTjogZW5jb2RlKGVuY29kaW5nVHlwZXMuTUVUQURBVEFfRU5DT0RJTkdfSlNPTiksXG4gIE1FVEFEQVRBX0VOQ09ESU5HX1BST1RPQlVGX0pTT046IGVuY29kZShlbmNvZGluZ1R5cGVzLk1FVEFEQVRBX0VOQ09ESU5HX1BST1RPQlVGX0pTT04pLFxuICBNRVRBREFUQV9FTkNPRElOR19QUk9UT0JVRjogZW5jb2RlKGVuY29kaW5nVHlwZXMuTUVUQURBVEFfRU5DT0RJTkdfUFJPVE9CVUYpLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IE1FVEFEQVRBX01FU1NBR0VfVFlQRV9LRVkgPSAnbWVzc2FnZVR5cGUnO1xuIiwiaW1wb3J0ICogYXMgdGltZSBmcm9tICcuL3RpbWUnO1xuaW1wb3J0IHsgdHlwZSBUaW1lc3RhbXAsIER1cmF0aW9uIH0gZnJvbSAnLi90aW1lJztcblxuLyoqXG4gKiBMb3NzeSBjb252ZXJzaW9uIGZ1bmN0aW9uIGZyb20gVGltZXN0YW1wIHRvIG51bWJlciBkdWUgdG8gcG9zc2libGUgb3ZlcmZsb3cuXG4gKiBJZiB0cyBpcyBudWxsIG9yIHVuZGVmaW5lZCByZXR1cm5zIHVuZGVmaW5lZC5cbiAqXG4gKiBAaGlkZGVuXG4gKiBAZGVwcmVjYXRlZCAtIG1lYW50IGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICovXG5leHBvcnQgZnVuY3Rpb24gb3B0aW9uYWxUc1RvTXModHM6IFRpbWVzdGFtcCB8IG51bGwgfCB1bmRlZmluZWQpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICByZXR1cm4gdGltZS5vcHRpb25hbFRzVG9Ncyh0cyk7XG59XG5cbi8qKlxuICogTG9zc3kgY29udmVyc2lvbiBmdW5jdGlvbiBmcm9tIFRpbWVzdGFtcCB0byBudW1iZXIgZHVlIHRvIHBvc3NpYmxlIG92ZXJmbG93XG4gKlxuICogQGhpZGRlblxuICogQGRlcHJlY2F0ZWQgLSBtZWFudCBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAqIEBkZXByZWNhdGVkIC0gbWVhbnQgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0c1RvTXModHM6IFRpbWVzdGFtcCB8IG51bGwgfCB1bmRlZmluZWQpOiBudW1iZXIge1xuICByZXR1cm4gdGltZS50c1RvTXModHMpO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqIEBkZXByZWNhdGVkIC0gbWVhbnQgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtc051bWJlclRvVHMobWlsbGlzOiBudW1iZXIpOiBUaW1lc3RhbXAge1xuICByZXR1cm4gdGltZS5tc051bWJlclRvVHMobWlsbGlzKTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKiBAZGVwcmVjYXRlZCAtIG1lYW50IGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICovXG5leHBvcnQgZnVuY3Rpb24gbXNUb1RzKHN0cjogRHVyYXRpb24pOiBUaW1lc3RhbXAge1xuICByZXR1cm4gdGltZS5tc1RvVHMoc3RyKTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKiBAZGVwcmVjYXRlZCAtIG1lYW50IGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICovXG5leHBvcnQgZnVuY3Rpb24gbXNPcHRpb25hbFRvVHMoc3RyOiBEdXJhdGlvbiB8IHVuZGVmaW5lZCk6IFRpbWVzdGFtcCB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiB0aW1lLm1zT3B0aW9uYWxUb1RzKHN0cik7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICogQGRlcHJlY2F0ZWQgLSBtZWFudCBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1zT3B0aW9uYWxUb051bWJlcih2YWw6IER1cmF0aW9uIHwgdW5kZWZpbmVkKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIHRpbWUubXNPcHRpb25hbFRvTnVtYmVyKHZhbCk7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICogQGRlcHJlY2F0ZWQgLSBtZWFudCBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1zVG9OdW1iZXIodmFsOiBEdXJhdGlvbik6IG51bWJlciB7XG4gIHJldHVybiB0aW1lLm1zVG9OdW1iZXIodmFsKTtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKiBAZGVwcmVjYXRlZCAtIG1lYW50IGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHNUb0RhdGUodHM6IFRpbWVzdGFtcCk6IERhdGUge1xuICByZXR1cm4gdGltZS50c1RvRGF0ZSh0cyk7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICogQGRlcHJlY2F0ZWQgLSBtZWFudCBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9wdGlvbmFsVHNUb0RhdGUodHM6IFRpbWVzdGFtcCB8IG51bGwgfCB1bmRlZmluZWQpOiBEYXRlIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIHRpbWUub3B0aW9uYWxUc1RvRGF0ZSh0cyk7XG59XG4iLCIvLyBQYXN0ZWQgd2l0aCBtb2RpZmljYXRpb25zIGZyb206IGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9hbm9ueWNvL0Zhc3Rlc3RTbWFsbGVzdFRleHRFbmNvZGVyRGVjb2Rlci9tYXN0ZXIvRW5jb2RlckRlY29kZXJUb2dldGhlci5zcmMuanNcbi8qIGVzbGludCBuby1mYWxsdGhyb3VnaDogMCAqL1xuXG5jb25zdCBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuY29uc3QgZW5jb2RlclJlZ2V4cCA9IC9bXFx4ODAtXFx1RDdmZlxcdURDMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXT8vZztcbmNvbnN0IHRtcEJ1ZmZlclUxNiA9IG5ldyBVaW50MTZBcnJheSgzMik7XG5cbmV4cG9ydCBjbGFzcyBUZXh0RGVjb2RlciB7XG4gIGRlY29kZShpbnB1dEFycmF5T3JCdWZmZXI6IFVpbnQ4QXJyYXkgfCBBcnJheUJ1ZmZlciB8IFNoYXJlZEFycmF5QnVmZmVyKTogc3RyaW5nIHtcbiAgICBjb25zdCBpbnB1dEFzOCA9IGlucHV0QXJyYXlPckJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBpbnB1dEFycmF5T3JCdWZmZXIgOiBuZXcgVWludDhBcnJheShpbnB1dEFycmF5T3JCdWZmZXIpO1xuXG4gICAgbGV0IHJlc3VsdGluZ1N0cmluZyA9ICcnLFxuICAgICAgdG1wU3RyID0gJycsXG4gICAgICBpbmRleCA9IDAsXG4gICAgICBuZXh0RW5kID0gMCxcbiAgICAgIGNwMCA9IDAsXG4gICAgICBjb2RlUG9pbnQgPSAwLFxuICAgICAgbWluQml0cyA9IDAsXG4gICAgICBjcDEgPSAwLFxuICAgICAgcG9zID0gMCxcbiAgICAgIHRtcCA9IC0xO1xuICAgIGNvbnN0IGxlbiA9IGlucHV0QXM4Lmxlbmd0aCB8IDA7XG4gICAgY29uc3QgbGVuTWludXMzMiA9IChsZW4gLSAzMikgfCAwO1xuICAgIC8vIE5vdGUgdGhhdCB0bXAgcmVwcmVzZW50cyB0aGUgMm5kIGhhbGYgb2YgYSBzdXJyb2dhdGUgcGFpciBpbmNhc2UgYSBzdXJyb2dhdGUgZ2V0cyBkaXZpZGVkIGJldHdlZW4gYmxvY2tzXG4gICAgZm9yICg7IGluZGV4IDwgbGVuOyApIHtcbiAgICAgIG5leHRFbmQgPSBpbmRleCA8PSBsZW5NaW51czMyID8gMzIgOiAobGVuIC0gaW5kZXgpIHwgMDtcbiAgICAgIGZvciAoOyBwb3MgPCBuZXh0RW5kOyBpbmRleCA9IChpbmRleCArIDEpIHwgMCwgcG9zID0gKHBvcyArIDEpIHwgMCkge1xuICAgICAgICBjcDAgPSBpbnB1dEFzOFtpbmRleF0gJiAweGZmO1xuICAgICAgICBzd2l0Y2ggKGNwMCA+PiA0KSB7XG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIGNwMSA9IGlucHV0QXM4WyhpbmRleCA9IChpbmRleCArIDEpIHwgMCldICYgMHhmZjtcbiAgICAgICAgICAgIGlmIChjcDEgPj4gNiAhPT0gMGIxMCB8fCAwYjExMTEwMTExIDwgY3AwKSB7XG4gICAgICAgICAgICAgIGluZGV4ID0gKGluZGV4IC0gMSkgfCAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGVQb2ludCA9ICgoY3AwICYgMGIxMTEpIDw8IDYpIHwgKGNwMSAmIDBiMDAxMTExMTEpO1xuICAgICAgICAgICAgbWluQml0cyA9IDU7IC8vIDIwIGVuc3VyZXMgaXQgbmV2ZXIgcGFzc2VzIC0+IGFsbCBpbnZhbGlkIHJlcGxhY2VtZW50c1xuICAgICAgICAgICAgY3AwID0gMHgxMDA7IC8vICBrZWVwIHRyYWNrIG9mIHRoIGJpdCBzaXplXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIGNwMSA9IGlucHV0QXM4WyhpbmRleCA9IChpbmRleCArIDEpIHwgMCldICYgMHhmZjtcbiAgICAgICAgICAgIGNvZGVQb2ludCA8PD0gNjtcbiAgICAgICAgICAgIGNvZGVQb2ludCB8PSAoKGNwMCAmIDBiMTExMSkgPDwgNikgfCAoY3AxICYgMGIwMDExMTExMSk7XG4gICAgICAgICAgICBtaW5CaXRzID0gY3AxID4+IDYgPT09IDBiMTAgPyAobWluQml0cyArIDQpIHwgMCA6IDI0OyAvLyAyNCBlbnN1cmVzIGl0IG5ldmVyIHBhc3NlcyAtPiBhbGwgaW52YWxpZCByZXBsYWNlbWVudHNcbiAgICAgICAgICAgIGNwMCA9IChjcDAgKyAweDEwMCkgJiAweDMwMDsgLy8ga2VlcCB0cmFjayBvZiB0aCBiaXQgc2l6ZVxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIGNwMSA9IGlucHV0QXM4WyhpbmRleCA9IChpbmRleCArIDEpIHwgMCldICYgMHhmZjtcbiAgICAgICAgICAgIGNvZGVQb2ludCA8PD0gNjtcbiAgICAgICAgICAgIGNvZGVQb2ludCB8PSAoKGNwMCAmIDBiMTExMTEpIDw8IDYpIHwgKGNwMSAmIDBiMDAxMTExMTEpO1xuICAgICAgICAgICAgbWluQml0cyA9IChtaW5CaXRzICsgNykgfCAwO1xuXG4gICAgICAgICAgICAvLyBOb3csIHByb2Nlc3MgdGhlIGNvZGUgcG9pbnRcbiAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbiAmJiBjcDEgPj4gNiA9PT0gMGIxMCAmJiBjb2RlUG9pbnQgPj4gbWluQml0cyAmJiBjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjcDAgPSBjb2RlUG9pbnQ7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IChjb2RlUG9pbnQgLSAweDEwMDAwKSB8IDA7XG4gICAgICAgICAgICAgIGlmICgwIDw9IGNvZGVQb2ludCAvKjB4ZmZmZiA8IGNvZGVQb2ludCovKSB7XG4gICAgICAgICAgICAgICAgLy8gQk1QIGNvZGUgcG9pbnRcbiAgICAgICAgICAgICAgICAvL25leHRFbmQgPSBuZXh0RW5kIC0gMXwwO1xuXG4gICAgICAgICAgICAgICAgdG1wID0gKChjb2RlUG9pbnQgPj4gMTApICsgMHhkODAwKSB8IDA7IC8vIGhpZ2hTdXJyb2dhdGVcbiAgICAgICAgICAgICAgICBjcDAgPSAoKGNvZGVQb2ludCAmIDB4M2ZmKSArIDB4ZGMwMCkgfCAwOyAvLyBsb3dTdXJyb2dhdGUgKHdpbGwgYmUgaW5zZXJ0ZWQgbGF0ZXIgaW4gdGhlIHN3aXRjaC1zdGF0ZW1lbnQpXG5cbiAgICAgICAgICAgICAgICBpZiAocG9zIDwgMzEpIHtcbiAgICAgICAgICAgICAgICAgIC8vIG5vdGljZSAzMSBpbnN0ZWFkIG9mIDMyXG4gICAgICAgICAgICAgICAgICB0bXBCdWZmZXJVMTZbcG9zXSA9IHRtcDtcbiAgICAgICAgICAgICAgICAgIHBvcyA9IChwb3MgKyAxKSB8IDA7XG4gICAgICAgICAgICAgICAgICB0bXAgPSAtMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gZWxzZSwgd2UgYXJlIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0QXM4IGFuZCBsZXQgdG1wMCBiZSBmaWxsZWQgaW4gbGF0ZXIgb25cbiAgICAgICAgICAgICAgICAgIC8vIE5PVEUgdGhhdCBjcDEgaXMgYmVpbmcgdXNlZCBhcyBhIHRlbXBvcmFyeSB2YXJpYWJsZSBmb3IgdGhlIHN3YXBwaW5nIG9mIHRtcCB3aXRoIGNwMFxuICAgICAgICAgICAgICAgICAgY3AxID0gdG1wO1xuICAgICAgICAgICAgICAgICAgdG1wID0gY3AwO1xuICAgICAgICAgICAgICAgICAgY3AwID0gY3AxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIG5leHRFbmQgPSAobmV4dEVuZCArIDEpIHwgMDsgLy8gYmVjYXVzZSB3ZSBhcmUgYWR2YW5jaW5nIGkgd2l0aG91dCBhZHZhbmNpbmcgcG9zXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBpbnZhbGlkIGNvZGUgcG9pbnQgbWVhbnMgcmVwbGFjaW5nIHRoZSB3aG9sZSB0aGluZyB3aXRoIG51bGwgcmVwbGFjZW1lbnQgY2hhcmFjdGVyc1xuICAgICAgICAgICAgICBjcDAgPj49IDg7XG4gICAgICAgICAgICAgIGluZGV4ID0gKGluZGV4IC0gY3AwIC0gMSkgfCAwOyAvLyByZXNldCBpbmRleCAgYmFjayB0byB3aGF0IGl0IHdhcyBiZWZvcmVcbiAgICAgICAgICAgICAgY3AwID0gMHhmZmZkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaW5hbGx5LCByZXNldCB0aGUgdmFyaWFibGVzIGZvciB0aGUgbmV4dCBnby1hcm91bmRcbiAgICAgICAgICAgIG1pbkJpdHMgPSAwO1xuICAgICAgICAgICAgY29kZVBvaW50ID0gMDtcbiAgICAgICAgICAgIG5leHRFbmQgPSBpbmRleCA8PSBsZW5NaW51czMyID8gMzIgOiAobGVuIC0gaW5kZXgpIHwgMDtcbiAgICAgICAgICAvKmNhc2UgMTE6XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIGNvZGVQb2ludCA/IGNvZGVQb2ludCA9IDAgOiBjcDAgPSAweGZmZmQ7IC8vIGZpbGwgd2l0aCBpbnZhbGlkIHJlcGxhY2VtZW50IGNoYXJhY3RlclxuICAgICAgICBjYXNlIDc6XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICB0bXBCdWZmZXJVMTZbcG9zXSA9IGNwMDtcbiAgICAgICAgICBjb250aW51ZTsqL1xuICAgICAgICAgIGRlZmF1bHQ6IC8vIGZpbGwgd2l0aCBpbnZhbGlkIHJlcGxhY2VtZW50IGNoYXJhY3RlclxuICAgICAgICAgICAgdG1wQnVmZmVyVTE2W3Bvc10gPSBjcDA7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgfVxuICAgICAgICB0bXBCdWZmZXJVMTZbcG9zXSA9IDB4ZmZmZDsgLy8gZmlsbCB3aXRoIGludmFsaWQgcmVwbGFjZW1lbnQgY2hhcmFjdGVyXG4gICAgICB9XG4gICAgICB0bXBTdHIgKz0gZnJvbUNoYXJDb2RlKFxuICAgICAgICB0bXBCdWZmZXJVMTZbMF0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxXSxcbiAgICAgICAgdG1wQnVmZmVyVTE2WzJdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbM10sXG4gICAgICAgIHRtcEJ1ZmZlclUxNls0XSxcbiAgICAgICAgdG1wQnVmZmVyVTE2WzVdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbNl0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNls3XSxcbiAgICAgICAgdG1wQnVmZmVyVTE2WzhdLFxuICAgICAgICB0bXBCdWZmZXJVMTZbOV0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxMF0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxMV0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxMl0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxM10sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxNF0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxNV0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxNl0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxN10sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxOF0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsxOV0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyMF0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyMV0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyMl0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyM10sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyNF0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyNV0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyNl0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyN10sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyOF0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlsyOV0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlszMF0sXG4gICAgICAgIHRtcEJ1ZmZlclUxNlszMV1cbiAgICAgICk7XG4gICAgICBpZiAocG9zIDwgMzIpIHRtcFN0ciA9IHRtcFN0ci5zbGljZSgwLCAocG9zIC0gMzIpIHwgMCk7IC8vLSgzMi1wb3MpKTtcbiAgICAgIGlmIChpbmRleCA8IGxlbikge1xuICAgICAgICAvL2Zyb21DaGFyQ29kZS5hcHBseSgwLCB0bXBCdWZmZXJVMTYgOiBVaW50OEFycmF5ID8gIHRtcEJ1ZmZlclUxNi5zdWJhcnJheSgwLHBvcykgOiB0bXBCdWZmZXJVMTYuc2xpY2UoMCxwb3MpKTtcbiAgICAgICAgdG1wQnVmZmVyVTE2WzBdID0gdG1wO1xuICAgICAgICBwb3MgPSB+dG1wID4+PiAzMTsgLy90bXAgIT09IC0xID8gMSA6IDA7XG4gICAgICAgIHRtcCA9IC0xO1xuXG4gICAgICAgIGlmICh0bXBTdHIubGVuZ3RoIDwgcmVzdWx0aW5nU3RyaW5nLmxlbmd0aCkgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHRtcCAhPT0gLTEpIHtcbiAgICAgICAgdG1wU3RyICs9IGZyb21DaGFyQ29kZSh0bXApO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRpbmdTdHJpbmcgKz0gdG1wU3RyO1xuICAgICAgdG1wU3RyID0gJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ1N0cmluZztcbiAgfVxufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gZW5jb2RlclJlcGxhY2VyKG5vbkFzY2lpQ2hhcnM6IHN0cmluZykge1xuICAvLyBtYWtlIHRoZSBVVEYgc3RyaW5nIGludG8gYSBiaW5hcnkgVVRGLTggZW5jb2RlZCBzdHJpbmdcbiAgbGV0IHBvaW50ID0gbm9uQXNjaWlDaGFycy5jaGFyQ29kZUF0KDApIHwgMDtcbiAgaWYgKDB4ZDgwMCA8PSBwb2ludCkge1xuICAgIGlmIChwb2ludCA8PSAweGRiZmYpIHtcbiAgICAgIGNvbnN0IG5leHRjb2RlID0gbm9uQXNjaWlDaGFycy5jaGFyQ29kZUF0KDEpIHwgMDsgLy8gZGVmYXVsdHMgdG8gMCB3aGVuIE5hTiwgY2F1c2luZyBudWxsIHJlcGxhY2VtZW50IGNoYXJhY3RlclxuXG4gICAgICBpZiAoMHhkYzAwIDw9IG5leHRjb2RlICYmIG5leHRjb2RlIDw9IDB4ZGZmZikge1xuICAgICAgICAvL3BvaW50ID0gKChwb2ludCAtIDB4RDgwMCk8PDEwKSArIG5leHRjb2RlIC0gMHhEQzAwICsgMHgxMDAwMHwwO1xuICAgICAgICBwb2ludCA9ICgocG9pbnQgPDwgMTApICsgbmV4dGNvZGUgLSAweDM1ZmRjMDApIHwgMDtcbiAgICAgICAgaWYgKHBvaW50ID4gMHhmZmZmKVxuICAgICAgICAgIHJldHVybiBmcm9tQ2hhckNvZGUoXG4gICAgICAgICAgICAoMHgxZSAvKjBiMTExMTAqLyA8PCAzKSB8IChwb2ludCA+PiAxOCksXG4gICAgICAgICAgICAoMHgyIC8qMGIxMCovIDw8IDYpIHwgKChwb2ludCA+PiAxMikgJiAweDNmKSAvKjBiMDAxMTExMTEqLyxcbiAgICAgICAgICAgICgweDIgLyowYjEwKi8gPDwgNikgfCAoKHBvaW50ID4+IDYpICYgMHgzZikgLyowYjAwMTExMTExKi8sXG4gICAgICAgICAgICAoMHgyIC8qMGIxMCovIDw8IDYpIHwgKHBvaW50ICYgMHgzZikgLyowYjAwMTExMTExKi9cbiAgICAgICAgICApO1xuICAgICAgfSBlbHNlIHBvaW50ID0gNjU1MzMgLyowYjExMTExMTExMTExMTExMDEqLzsgLy9yZXR1cm4gJ1xceEVGXFx4QkZcXHhCRCc7Ly9mcm9tQ2hhckNvZGUoMHhlZiwgMHhiZiwgMHhiZCk7XG4gICAgfSBlbHNlIGlmIChwb2ludCA8PSAweGRmZmYpIHtcbiAgICAgIHBvaW50ID0gNjU1MzMgLyowYjExMTExMTExMTExMTExMDEqLzsgLy9yZXR1cm4gJ1xceEVGXFx4QkZcXHhCRCc7Ly9mcm9tQ2hhckNvZGUoMHhlZiwgMHhiZiwgMHhiZCk7XG4gICAgfVxuICB9XG4gIC8qaWYgKHBvaW50IDw9IDB4MDA3ZikgcmV0dXJuIG5vbkFzY2lpQ2hhcnM7XG4gIGVsc2UgKi8gaWYgKHBvaW50IDw9IDB4MDdmZikge1xuICAgIHJldHVybiBmcm9tQ2hhckNvZGUoKDB4NiA8PCA1KSB8IChwb2ludCA+PiA2KSwgKDB4MiA8PCA2KSB8IChwb2ludCAmIDB4M2YpKTtcbiAgfSBlbHNlXG4gICAgcmV0dXJuIGZyb21DaGFyQ29kZShcbiAgICAgICgweGUgLyowYjExMTAqLyA8PCA0KSB8IChwb2ludCA+PiAxMiksXG4gICAgICAoMHgyIC8qMGIxMCovIDw8IDYpIHwgKChwb2ludCA+PiA2KSAmIDB4M2YpIC8qMGIwMDExMTExMSovLFxuICAgICAgKDB4MiAvKjBiMTAqLyA8PCA2KSB8IChwb2ludCAmIDB4M2YpIC8qMGIwMDExMTExMSovXG4gICAgKTtcbn1cblxuZXhwb3J0IGNsYXNzIFRleHRFbmNvZGVyIHtcbiAgcHVibGljIGVuY29kZShpbnB1dFN0cmluZzogc3RyaW5nKTogVWludDhBcnJheSB7XG4gICAgLy8gMHhjMCA9PiAwYjExMDAwMDAwOyAweGZmID0+IDBiMTExMTExMTE7IDB4YzAtMHhmZiA9PiAwYjExeHh4eHh4XG4gICAgLy8gMHg4MCA9PiAwYjEwMDAwMDAwOyAweGJmID0+IDBiMTAxMTExMTE7IDB4ODAtMHhiZiA9PiAwYjEweHh4eHh4XG4gICAgY29uc3QgZW5jb2RlZFN0cmluZyA9IGlucHV0U3RyaW5nID09PSB2b2lkIDAgPyAnJyA6ICcnICsgaW5wdXRTdHJpbmcsXG4gICAgICBsZW4gPSBlbmNvZGVkU3RyaW5nLmxlbmd0aCB8IDA7XG4gICAgbGV0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KCgobGVuIDw8IDEpICsgOCkgfCAwKTtcbiAgICBsZXQgdG1wUmVzdWx0OiBVaW50OEFycmF5O1xuICAgIGxldCBpID0gMCxcbiAgICAgIHBvcyA9IDAsXG4gICAgICBwb2ludCA9IDAsXG4gICAgICBuZXh0Y29kZSA9IDA7XG4gICAgbGV0IHVwZ3JhZGVkZWRBcnJheVNpemUgPSAhVWludDhBcnJheTsgLy8gbm9ybWFsIGFycmF5cyBhcmUgYXV0by1leHBhbmRpbmdcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpID0gKGkgKyAxKSB8IDAsIHBvcyA9IChwb3MgKyAxKSB8IDApIHtcbiAgICAgIHBvaW50ID0gZW5jb2RlZFN0cmluZy5jaGFyQ29kZUF0KGkpIHwgMDtcbiAgICAgIGlmIChwb2ludCA8PSAweDAwN2YpIHtcbiAgICAgICAgcmVzdWx0W3Bvc10gPSBwb2ludDtcbiAgICAgIH0gZWxzZSBpZiAocG9pbnQgPD0gMHgwN2ZmKSB7XG4gICAgICAgIHJlc3VsdFtwb3NdID0gKDB4NiA8PCA1KSB8IChwb2ludCA+PiA2KTtcbiAgICAgICAgcmVzdWx0Wyhwb3MgPSAocG9zICsgMSkgfCAwKV0gPSAoMHgyIDw8IDYpIHwgKHBvaW50ICYgMHgzZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aWRlbkNoZWNrOiB7XG4gICAgICAgICAgaWYgKDB4ZDgwMCA8PSBwb2ludCkge1xuICAgICAgICAgICAgaWYgKHBvaW50IDw9IDB4ZGJmZikge1xuICAgICAgICAgICAgICBuZXh0Y29kZSA9IGVuY29kZWRTdHJpbmcuY2hhckNvZGVBdCgoaSA9IChpICsgMSkgfCAwKSkgfCAwOyAvLyBkZWZhdWx0cyB0byAwIHdoZW4gTmFOLCBjYXVzaW5nIG51bGwgcmVwbGFjZW1lbnQgY2hhcmFjdGVyXG5cbiAgICAgICAgICAgICAgaWYgKDB4ZGMwMCA8PSBuZXh0Y29kZSAmJiBuZXh0Y29kZSA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgICAgICAvL3BvaW50ID0gKChwb2ludCAtIDB4RDgwMCk8PDEwKSArIG5leHRjb2RlIC0gMHhEQzAwICsgMHgxMDAwMHwwO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gKChwb2ludCA8PCAxMCkgKyBuZXh0Y29kZSAtIDB4MzVmZGMwMCkgfCAwO1xuICAgICAgICAgICAgICAgIGlmIChwb2ludCA+IDB4ZmZmZikge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0W3Bvc10gPSAoMHgxZSAvKjBiMTExMTAqLyA8PCAzKSB8IChwb2ludCA+PiAxOCk7XG4gICAgICAgICAgICAgICAgICByZXN1bHRbKHBvcyA9IChwb3MgKyAxKSB8IDApXSA9ICgweDIgLyowYjEwKi8gPDwgNikgfCAoKHBvaW50ID4+IDEyKSAmIDB4M2YpIC8qMGIwMDExMTExMSovO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0Wyhwb3MgPSAocG9zICsgMSkgfCAwKV0gPSAoMHgyIC8qMGIxMCovIDw8IDYpIHwgKChwb2ludCA+PiA2KSAmIDB4M2YpIC8qMGIwMDExMTExMSovO1xuICAgICAgICAgICAgICAgICAgcmVzdWx0Wyhwb3MgPSAocG9zICsgMSkgfCAwKV0gPSAoMHgyIC8qMGIxMCovIDw8IDYpIHwgKHBvaW50ICYgMHgzZikgLyowYjAwMTExMTExKi87XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWsgd2lkZW5DaGVjaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwb2ludCA9IDY1NTMzIC8qMGIxMTExMTExMTExMTExMTAxKi87IC8vcmV0dXJuICdcXHhFRlxceEJGXFx4QkQnOy8vZnJvbUNoYXJDb2RlKDB4ZWYsIDB4YmYsIDB4YmQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb2ludCA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgICAgcG9pbnQgPSA2NTUzMyAvKjBiMTExMTExMTExMTExMTEwMSovOyAvL3JldHVybiAnXFx4RUZcXHhCRlxceEJEJzsvL2Zyb21DaGFyQ29kZSgweGVmLCAweGJmLCAweGJkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF1cGdyYWRlZGVkQXJyYXlTaXplICYmIGkgPDwgMSA8IHBvcyAmJiBpIDw8IDEgPCAoKHBvcyAtIDcpIHwgMCkpIHtcbiAgICAgICAgICAgIHVwZ3JhZGVkZWRBcnJheVNpemUgPSB0cnVlO1xuICAgICAgICAgICAgdG1wUmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuICogMyk7XG4gICAgICAgICAgICB0bXBSZXN1bHQuc2V0KHJlc3VsdCk7XG4gICAgICAgICAgICByZXN1bHQgPSB0bXBSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtwb3NdID0gKDB4ZSAvKjBiMTExMCovIDw8IDQpIHwgKHBvaW50ID4+IDEyKTtcbiAgICAgICAgcmVzdWx0Wyhwb3MgPSAocG9zICsgMSkgfCAwKV0gPSAoMHgyIC8qMGIxMCovIDw8IDYpIHwgKChwb2ludCA+PiA2KSAmIDB4M2YpIC8qMGIwMDExMTExMSovO1xuICAgICAgICByZXN1bHRbKHBvcyA9IChwb3MgKyAxKSB8IDApXSA9ICgweDIgLyowYjEwKi8gPDwgNikgfCAocG9pbnQgJiAweDNmKSAvKjBiMDAxMTExMTEqLztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkgPyByZXN1bHQuc3ViYXJyYXkoMCwgcG9zKSA6IHJlc3VsdC5zbGljZSgwLCBwb3MpO1xuICB9XG5cbiAgcHVibGljIGVuY29kZUludG8oaW5wdXRTdHJpbmc6IHN0cmluZywgdThBcnI6IFVpbnQ4QXJyYXkpOiB7IHdyaXR0ZW46IG51bWJlcjsgcmVhZDogbnVtYmVyIH0ge1xuICAgIGNvbnN0IGVuY29kZWRTdHJpbmcgPSBpbnB1dFN0cmluZyA9PT0gdm9pZCAwID8gJycgOiAoJycgKyBpbnB1dFN0cmluZykucmVwbGFjZShlbmNvZGVyUmVnZXhwLCBlbmNvZGVyUmVwbGFjZXIpO1xuICAgIGxldCBsZW4gPSBlbmNvZGVkU3RyaW5nLmxlbmd0aCB8IDAsXG4gICAgICBpID0gMCxcbiAgICAgIGNoYXIgPSAwLFxuICAgICAgcmVhZCA9IDA7XG4gICAgY29uc3QgdThBcnJMZW4gPSB1OEFyci5sZW5ndGggfCAwO1xuICAgIGNvbnN0IGlucHV0TGVuZ3RoID0gaW5wdXRTdHJpbmcubGVuZ3RoIHwgMDtcbiAgICBpZiAodThBcnJMZW4gPCBsZW4pIGxlbiA9IHU4QXJyTGVuO1xuICAgIHB1dENoYXJzOiB7XG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSA9IChpICsgMSkgfCAwKSB7XG4gICAgICAgIGNoYXIgPSBlbmNvZGVkU3RyaW5nLmNoYXJDb2RlQXQoaSkgfCAwO1xuICAgICAgICBzd2l0Y2ggKGNoYXIgPj4gNCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICByZWFkID0gKHJlYWQgKyAxKSB8IDA7XG4gICAgICAgICAgLy8gZXh0ZW5zaW9uIHBvaW50czpcbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIGlmICgoKGkgKyAxKSB8IDApIDwgdThBcnJMZW4pIHtcbiAgICAgICAgICAgICAgcmVhZCA9IChyZWFkICsgMSkgfCAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgaWYgKCgoaSArIDIpIHwgMCkgPCB1OEFyckxlbikge1xuICAgICAgICAgICAgICAvL2lmICghKGNoYXIgPT09IDB4RUYgJiYgZW5jb2RlZFN0cmluZy5zdWJzdHIoaSsxfDAsMikgPT09IFwiXFx4QkZcXHhCRFwiKSlcbiAgICAgICAgICAgICAgcmVhZCA9IChyZWFkICsgMSkgfCAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgaWYgKCgoaSArIDMpIHwgMCkgPCB1OEFyckxlbikge1xuICAgICAgICAgICAgICByZWFkID0gKHJlYWQgKyAxKSB8IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhayBwdXRDaGFycztcbiAgICAgICAgfVxuICAgICAgICAvL3JlYWQgPSByZWFkICsgKChjaGFyID4+IDYpICE9PSAyKSB8MDtcbiAgICAgICAgdThBcnJbaV0gPSBjaGFyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyB3cml0dGVuOiBpLCByZWFkOiBpbnB1dExlbmd0aCA8IHJlYWQgPyBpbnB1dExlbmd0aCA6IHJlYWQgfTtcbiAgfVxufVxuXG4vKipcbiAqIEVuY29kZSBhIFVURi04IHN0cmluZyBpbnRvIGEgVWludDhBcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKHM6IHN0cmluZyk6IFVpbnQ4QXJyYXkge1xuICByZXR1cm4gVGV4dEVuY29kZXIucHJvdG90eXBlLmVuY29kZShzKTtcbn1cblxuLyoqXG4gKiBEZWNvZGUgYSBVaW50OEFycmF5IGludG8gYSBVVEYtOCBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShhOiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgcmV0dXJuIFRleHREZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUoYSk7XG59XG4iLCJpbXBvcnQgeyBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvciB9IGZyb20gJy4vdHlwZS1oZWxwZXJzJztcblxuLyoqXG4gKiBUaHJvd24gZnJvbSBjb2RlIHRoYXQgcmVjZWl2ZXMgYSB2YWx1ZSB0aGF0IGlzIHVuZXhwZWN0ZWQgb3IgdGhhdCBpdCdzIHVuYWJsZSB0byBoYW5kbGUuXG4gKi9cbkBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvcignVmFsdWVFcnJvcicpXG5leHBvcnQgY2xhc3MgVmFsdWVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoXG4gICAgbWVzc2FnZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHB1YmxpYyByZWFkb25seSBjYXVzZT86IHVua25vd25cbiAgKSB7XG4gICAgc3VwZXIobWVzc2FnZSA/PyB1bmRlZmluZWQpO1xuICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYSBQYXlsb2FkIENvbnZlcnRlciBpcyBtaXNjb25maWd1cmVkLlxuICovXG5AU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IoJ1BheWxvYWRDb252ZXJ0ZXJFcnJvcicpXG5leHBvcnQgY2xhc3MgUGF5bG9hZENvbnZlcnRlckVycm9yIGV4dGVuZHMgVmFsdWVFcnJvciB7fVxuXG4vKipcbiAqIFNpZ25hbHMgdGhhdCBhIHJlcXVlc3RlZCBvcGVyYXRpb24gY2FuJ3QgYmUgY29tcGxldGVkIGJlY2F1c2UgaXQgaXMgaWxsZWdhbCBnaXZlbiB0aGVcbiAqIGN1cnJlbnQgc3RhdGUgb2YgdGhlIG9iamVjdDsgZS5nLiB0cnlpbmcgdG8gdXNlIGEgcmVzb3VyY2UgYWZ0ZXIgaXQgaGFzIGJlZW4gY2xvc2VkLlxuICovXG5AU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IoJ0lsbGVnYWxTdGF0ZUVycm9yJylcbmV4cG9ydCBjbGFzcyBJbGxlZ2FsU3RhdGVFcnJvciBleHRlbmRzIEVycm9yIHt9XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYSBXb3JrZmxvdyB3aXRoIHRoZSBnaXZlbiBJZCBpcyBub3Qga25vd24gdG8gVGVtcG9yYWwgU2VydmVyLlxuICogSXQgY291bGQgYmUgYmVjYXVzZTpcbiAqIC0gSWQgcGFzc2VkIGlzIGluY29ycmVjdFxuICogLSBXb3JrZmxvdyBpcyBjbG9zZWQgKGZvciBzb21lIGNhbGxzLCBlLmcuIGB0ZXJtaW5hdGVgKVxuICogLSBXb3JrZmxvdyB3YXMgZGVsZXRlZCBmcm9tIHRoZSBTZXJ2ZXIgYWZ0ZXIgcmVhY2hpbmcgaXRzIHJldGVudGlvbiBsaW1pdFxuICovXG5AU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IoJ1dvcmtmbG93Tm90Rm91bmRFcnJvcicpXG5leHBvcnQgY2xhc3MgV29ya2Zsb3dOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihcbiAgICBtZXNzYWdlOiBzdHJpbmcsXG4gICAgcHVibGljIHJlYWRvbmx5IHdvcmtmbG93SWQ6IHN0cmluZyxcbiAgICBwdWJsaWMgcmVhZG9ubHkgcnVuSWQ6IHN0cmluZyB8IHVuZGVmaW5lZFxuICApIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBzcGVjaWZpZWQgbmFtZXNwYWNlIGlzIG5vdCBrbm93biB0byBUZW1wb3JhbCBTZXJ2ZXIuXG4gKi9cbkBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvcignTmFtZXNwYWNlTm90Rm91bmRFcnJvcicpXG5leHBvcnQgY2xhc3MgTmFtZXNwYWNlTm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IG5hbWVzcGFjZTogc3RyaW5nKSB7XG4gICAgc3VwZXIoYE5hbWVzcGFjZSBub3QgZm91bmQ6ICcke25hbWVzcGFjZX0nYCk7XG4gIH1cbn1cbiIsImltcG9ydCB0eXBlIHsgdGVtcG9yYWwgfSBmcm9tICdAdGVtcG9yYWxpby9wcm90byc7XG5pbXBvcnQgeyBlcnJvck1lc3NhZ2UsIGlzUmVjb3JkLCBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvciB9IGZyb20gJy4vdHlwZS1oZWxwZXJzJztcbmltcG9ydCB7IER1cmF0aW9uIH0gZnJvbSAnLi90aW1lJztcbmltcG9ydCB7IG1ha2VQcm90b0VudW1Db252ZXJ0ZXJzIH0gZnJvbSAnLi9pbnRlcm5hbC13b3JrZmxvdyc7XG5cbmV4cG9ydCBjb25zdCBGQUlMVVJFX1NPVVJDRSA9ICdUeXBlU2NyaXB0U0RLJztcbmV4cG9ydCB0eXBlIFByb3RvRmFpbHVyZSA9IHRlbXBvcmFsLmFwaS5mYWlsdXJlLnYxLklGYWlsdXJlO1xuXG5leHBvcnQgY29uc3QgVGltZW91dFR5cGUgPSB7XG4gIFNUQVJUX1RPX0NMT1NFOiAnU1RBUlRfVE9fQ0xPU0UnLFxuICBTQ0hFRFVMRV9UT19TVEFSVDogJ1NDSEVEVUxFX1RPX1NUQVJUJyxcbiAgU0NIRURVTEVfVE9fQ0xPU0U6ICdTQ0hFRFVMRV9UT19DTE9TRScsXG4gIEhFQVJUQkVBVDogJ0hFQVJUQkVBVCcsXG5cbiAgLyoqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgU1RBUlRfVE9fQ0xPU0V9IGluc3RlYWQuICovXG4gIFRJTUVPVVRfVFlQRV9TVEFSVF9UT19DTE9TRTogJ1NUQVJUX1RPX0NMT1NFJywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuXG4gIC8qKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIFNDSEVEVUxFX1RPX1NUQVJUfSBpbnN0ZWFkLiAqL1xuICBUSU1FT1VUX1RZUEVfU0NIRURVTEVfVE9fU1RBUlQ6ICdTQ0hFRFVMRV9UT19TVEFSVCcsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cblxuICAvKiogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBTQ0hFRFVMRV9UT19DTE9TRX0gaW5zdGVhZC4gKi9cbiAgVElNRU9VVF9UWVBFX1NDSEVEVUxFX1RPX0NMT1NFOiAnU0NIRURVTEVfVE9fQ0xPU0UnLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG5cbiAgLyoqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgSEVBUlRCRUFUfSBpbnN0ZWFkLiAqL1xuICBUSU1FT1VUX1RZUEVfSEVBUlRCRUFUOiAnSEVBUlRCRUFUJywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuXG4gIC8qKiBAZGVwcmVjYXRlZCBVc2UgYHVuZGVmaW5lZGAgaW5zdGVhZC4gKi9cbiAgVElNRU9VVF9UWVBFX1VOU1BFQ0lGSUVEOiB1bmRlZmluZWQsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbn0gYXMgY29uc3Q7XG5leHBvcnQgdHlwZSBUaW1lb3V0VHlwZSA9ICh0eXBlb2YgVGltZW91dFR5cGUpW2tleW9mIHR5cGVvZiBUaW1lb3V0VHlwZV07XG5cbmV4cG9ydCBjb25zdCBbZW5jb2RlVGltZW91dFR5cGUsIGRlY29kZVRpbWVvdXRUeXBlXSA9IG1ha2VQcm90b0VudW1Db252ZXJ0ZXJzPFxuICB0ZW1wb3JhbC5hcGkuZW51bXMudjEuVGltZW91dFR5cGUsXG4gIHR5cGVvZiB0ZW1wb3JhbC5hcGkuZW51bXMudjEuVGltZW91dFR5cGUsXG4gIGtleW9mIHR5cGVvZiB0ZW1wb3JhbC5hcGkuZW51bXMudjEuVGltZW91dFR5cGUsXG4gIHR5cGVvZiBUaW1lb3V0VHlwZSxcbiAgJ1RJTUVPVVRfVFlQRV8nXG4+KFxuICB7XG4gICAgW1RpbWVvdXRUeXBlLlNUQVJUX1RPX0NMT1NFXTogMSxcbiAgICBbVGltZW91dFR5cGUuU0NIRURVTEVfVE9fU1RBUlRdOiAyLFxuICAgIFtUaW1lb3V0VHlwZS5TQ0hFRFVMRV9UT19DTE9TRV06IDMsXG4gICAgW1RpbWVvdXRUeXBlLkhFQVJUQkVBVF06IDQsXG4gICAgVU5TUEVDSUZJRUQ6IDAsXG4gIH0gYXMgY29uc3QsXG4gICdUSU1FT1VUX1RZUEVfJ1xuKTtcblxuZXhwb3J0IGNvbnN0IFJldHJ5U3RhdGUgPSB7XG4gIElOX1BST0dSRVNTOiAnSU5fUFJPR1JFU1MnLFxuICBOT05fUkVUUllBQkxFX0ZBSUxVUkU6ICdOT05fUkVUUllBQkxFX0ZBSUxVUkUnLFxuICBUSU1FT1VUOiAnVElNRU9VVCcsXG4gIE1BWElNVU1fQVRURU1QVFNfUkVBQ0hFRDogJ01BWElNVU1fQVRURU1QVFNfUkVBQ0hFRCcsXG4gIFJFVFJZX1BPTElDWV9OT1RfU0VUOiAnUkVUUllfUE9MSUNZX05PVF9TRVQnLFxuICBJTlRFUk5BTF9TRVJWRVJfRVJST1I6ICdJTlRFUk5BTF9TRVJWRVJfRVJST1InLFxuICBDQU5DRUxfUkVRVUVTVEVEOiAnQ0FOQ0VMX1JFUVVFU1RFRCcsXG5cbiAgLyoqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgSU5fUFJPR1JFU1N9IGluc3RlYWQuICovXG4gIFJFVFJZX1NUQVRFX0lOX1BST0dSRVNTOiAnSU5fUFJPR1JFU1MnLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG5cbiAgLyoqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgTk9OX1JFVFJZQUJMRV9GQUlMVVJFfSBpbnN0ZWFkLiAqL1xuICBSRVRSWV9TVEFURV9OT05fUkVUUllBQkxFX0ZBSUxVUkU6ICdOT05fUkVUUllBQkxFX0ZBSUxVUkUnLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG5cbiAgLyoqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgVElNRU9VVH0gaW5zdGVhZC4gKi9cbiAgUkVUUllfU1RBVEVfVElNRU9VVDogJ1RJTUVPVVQnLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG5cbiAgLyoqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgTUFYSU1VTV9BVFRFTVBUU19SRUFDSEVEfSBpbnN0ZWFkLiAqL1xuICBSRVRSWV9TVEFURV9NQVhJTVVNX0FUVEVNUFRTX1JFQUNIRUQ6ICdNQVhJTVVNX0FUVEVNUFRTX1JFQUNIRUQnLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG5cbiAgLyoqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgUkVUUllfUE9MSUNZX05PVF9TRVR9IGluc3RlYWQuICovXG4gIFJFVFJZX1NUQVRFX1JFVFJZX1BPTElDWV9OT1RfU0VUOiAnUkVUUllfUE9MSUNZX05PVF9TRVQnLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG5cbiAgLyoqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgSU5URVJOQUxfU0VSVkVSX0VSUk9SfSBpbnN0ZWFkLiAqL1xuICBSRVRSWV9TVEFURV9JTlRFUk5BTF9TRVJWRVJfRVJST1I6ICdJTlRFUk5BTF9TRVJWRVJfRVJST1InLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG5cbiAgLyoqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgQ0FOQ0VMX1JFUVVFU1RFRH0gaW5zdGVhZC4gKi9cbiAgUkVUUllfU1RBVEVfQ0FOQ0VMX1JFUVVFU1RFRDogJ0NBTkNFTF9SRVFVRVNURUQnLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG5cbiAgLyoqIEBkZXByZWNhdGVkIFVzZSBgdW5kZWZpbmVkYCBpbnN0ZWFkLiAqL1xuICBSRVRSWV9TVEFURV9VTlNQRUNJRklFRDogdW5kZWZpbmVkLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG59IGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgUmV0cnlTdGF0ZSA9ICh0eXBlb2YgUmV0cnlTdGF0ZSlba2V5b2YgdHlwZW9mIFJldHJ5U3RhdGVdO1xuXG5leHBvcnQgY29uc3QgW2VuY29kZVJldHJ5U3RhdGUsIGRlY29kZVJldHJ5U3RhdGVdID0gbWFrZVByb3RvRW51bUNvbnZlcnRlcnM8XG4gIHRlbXBvcmFsLmFwaS5lbnVtcy52MS5SZXRyeVN0YXRlLFxuICB0eXBlb2YgdGVtcG9yYWwuYXBpLmVudW1zLnYxLlJldHJ5U3RhdGUsXG4gIGtleW9mIHR5cGVvZiB0ZW1wb3JhbC5hcGkuZW51bXMudjEuUmV0cnlTdGF0ZSxcbiAgdHlwZW9mIFJldHJ5U3RhdGUsXG4gICdSRVRSWV9TVEFURV8nXG4+KFxuICB7XG4gICAgW1JldHJ5U3RhdGUuSU5fUFJPR1JFU1NdOiAxLFxuICAgIFtSZXRyeVN0YXRlLk5PTl9SRVRSWUFCTEVfRkFJTFVSRV06IDIsXG4gICAgW1JldHJ5U3RhdGUuVElNRU9VVF06IDMsXG4gICAgW1JldHJ5U3RhdGUuTUFYSU1VTV9BVFRFTVBUU19SRUFDSEVEXTogNCxcbiAgICBbUmV0cnlTdGF0ZS5SRVRSWV9QT0xJQ1lfTk9UX1NFVF06IDUsXG4gICAgW1JldHJ5U3RhdGUuSU5URVJOQUxfU0VSVkVSX0VSUk9SXTogNixcbiAgICBbUmV0cnlTdGF0ZS5DQU5DRUxfUkVRVUVTVEVEXTogNyxcbiAgICBVTlNQRUNJRklFRDogMCxcbiAgfSBhcyBjb25zdCxcbiAgJ1JFVFJZX1NUQVRFXydcbik7XG5cbi8qKlxuICogQSBjYXRlZ29yeSB0byBkZXNjcmliZSB0aGUgc2V2ZXJpdHkgYW5kIGNoYW5nZSB0aGUgb2JzZXJ2YWJpbGl0eSBiZWhhdmlvciBvZiBhbiBhcHBsaWNhdGlvbiBmYWlsdXJlLlxuICpcbiAqIEN1cnJlbnRseSwgb2JzZXJ2YWJpbGl0eSBiZWhhdmlvdXIgY2hhbmdlcyBhcmUgbGltaXRlZCB0bzpcbiAqIC0gYWN0aXZpdGllcyB0aGF0IGZhaWwgZHVlIHRvIGEgQkVOSUdOIGFwcGxpY2F0aW9uIGZhaWx1cmUgZW1pdCBERUJVRyBsZXZlbCBsb2dzIGFuZCBkbyBub3QgcmVjb3JkIG1ldHJpY3NcbiAqXG4gKiBAZXhwZXJpbWVudGFsIENhdGVnb3J5IGlzIGEgbmV3IGZlYXR1cmUgYW5kIG1heSBiZSBzdWJqZWN0IHRvIGNoYW5nZS5cbiAqL1xuZXhwb3J0IGNvbnN0IEFwcGxpY2F0aW9uRmFpbHVyZUNhdGVnb3J5ID0ge1xuICBCRU5JR046ICdCRU5JR04nLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IHR5cGUgQXBwbGljYXRpb25GYWlsdXJlQ2F0ZWdvcnkgPSAodHlwZW9mIEFwcGxpY2F0aW9uRmFpbHVyZUNhdGVnb3J5KVtrZXlvZiB0eXBlb2YgQXBwbGljYXRpb25GYWlsdXJlQ2F0ZWdvcnldO1xuXG5leHBvcnQgY29uc3QgW2VuY29kZUFwcGxpY2F0aW9uRmFpbHVyZUNhdGVnb3J5LCBkZWNvZGVBcHBsaWNhdGlvbkZhaWx1cmVDYXRlZ29yeV0gPSBtYWtlUHJvdG9FbnVtQ29udmVydGVyczxcbiAgdGVtcG9yYWwuYXBpLmVudW1zLnYxLkFwcGxpY2F0aW9uRXJyb3JDYXRlZ29yeSxcbiAgdHlwZW9mIHRlbXBvcmFsLmFwaS5lbnVtcy52MS5BcHBsaWNhdGlvbkVycm9yQ2F0ZWdvcnksXG4gIGtleW9mIHR5cGVvZiB0ZW1wb3JhbC5hcGkuZW51bXMudjEuQXBwbGljYXRpb25FcnJvckNhdGVnb3J5LFxuICB0eXBlb2YgQXBwbGljYXRpb25GYWlsdXJlQ2F0ZWdvcnksXG4gICdBUFBMSUNBVElPTl9FUlJPUl9DQVRFR09SWV8nXG4+KFxuICB7XG4gICAgW0FwcGxpY2F0aW9uRmFpbHVyZUNhdGVnb3J5LkJFTklHTl06IDEsXG4gICAgVU5TUEVDSUZJRUQ6IDAsXG4gIH0gYXMgY29uc3QsXG4gICdBUFBMSUNBVElPTl9FUlJPUl9DQVRFR09SWV8nXG4pO1xuXG5leHBvcnQgdHlwZSBXb3JrZmxvd0V4ZWN1dGlvbiA9IHRlbXBvcmFsLmFwaS5jb21tb24udjEuSVdvcmtmbG93RXhlY3V0aW9uO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgZmFpbHVyZXMgdGhhdCBjYW4gY3Jvc3MgV29ya2Zsb3cgYW5kIEFjdGl2aXR5IGJvdW5kYXJpZXMuXG4gKlxuICogKipOZXZlciBleHRlbmQgdGhpcyBjbGFzcyBvciBhbnkgb2YgaXRzIGNoaWxkcmVuLioqXG4gKlxuICogVGhlIG9ubHkgY2hpbGQgY2xhc3MgeW91IHNob3VsZCBldmVyIHRocm93IGZyb20geW91ciBjb2RlIGlzIHtAbGluayBBcHBsaWNhdGlvbkZhaWx1cmV9LlxuICovXG5AU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IoJ1RlbXBvcmFsRmFpbHVyZScpXG5leHBvcnQgY2xhc3MgVGVtcG9yYWxGYWlsdXJlIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogVGhlIG9yaWdpbmFsIGZhaWx1cmUgdGhhdCBjb25zdHJ1Y3RlZCB0aGlzIGVycm9yLlxuICAgKlxuICAgKiBPbmx5IHByZXNlbnQgaWYgdGhpcyBlcnJvciB3YXMgZ2VuZXJhdGVkIGZyb20gYW4gZXh0ZXJuYWwgb3BlcmF0aW9uLlxuICAgKi9cbiAgcHVibGljIGZhaWx1cmU/OiBQcm90b0ZhaWx1cmU7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgbWVzc2FnZT86IHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGwsXG4gICAgcHVibGljIHJlYWRvbmx5IGNhdXNlPzogRXJyb3JcbiAgKSB7XG4gICAgc3VwZXIobWVzc2FnZSA/PyB1bmRlZmluZWQpO1xuICB9XG59XG5cbi8qKiBFeGNlcHRpb25zIG9yaWdpbmF0ZWQgYXQgdGhlIFRlbXBvcmFsIHNlcnZpY2UuICovXG5AU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IoJ1NlcnZlckZhaWx1cmUnKVxuZXhwb3J0IGNsYXNzIFNlcnZlckZhaWx1cmUgZXh0ZW5kcyBUZW1wb3JhbEZhaWx1cmUge1xuICBjb25zdHJ1Y3RvcihcbiAgICBtZXNzYWdlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgcHVibGljIHJlYWRvbmx5IG5vblJldHJ5YWJsZTogYm9vbGVhbixcbiAgICBjYXVzZT86IEVycm9yXG4gICkge1xuICAgIHN1cGVyKG1lc3NhZ2UsIGNhdXNlKTtcbiAgfVxufVxuXG4vKipcbiAqIGBBcHBsaWNhdGlvbkZhaWx1cmVgcyBhcmUgdXNlZCB0byBjb21tdW5pY2F0ZSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBmYWlsdXJlcyBpbiBXb3JrZmxvd3MgYW5kIEFjdGl2aXRpZXMuXG4gKlxuICogVGhlIHtAbGluayB0eXBlfSBwcm9wZXJ0eSBpcyBtYXRjaGVkIGFnYWluc3Qge0BsaW5rIFJldHJ5UG9saWN5Lm5vblJldHJ5YWJsZUVycm9yVHlwZXN9IHRvIGRldGVybWluZSBpZiBhbiBpbnN0YW5jZVxuICogb2YgdGhpcyBlcnJvciBpcyByZXRyeWFibGUuIEFub3RoZXIgd2F5IHRvIGF2b2lkIHJldHJ5aW5nIGlzIGJ5IHNldHRpbmcgdGhlIHtAbGluayBub25SZXRyeWFibGV9IGZsYWcgdG8gYHRydWVgLlxuICpcbiAqIEluIFdvcmtmbG93cywgaWYgeW91IHRocm93IGEgbm9uLWBBcHBsaWNhdGlvbkZhaWx1cmVgLCB0aGUgV29ya2Zsb3cgVGFzayB3aWxsIGZhaWwgYW5kIGJlIHJldHJpZWQuIElmIHlvdSB0aHJvdyBhblxuICogYEFwcGxpY2F0aW9uRmFpbHVyZWAsIHRoZSBXb3JrZmxvdyBFeGVjdXRpb24gd2lsbCBmYWlsLlxuICpcbiAqIEluIEFjdGl2aXRpZXMsIHlvdSBjYW4gZWl0aGVyIHRocm93IGFuIGBBcHBsaWNhdGlvbkZhaWx1cmVgIG9yIGFub3RoZXIgYEVycm9yYCB0byBmYWlsIHRoZSBBY3Rpdml0eSBUYXNrLiBJbiB0aGVcbiAqIGxhdHRlciBjYXNlLCB0aGUgYEVycm9yYCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhbiBgQXBwbGljYXRpb25GYWlsdXJlYC4gVGhlIGNvbnZlcnNpb24gaXMgZG9uZSBhcyBmb2xsb3dpbmc6XG4gKlxuICogLSBgdHlwZWAgaXMgc2V0IHRvIGBlcnJvci5jb25zdHJ1Y3Rvcj8ubmFtZSA/PyBlcnJvci5uYW1lYFxuICogLSBgbWVzc2FnZWAgaXMgc2V0IHRvIGBlcnJvci5tZXNzYWdlYFxuICogLSBgbm9uUmV0cnlhYmxlYCBpcyBzZXQgdG8gZmFsc2VcbiAqIC0gYGRldGFpbHNgIGFyZSBzZXQgdG8gbnVsbFxuICogLSBzdGFjayB0cmFjZSBpcyBjb3BpZWQgZnJvbSB0aGUgb3JpZ2luYWwgZXJyb3JcbiAqXG4gKiBXaGVuIGFuIHtAbGluayBodHRwczovL2RvY3MudGVtcG9yYWwuaW8vY29uY2VwdHMvd2hhdC1pcy1hbi1hY3Rpdml0eS1leGVjdXRpb24gfCBBY3Rpdml0eSBFeGVjdXRpb259IGZhaWxzLCB0aGVcbiAqIGBBcHBsaWNhdGlvbkZhaWx1cmVgIGZyb20gdGhlIGxhc3QgQWN0aXZpdHkgVGFzayB3aWxsIGJlIHRoZSBgY2F1c2VgIG9mIHRoZSB7QGxpbmsgQWN0aXZpdHlGYWlsdXJlfSB0aHJvd24gaW4gdGhlXG4gKiBXb3JrZmxvdy5cbiAqL1xuQFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yKCdBcHBsaWNhdGlvbkZhaWx1cmUnKVxuZXhwb3J0IGNsYXNzIEFwcGxpY2F0aW9uRmFpbHVyZSBleHRlbmRzIFRlbXBvcmFsRmFpbHVyZSB7XG4gIC8qKlxuICAgKiBBbHRlcm5hdGl2ZWx5LCB1c2Uge0BsaW5rIGZyb21FcnJvcn0gb3Ige0BsaW5rIGNyZWF0ZX0uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBtZXNzYWdlPzogc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbCxcbiAgICBwdWJsaWMgcmVhZG9ubHkgdHlwZT86IHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGwsXG4gICAgcHVibGljIHJlYWRvbmx5IG5vblJldHJ5YWJsZT86IGJvb2xlYW4gfCB1bmRlZmluZWQgfCBudWxsLFxuICAgIHB1YmxpYyByZWFkb25seSBkZXRhaWxzPzogdW5rbm93bltdIHwgdW5kZWZpbmVkIHwgbnVsbCxcbiAgICBjYXVzZT86IEVycm9yLFxuICAgIHB1YmxpYyByZWFkb25seSBuZXh0UmV0cnlEZWxheT86IER1cmF0aW9uIHwgdW5kZWZpbmVkIHwgbnVsbCxcbiAgICBwdWJsaWMgcmVhZG9ubHkgY2F0ZWdvcnk/OiBBcHBsaWNhdGlvbkZhaWx1cmVDYXRlZ29yeSB8IHVuZGVmaW5lZCB8IG51bGxcbiAgKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgY2F1c2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgQXBwbGljYXRpb25GYWlsdXJlYCBmcm9tIGFuIEVycm9yIG9iamVjdC5cbiAgICpcbiAgICogRmlyc3QgY2FsbHMge0BsaW5rIGVuc3VyZUFwcGxpY2F0aW9uRmFpbHVyZSB8IGBlbnN1cmVBcHBsaWNhdGlvbkZhaWx1cmUoZXJyb3IpYH0gYW5kIHRoZW4gb3ZlcnJpZGVzIGFueSBmaWVsZHNcbiAgICogcHJvdmlkZWQgaW4gYG92ZXJyaWRlc2AuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21FcnJvcihlcnJvcjogRXJyb3IgfCB1bmtub3duLCBvdmVycmlkZXM/OiBBcHBsaWNhdGlvbkZhaWx1cmVPcHRpb25zKTogQXBwbGljYXRpb25GYWlsdXJlIHtcbiAgICBjb25zdCBmYWlsdXJlID0gZW5zdXJlQXBwbGljYXRpb25GYWlsdXJlKGVycm9yKTtcbiAgICBPYmplY3QuYXNzaWduKGZhaWx1cmUsIG92ZXJyaWRlcyk7XG4gICAgcmV0dXJuIGZhaWx1cmU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBBcHBsaWNhdGlvbkZhaWx1cmVgLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB3aWxsIGJlIHJldHJ5YWJsZSAodW5sZXNzIGl0cyBgdHlwZWAgaXMgaW5jbHVkZWQgaW4ge0BsaW5rIFJldHJ5UG9saWN5Lm5vblJldHJ5YWJsZUVycm9yVHlwZXN9KS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlKG9wdGlvbnM6IEFwcGxpY2F0aW9uRmFpbHVyZU9wdGlvbnMpOiBBcHBsaWNhdGlvbkZhaWx1cmUge1xuICAgIGNvbnN0IHsgbWVzc2FnZSwgdHlwZSwgbm9uUmV0cnlhYmxlID0gZmFsc2UsIGRldGFpbHMsIG5leHRSZXRyeURlbGF5LCBjYXVzZSwgY2F0ZWdvcnkgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIG5ldyB0aGlzKG1lc3NhZ2UsIHR5cGUsIG5vblJldHJ5YWJsZSwgZGV0YWlscywgY2F1c2UsIG5leHRSZXRyeURlbGF5LCBjYXRlZ29yeSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgbmV3IGBBcHBsaWNhdGlvbkZhaWx1cmVgIHdpdGggdGhlIHtAbGluayBub25SZXRyeWFibGV9IGZsYWcgc2V0IHRvIGZhbHNlLiBOb3RlIHRoYXQgdGhpcyBlcnJvciB3aWxsIHN0aWxsXG4gICAqIG5vdCBiZSByZXRyaWVkIGlmIGl0cyBgdHlwZWAgaXMgaW5jbHVkZWQgaW4ge0BsaW5rIFJldHJ5UG9saWN5Lm5vblJldHJ5YWJsZUVycm9yVHlwZXN9LlxuICAgKlxuICAgKiBAcGFyYW0gbWVzc2FnZSBPcHRpb25hbCBlcnJvciBtZXNzYWdlXG4gICAqIEBwYXJhbSB0eXBlIE9wdGlvbmFsIGVycm9yIHR5cGUgKHVzZWQgYnkge0BsaW5rIFJldHJ5UG9saWN5Lm5vblJldHJ5YWJsZUVycm9yVHlwZXN9KVxuICAgKiBAcGFyYW0gZGV0YWlscyBPcHRpb25hbCBkZXRhaWxzIGFib3V0IHRoZSBmYWlsdXJlLiBTZXJpYWxpemVkIGJ5IHRoZSBXb3JrZXIncyB7QGxpbmsgUGF5bG9hZENvbnZlcnRlcn0uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJldHJ5YWJsZShtZXNzYWdlPzogc3RyaW5nIHwgbnVsbCwgdHlwZT86IHN0cmluZyB8IG51bGwsIC4uLmRldGFpbHM6IHVua25vd25bXSk6IEFwcGxpY2F0aW9uRmFpbHVyZSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKG1lc3NhZ2UsIHR5cGUgPz8gJ0Vycm9yJywgZmFsc2UsIGRldGFpbHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIG5ldyBgQXBwbGljYXRpb25GYWlsdXJlYCB3aXRoIHRoZSB7QGxpbmsgbm9uUmV0cnlhYmxlfSBmbGFnIHNldCB0byB0cnVlLlxuICAgKlxuICAgKiBXaGVuIHRocm93biBmcm9tIGFuIEFjdGl2aXR5IG9yIFdvcmtmbG93LCB0aGUgQWN0aXZpdHkgb3IgV29ya2Zsb3cgd2lsbCBub3QgYmUgcmV0cmllZCAoZXZlbiBpZiBgdHlwZWAgaXMgbm90XG4gICAqIGxpc3RlZCBpbiB7QGxpbmsgUmV0cnlQb2xpY3kubm9uUmV0cnlhYmxlRXJyb3JUeXBlc30pLlxuICAgKlxuICAgKiBAcGFyYW0gbWVzc2FnZSBPcHRpb25hbCBlcnJvciBtZXNzYWdlXG4gICAqIEBwYXJhbSB0eXBlIE9wdGlvbmFsIGVycm9yIHR5cGVcbiAgICogQHBhcmFtIGRldGFpbHMgT3B0aW9uYWwgZGV0YWlscyBhYm91dCB0aGUgZmFpbHVyZS4gU2VyaWFsaXplZCBieSB0aGUgV29ya2VyJ3Mge0BsaW5rIFBheWxvYWRDb252ZXJ0ZXJ9LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBub25SZXRyeWFibGUobWVzc2FnZT86IHN0cmluZyB8IG51bGwsIHR5cGU/OiBzdHJpbmcgfCBudWxsLCAuLi5kZXRhaWxzOiB1bmtub3duW10pOiBBcHBsaWNhdGlvbkZhaWx1cmUge1xuICAgIHJldHVybiBuZXcgdGhpcyhtZXNzYWdlLCB0eXBlID8/ICdFcnJvcicsIHRydWUsIGRldGFpbHMpO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXBwbGljYXRpb25GYWlsdXJlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBFcnJvciBtZXNzYWdlXG4gICAqL1xuICBtZXNzYWdlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBFcnJvciB0eXBlICh1c2VkIGJ5IHtAbGluayBSZXRyeVBvbGljeS5ub25SZXRyeWFibGVFcnJvclR5cGVzfSlcbiAgICovXG4gIHR5cGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGN1cnJlbnQgQWN0aXZpdHkgb3IgV29ya2Zsb3cgY2FuIGJlIHJldHJpZWRcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIG5vblJldHJ5YWJsZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIERldGFpbHMgYWJvdXQgdGhlIGZhaWx1cmUuIFNlcmlhbGl6ZWQgYnkgdGhlIFdvcmtlcidzIHtAbGluayBQYXlsb2FkQ29udmVydGVyfS5cbiAgICovXG4gIGRldGFpbHM/OiB1bmtub3duW107XG5cbiAgLyoqXG4gICAqIElmIHNldCwgb3ZlcnJpZGVzIHRoZSBkZWxheSB1bnRpbCB0aGUgbmV4dCByZXRyeSBvZiB0aGlzIEFjdGl2aXR5IC8gV29ya2Zsb3cgVGFzay5cbiAgICpcbiAgICogUmV0cnkgYXR0ZW1wdHMgd2lsbCBzdGlsbCBiZSBzdWJqZWN0IHRvIHRoZSBtYXhpbXVtIHJldHJpZXMgbGltaXQgYW5kIHRvdGFsIHRpbWUgbGltaXQgZGVmaW5lZFxuICAgKiBieSB0aGUgcG9saWN5LlxuICAgKi9cbiAgbmV4dFJldHJ5RGVsYXk/OiBEdXJhdGlvbjtcblxuICAvKipcbiAgICogQ2F1c2Ugb2YgdGhlIGZhaWx1cmVcbiAgICovXG4gIGNhdXNlPzogRXJyb3I7XG5cbiAgLyoqXG4gICAqIFNldmVyaXR5IGNhdGVnb3J5IG9mIHRoZSBhcHBsaWNhdGlvbiBlcnJvci5cbiAgICogQWZmZWN0cyB3b3JrZXItc2lkZSBsb2dnaW5nIGFuZCBtZXRyaWNzIGJlaGF2aW9yIG9mIHRoaXMgZmFpbHVyZS5cbiAgICovXG4gIGNhdGVnb3J5PzogQXBwbGljYXRpb25GYWlsdXJlQ2F0ZWdvcnk7XG59XG5cbi8qKlxuICogVGhpcyBlcnJvciBpcyB0aHJvd24gd2hlbiBDYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLiBUbyBhbGxvdyBDYW5jZWxsYXRpb24gdG8gaGFwcGVuLCBsZXQgaXQgcHJvcGFnYXRlLiBUb1xuICogaWdub3JlIENhbmNlbGxhdGlvbiwgY2F0Y2ggaXQgYW5kIGNvbnRpbnVlIGV4ZWN1dGluZy4gTm90ZSB0aGF0IENhbmNlbGxhdGlvbiBjYW4gb25seSBiZSByZXF1ZXN0ZWQgYSBzaW5nbGUgdGltZSwgc29cbiAqIHlvdXIgV29ya2Zsb3cvQWN0aXZpdHkgRXhlY3V0aW9uIHdpbGwgbm90IHJlY2VpdmUgZnVydGhlciBDYW5jZWxsYXRpb24gcmVxdWVzdHMuXG4gKlxuICogV2hlbiBhIFdvcmtmbG93IG9yIEFjdGl2aXR5IGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBjYW5jZWxsZWQsIGEgYENhbmNlbGxlZEZhaWx1cmVgIHdpbGwgYmUgdGhlIGBjYXVzZWAuXG4gKi9cbkBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvcignQ2FuY2VsbGVkRmFpbHVyZScpXG5leHBvcnQgY2xhc3MgQ2FuY2VsbGVkRmFpbHVyZSBleHRlbmRzIFRlbXBvcmFsRmFpbHVyZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIG1lc3NhZ2U6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBwdWJsaWMgcmVhZG9ubHkgZGV0YWlsczogdW5rbm93bltdID0gW10sXG4gICAgY2F1c2U/OiBFcnJvclxuICApIHtcbiAgICBzdXBlcihtZXNzYWdlLCBjYXVzZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBVc2VkIGFzIHRoZSBgY2F1c2VgIHdoZW4gYSBXb3JrZmxvdyBoYXMgYmVlbiB0ZXJtaW5hdGVkXG4gKi9cbkBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvcignVGVybWluYXRlZEZhaWx1cmUnKVxuZXhwb3J0IGNsYXNzIFRlcm1pbmF0ZWRGYWlsdXJlIGV4dGVuZHMgVGVtcG9yYWxGYWlsdXJlIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZTogc3RyaW5nIHwgdW5kZWZpbmVkLCBjYXVzZT86IEVycm9yKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgY2F1c2UpO1xuICB9XG59XG5cbi8qKlxuICogVXNlZCB0byByZXByZXNlbnQgdGltZW91dHMgb2YgQWN0aXZpdGllcyBhbmQgV29ya2Zsb3dzXG4gKi9cbkBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvcignVGltZW91dEZhaWx1cmUnKVxuZXhwb3J0IGNsYXNzIFRpbWVvdXRGYWlsdXJlIGV4dGVuZHMgVGVtcG9yYWxGYWlsdXJlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgbWVzc2FnZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHB1YmxpYyByZWFkb25seSBsYXN0SGVhcnRiZWF0RGV0YWlsczogdW5rbm93bixcbiAgICBwdWJsaWMgcmVhZG9ubHkgdGltZW91dFR5cGU6IFRpbWVvdXRUeXBlXG4gICkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICB9XG59XG5cbi8qKlxuICogQ29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgYW4gQWN0aXZpdHkgZmFpbHVyZS4gQWx3YXlzIGNvbnRhaW5zIHRoZSBvcmlnaW5hbCByZWFzb24gZm9yIHRoZSBmYWlsdXJlIGFzIGl0cyBgY2F1c2VgLlxuICogRm9yIGV4YW1wbGUsIGlmIGFuIEFjdGl2aXR5IHRpbWVkIG91dCwgdGhlIGNhdXNlIHdpbGwgYmUgYSB7QGxpbmsgVGltZW91dEZhaWx1cmV9LlxuICpcbiAqIFRoaXMgZXhjZXB0aW9uIGlzIGV4cGVjdGVkIHRvIGJlIHRocm93biBvbmx5IGJ5IHRoZSBmcmFtZXdvcmsgY29kZS5cbiAqL1xuQFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yKCdBY3Rpdml0eUZhaWx1cmUnKVxuZXhwb3J0IGNsYXNzIEFjdGl2aXR5RmFpbHVyZSBleHRlbmRzIFRlbXBvcmFsRmFpbHVyZSB7XG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICBtZXNzYWdlOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgcHVibGljIHJlYWRvbmx5IGFjdGl2aXR5VHlwZTogc3RyaW5nLFxuICAgIHB1YmxpYyByZWFkb25seSBhY3Rpdml0eUlkOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgcHVibGljIHJlYWRvbmx5IHJldHJ5U3RhdGU6IFJldHJ5U3RhdGUsXG4gICAgcHVibGljIHJlYWRvbmx5IGlkZW50aXR5OiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgY2F1c2U/OiBFcnJvclxuICApIHtcbiAgICBzdXBlcihtZXNzYWdlLCBjYXVzZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCBhIENoaWxkIFdvcmtmbG93IGZhaWx1cmUuIEFsd2F5cyBjb250YWlucyB0aGUgcmVhc29uIGZvciB0aGUgZmFpbHVyZSBhcyBpdHMge0BsaW5rIGNhdXNlfS5cbiAqIEZvciBleGFtcGxlLCBpZiB0aGUgQ2hpbGQgd2FzIFRlcm1pbmF0ZWQsIHRoZSBgY2F1c2VgIGlzIGEge0BsaW5rIFRlcm1pbmF0ZWRGYWlsdXJlfS5cbiAqXG4gKiBUaGlzIGV4Y2VwdGlvbiBpcyBleHBlY3RlZCB0byBiZSB0aHJvd24gb25seSBieSB0aGUgZnJhbWV3b3JrIGNvZGUuXG4gKi9cbkBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvcignQ2hpbGRXb3JrZmxvd0ZhaWx1cmUnKVxuZXhwb3J0IGNsYXNzIENoaWxkV29ya2Zsb3dGYWlsdXJlIGV4dGVuZHMgVGVtcG9yYWxGYWlsdXJlIHtcbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyByZWFkb25seSBuYW1lc3BhY2U6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBwdWJsaWMgcmVhZG9ubHkgZXhlY3V0aW9uOiBXb3JrZmxvd0V4ZWN1dGlvbixcbiAgICBwdWJsaWMgcmVhZG9ubHkgd29ya2Zsb3dUeXBlOiBzdHJpbmcsXG4gICAgcHVibGljIHJlYWRvbmx5IHJldHJ5U3RhdGU6IFJldHJ5U3RhdGUsXG4gICAgY2F1c2U/OiBFcnJvclxuICApIHtcbiAgICBzdXBlcignQ2hpbGQgV29ya2Zsb3cgZXhlY3V0aW9uIGZhaWxlZCcsIGNhdXNlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIGEgTmV4dXMgT3BlcmF0aW9uIGV4ZWN1dGVkIGluc2lkZSBhIFdvcmtmbG93IGZhaWxzLlxuICpcbiAqIEBleHBlcmltZW50YWwgTmV4dXMgc3VwcG9ydCBpbiBUZW1wb3JhbCBTREsgaXMgZXhwZXJpbWVudGFsLlxuICovXG5AU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IoJ05leHVzT3BlcmF0aW9uRmFpbHVyZScpXG5leHBvcnQgY2xhc3MgTmV4dXNPcGVyYXRpb25GYWlsdXJlIGV4dGVuZHMgVGVtcG9yYWxGYWlsdXJlIHtcbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIG1lc3NhZ2U6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBwdWJsaWMgcmVhZG9ubHkgc2NoZWR1bGVkRXZlbnRJZDogbnVtYmVyIHwgdW5kZWZpbmVkLFxuICAgIHB1YmxpYyByZWFkb25seSBlbmRwb2ludDogc3RyaW5nLFxuICAgIHB1YmxpYyByZWFkb25seSBzZXJ2aWNlOiBzdHJpbmcsXG4gICAgcHVibGljIHJlYWRvbmx5IG9wZXJhdGlvbjogc3RyaW5nLFxuICAgIHB1YmxpYyByZWFkb25seSBvcGVyYXRpb25Ub2tlbjogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIGNhdXNlPzogRXJyb3JcbiAgKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgY2F1c2UpO1xuICB9XG59XG5cbi8vIFRPRE8obmV4dXMvZXJyb3IpOiBNYXliZSBhZGQgYSBOZXh1c0hhbmRsZXJGYWlsdXJlIGNsYXNzIGhlcmUsIG9uY2Ugd2UndmUgZGVjaWRlZCBvbiBlcnJvciBoYW5kbGluZy5cblxuLyoqXG4gKiBUaGlzIGV4Y2VwdGlvbiBpcyB0aHJvd24gaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcbiAqICAtIFdvcmtmbG93IHdpdGggdGhlIHNhbWUgV29ya2Zsb3cgSUQgaXMgY3VycmVudGx5IHJ1bm5pbmcgYW5kIHRoZSB7QGxpbmsgV29ya2Zsb3dPcHRpb25zLndvcmtmbG93SWRDb25mbGljdFBvbGljeX0gaXMgYFdPUktGTE9XX0lEX0NPTkZMSUNUX1BPTElDWV9GQUlMYFxuICogIC0gVGhlcmUgaXMgYSBjbG9zZWQgV29ya2Zsb3cgd2l0aCB0aGUgc2FtZSBXb3JrZmxvdyBJZCBhbmQgdGhlIHtAbGluayBXb3JrZmxvd09wdGlvbnMud29ya2Zsb3dJZFJldXNlUG9saWN5fVxuICogICAgaXMgYFdPUktGTE9XX0lEX1JFVVNFX1BPTElDWV9SRUpFQ1RfRFVQTElDQVRFYFxuICogIC0gVGhlcmUgaXMgY2xvc2VkIFdvcmtmbG93IGluIHRoZSBgQ29tcGxldGVkYCBzdGF0ZSB3aXRoIHRoZSBzYW1lIFdvcmtmbG93IElkIGFuZCB0aGUge0BsaW5rIFdvcmtmbG93T3B0aW9ucy53b3JrZmxvd0lkUmV1c2VQb2xpY3l9XG4gKiAgICBpcyBgV09SS0ZMT1dfSURfUkVVU0VfUE9MSUNZX0FMTE9XX0RVUExJQ0FURV9GQUlMRURfT05MWWBcbiAqL1xuQFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yKCdXb3JrZmxvd0V4ZWN1dGlvbkFscmVhZHlTdGFydGVkRXJyb3InKVxuZXhwb3J0IGNsYXNzIFdvcmtmbG93RXhlY3V0aW9uQWxyZWFkeVN0YXJ0ZWRFcnJvciBleHRlbmRzIFRlbXBvcmFsRmFpbHVyZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIG1lc3NhZ2U6IHN0cmluZyxcbiAgICBwdWJsaWMgcmVhZG9ubHkgd29ya2Zsb3dJZDogc3RyaW5nLFxuICAgIHB1YmxpYyByZWFkb25seSB3b3JrZmxvd1R5cGU6IHN0cmluZ1xuICApIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgfVxufVxuXG4vKipcbiAqIElmIGBlcnJvcmAgaXMgYWxyZWFkeSBhbiBgQXBwbGljYXRpb25GYWlsdXJlYCwgcmV0dXJucyBgZXJyb3JgLlxuICpcbiAqIE90aGVyd2lzZSwgY29udmVydHMgYGVycm9yYCBpbnRvIGFuIGBBcHBsaWNhdGlvbkZhaWx1cmVgIHdpdGg6XG4gKlxuICogLSBgbWVzc2FnZWA6IGBlcnJvci5tZXNzYWdlYCBvciBgU3RyaW5nKGVycm9yKWBcbiAqIC0gYHR5cGVgOiBgZXJyb3IuY29uc3RydWN0b3IubmFtZWAgb3IgYGVycm9yLm5hbWVgXG4gKiAtIGBzdGFja2A6IGBlcnJvci5zdGFja2Agb3IgYCcnYFxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlQXBwbGljYXRpb25GYWlsdXJlKGVycm9yOiB1bmtub3duKTogQXBwbGljYXRpb25GYWlsdXJlIHtcbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgQXBwbGljYXRpb25GYWlsdXJlKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgY29uc3QgbWVzc2FnZSA9IChpc1JlY29yZChlcnJvcikgJiYgU3RyaW5nKGVycm9yLm1lc3NhZ2UpKSB8fCBTdHJpbmcoZXJyb3IpO1xuICBjb25zdCB0eXBlID0gKGlzUmVjb3JkKGVycm9yKSAmJiAoZXJyb3IuY29uc3RydWN0b3I/Lm5hbWUgPz8gZXJyb3IubmFtZSkpIHx8IHVuZGVmaW5lZDtcbiAgY29uc3QgZmFpbHVyZSA9IEFwcGxpY2F0aW9uRmFpbHVyZS5jcmVhdGUoeyBtZXNzYWdlLCB0eXBlLCBub25SZXRyeWFibGU6IGZhbHNlIH0pO1xuICBmYWlsdXJlLnN0YWNrID0gKGlzUmVjb3JkKGVycm9yKSAmJiBTdHJpbmcoZXJyb3Iuc3RhY2spKSB8fCAnJztcbiAgcmV0dXJuIGZhaWx1cmU7XG59XG5cbi8qKlxuICogSWYgYGVycmAgaXMgYW4gRXJyb3IgaXQgaXMgdHVybmVkIGludG8gYW4gYEFwcGxpY2F0aW9uRmFpbHVyZWAuXG4gKlxuICogSWYgYGVycmAgd2FzIGFscmVhZHkgYSBgVGVtcG9yYWxGYWlsdXJlYCwgcmV0dXJucyB0aGUgb3JpZ2luYWwgZXJyb3IuXG4gKlxuICogT3RoZXJ3aXNlIHJldHVybnMgYW4gYEFwcGxpY2F0aW9uRmFpbHVyZWAgd2l0aCBgU3RyaW5nKGVycilgIGFzIHRoZSBtZXNzYWdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlVGVtcG9yYWxGYWlsdXJlKGVycjogdW5rbm93bik6IFRlbXBvcmFsRmFpbHVyZSB7XG4gIGlmIChlcnIgaW5zdGFuY2VvZiBUZW1wb3JhbEZhaWx1cmUpIHtcbiAgICByZXR1cm4gZXJyO1xuICB9XG4gIHJldHVybiBlbnN1cmVBcHBsaWNhdGlvbkZhaWx1cmUoZXJyKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJvb3QgY2F1c2UgbWVzc2FnZSBvZiBnaXZlbiBgZXJyb3JgLlxuICpcbiAqIEluIGNhc2UgYGVycm9yYCBpcyBhIHtAbGluayBUZW1wb3JhbEZhaWx1cmV9LCByZWN1cnNlIHRoZSBgY2F1c2VgIGNoYWluIGFuZCByZXR1cm4gdGhlIHJvb3QgYGNhdXNlLm1lc3NhZ2VgLlxuICogT3RoZXJ3aXNlLCByZXR1cm4gYGVycm9yLm1lc3NhZ2VgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcm9vdENhdXNlKGVycm9yOiB1bmtub3duKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgVGVtcG9yYWxGYWlsdXJlKSB7XG4gICAgcmV0dXJuIGVycm9yLmNhdXNlID8gcm9vdENhdXNlKGVycm9yLmNhdXNlKSA6IGVycm9yLm1lc3NhZ2U7XG4gIH1cbiAgcmV0dXJuIGVycm9yTWVzc2FnZShlcnJvcik7XG59XG4iLCIvKipcbiAqIENvbW1vbiBsaWJyYXJ5IGZvciBjb2RlIHRoYXQncyB1c2VkIGFjcm9zcyB0aGUgQ2xpZW50LCBXb3JrZXIsIGFuZC9vciBXb3JrZmxvd1xuICpcbiAqIEBtb2R1bGVcbiAqL1xuXG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICcuL2VuY29kaW5nJztcbmltcG9ydCAqIGFzIGhlbHBlcnMgZnJvbSAnLi90eXBlLWhlbHBlcnMnO1xuXG5leHBvcnQgKiBmcm9tICcuL2FjdGl2aXR5LW9wdGlvbnMnO1xuZXhwb3J0IHsgQWN0aXZpdHlDYW5jZWxsYXRpb25EZXRhaWxzT3B0aW9ucywgQWN0aXZpdHlDYW5jZWxsYXRpb25EZXRhaWxzIH0gZnJvbSAnLi9hY3Rpdml0eS1jYW5jZWxsYXRpb24tZGV0YWlscyc7XG5leHBvcnQgKiBmcm9tICcuL2NvbnZlcnRlci9kYXRhLWNvbnZlcnRlcic7XG5leHBvcnQgKiBmcm9tICcuL2NvbnZlcnRlci9mYWlsdXJlLWNvbnZlcnRlcic7XG5leHBvcnQgKiBmcm9tICcuL2NvbnZlcnRlci9wYXlsb2FkLWNvZGVjJztcbmV4cG9ydCAqIGZyb20gJy4vY29udmVydGVyL3BheWxvYWQtY29udmVydGVyJztcbmV4cG9ydCAqIGZyb20gJy4vY29udmVydGVyL3R5cGVzJztcbmV4cG9ydCAqIGZyb20gJy4vZGVwcmVjYXRlZC10aW1lJztcbmV4cG9ydCAqIGZyb20gJy4vZXJyb3JzJztcbmV4cG9ydCAqIGZyb20gJy4vZmFpbHVyZSc7XG5leHBvcnQgeyBIZWFkZXJzLCBOZXh0IH0gZnJvbSAnLi9pbnRlcmNlcHRvcnMnO1xuZXhwb3J0ICogZnJvbSAnLi9pbnRlcmZhY2VzJztcbmV4cG9ydCAqIGZyb20gJy4vbG9nZ2VyJztcbmV4cG9ydCAqIGZyb20gJy4vcHJpb3JpdHknO1xuZXhwb3J0ICogZnJvbSAnLi9tZXRyaWNzJztcbmV4cG9ydCAqIGZyb20gJy4vcmV0cnktcG9saWN5JztcbmV4cG9ydCB0eXBlIHsgVGltZXN0YW1wLCBEdXJhdGlvbiwgU3RyaW5nVmFsdWUgfSBmcm9tICcuL3RpbWUnO1xuZXhwb3J0ICogZnJvbSAnLi93b3JrZXItZGVwbG95bWVudHMnO1xuZXhwb3J0ICogZnJvbSAnLi93b3JrZmxvdy1kZWZpbml0aW9uLW9wdGlvbnMnO1xuZXhwb3J0ICogZnJvbSAnLi93b3JrZmxvdy1oYW5kbGUnO1xuZXhwb3J0ICogZnJvbSAnLi93b3JrZmxvdy1vcHRpb25zJztcbmV4cG9ydCAqIGZyb20gJy4vdmVyc2lvbmluZy1pbnRlbnQnO1xuZXhwb3J0IHtcbiAgU2VhcmNoQXR0cmlidXRlcywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBTZWFyY2hBdHRyaWJ1dGVWYWx1ZSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICBTZWFyY2hBdHRyaWJ1dGVUeXBlLFxuICBTZWFyY2hBdHRyaWJ1dGVQYWlyLFxuICBTZWFyY2hBdHRyaWJ1dGVVcGRhdGVQYWlyLFxuICBUeXBlZFNlYXJjaEF0dHJpYnV0ZXMsXG4gIGRlZmluZVNlYXJjaEF0dHJpYnV0ZUtleSxcbn0gZnJvbSAnLi9zZWFyY2gtYXR0cmlidXRlcyc7XG5cbi8qKlxuICogRW5jb2RlIGEgVVRGLTggc3RyaW5nIGludG8gYSBVaW50OEFycmF5XG4gKlxuICogQGhpZGRlblxuICogQGRlcHJlY2F0ZWQgLSBtZWFudCBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHU4KHM6IHN0cmluZyk6IFVpbnQ4QXJyYXkge1xuICByZXR1cm4gZW5jb2RpbmcuZW5jb2RlKHMpO1xufVxuXG4vKipcbiAqIERlY29kZSBhIFVpbnQ4QXJyYXkgaW50byBhIFVURi04IHN0cmluZ1xuICpcbiAqIEBoaWRkZW5cbiAqIEBkZXByZWNhdGVkIC0gbWVhbnQgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYXJyOiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgcmV0dXJuIGVuY29kaW5nLmRlY29kZShhcnIpO1xufVxuXG4vKipcbiAqIEdldCBgZXJyb3IubWVzc2FnZWAgKG9yIGB1bmRlZmluZWRgIGlmIG5vdCBwcmVzZW50KVxuICpcbiAqIEBoaWRkZW5cbiAqIEBkZXByZWNhdGVkIC0gbWVhbnQgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcnJvck1lc3NhZ2UoZXJyb3I6IHVua25vd24pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICByZXR1cm4gaGVscGVycy5lcnJvck1lc3NhZ2UoZXJyb3IpO1xufVxuXG4vKipcbiAqIEdldCBgZXJyb3IuY29kZWAgKG9yIGB1bmRlZmluZWRgIGlmIG5vdCBwcmVzZW50KVxuICpcbiAqIEBoaWRkZW5cbiAqIEBkZXByZWNhdGVkIC0gbWVhbnQgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcnJvckNvZGUoZXJyb3I6IHVua25vd24pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICByZXR1cm4gaGVscGVycy5lcnJvckNvZGUoZXJyb3IpO1xufVxuIiwiaW1wb3J0IHsgQW55RnVuYywgT21pdExhc3RQYXJhbSB9IGZyb20gJy4vdHlwZS1oZWxwZXJzJztcbmltcG9ydCB7IFBheWxvYWQgfSBmcm9tICcuL2ludGVyZmFjZXMnO1xuXG4vKipcbiAqIFR5cGUgb2YgdGhlIG5leHQgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gaW50ZXJjZXB0b3IgZnVuY3Rpb25cbiAqXG4gKiBDYWxsZWQgZnJvbSBhbiBpbnRlcmNlcHRvciB0byBjb250aW51ZSB0aGUgaW50ZXJjZXB0aW9uIGNoYWluXG4gKi9cbmV4cG9ydCB0eXBlIE5leHQ8SUYsIEZOIGV4dGVuZHMga2V5b2YgSUY+ID0gUmVxdWlyZWQ8SUY+W0ZOXSBleHRlbmRzIEFueUZ1bmMgPyBPbWl0TGFzdFBhcmFtPFJlcXVpcmVkPElGPltGTl0+IDogbmV2ZXI7XG5cbi8qKiBIZWFkZXJzIGFyZSBqdXN0IGEgbWFwcGluZyBvZiBoZWFkZXIgbmFtZSB0byBQYXlsb2FkICovXG5leHBvcnQgdHlwZSBIZWFkZXJzID0gUmVjb3JkPHN0cmluZywgUGF5bG9hZD47XG5cbi8qKlxuICogQ29tcG9zZSBhbGwgaW50ZXJjZXB0b3IgbWV0aG9kcyBpbnRvIGEgc2luZ2xlIGZ1bmN0aW9uLlxuICpcbiAqIENhbGxpbmcgdGhlIGNvbXBvc2VkIGZ1bmN0aW9uIHJlc3VsdHMgaW4gY2FsbGluZyBlYWNoIG9mIHRoZSBwcm92aWRlZCBpbnRlcmNlcHRvciwgaW4gb3JkZXIgKGZyb20gdGhlIGZpcnN0IHRvXG4gKiB0aGUgbGFzdCksIGZvbGxvd2VkIGJ5IHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBwcm92aWRlZCBhcyBhcmd1bWVudCB0byBgY29tcG9zZUludGVyY2VwdG9ycygpYC5cbiAqXG4gKiBAcGFyYW0gaW50ZXJjZXB0b3JzIGEgbGlzdCBvZiBpbnRlcmNlcHRvcnNcbiAqIEBwYXJhbSBtZXRob2QgdGhlIG5hbWUgb2YgdGhlIGludGVyY2VwdG9yIG1ldGhvZCB0byBjb21wb3NlXG4gKiBAcGFyYW0gbmV4dCB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYXQgdGhlIGVuZCBvZiB0aGUgaW50ZXJjZXB0aW9uIGNoYWluXG4gKi9cbi8vIHRzLXBydW5lLWlnbm9yZS1uZXh0IChpbXBvcnRlZCB2aWEgbGliL2ludGVyY2VwdG9ycylcbmV4cG9ydCBmdW5jdGlvbiBjb21wb3NlSW50ZXJjZXB0b3JzPEksIE0gZXh0ZW5kcyBrZXlvZiBJPihpbnRlcmNlcHRvcnM6IElbXSwgbWV0aG9kOiBNLCBuZXh0OiBOZXh0PEksIE0+KTogTmV4dDxJLCBNPiB7XG4gIGZvciAobGV0IGkgPSBpbnRlcmNlcHRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBjb25zdCBpbnRlcmNlcHRvciA9IGludGVyY2VwdG9yc1tpXTtcbiAgICBpZiAoaW50ZXJjZXB0b3JbbWV0aG9kXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBwcmV2ID0gbmV4dDtcbiAgICAgIC8vIFdlIGxvc2UgdHlwZSBzYWZldHkgaGVyZSBiZWNhdXNlIFR5cGVzY3JpcHQgY2FuJ3QgZGVkdWNlIHRoYXQgaW50ZXJjZXB0b3JbbWV0aG9kXSBpcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJuc1xuICAgICAgLy8gdGhlIHNhbWUgdHlwZSBhcyBOZXh0PEksIE0+XG4gICAgICBuZXh0ID0gKChpbnB1dDogYW55KSA9PiAoaW50ZXJjZXB0b3JbbWV0aG9kXSBhcyBhbnkpKGlucHV0LCBwcmV2KSkgYXMgYW55O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV4dDtcbn1cbiIsImltcG9ydCB0eXBlIHsgdGVtcG9yYWwgfSBmcm9tICdAdGVtcG9yYWxpby9wcm90byc7XG5cbmV4cG9ydCB0eXBlIFBheWxvYWQgPSB0ZW1wb3JhbC5hcGkuY29tbW9uLnYxLklQYXlsb2FkO1xuXG4vKiogVHlwZSB0aGF0IGNhbiBiZSByZXR1cm5lZCBmcm9tIGEgV29ya2Zsb3cgYGV4ZWN1dGVgIGZ1bmN0aW9uICovXG5leHBvcnQgdHlwZSBXb3JrZmxvd1JldHVyblR5cGUgPSBQcm9taXNlPGFueT47XG5leHBvcnQgdHlwZSBXb3JrZmxvd1VwZGF0ZVR5cGUgPSAoLi4uYXJnczogYW55W10pID0+IFByb21pc2U8YW55PiB8IGFueTtcbmV4cG9ydCB0eXBlIFdvcmtmbG93VXBkYXRlVmFsaWRhdG9yVHlwZSA9ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZDtcbmV4cG9ydCB0eXBlIFdvcmtmbG93VXBkYXRlQW5ub3RhdGVkVHlwZSA9IHtcbiAgaGFuZGxlcjogV29ya2Zsb3dVcGRhdGVUeXBlO1xuICB1bmZpbmlzaGVkUG9saWN5OiBIYW5kbGVyVW5maW5pc2hlZFBvbGljeTtcbiAgdmFsaWRhdG9yPzogV29ya2Zsb3dVcGRhdGVWYWxpZGF0b3JUeXBlO1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbn07XG5leHBvcnQgdHlwZSBXb3JrZmxvd1NpZ25hbFR5cGUgPSAoLi4uYXJnczogYW55W10pID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xuZXhwb3J0IHR5cGUgV29ya2Zsb3dTaWduYWxBbm5vdGF0ZWRUeXBlID0ge1xuICBoYW5kbGVyOiBXb3JrZmxvd1NpZ25hbFR5cGU7XG4gIHVuZmluaXNoZWRQb2xpY3k6IEhhbmRsZXJVbmZpbmlzaGVkUG9saWN5O1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbn07XG5leHBvcnQgdHlwZSBXb3JrZmxvd1F1ZXJ5VHlwZSA9ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55O1xuZXhwb3J0IHR5cGUgV29ya2Zsb3dRdWVyeUFubm90YXRlZFR5cGUgPSB7IGhhbmRsZXI6IFdvcmtmbG93UXVlcnlUeXBlOyBkZXNjcmlwdGlvbj86IHN0cmluZyB9O1xuXG4vKipcbiAqIEJyb2FkIFdvcmtmbG93IGZ1bmN0aW9uIGRlZmluaXRpb24sIHNwZWNpZmljIFdvcmtmbG93cyB3aWxsIHR5cGljYWxseSB1c2UgYSBuYXJyb3dlciB0eXBlIGRlZmluaXRpb24sIGUuZzpcbiAqIGBgYHRzXG4gKiBleHBvcnQgYXN5bmMgZnVuY3Rpb24gbXlXb3JrZmxvdyhhcmcxOiBudW1iZXIsIGFyZzI6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPjtcbiAqIGBgYFxuICovXG5leHBvcnQgdHlwZSBXb3JrZmxvdyA9ICguLi5hcmdzOiBhbnlbXSkgPT4gV29ya2Zsb3dSZXR1cm5UeXBlO1xuXG5kZWNsYXJlIGNvbnN0IGFyZ3NCcmFuZDogdW5pcXVlIHN5bWJvbDtcbmRlY2xhcmUgY29uc3QgcmV0QnJhbmQ6IHVuaXF1ZSBzeW1ib2w7XG5cbi8qKlxuICogQW4gaW50ZXJmYWNlIHJlcHJlc2VudGluZyBhIFdvcmtmbG93IHVwZGF0ZSBkZWZpbml0aW9uLCBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBkZWZpbmVVcGRhdGV9XG4gKlxuICogQHJlbWFya3MgYEFyZ3NgIGNhbiBiZSB1c2VkIGZvciBwYXJhbWV0ZXIgdHlwZSBpbmZlcmVuY2UgaW4gaGFuZGxlciBmdW5jdGlvbnMgYW5kIFdvcmtmbG93SGFuZGxlIG1ldGhvZHMuXG4gKiBgTmFtZWAgY2FuIG9wdGlvbmFsbHkgYmUgc3BlY2lmaWVkIHdpdGggYSBzdHJpbmcgbGl0ZXJhbCB0eXBlIHRvIHByZXNlcnZlIHR5cGUtbGV2ZWwga25vd2xlZGdlIG9mIHRoZSB1cGRhdGUgbmFtZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVcGRhdGVEZWZpbml0aW9uPFJldCwgQXJncyBleHRlbmRzIGFueVtdID0gW10sIE5hbWUgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IHtcbiAgdHlwZTogJ3VwZGF0ZSc7XG4gIG5hbWU6IE5hbWU7XG4gIC8qKlxuICAgKiBWaXJ0dWFsIHR5cGUgYnJhbmQgdG8gbWFpbnRhaW4gYSBkaXN0aW5jdGlvbiBiZXR3ZWVuIHtAbGluayBVcGRhdGVEZWZpbml0aW9ufSB0eXBlcyB3aXRoIGRpZmZlcmVudCBhcmdzLlxuICAgKiBUaGlzIGZpZWxkIGlzIG5vdCBwcmVzZW50IGF0IHJ1bi10aW1lLlxuICAgKi9cbiAgW2FyZ3NCcmFuZF06IEFyZ3M7XG4gIC8qKlxuICAgKiBWaXJ0dWFsIHR5cGUgYnJhbmQgdG8gbWFpbnRhaW4gYSBkaXN0aW5jdGlvbiBiZXR3ZWVuIHtAbGluayBVcGRhdGVEZWZpbml0aW9ufSB0eXBlcyB3aXRoIGRpZmZlcmVudCByZXR1cm4gdHlwZXMuXG4gICAqIFRoaXMgZmllbGQgaXMgbm90IHByZXNlbnQgYXQgcnVuLXRpbWUuXG4gICAqL1xuICBbcmV0QnJhbmRdOiBSZXQ7XG59XG5cbi8qKlxuICogQW4gaW50ZXJmYWNlIHJlcHJlc2VudGluZyBhIFdvcmtmbG93IHNpZ25hbCBkZWZpbml0aW9uLCBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBkZWZpbmVTaWduYWx9XG4gKlxuICogQHJlbWFya3MgYEFyZ3NgIGNhbiBiZSB1c2VkIGZvciBwYXJhbWV0ZXIgdHlwZSBpbmZlcmVuY2UgaW4gaGFuZGxlciBmdW5jdGlvbnMgYW5kIFdvcmtmbG93SGFuZGxlIG1ldGhvZHMuXG4gKiBgTmFtZWAgY2FuIG9wdGlvbmFsbHkgYmUgc3BlY2lmaWVkIHdpdGggYSBzdHJpbmcgbGl0ZXJhbCB0eXBlIHRvIHByZXNlcnZlIHR5cGUtbGV2ZWwga25vd2xlZGdlIG9mIHRoZSBzaWduYWwgbmFtZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTaWduYWxEZWZpbml0aW9uPEFyZ3MgZXh0ZW5kcyBhbnlbXSA9IFtdLCBOYW1lIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPiB7XG4gIHR5cGU6ICdzaWduYWwnO1xuICBuYW1lOiBOYW1lO1xuICAvKipcbiAgICogVmlydHVhbCB0eXBlIGJyYW5kIHRvIG1haW50YWluIGEgZGlzdGluY3Rpb24gYmV0d2VlbiB7QGxpbmsgU2lnbmFsRGVmaW5pdGlvbn0gdHlwZXMgd2l0aCBkaWZmZXJlbnQgYXJncy5cbiAgICogVGhpcyBmaWVsZCBpcyBub3QgcHJlc2VudCBhdCBydW4tdGltZS5cbiAgICovXG4gIFthcmdzQnJhbmRdOiBBcmdzO1xufVxuXG4vKipcbiAqIEFuIGludGVyZmFjZSByZXByZXNlbnRpbmcgYSBXb3JrZmxvdyBxdWVyeSBkZWZpbml0aW9uIGFzIHJldHVybmVkIGZyb20ge0BsaW5rIGRlZmluZVF1ZXJ5fVxuICpcbiAqIEByZW1hcmtzIGBBcmdzYCBhbmQgYFJldGAgY2FuIGJlIHVzZWQgZm9yIHBhcmFtZXRlciB0eXBlIGluZmVyZW5jZSBpbiBoYW5kbGVyIGZ1bmN0aW9ucyBhbmQgV29ya2Zsb3dIYW5kbGUgbWV0aG9kcy5cbiAqIGBOYW1lYCBjYW4gb3B0aW9uYWxseSBiZSBzcGVjaWZpZWQgd2l0aCBhIHN0cmluZyBsaXRlcmFsIHR5cGUgdG8gcHJlc2VydmUgdHlwZS1sZXZlbCBrbm93bGVkZ2Ugb2YgdGhlIHF1ZXJ5IG5hbWUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlEZWZpbml0aW9uPFJldCwgQXJncyBleHRlbmRzIGFueVtdID0gW10sIE5hbWUgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IHtcbiAgdHlwZTogJ3F1ZXJ5JztcbiAgbmFtZTogTmFtZTtcbiAgLyoqXG4gICAqIFZpcnR1YWwgdHlwZSBicmFuZCB0byBtYWludGFpbiBhIGRpc3RpbmN0aW9uIGJldHdlZW4ge0BsaW5rIFF1ZXJ5RGVmaW5pdGlvbn0gdHlwZXMgd2l0aCBkaWZmZXJlbnQgYXJncy5cbiAgICogVGhpcyBmaWVsZCBpcyBub3QgcHJlc2VudCBhdCBydW4tdGltZS5cbiAgICovXG4gIFthcmdzQnJhbmRdOiBBcmdzO1xuICAvKipcbiAgICogVmlydHVhbCB0eXBlIGJyYW5kIHRvIG1haW50YWluIGEgZGlzdGluY3Rpb24gYmV0d2VlbiB7QGxpbmsgUXVlcnlEZWZpbml0aW9ufSB0eXBlcyB3aXRoIGRpZmZlcmVudCByZXR1cm4gdHlwZXMuXG4gICAqIFRoaXMgZmllbGQgaXMgbm90IHByZXNlbnQgYXQgcnVuLXRpbWUuXG4gICAqL1xuICBbcmV0QnJhbmRdOiBSZXQ7XG59XG5cbi8qKiBHZXQgdGhlIFwidW53cmFwcGVkXCIgcmV0dXJuIHR5cGUgKHdpdGhvdXQgUHJvbWlzZSkgb2YgdGhlIGV4ZWN1dGUgaGFuZGxlciBmcm9tIFdvcmtmbG93IHR5cGUgYFdgICovXG5leHBvcnQgdHlwZSBXb3JrZmxvd1Jlc3VsdFR5cGU8VyBleHRlbmRzIFdvcmtmbG93PiA9IFJldHVyblR5cGU8Vz4gZXh0ZW5kcyBQcm9taXNlPGluZmVyIFI+ID8gUiA6IG5ldmVyO1xuXG5leHBvcnQgaW50ZXJmYWNlIEFjdGl2aXR5RnVuY3Rpb248UCBleHRlbmRzIGFueVtdID0gYW55W10sIFIgPSBhbnk+IHtcbiAgKC4uLmFyZ3M6IFApOiBQcm9taXNlPFI+O1xufVxuXG4vKipcbiAqIE1hcHBpbmcgb2YgQWN0aXZpdHkgbmFtZSB0byBmdW5jdGlvblxuICogQGRlcHJlY2F0ZWQgbm90IHJlcXVpcmVkIGFueW1vcmUsIGZvciB1bnR5cGVkIGFjdGl2aXRpZXMgdXNlIHtAbGluayBVbnR5cGVkQWN0aXZpdGllc31cbiAqL1xuZXhwb3J0IHR5cGUgQWN0aXZpdHlJbnRlcmZhY2UgPSBSZWNvcmQ8c3RyaW5nLCBBY3Rpdml0eUZ1bmN0aW9uPjtcblxuLyoqXG4gKiBNYXBwaW5nIG9mIEFjdGl2aXR5IG5hbWUgdG8gZnVuY3Rpb25cbiAqL1xuZXhwb3J0IHR5cGUgVW50eXBlZEFjdGl2aXRpZXMgPSBSZWNvcmQ8c3RyaW5nLCBBY3Rpdml0eUZ1bmN0aW9uPjtcblxuLyoqXG4gKiBBIHdvcmtmbG93J3MgaGlzdG9yeSBhbmQgSUQuIFVzZWZ1bCBmb3IgcmVwbGF5LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEhpc3RvcnlBbmRXb3JrZmxvd0lkIHtcbiAgd29ya2Zsb3dJZDogc3RyaW5nO1xuICBoaXN0b3J5OiB0ZW1wb3JhbC5hcGkuaGlzdG9yeS52MS5IaXN0b3J5IHwgdW5rbm93biB8IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBQb2xpY3kgZGVmaW5pbmcgYWN0aW9ucyB0YWtlbiB3aGVuIGEgd29ya2Zsb3cgZXhpdHMgd2hpbGUgdXBkYXRlIG9yIHNpZ25hbCBoYW5kbGVycyBhcmUgcnVubmluZy5cbiAqIFRoZSB3b3JrZmxvdyBleGl0IG1heSBiZSBkdWUgdG8gc3VjY2Vzc2Z1bCByZXR1cm4sIGZhaWx1cmUsIGNhbmNlbGxhdGlvbiwgb3IgY29udGludWUtYXMtbmV3LlxuICovXG5leHBvcnQgY29uc3QgSGFuZGxlclVuZmluaXNoZWRQb2xpY3kgPSB7XG4gIC8qKlxuICAgKiBJc3N1ZSBhIHdhcm5pbmcgaW4gYWRkaXRpb24gdG8gYWJhbmRvbmluZyB0aGUgaGFuZGxlciBleGVjdXRpb24uIFRoZSB3YXJuaW5nIHdpbGwgbm90IGJlIGlzc3VlZCBpZiB0aGUgd29ya2Zsb3cgZmFpbHMuXG4gICAqL1xuICBXQVJOX0FORF9BQkFORE9OOiAnV0FSTl9BTkRfQUJBTkRPTicsXG5cbiAgLyoqXG4gICAqIEFiYW5kb24gdGhlIGhhbmRsZXIgZXhlY3V0aW9uLlxuICAgKlxuICAgKiBJbiB0aGUgY2FzZSBvZiBhbiB1cGRhdGUgaGFuZGxlciB0aGlzIG1lYW5zIHRoYXQgdGhlIGNsaWVudCB3aWxsIHJlY2VpdmUgYW4gZXJyb3IgcmF0aGVyIHRoYW5cbiAgICogdGhlIHVwZGF0ZSByZXN1bHQuXG4gICAqL1xuICBBQkFORE9OOiAnQUJBTkRPTicsXG59IGFzIGNvbnN0O1xuZXhwb3J0IHR5cGUgSGFuZGxlclVuZmluaXNoZWRQb2xpY3kgPSAodHlwZW9mIEhhbmRsZXJVbmZpbmlzaGVkUG9saWN5KVtrZXlvZiB0eXBlb2YgSGFuZGxlclVuZmluaXNoZWRQb2xpY3ldO1xuIiwiaW1wb3J0IHsgVmFsdWVFcnJvciB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBFeGFjdCwgUmVtb3ZlUHJlZml4LCBVbmlvblRvSW50ZXJzZWN0aW9uIH0gZnJvbSAnLi4vdHlwZS1oZWxwZXJzJztcblxuLyoqXG4gKiBDcmVhdGUgZW5jb2RpbmcgYW5kIGRlY29kaW5nIGZ1bmN0aW9ucyB0byBjb252ZXJ0IGJldHdlZW4gdGhlIG51bWVyaWMgYGVudW1gIHR5cGVzIHByb2R1Y2VkIGJ5IG91clxuICogUHJvdG9idWYgY29tcGlsZXIgYW5kIFwiY29uc3Qgb2JqZWN0IG9mIHN0cmluZ3NcIiBlbnVtIHZhbHVlcyB0aGF0IHdlIGV4cG9zZSBpbiBvdXIgcHVibGljIEFQSXMuXG4gKlxuICogIyMjIFVzYWdlXG4gKlxuICogTmV3bHkgaW50cm9kdWNlZCBlbnVtcyBzaG91bGQgZm9sbG93IHRoZSBmb2xsb3dpbmcgcGF0dGVybjpcbiAqXG4gKiBgYGB0c1xuICogICAgIHR5cGUgUGFyZW50Q2xvc2VQb2xpY3kgPSAodHlwZW9mIFBhcmVudENsb3NlUG9saWN5KVtrZXlvZiB0eXBlb2YgUGFyZW50Q2xvc2VQb2xpY3ldO1xuICogICAgIGNvbnN0IFBhcmVudENsb3NlUG9saWN5ID0ge1xuICogICAgICAgVEVSTUlOQVRFOiAnVEVSTUlOQVRFJyxcbiAqICAgICAgIEFCQU5ET046ICdBQkFORE9OJyxcbiAqICAgICAgIFJFUVVFU1RfQ0FOQ0VMOiAnUkVRVUVTVF9DQU5DRUwnLFxuICogICAgIH0gYXMgY29uc3Q7XG4gKlxuICogICAgIGNvbnN0IFtlbmNvZGVQYXJlbnRDbG9zZVBvbGljeSwgZGVjb2RlUGFyZW50Q2xvc2VQb2xpY3ldID0gLy9cbiAqICAgICAgIG1ha2VQcm90b0VudW1Db252ZXJ0ZXJzPFxuICogICAgICAgICBjb3Jlc2RrLmNoaWxkX3dvcmtmbG93LlBhcmVudENsb3NlUG9saWN5LFxuICogICAgICAgICB0eXBlb2YgY29yZXNkay5jaGlsZF93b3JrZmxvdy5QYXJlbnRDbG9zZVBvbGljeSxcbiAqICAgICAgICAga2V5b2YgdHlwZW9mIGNvcmVzZGsuY2hpbGRfd29ya2Zsb3cuUGFyZW50Q2xvc2VQb2xpY3ksXG4gKiAgICAgICAgIHR5cGVvZiBQYXJlbnRDbG9zZVBvbGljeSxcbiAqICAgICAgICAgJ1BBUkVOVF9DTE9TRV9QT0xJQ1lfJyAgLy8gVGhpcyBtYXkgYmUgYW4gZW1wdHkgc3RyaW5nIGlmIHRoZSBwcm90byBlbnVtIGRvZXNuJ3QgYWRkIGEgcmVwZWF0ZWQgcHJlZml4IG9uIHZhbHVlc1xuICogICAgICAgPihcbiAqICAgICAgICAge1xuICogICAgICAgICAgIFtQYXJlbnRDbG9zZVBvbGljeS5URVJNSU5BVEVdOiAxLCAvLyBUaGVzZSBudW1iZXJzIG11c3QgbWF0Y2ggdGhlIG9uZXMgaW4gdGhlIHByb3RvIGVudW1cbiAqICAgICAgICAgICBbUGFyZW50Q2xvc2VQb2xpY3kuQUJBTkRPTl06IDIsXG4gKiAgICAgICAgICAgW1BhcmVudENsb3NlUG9saWN5LlJFUVVFU1RfQ0FOQ0VMXTogMyxcbiAqXG4gKiAgICAgICAgICAgVU5TUEVDSUZJRUQ6IDAsXG4gKiAgICAgICAgIH0gYXMgY29uc3QsXG4gKiAgICAgICAgICdQQVJFTlRfQ0xPU0VfUE9MSUNZXydcbiAqICAgICAgICk7XG4gKiBgYGBcbiAqXG4gKiBgbWFrZVByb3RvRW51bUNvbnZlcnRlcnNgIHN1cHBvcnRzIG90aGVyIHVzYWdlIHBhdHRlcm5zLCBidXQgdGhleSBhcmUgb25seSBtZWFudCBmb3JcbiAqIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBmb3JtZXIgZW51bSBkZWZpbml0aW9ucyBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkIGZvciBuZXcgZW51bXMuXG4gKlxuICogIyMjIENvbnRleHRcbiAqXG4gKiBUZW1wb3JhbCdzIFByb3RvYnVmIEFQSXMgZGVmaW5lIHNldmVyYWwgYGVudW1gIHR5cGVzOyBvdXIgUHJvdG9idWYgY29tcGlsZXIgdHJhbnNmb3JtcyB0aGVzZSB0b1xuICogdHJhZGl0aW9uYWwgKGkuZS4gbm9uLWNvbnN0KSBbVHlwZVNjcmlwdCBudW1lcmljIGBlbnVtYHNdKGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL2VudW1zLmh0bWwjbnVtZXJpYy1lbnVtcykuXG4gKlxuICogRm9yIHZhcmlvdXMgcmVhc29ucywgdGhpcyBpcyBmYXIgZnJvbSBpZGVhbDpcbiAqXG4gKiAgLSBEdWUgdG8gdGhlIGR1YWwgbmF0dXJlIG9mIG5vbi1jb25zdCBUeXBlU2NyaXB0IGBlbnVtYHMgKHRoZXkgYXJlIGJvdGggYSB0eXBlIGFuZCBhIHZhbHVlKSxcbiAqICAgIGl0IGlzIG5vdCBwb3NzaWJsZSB0byByZWZlciB0byBhbiBlbnVtIHZhbHVlIGZyb20gY29kZSB3aXRob3V0IGEgXCJyZWFsXCIgaW1wb3J0IG9mIHRoZSBlbnVtIHR5cGVcbiAqICAgIChpLmUuIGNhbid0IHNpbXBseSBkbyBgaW1wb3J0IHR5cGUgLi4uYCkuIEluIFdvcmtmbG93IGNvZGUsIHN1Y2ggYW4gaW1wb3J0IHdvdWxkIHJlc3VsdCBpblxuICogICAgbG9hZGluZyBvdXIgZW50aXJlIFByb3RvYnVmIGRlZmluaXRpb25zIGludG8gdGhlIHdvcmtmbG93IHNhbmRib3gsIGFkZGluZyBzZXZlcmFsIG1lZ2FieXRlcyB0b1xuICogICAgdGhlIHBlci13b3JrZmxvdyBtZW1vcnkgZm9vdHByaW50LCB3aGljaCBpcyB1bmFjY2VwdGFibGU7IHRvIGF2b2lkIHRoYXQsIHdlIG5lZWQgdG8gbWFpbnRhaW5cbiAqICAgIGEgbWlycm9yIGNvcHkgb2YgZWFjaCBlbnVtIHR5cGVzIHVzZWQgYnkgaW4td29ya2Zsb3cgQVBJcywgYW5kIGV4cG9ydCB0aGVzZSBmcm9tIGVpdGhlclxuICogICAgYEB0ZW1wb3JhbGlvL2NvbW1vbmAgb3IgYEB0ZW1wb3JhbGlvL3dvcmtmbG93YC5cbiAqICAtIEl0IGlzIG5vdCBkZXNpcmFibGUgZm9yIHVzZXJzIHRvIG5lZWQgYW4gZXhwbGljaXQgZGVwZW5kZW5jeSBvbiBgQHRlbXBvcmFsaW8vcHJvdG9gIGp1c3QgdG9cbiAqICAgIGdldCBhY2Nlc3MgdG8gdGhlc2UgZW51bSB0eXBlczsgd2UgdGhlcmVmb3JlIG1hZGUgaXQgYSBjb21tb24gcHJhY3RpY2UgdG8gcmVleHBvcnQgdGhlc2UgZW51bXNcbiAqICAgIGZyb20gb3VyIHB1YmxpYyBmYWNpbmcgcGFja2FnZXMuIEhvd2V2ZXIsIGV4cGVyaWVuY2UgZGVtb250cmF0ZWQgdGhhdCB0aGVzZSByZWV4cG9ydHMgZWZmZWN0aXZlbHlcbiAqICAgIHJlc3VsdGVkIGluIHBvb3IgYW5kIGluY29uc2lzdGVudCBkb2N1bWVudGF0aW9uIGNvdmVyYWdlIGNvbXBhcmVkIHRvIG1pcnJvcmVkIGVudW1zIHR5cGVzLlxuICogIC0gT3VyIFByb3RvYnVmIGVudW0gdHlwZXMgdGVuZCB0byBmb2xsb3cgYSB2ZXJib3NlIGFuZCByZWR1bmRhbnQgbmFtaW5nIGNvbnZlbnRpb24sIHdoaWNoIGZlZWxzXG4gKiAgICB1bmF0dXJhbCBhbmQgZXhjZXNzaXZlIGFjY29yZGluZyB0byBtb3N0IFR5cGVTY3JpcHQgc3R5bGUgZ3VpZGVzOyBlLmcuIGluc3RlYWQgb2ZcbiAqICAgIGB3b3JrZmxvd0lkUmV1c2VQb2xpY3k6IFdvcmtmbG93SWRSZXVzZVBvbGljeS5XT1JLRkxPV19JRF9SRVVTRV9QT0xJQ1lfUkVKRUNUX0RVUExJQ0FURWAsXG4gKiAgICBhIFR5cGVTY3JpcHQgZGV2ZWxvcGVyIHdvdWxkIGdlbmVyYWxseSBleHBlY3QgdG8gYmUgYWJsZSB0byB3cml0ZSBzb21ldGhpbmcgc2ltaWxhciB0b1xuICogICAgYHdvcmtmbG93SWRSZXVzZVBvbGljeTogJ1JFSkVDVF9EVVBMSUNBVEUnYC5cbiAqICAtIEJlY2F1c2Ugb2YgdGhlIHdheSBQcm90b2J1ZiB3b3JrcywgbWFueSBvZiBvdXIgZW51bSB0eXBlcyBjb250YWluIGFuIGBVTlNQRUNJRklFRGAgdmFsdWUsIHdoaWNoXG4gKiAgICBpcyB1c2VkIHRvIGV4cGxpY2l0bHkgaWRlbnRpZnkgYSB2YWx1ZSB0aGF0IGlzIHVuc2V0LiBJbiBUeXBlU2NyaXB0IGNvZGUsIHRoZSBgdW5kZWZpbmVkYCB2YWx1ZVxuICogICAgYWxyZWFkeSBzZXJ2ZXMgdGhhdCBwdXJwb3NlLCBhbmQgaXMgZGVmaW5pdGVseSBtb3JlIGlkaW9tYXRpYyB0byBUUyBkZXZlbG9wZXJzLCB3aGVyZWFzIHRoZXNlXG4gKiAgICBgVU5TUEVDSUZJRURgIHZhbHVlcyBjcmVhdGUgbm9pc2UgYW5kIGNvbmZ1c2lvbiBpbiBvdXIgQVBJcy5cbiAqICAtIFR5cGVTY3JpcHQgZWRpdG9ycyBnZW5lcmFsbHkgZG8gYSB2ZXJ5IGJhZCBqb2IgYXQgcHJvdmlkaW5nIGF1dG9jb21wbGV0aW9uIHRoYXQgaW1wbGllcyByZWFjaGluZ1xuICogICAgZm9yIHZhbHVlcyBvZiBhIFR5cGVTY3JpcHQgZW51bSB0eXBlLCBmb3JjaW5nIGRldmVsb3BlcnMgdG8gZXhwbGljaXRseSB0eXBlIGluIGF0IGxlYXN0IHBhcnRcbiAqICAgIG9mIHRoZSBuYW1lIG9mIHRoZSBlbnVtIHR5cGUgYmVmb3JlIHRoZXkgY2FuIGdldCBhdXRvY29tcGxldGlvbiBmb3IgaXRzIHZhbHVlcy4gT24gdGhlIG90aGVyXG4gKiAgICBoYW5kLCBhbGwgVFMgZWRpdG9ycyBpbW1lZGlhdGVseSBwcm92aWRlIGF1dG9jb21wbGV0aW9uIGZvciBzdHJpbmcgdW5pb24gdHlwZXMuXG4gKiAgLSBUaGUgW1R5cGVTY3JpcHQncyBvZmZpY2lhbCBkb2N1bWVudGF0aW9uXShodHRwczovL3d3dy50eXBlc2NyaXB0bGFuZy5vcmcvZG9jcy9oYW5kYm9vay9lbnVtcy5odG1sI29iamVjdHMtdnMtZW51bXMpXG4gKiAgICBpdHNlbGYgc3VnZ2VzdHMgdGhhdCwgaW4gbW9kZXJuIFR5cGVTY3JpcHQsIHRoZSB1c2Ugb2YgYGFzIGNvbnN0YCBvYmplY3RzIG1heSBnZW5lcmFsbHkgc3VmZmljZVxuICogICAgYW5kIG1heSBiZSBhZHZhbnRhZ2VvdXMgb3ZlciB0aGUgdXNlIG9mIGBlbnVtYCB0eXBlcy5cbiAqXG4gKiBBIGNvbnN0IG9iamVjdCBvZiBzdHJpbmdzLCBjb21iaW5lZCB3aXRoIGEgdW5pb24gdHlwZSBvZiBwb3NzaWJsZSBzdHJpbmcgdmFsdWVzLCBwcm92aWRlcyBhIG11Y2hcbiAqIG1vcmUgaWRpb21hdGljIHN5bnRheCBhbmQgYSBiZXR0ZXIgRFggZm9yIFR5cGVTY3JpcHQgZGV2ZWxvcGVycy4gVGhpcyBob3dldmVyIHJlcXVpcmVzIGEgd2F5IHRvXG4gKiBjb252ZXJ0IGJhY2sgYW5kIGZvcnRoIGJldHdlZW4gdGhlIGBlbnVtYCB2YWx1ZXMgcHJvZHVjZWQgYnkgdGhlIFByb3RvYnVmIGNvbXBpbGVyIGFuZCB0aGVcbiAqIGVxdWl2YWxlbnQgc3RyaW5nIHZhbHVlcy5cbiAqXG4gKiBUaGlzIGhlbHBlciBkeW5hbWljYWxseSBjcmVhdGVzIHRoZXNlIGNvbnZlcnNpb24gZnVuY3Rpb25zIGZvciBhIGdpdmVuIFByb3RvYnVmIGVudW0gdHlwZSxcbiAqIHN0cm9uZ2x5IGJ1aWxkaW5nIHVwb24gc3BlY2lmaWMgY29udmVudGlvbnMgdGhhdCB3ZSBoYXZlIGFkb3B0ZWQgaW4gb3VyIFByb3RvYnVmIGRlZmluaXRpb25zLlxuICpcbiAqICMjIyBWYWxpZGF0aW9uc1xuICpcbiAqIFRoZSBjb21wbGV4IHR5cGUgc2lnbmF0dXJlIG9mIHRoaXMgaGVscGVyIGlzIHRoZXJlIHRvIHByZXZlbnQgbW9zdCBwb3RlbnRpYWwgaW5jb2hlcmVuY2llc1xuICogdGhhdCBjb3VsZCByZXN1bHQgZnJvbSBoYXZpbmcgdG8gbWFudWFsbHkgc3luY2hyb25pemUgdGhlIGNvbnN0IG9iamVjdCBvZiBzdHJpbmdzIGVudW0gYW5kIHRoZVxuICogY29udmVyc2lvbiB0YWJsZSB3aXRoIHRoZSBwcm90byBlbnVtLCB3aGlsZSBub3QgcmVxdWlyaW5nIGEgcmVndWxhciBpbXBvcnQgb24gdGhlIFByb3RvYnVmIGVudW1cbiAqIGl0c2VsZiAoc28gaXQgY2FuIGJlIHVzZWQgc2FmZWx5IGZvciBlbnVtcyBtZWFudCB0byBiZSB1c2VkIGZyb20gd29ya2Zsb3cgY29kZSkuXG4gKlxuICogSW4gcGFydGljdWxhciwgZmFpbGluZyBhbnkgb2YgdGhlIGZvbGxvd2luZyBpbnZhcmlhbnRzIHdpbGwgcmVzdWx0IGluIGJ1aWxkIHRpbWUgZXJyb3JzOlxuICpcbiAqIC0gRm9yIGV2ZXJ5IGtleSBvZiB0aGUgZm9ybSBgUFJFRklYX0tFWTogbnVtYmVyYCBpbiB0aGUgcHJvdG8gZW51bSwgZXhjbHVkaW5nIHRoZSBgVU5TUEVDSUZJRURgIGtleTpcbiAqICAgLSBUaGVyZSBNVVNUIGJlIGEgY29ycmVzcG9uZGluZyBgS0VZOiAnS0VZJ2AgZW50cnkgaW4gdGhlIGNvbnN0IG9iamVjdCBvZiBzdHJpbmdzIGVudW07XG4gKiAgIC0gVGhlcmUgTUFZIGJlIGEgY29ycmVzcG9uZGluZyBgUFJFRklYX0tFWTogJ0tFWSdgIGluIHRoZSBjb25zdCBvYmplY3Qgb2Ygc3RyaW5ncyBlbnVtXG4gKiAgICAgKHRoaXMgaXMgbWVhbnQgdG8gcHJlc2VydmUgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBmb3JtZXIgc3ludGF4OyBzdWNoIGFsaWFzZXMgc2hvdWxkXG4gKiAgICAgbm90IGJlIGFkZGVkIGZvciBuZXcgZW51bXMgYW5kIGVudW0gZW50cmllcyBpbnRyb2R1Y2VkIGdvaW5nIGZvcndhcmQpO1xuICogICAtIFRoZXJlIE1VU1QgYmUgYSBjb3JyZXNwb25kaW5nIGBLRVk6IG51bWJlcmAgaW4gdGhlIG1hcHBpbmcgdGFibGUuXG4gKiAtIElmIHRoZSBwcm90byBlbnVtIGNvbnRhaW5zIGEgYFBSRUZJWF9VTlNQRUNJRklFRGAgZW50cnksIHRoZW46XG4gKiAgIC0gVGhlcmUgTUFZIGJlIGEgY29ycmVzcG9uZGluZyBgUFJFRklYX1VOU1BFQ0lGSUVEOiB1bmRlZmluZWRgIGFuZC9vciBgVU5TUEVDSUZJRUQ6IHVuZGVmaW5lZGBcbiAqICAgICBlbnRyaWVzIGluIHRoZSBjb25zdCBvYmplY3Qgb2Ygc3RyaW5ncyBlbnVtIOKAlCB0aGlzIGlzIG1lYW50IHRvIHByZXNlcnZlIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAqICAgICB3aXRoIHRoZSBmb3JtZXIgc3ludGF4OyB0aGlzIGFsaWFzIHNob3VsZCBub3QgYmUgYWRkZWQgZm9yIG5ldyBlbnVtcyBpbnRyb2R1Y2VkIGdvaW5nIGZvcndhcmQ7XG4gKiAgIC0gVGhlcmUgTVVTVCBiZSBhbiBgVU5TUEVDSUZJRUQ6IDBgIGluIHRoZSBtYXBwaW5nIHRhYmxlLlxuICogLSBUaGUgY29uc3Qgb2JqZWN0IG9mIHN0cmluZ3MgZW51bSBNVVNUIE5PVCBjb250YWluIGFueSBvdGhlciBrZXlzIHRoYW4gdGhlIG9uZXMgbWFuZGF0ZWQgb3JcbiAqICAgb3B0aW9uYWxseSBhbGxvd2VkIGJlIHRoZSBwcmVjZWVkaW5nIHJ1bGVzLlxuICogLSBUaGUgbWFwcGluZyB0YWJsZSBNVVNUIE5PVCBjb250YWluIGFueSBvdGhlciBrZXlzIHRoYW4gdGhlIG9uZXMgbWFuZGF0ZWQgYWJvdmUuXG4gKlxuICogVGhlc2UgcnVsZXMgbm90YWJseSBlbnN1cmUgdGhhdCB3aGVuZXZlciBhIG5ldyB2YWx1ZSBpcyBhZGRlZCB0byBhbiBleGlzdGluZyBQcm90byBlbnVtLCB0aGUgY29kZVxuICogd2lsbCBmYWlsIHRvIGNvbXBpbGUgdW50aWwgdGhlIGNvcnJlc3BvbmRpbmcgZW50cnkgaXMgYWRkZWQgb24gdGhlIGNvbnN0IG9iamVjdCBvZiBzdHJpbmdzIGVudW1cbiAqIGFuZCB0aGUgbWFwcGluZyB0YWJsZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VQcm90b0VudW1Db252ZXJ0ZXJzPFxuICBQcm90b0VudW1WYWx1ZSBleHRlbmRzIG51bWJlcixcbiAgUHJvdG9FbnVtIGV4dGVuZHMgeyBbayBpbiBQcm90b0VudW1LZXldOiBQcm90b0VudW1WYWx1ZSB9LFxuICBQcm90b0VudW1LZXkgZXh0ZW5kcyBgJHtQcmVmaXh9JHtzdHJpbmd9YCxcbiAgU3RyaW5nRW51bVR5cGVBY3R1YWwgZXh0ZW5kcyBFeGFjdDxTdHJpbmdFbnVtVHlwZSwgU3RyaW5nRW51bVR5cGVBY3R1YWw+LFxuICBQcmVmaXggZXh0ZW5kcyBzdHJpbmcsXG4gIC8vXG4gIC8vIFBhcmFtZXRlcnMgYWZ0ZXIgdGhpcyBwb2ludCB3aWxsIGJlIGluZmVycmVkOyB0aGV5J3JlIG5vdCBtZWFudCBub3QgdG8gYmUgc3BlY2lmaWVkIGJ5IGRldmVsb3BlcnNcbiAgVW5zcGVjaWZpZWQgPSBQcm90b0VudW1LZXkgZXh0ZW5kcyBgJHtQcmVmaXh9VU5TUEVDSUZJRURgID8gJ1VOU1BFQ0lGSUVEJyA6IG5ldmVyLFxuICBTaG9ydFN0cmluZ0VudW1LZXkgZXh0ZW5kcyBSZW1vdmVQcmVmaXg8UHJlZml4LCBQcm90b0VudW1LZXk+ID0gRXhjbHVkZTxcbiAgICBSZW1vdmVQcmVmaXg8UHJlZml4LCBQcm90b0VudW1LZXk+LFxuICAgIFVuc3BlY2lmaWVkXG4gID4sXG4gIFN0cmluZ0VudW1UeXBlIGV4dGVuZHMgUHJvdG9Db25zdE9iamVjdE9mU3RyaW5nc0VudW08XG4gICAgU2hvcnRTdHJpbmdFbnVtS2V5LFxuICAgIFByZWZpeCxcbiAgICBVbnNwZWNpZmllZFxuICA+ID0gUHJvdG9Db25zdE9iamVjdE9mU3RyaW5nc0VudW08U2hvcnRTdHJpbmdFbnVtS2V5LCBQcmVmaXgsIFVuc3BlY2lmaWVkPixcbiAgTWFwVGFibGUgZXh0ZW5kcyBQcm90b0VudW1Ub0NvbnN0T2JqZWN0T2ZTdHJpbmdNYXBUYWJsZTxcbiAgICBTdHJpbmdFbnVtVHlwZSxcbiAgICBQcm90b0VudW1WYWx1ZSxcbiAgICBQcm90b0VudW0sXG4gICAgUHJvdG9FbnVtS2V5LFxuICAgIFByZWZpeCxcbiAgICBVbnNwZWNpZmllZCxcbiAgICBTaG9ydFN0cmluZ0VudW1LZXlcbiAgPiA9IFByb3RvRW51bVRvQ29uc3RPYmplY3RPZlN0cmluZ01hcFRhYmxlPFxuICAgIFN0cmluZ0VudW1UeXBlLFxuICAgIFByb3RvRW51bVZhbHVlLFxuICAgIFByb3RvRW51bSxcbiAgICBQcm90b0VudW1LZXksXG4gICAgUHJlZml4LFxuICAgIFVuc3BlY2lmaWVkLFxuICAgIFNob3J0U3RyaW5nRW51bUtleVxuICA+LFxuPihcbiAgbWFwVGFibGU6IE1hcFRhYmxlLFxuICBwcmVmaXg6IFByZWZpeFxuKTogW1xuICAoXG4gICAgaW5wdXQ6IFNob3J0U3RyaW5nRW51bUtleSB8IGAke1ByZWZpeH0ke1Nob3J0U3RyaW5nRW51bUtleX1gIHwgUHJvdG9FbnVtVmFsdWUgfCBudWxsIHwgdW5kZWZpbmVkXG4gICkgPT4gUHJvdG9FbnVtVmFsdWUgfCB1bmRlZmluZWQsIC8vXG4gIChpbnB1dDogUHJvdG9FbnVtVmFsdWUgfCBudWxsIHwgdW5kZWZpbmVkKSA9PiBTaG9ydFN0cmluZ0VudW1LZXkgfCB1bmRlZmluZWQsIC8vXG5dIHtcbiAgY29uc3QgcmV2ZXJzZVRhYmxlOiBSZWNvcmQ8UHJvdG9FbnVtVmFsdWUsIFNob3J0U3RyaW5nRW51bUtleT4gPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMobWFwVGFibGUpLm1hcCgoW2ssIHZdKSA9PiBbdiwga10pXG4gICk7XG4gIGNvbnN0IGhhc1Vuc3BlY2lmaWVkID0gKG1hcFRhYmxlIGFzIGFueSlbJ1VOU1BFQ0lGSUVEJ10gPT09IDAgfHwgKG1hcFRhYmxlIGFzIGFueSlbYCR7cHJlZml4fVVOU1BFQ0lGSUVEYF0gPT09IDA7XG5cbiAgZnVuY3Rpb24gaXNTaG9ydFN0cmluZ0VudW1LZXlzKHg6IHVua25vd24pOiB4IGlzIFNob3J0U3RyaW5nRW51bUtleSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnc3RyaW5nJyAmJiB4IGluIG1hcFRhYmxlO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOdW1lcmljRW51bVZhbHVlKHg6IHVua25vd24pOiB4IGlzIFByb3RvRW51bVtrZXlvZiBQcm90b0VudW1dIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT09ICdudW1iZXInICYmIHggaW4gcmV2ZXJzZVRhYmxlO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlKFxuICAgIGlucHV0OiBTaG9ydFN0cmluZ0VudW1LZXkgfCBgJHtQcmVmaXh9JHtTaG9ydFN0cmluZ0VudW1LZXl9YCB8IFByb3RvRW51bVZhbHVlIHwgbnVsbCB8IHVuZGVmaW5lZFxuICApOiBQcm90b0VudW1WYWx1ZSB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsZXQgc2hvcnRlbjogc3RyaW5nID0gaW5wdXQ7XG4gICAgICBpZiAoc2hvcnRlbi5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgc2hvcnRlbiA9IHNob3J0ZW4uc2xpY2UocHJlZml4Lmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNTaG9ydFN0cmluZ0VudW1LZXlzKHNob3J0ZW4pKSB7XG4gICAgICAgIHJldHVybiBtYXBUYWJsZVtzaG9ydGVuXTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKGBJbnZhbGlkIGVudW0gdmFsdWU6ICcke2lucHV0fSdgKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoYEludmFsaWQgZW51bSB2YWx1ZTogJyR7aW5wdXR9JyBvZiB0eXBlICR7dHlwZW9mIGlucHV0fWApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZShpbnB1dDogUHJvdG9FbnVtVmFsdWUgfCBudWxsIHwgdW5kZWZpbmVkKTogU2hvcnRTdHJpbmdFbnVtS2V5IHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChoYXNVbnNwZWNpZmllZCAmJiBpbnB1dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOdW1lcmljRW51bVZhbHVlKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gcmV2ZXJzZVRhYmxlW2lucHV0XTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgZ290IGEgcHJvdG8gZW51bSB2YWx1ZSB0aGF0IHdlIGRvbid0IHlldCBrbm93IGFib3V0IChpLmUuIGl0IGRpZG4ndCBleGlzdCB3aGVuIHRoaXMgY29kZVxuICAgICAgLy8gd2FzIGNvbXBpbGVkKS4gVGhpcyBpcyBjZXJ0YWlubHkgYSBwb3NzaWJpbGl0eSwgYnV0IGdpdmVuIGhvdyBvdXIgQVBJcyBldm9sdmUsIHRoaXMgaXMgaXNcbiAgICAgIC8vIHVubGlrZWx5IHRvIGJlIGEgdGVycmlibHkgYmFkIHRoaW5nIGJ5IGl0c2VsZiAod2UgYXZvaWQgYWRkaW5nIG5ldyBlbnVtIHZhbHVlcyBpbiBwbGFjZXNcbiAgICAgIC8vIHRoYXQgd291bGQgYnJlYWsgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIGV4aXN0aW5nIGRlcGxveWVkIGNvZGUpLiBUaGVyZWZvcmUsIHRocm93aW5nXG4gICAgICAvLyBvbiBcInVuZXhwZWN0ZWRcIiB2YWx1ZXMgaXMgbGlrZWx5IHRvIGVuZCB1cCBjYXVzaW5nIG1vcmUgcHJvYmxlbXMgdGhhbiBpdCBtaWdodCBhdm9pZCxcbiAgICAgIC8vIGVzcGVjaWFsbHkgZ2l2ZW4gdGhhdCB0aGUgZGVjb2RlZCB2YWx1ZSBtYXkgYWN0dWFsbHkgbmV2ZXIgZ2V0IHJlYWQgYW53eWF5LlxuICAgICAgLy9cbiAgICAgIC8vIFRoZXJlZm9yZSwgd2UgaW5zdGVhZCBjaGVhdCBvbiB0eXBlIGNvbnN0cmFpbnRzIGFuZCByZXR1cm4gYSBzdHJpbmcgb2YgdGhlIGZvcm0gXCJ1bmtub3duXzIzXCIuXG4gICAgICAvLyBUaGF0IHNvbWV3aGF0IG1pcnJvcnMgdGhlIGJlaGF2aW9yIHdlJ2QgZ2V0IHdpdGggdGhlIHB1cmUgbnVtZXJpY2FsIGFwcHJvYWNoLlxuICAgICAgcmV0dXJuIGB1bmtub3duXyR7aW5wdXR9YCBhcyBTaG9ydFN0cmluZ0VudW1LZXk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoYEludmFsaWQgcHJvdG8gZW51bSB2YWx1ZTogJyR7aW5wdXR9JyBvZiB0eXBlICR7dHlwZW9mIGlucHV0fWApO1xuICB9XG5cbiAgcmV0dXJuIFtlbmNvZGUsIGRlY29kZV0gYXMgY29uc3Q7XG59XG5cbi8qKlxuICogR2l2ZW4gdGhlIGV4cGxvZGVkIHBhcmFtZXRlcnMgb2YgYSBwcm90byBlbnVtIChpLmUuIHNob3J0IGtleXMsIHByZWZpeCwgYW5kIHNob3J0IGtleSBvZiB0aGVcbiAqIHVuc3BlY2lmaWVkIHZhbHVlKSwgbWFrZSBhIHR5cGUgdGhhdCBfZXhhY3RseV8gY29ycmVzcG9uZHMgdG8gdGhlIGNvbnN0IG9iamVjdCBvZiBzdHJpbmdzIGVudW0sXG4gKiBlLmcuIHRoZSB0eXBlIHRoYXQgdGhlIGRldmVsb3BlciBpcyBleHBlY3RlZCB0byB3cml0ZS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgZm9yIGNvcmVzZGsuY2hpbGRfd29ya2Zsb3cuUGFyZW50Q2xvc2VQb2xpY3ksIHRoaXMgZXZhbHVhdGVzIHRvOlxuICpcbiAqIHtcbiAqICAgVEVSTUlOQVRFOiBcIlRFUk1JTkFURVwiO1xuICogICBBQkFORE9OOiBcIkFCQU5ET05cIjtcbiAqICAgUkVRVUVTVF9DQU5DRUw6IFwiUkVRVUVTVF9DQU5DRUxcIjtcbiAqXG4gKiAgIFBBUkVOVF9DTE9TRV9QT0xJQ1lfVEVSTUlOQVRFPzogXCJURVJNSU5BVEVcIjtcbiAqICAgUEFSRU5UX0NMT1NFX1BPTElDWV9BQkFORE9OPzogXCJBQkFORE9OXCI7XG4gKiAgIFBBUkVOVF9DTE9TRV9QT0xJQ1lfUkVRVUVTVF9DQU5DRUw/OiBcIlJFUVVFU1RfQ0FOQ0VMXCI7XG4gKlxuICogICBQQVJFTlRfQ0xPU0VfUE9MSUNZX1VOU1BFQ0lGSUVEPzogdW5kZWZpbmVkO1xuICogfVxuICovXG50eXBlIFByb3RvQ29uc3RPYmplY3RPZlN0cmluZ3NFbnVtPFxuICBTaG9ydFN0cmluZ0VudW1LZXkgZXh0ZW5kcyBzdHJpbmcsXG4gIFByZWZpeCBleHRlbmRzIHN0cmluZyxcbiAgVW5zcGVjaWZpZWQsIC8vIGUuZy4gJ1VOU1BFQ0lGSUVEJ1xuPiA9IFVuaW9uVG9JbnRlcnNlY3Rpb248XG4gIHwge1xuICAgICAgLy8gZS5nLjogXCJURVJNSU5BVEVcIjogXCJURVJNSU5BVEVcIlxuICAgICAgcmVhZG9ubHkgW2sgaW4gU2hvcnRTdHJpbmdFbnVtS2V5XTogaztcbiAgICB9XG4gIHwge1xuICAgICAgW2sgaW4gU2hvcnRTdHJpbmdFbnVtS2V5XTogUHJlZml4IGV4dGVuZHMgJydcbiAgICAgICAgPyBvYmplY3RcbiAgICAgICAgOiB7XG4gICAgICAgICAgICAvLyBlLmcuOiBcIlBBUkVOVF9DTE9TRV9QT0xJQ1lfVEVSTUlOQVRFXCI/OiBcIlRFUk1JTkFURVwiXG4gICAgICAgICAgICByZWFkb25seSBba2sgaW4gYCR7UHJlZml4fSR7a31gXT86IGs7XG4gICAgICAgICAgfTtcbiAgICB9W1Nob3J0U3RyaW5nRW51bUtleV1cbiAgfCAoVW5zcGVjaWZpZWQgZXh0ZW5kcyBzdHJpbmdcbiAgICAgID8ge1xuICAgICAgICAgIC8vIGUuZy46IFwiUEFSRU5UX0NMT1NFX1BPTElDWV9VTlNQRUNJRklFRFwiPzogdW5kZWZpbmVkXG4gICAgICAgICAgW2sgaW4gYCR7UHJlZml4fSR7VW5zcGVjaWZpZWR9YF0/OiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIDogb2JqZWN0KVxuICB8IChVbnNwZWNpZmllZCBleHRlbmRzIHN0cmluZ1xuICAgICAgPyB7XG4gICAgICAgICAgLy8gZS5nLjogXCJVTlNQRUNJRklFRFwiPzogdW5kZWZpbmVkXG4gICAgICAgICAgW2sgaW4gYCR7VW5zcGVjaWZpZWR9YF0/OiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIDogb2JqZWN0KVxuPjtcblxuLyoqXG4gKiBHaXZlbiB0aGUgZXhwbG9kZWQgcGFyYW1ldGVycyBvZiBhIHByb3RvIGVudW0gKGkuZS4gc2hvcnQga2V5cywgcHJlZml4LCBhbmQgc2hvcnQga2V5IG9mIHRoZVxuICogdW5zcGVjaWZpZWQgdmFsdWUpLCBtYWtlIGEgdHlwZSB0aGF0IF9leGFjdGx5XyBjb3JyZXNwb25kcyB0byB0aGUgbWFwcGluZyB0YWJsZSB0aGF0IHRoZSB1c2VyIGlzXG4gKiBleHBlY3RlZCB0byBwcm92aWRlLlxuICpcbiAqIEZvciBleGFtcGxlLCBmb3IgY29yZXNkay5jaGlsZF93b3JrZmxvdy5QYXJlbnRDbG9zZVBvbGljeSwgdGhpcyBldmFsdWF0ZXMgdG86XG4gKlxuICoge1xuICogIFVOU1BFQ0lGSUVEOiAwLFxuICogIFRFUk1JTkFURTogMSxcbiAqICBBQkFORE9OOiAyLFxuICogIFJFUVVFU1RfQ0FOQ0VMOiAzLFxuICogfVxuICovXG50eXBlIFByb3RvRW51bVRvQ29uc3RPYmplY3RPZlN0cmluZ01hcFRhYmxlPFxuICBfU3RyaW5nRW51bSBleHRlbmRzIFByb3RvQ29uc3RPYmplY3RPZlN0cmluZ3NFbnVtPFNob3J0U3RyaW5nRW51bUtleSwgUHJlZml4LCBVbnNwZWNpZmllZD4sXG4gIFByb3RvRW51bVZhbHVlIGV4dGVuZHMgbnVtYmVyLFxuICBQcm90b0VudW0gZXh0ZW5kcyB7IFtrIGluIFByb3RvRW51bUtleV06IFByb3RvRW51bVZhbHVlIH0sXG4gIFByb3RvRW51bUtleSBleHRlbmRzIGAke1ByZWZpeH0ke3N0cmluZ31gLFxuICBQcmVmaXggZXh0ZW5kcyBzdHJpbmcsXG4gIFVuc3BlY2lmaWVkLFxuICBTaG9ydFN0cmluZ0VudW1LZXkgZXh0ZW5kcyBSZW1vdmVQcmVmaXg8UHJlZml4LCBQcm90b0VudW1LZXk+LFxuPiA9IFVuaW9uVG9JbnRlcnNlY3Rpb248XG4gIHtcbiAgICBbayBpbiBQcm90b0VudW1LZXldOiB7XG4gICAgICBba2sgaW4gUmVtb3ZlUHJlZml4PFByZWZpeCwgaz5dOiBQcm90b0VudW1ba10gZXh0ZW5kcyBudW1iZXIgPyBQcm90b0VudW1ba10gOiBuZXZlcjtcbiAgICB9O1xuICB9W1Byb3RvRW51bUtleV1cbj47XG4iLCJleHBvcnQgKiBmcm9tICcuL2VudW1zLWhlbHBlcnMnO1xuZXhwb3J0IHtcbiAgZmlsdGVyTnVsbEFuZFVuZGVmaW5lZCxcbiAgbWVyZ2VPYmplY3RzLFxuICAvLyB0cy1wcnVuZS1pZ25vcmUtbmV4dFxuICBkZWVwTWVyZ2UsXG59IGZyb20gJy4vb2JqZWN0cy1oZWxwZXJzJztcbiIsIi8qKlxuICogSGVscGVyIHRvIHByZXZlbnQgYHVuZGVmaW5lZGAgYW5kIGBudWxsYCB2YWx1ZXMgb3ZlcnJpZGluZyBkZWZhdWx0cyB3aGVuIG1lcmdpbmcgbWFwcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlck51bGxBbmRVbmRlZmluZWQ8VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4+KG9iajogVCk6IFQge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKG9iaikuZmlsdGVyKChbX2ssIHZdKSA9PiB2ICE9IG51bGwpKSBhcyBhbnk7XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9iamVjdHMsIHBvc3NpYmx5IHJlbW92aW5nIGtleXMuXG4gKlxuICogTW9yZSBzcGVjaWZpY2FsbHk6XG4gKiAtIEFueSBrZXkvdmFsdWUgcGFpciBpbiBgZGVsdGFgIG92ZXJyaWRlcyB0aGUgY29ycmVzcG9uZGluZyBrZXkvdmFsdWUgcGFpciBpbiBgb3JpZ2luYWxgO1xuICogLSBBIGtleSBwcmVzZW50IGluIGBkZWx0YWAgd2l0aCB2YWx1ZSBgdW5kZWZpbmVkYCByZW1vdmVzIHRoZSBrZXkgZnJvbSB0aGUgcmVzdWx0aW5nIG9iamVjdDtcbiAqIC0gSWYgYG9yaWdpbmFsYCBpcyBgdW5kZWZpbmVkYCBvciBlbXB0eSwgcmV0dXJuIGBkZWx0YWA7XG4gKiAtIElmIGBkZWx0YWAgaXMgYHVuZGVmaW5lZGAgb3IgZW1wdHksIHJldHVybiBgb3JpZ2luYWxgIChvciB1bmRlZmluZWQgaWYgYG9yaWdpbmFsYCBpcyBhbHNvIHVuZGVmaW5lZCk7XG4gKiAtIElmIHRoZXJlIGFyZSBubyBjaGFuZ2VzLCB0aGVuIHJldHVybiBgb3JpZ2luYWxgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VPYmplY3RzPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+PihvcmlnaW5hbDogVCwgZGVsdGE6IFQgfCB1bmRlZmluZWQpOiBUO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlT2JqZWN0czxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55Pj4oXG4gIG9yaWdpbmFsOiBUIHwgdW5kZWZpbmVkLFxuICBkZWx0YTogVCB8IHVuZGVmaW5lZFxuKTogVCB8IHVuZGVmaW5lZCB7XG4gIGlmIChvcmlnaW5hbCA9PSBudWxsKSByZXR1cm4gZGVsdGE7XG4gIGlmIChkZWx0YSA9PSBudWxsKSByZXR1cm4gb3JpZ2luYWw7XG5cbiAgY29uc3QgbWVyZ2VkOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0geyAuLi5vcmlnaW5hbCB9O1xuICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhkZWx0YSkpIHtcbiAgICBpZiAodiAhPT0gbWVyZ2VkW2tdKSB7XG4gICAgICBpZiAodiA9PSBudWxsKSBkZWxldGUgbWVyZ2VkW2tdO1xuICAgICAgZWxzZSBtZXJnZWRba10gPSB2O1xuICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNoYW5nZWQgPyAobWVyZ2VkIGFzIFQpIDogb3JpZ2luYWw7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGl0ZW06IGFueSk6IGl0ZW0gaXMgUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIHJldHVybiBpdGVtICYmIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpdGVtKTtcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBtZXJnZXMgdHdvIG9iamVjdHMsIHJldHVybmluZyBhIG5ldyBvYmplY3QuXG4gKlxuICogUHJvcGVydGllcyBmcm9tIGBzb3VyY2VgIHdpbGwgb3ZlcndyaXRlIHByb3BlcnRpZXMgb24gYHRhcmdldGAuXG4gKiBOZXN0ZWQgb2JqZWN0cyBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LlxuICpcbiAqIE9iamVjdCBmaWVsZHMgaW4gdGhlIHJldHVybmVkIG9iamVjdCBhcmUgcmVmZXJlbmNlcywgYXMgaW4sXG4gKiB0aGUgcmV0dXJuZWQgb2JqZWN0IGlzIG5vdCBjb21wbGV0ZWx5IGZyZXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVlcE1lcmdlPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+Pih0YXJnZXQ6IFQsIHNvdXJjZTogUGFydGlhbDxUPik6IFQge1xuICBjb25zdCBvdXRwdXQgPSB7IC4uLnRhcmdldCB9O1xuXG4gIGlmIChpc09iamVjdCh0YXJnZXQpICYmIGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzb3VyY2UpKSB7XG4gICAgICBjb25zdCBzb3VyY2VWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgaWYgKGlzT2JqZWN0KHNvdXJjZVZhbHVlKSAmJiBrZXkgaW4gdGFyZ2V0ICYmIGlzT2JqZWN0KHRhcmdldFtrZXldIGFzIGFueSkpIHtcbiAgICAgICAgb3V0cHV0W2tleSBhcyBrZXlvZiBUXSA9IGRlZXBNZXJnZSh0YXJnZXRba2V5XSwgc291cmNlVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKG91dHB1dCBhcyBhbnkpW2tleV0gPSBzb3VyY2VWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuIiwiaW1wb3J0IHsgZmlsdGVyTnVsbEFuZFVuZGVmaW5lZCwgbWVyZ2VPYmplY3RzIH0gZnJvbSAnLi9pbnRlcm5hbC13b3JrZmxvdyc7XG5cbmV4cG9ydCB0eXBlIExvZ0xldmVsID0gJ1RSQUNFJyB8ICdERUJVRycgfCAnSU5GTycgfCAnV0FSTicgfCAnRVJST1InO1xuXG5leHBvcnQgdHlwZSBMb2dNZXRhZGF0YSA9IFJlY29yZDxzdHJpbmcgfCBzeW1ib2wsIGFueT47XG5cbi8qKlxuICogSW1wbGVtZW50IHRoaXMgaW50ZXJmYWNlIGluIG9yZGVyIHRvIGN1c3RvbWl6ZSB3b3JrZXIgbG9nZ2luZ1xuICovXG5leHBvcnQgaW50ZXJmYWNlIExvZ2dlciB7XG4gIGxvZyhsZXZlbDogTG9nTGV2ZWwsIG1lc3NhZ2U6IHN0cmluZywgbWV0YT86IExvZ01ldGFkYXRhKTogYW55O1xuICB0cmFjZShtZXNzYWdlOiBzdHJpbmcsIG1ldGE/OiBMb2dNZXRhZGF0YSk6IGFueTtcbiAgZGVidWcobWVzc2FnZTogc3RyaW5nLCBtZXRhPzogTG9nTWV0YWRhdGEpOiBhbnk7XG4gIGluZm8obWVzc2FnZTogc3RyaW5nLCBtZXRhPzogTG9nTWV0YWRhdGEpOiBhbnk7XG4gIHdhcm4obWVzc2FnZTogc3RyaW5nLCBtZXRhPzogTG9nTWV0YWRhdGEpOiBhbnk7XG4gIGVycm9yKG1lc3NhZ2U6IHN0cmluZywgbWV0YT86IExvZ01ldGFkYXRhKTogYW55O1xufVxuXG4vKipcbiAqIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgYHNka0NvbXBvbmVudGAgbWV0YSBhdHRyaWJ1dGVzIG9uIGxvZyBtZXNzYWdlcy4gVGhpc1xuICogYXR0cmlidXRlIGluZGljYXRlcyB3aGljaCBzdWJzeXN0ZW0gZW1pdHRlZCB0aGUgbG9nIG1lc3NhZ2U7IHRoaXMgbWF5IGZvclxuICogZXhhbXBsZSBiZSB1c2VkIHRvIGltcGxlbWVudCBmaW5lLWdyYWluZWQgZmlsdGVyaW5nIG9mIGxvZyBtZXNzYWdlcy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhpcyBsaXN0IHdpbGwgcmVtYWluIHN0YWJsZSBpbiB0aGVcbiAqIGZ1dHVyZTsgdmFsdWVzIG1heSBiZSBhZGRlZCBvciByZW1vdmVkLCBhbmQgbWVzc2FnZXMgdGhhdCBhcmUgY3VycmVudGx5XG4gKiBlbWl0dGVkIHdpdGggc29tZSBgc2RrQ29tcG9uZW50YCB2YWx1ZSBtYXkgdXNlIGEgZGlmZmVyZW50IHZhbHVlIGluIHRoZSBmdXR1cmUuXG4gKi9cbmV4cG9ydCBlbnVtIFNka0NvbXBvbmVudCB7XG4gIC8qKlxuICAgKiBDb21wb25lbnQgbmFtZSBmb3IgbWVzc2FnZXMgZW1pdGVkIGZyb20gV29ya2Zsb3cgY29kZSwgdXNpbmcgdGhlIHtAbGluayBXb3JrZmxvdyBjb250ZXh0IGxvZ2dlcnx3b3JrZmxvdy5sb2d9LlxuICAgKiBUaGUgU0RLIGl0c2VsZiBuZXZlciBwdWJsaXNoZXMgbWVzc2FnZXMgd2l0aCB0aGlzIGNvbXBvbmVudCBuYW1lLlxuICAgKi9cbiAgd29ya2Zsb3cgPSAnd29ya2Zsb3cnLFxuXG4gIC8qKlxuICAgKiBDb21wb25lbnQgbmFtZSBmb3IgbWVzc2FnZXMgZW1pdGVkIGZyb20gYW4gYWN0aXZpdHksIHVzaW5nIHRoZSB7QGxpbmsgYWN0aXZpdHkgY29udGV4dCBsb2dnZXJ8Q29udGV4dC5sb2d9LlxuICAgKiBUaGUgU0RLIGl0c2VsZiBuZXZlciBwdWJsaXNoZXMgbWVzc2FnZXMgd2l0aCB0aGlzIGNvbXBvbmVudCBuYW1lLlxuICAgKi9cbiAgYWN0aXZpdHkgPSAnYWN0aXZpdHknLFxuXG4gIC8qKlxuICAgKiBDb21wb25lbnQgbmFtZSBmb3IgbWVzc2FnZXMgZW1pdGVkIGZyb20gYSBOZXh1cyBPcGVyYXRpb24gSGFuZGxlciwgdXNpbmcgdGhlIE5leHVzIGNvbnRleHQgbG9nZ2VyLlxuICAgKiBUaGUgU0RLIGl0c2VsZiBuZXZlciBwdWJsaXNoZXMgbWVzc2FnZXMgd2l0aCB0aGlzIGNvbXBvbmVudCBuYW1lLlxuICAgKi9cbiAgbmV4dXMgPSAnbmV4dXMnLFxuXG4gIC8qKlxuICAgKiBDb21wb25lbnQgbmFtZSBmb3IgbWVzc2FnZXMgZW1pdGVkIGZyb20gYSBUZW1wb3JhbCBXb3JrZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIFRoaXMgbm90YWJseSBpbmNsdWRlczpcbiAgICogLSBJc3N1ZXMgd2l0aCBXb3JrZXIgb3IgcnVudGltZSBjb25maWd1cmF0aW9uLCBvciB0aGUgSlMgZXhlY3V0aW9uIGVudmlyb25tZW50O1xuICAgKiAtIFdvcmtlcidzLCBBY3Rpdml0eSdzLCBhbmQgV29ya2Zsb3cncyBsaWZlY3ljbGUgZXZlbnRzO1xuICAgKiAtIFdvcmtmbG93IEFjdGl2YXRpb24gYW5kIEFjdGl2aXR5IFRhc2sgcHJvY2Vzc2luZyBldmVudHM7XG4gICAqIC0gV29ya2Zsb3cgYnVuZGxpbmcgbWVzc2FnZXM7XG4gICAqIC0gU2luayBwcm9jZXNzaW5nIGlzc3Vlcy5cbiAgICovXG4gIHdvcmtlciA9ICd3b3JrZXInLFxuXG4gIC8qKlxuICAgKiBDb21wb25lbnQgbmFtZSBmb3IgYWxsIG1lc3NhZ2VzIGVtaXR0ZWQgYnkgdGhlIFJ1c3QgQ29yZSBTREsgbGlicmFyeS5cbiAgICovXG4gIGNvcmUgPSAnY29yZScsXG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IHR5cGUgTG9nTWV0YU9yRnVuYyA9IExvZ01ldGFkYXRhIHwgKCgpID0+IExvZ01ldGFkYXRhKTtcblxuLyoqXG4gKiBBIGxvZ2dlciBpbXBsZW1lbnRhdGlvbiB0aGF0IGFkZHMgbWV0YWRhdGEgYmVmb3JlIGRlbGVnYXRpbmcgY2FsbHMgdG8gYSBwYXJlbnQgbG9nZ2VyLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgTG9nZ2VyV2l0aENvbXBvc2VkTWV0YWRhdGEgaW1wbGVtZW50cyBMb2dnZXIge1xuICAvKipcbiAgICogUmV0dXJuIGEge0BsaW5rIExvZ2dlcn0gdGhhdCBhZGRzIG1ldGFkYXRhIGJlZm9yZSBkZWxlZ2F0aW5nIGNhbGxzIHRvIGEgcGFyZW50IGxvZ2dlci5cbiAgICpcbiAgICogTmV3IG1ldGFkYXRhIG1heSBlaXRoZXIgYmUgc3BlY2lmaWVkIHN0YXRpY2FsbHkgYXMgYSBkZWx0YSBvYmplY3QsIG9yIGFzIGEgZnVuY3Rpb24gZXZhbHVhdGVkXG4gICAqIGV2ZXJ5IHRpbWUgYSBsb2cgaXMgZW1pdHRlZCB0aGF0IHdpbGwgcmV0dXJuIGEgZGVsdGEgb2JqZWN0LlxuICAgKlxuICAgKiBTb21lIG9wdGltaXphdGlvbnMgYXJlIHBlcmZvcm1lZCB0byBhdm9pZCBjcmVhdGluZyB1bm5lY2Vzc2FyeSBvYmplY3RzIGFuZCB0byBrZWVwIHJ1bnRpbWVcbiAgICogb3ZlcmhlYWQgYXNzb2NpYXRlZCB3aXRoIHJlc29sdmluZyBtZXRhZGF0YSBhcyBsb3cgYXMgcG9zc2libGUuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNvbXBvc2UobG9nZ2VyOiBMb2dnZXIsIG1ldGFPckZ1bmM6IExvZ01ldGFPckZ1bmMpOiBMb2dnZXIge1xuICAgIC8vIEZsYXR0ZW4gcmVjdXJzaXZlIExvZ2dlcldpdGhDb21wb3NlZE1ldGFkYXRhIGluc3RhbmNlc1xuICAgIGlmIChsb2dnZXIgaW5zdGFuY2VvZiBMb2dnZXJXaXRoQ29tcG9zZWRNZXRhZGF0YSkge1xuICAgICAgY29uc3QgY29udHJpYnV0b3JzID0gYXBwZW5kVG9DaGFpbihsb2dnZXIuY29udHJpYnV0b3JzLCBtZXRhT3JGdW5jKTtcbiAgICAgIC8vIElmIHRoZSBuZXcgY29udHJpYnV0b3IgcmVzdWx0cyBpbiBubyBhY3R1YWwgY2hhbmdlIHRvIHRoZSBjaGFpbiwgdGhlbiB3ZSBkb24ndCBuZWVkIGEgbmV3IGxvZ2dlclxuICAgICAgaWYgKGNvbnRyaWJ1dG9ycyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbG9nZ2VyO1xuICAgICAgcmV0dXJuIG5ldyBMb2dnZXJXaXRoQ29tcG9zZWRNZXRhZGF0YShsb2dnZXIucGFyZW50TG9nZ2VyLCBjb250cmlidXRvcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb250cmlidXRvcnMgPSBhcHBlbmRUb0NoYWluKHVuZGVmaW5lZCwgbWV0YU9yRnVuYyk7XG4gICAgICBpZiAoY29udHJpYnV0b3JzID09PSB1bmRlZmluZWQpIHJldHVybiBsb2dnZXI7XG4gICAgICByZXR1cm4gbmV3IExvZ2dlcldpdGhDb21wb3NlZE1ldGFkYXRhKGxvZ2dlciwgY29udHJpYnV0b3JzKTtcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHBhcmVudExvZ2dlcjogTG9nZ2VyLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY29udHJpYnV0b3JzOiBMb2dNZXRhT3JGdW5jW11cbiAgKSB7fVxuXG4gIGxvZyhsZXZlbDogTG9nTGV2ZWwsIG1lc3NhZ2U6IHN0cmluZywgZXh0cmFNZXRhPzogTG9nTWV0YWRhdGEpOiB2b2lkIHtcbiAgICB0aGlzLnBhcmVudExvZ2dlci5sb2cobGV2ZWwsIG1lc3NhZ2UsIHJlc29sdmVNZXRhZGF0YSh0aGlzLmNvbnRyaWJ1dG9ycywgZXh0cmFNZXRhKSk7XG4gIH1cblxuICB0cmFjZShtZXNzYWdlOiBzdHJpbmcsIGV4dHJhTWV0YT86IExvZ01ldGFkYXRhKTogdm9pZCB7XG4gICAgdGhpcy5wYXJlbnRMb2dnZXIudHJhY2UobWVzc2FnZSwgcmVzb2x2ZU1ldGFkYXRhKHRoaXMuY29udHJpYnV0b3JzLCBleHRyYU1ldGEpKTtcbiAgfVxuXG4gIGRlYnVnKG1lc3NhZ2U6IHN0cmluZywgZXh0cmFNZXRhPzogTG9nTWV0YWRhdGEpOiB2b2lkIHtcbiAgICB0aGlzLnBhcmVudExvZ2dlci5kZWJ1ZyhtZXNzYWdlLCByZXNvbHZlTWV0YWRhdGEodGhpcy5jb250cmlidXRvcnMsIGV4dHJhTWV0YSkpO1xuICB9XG5cbiAgaW5mbyhtZXNzYWdlOiBzdHJpbmcsIGV4dHJhTWV0YT86IExvZ01ldGFkYXRhKTogdm9pZCB7XG4gICAgdGhpcy5wYXJlbnRMb2dnZXIuaW5mbyhtZXNzYWdlLCByZXNvbHZlTWV0YWRhdGEodGhpcy5jb250cmlidXRvcnMsIGV4dHJhTWV0YSkpO1xuICB9XG5cbiAgd2FybihtZXNzYWdlOiBzdHJpbmcsIGV4dHJhTWV0YT86IExvZ01ldGFkYXRhKTogdm9pZCB7XG4gICAgdGhpcy5wYXJlbnRMb2dnZXIud2FybihtZXNzYWdlLCByZXNvbHZlTWV0YWRhdGEodGhpcy5jb250cmlidXRvcnMsIGV4dHJhTWV0YSkpO1xuICB9XG5cbiAgZXJyb3IobWVzc2FnZTogc3RyaW5nLCBleHRyYU1ldGE/OiBMb2dNZXRhZGF0YSk6IHZvaWQge1xuICAgIHRoaXMucGFyZW50TG9nZ2VyLmVycm9yKG1lc3NhZ2UsIHJlc29sdmVNZXRhZGF0YSh0aGlzLmNvbnRyaWJ1dG9ycywgZXh0cmFNZXRhKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1ldGFkYXRhKGNvbnRyaWJ1dG9yczogTG9nTWV0YU9yRnVuY1tdLCBleHRyYU1ldGE/OiBMb2dNZXRhZGF0YSk6IExvZ01ldGFkYXRhIHtcbiAgY29uc3QgcmVzb2x2ZWQgPSB7fTtcbiAgZm9yIChjb25zdCBjb250cmlidXRvciBvZiBjb250cmlidXRvcnMpIHtcbiAgICBPYmplY3QuYXNzaWduKHJlc29sdmVkLCB0eXBlb2YgY29udHJpYnV0b3IgPT09ICdmdW5jdGlvbicgPyBjb250cmlidXRvcigpIDogY29udHJpYnV0b3IpO1xuICB9XG4gIE9iamVjdC5hc3NpZ24ocmVzb2x2ZWQsIGV4dHJhTWV0YSk7XG4gIHJldHVybiBmaWx0ZXJOdWxsQW5kVW5kZWZpbmVkKHJlc29sdmVkKTtcbn1cblxuLyoqXG4gKiBBcHBlbmQgYSBtZXRhZGF0YSBjb250cmlidXRvciB0byB0aGUgY2hhaW4sIG1lcmdpbmcgaXQgd2l0aCB0aGUgZm9ybWVyIGxhc3QgY29udHJpYnV0b3IgaWYgYm90aCBhcmUgcGxhaW4gb2JqZWN0c1xuICovXG5mdW5jdGlvbiBhcHBlbmRUb0NoYWluKFxuICBleGlzdGluZ0NvbnRyaWJ1dG9yczogTG9nTWV0YU9yRnVuY1tdIHwgdW5kZWZpbmVkLFxuICBuZXdDb250cmlidXRvcjogTG9nTWV0YU9yRnVuY1xuKTogTG9nTWV0YU9yRnVuY1tdIHwgdW5kZWZpbmVkIHtcbiAgLy8gSWYgdGhlIG5ldyBjb250cmlidXRvciBpcyBhbiBlbXB0eSBvYmplY3QsIHRoZW4gaXQgcmVzdWx0cyBpbiBubyBhY3R1YWwgY2hhbmdlIHRvIHRoZSBjaGFpblxuICBpZiAodHlwZW9mIG5ld0NvbnRyaWJ1dG9yID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhuZXdDb250cmlidXRvcikubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGV4aXN0aW5nQ29udHJpYnV0b3JzO1xuICB9XG5cbiAgLy8gSWYgZXhpc3RpbmcgY2hhaW4gaXMgZW1wdHksIHRoZW4gdGhlIG5ldyBjb250cmlidXRvciBpcyB0aGUgY2hhaW5cbiAgaWYgKGV4aXN0aW5nQ29udHJpYnV0b3JzID09IG51bGwgfHwgZXhpc3RpbmdDb250cmlidXRvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtuZXdDb250cmlidXRvcl07XG4gIH1cblxuICAvLyBJZiBib3RoIGxhc3QgY29udHJpYnV0b3IgYW5kIG5ldyBjb250cmlidXRvciBhcmUgcGxhaW4gb2JqZWN0cywgbWVyZ2UgdGhlbSB0byBhIHNpbmdsZSBvYmplY3QuXG4gIGNvbnN0IGxhc3QgPSBleGlzdGluZ0NvbnRyaWJ1dG9yc1tleGlzdGluZ0NvbnRyaWJ1dG9ycy5sZW5ndGggLSAxXTtcbiAgaWYgKHR5cGVvZiBsYXN0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbmV3Q29udHJpYnV0b3IgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgbWVyZ2VkID0gbWVyZ2VPYmplY3RzKGxhc3QsIG5ld0NvbnRyaWJ1dG9yKTtcbiAgICBpZiAobWVyZ2VkID09PSBsYXN0KSByZXR1cm4gZXhpc3RpbmdDb250cmlidXRvcnM7XG4gICAgcmV0dXJuIFsuLi5leGlzdGluZ0NvbnRyaWJ1dG9ycy5zbGljZSgwLCAtMSksIG1lcmdlZF07XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIGp1c3QgYXBwZW5kIHRoZSBuZXcgY29udHJpYnV0b3IgdG8gdGhlIGNoYWluLlxuICByZXR1cm4gWy4uLmV4aXN0aW5nQ29udHJpYnV0b3JzLCBuZXdDb250cmlidXRvcl07XG59XG4iLCJpbXBvcnQgeyBmaWx0ZXJOdWxsQW5kVW5kZWZpbmVkLCBtZXJnZU9iamVjdHMgfSBmcm9tICcuL2ludGVybmFsLXdvcmtmbG93JztcblxuLyoqXG4gKiBBIG1ldGVyIGZvciBjcmVhdGluZyBtZXRyaWNzIHRvIHJlY29yZCB2YWx1ZXMgb24uXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGUgTWV0cmljIEFQSSBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSBhbmQgbWF5IGJlIHN1YmplY3QgdG8gY2hhbmdlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1ldHJpY01ldGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBjb3VudGVyIG1ldHJpYyB0aGF0IHN1cHBvcnRzIGFkZGluZyB2YWx1ZXMuXG4gICAqXG4gICAqIEBwYXJhbSBuYW1lIE5hbWUgZm9yIHRoZSBjb3VudGVyIG1ldHJpYy5cbiAgICogQHBhcmFtIHVuaXQgVW5pdCBmb3IgdGhlIGNvdW50ZXIgbWV0cmljLiBPcHRpb25hbC5cbiAgICogQHBhcmFtIGRlc2NyaXB0aW9uIERlc2NyaXB0aW9uIGZvciB0aGUgY291bnRlciBtZXRyaWMuIE9wdGlvbmFsLlxuICAgKi9cbiAgY3JlYXRlQ291bnRlcihuYW1lOiBzdHJpbmcsIHVuaXQ/OiBzdHJpbmcsIGRlc2NyaXB0aW9uPzogc3RyaW5nKTogTWV0cmljQ291bnRlcjtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGhpc3RvZ3JhbSBtZXRyaWMgdGhhdCBzdXBwb3J0cyByZWNvcmRpbmcgdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBOYW1lIGZvciB0aGUgaGlzdG9ncmFtIG1ldHJpYy5cbiAgICogQHBhcmFtIHZhbHVlVHlwZSBUeXBlIG9mIHZhbHVlIHRvIHJlY29yZC4gRGVmYXVsdHMgdG8gYGludGAuXG4gICAqIEBwYXJhbSB1bml0IFVuaXQgZm9yIHRoZSBoaXN0b2dyYW0gbWV0cmljLiBPcHRpb25hbC5cbiAgICogQHBhcmFtIGRlc2NyaXB0aW9uIERlc2NyaXB0aW9uIGZvciB0aGUgaGlzdG9ncmFtIG1ldHJpYy4gT3B0aW9uYWwuXG4gICAqL1xuICBjcmVhdGVIaXN0b2dyYW0oXG4gICAgbmFtZTogc3RyaW5nLFxuICAgIHZhbHVlVHlwZT86IE51bWVyaWNNZXRyaWNWYWx1ZVR5cGUsXG4gICAgdW5pdD86IHN0cmluZyxcbiAgICBkZXNjcmlwdGlvbj86IHN0cmluZ1xuICApOiBNZXRyaWNIaXN0b2dyYW07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBnYXVnZSBtZXRyaWMgdGhhdCBzdXBwb3J0cyBzZXR0aW5nIHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgTmFtZSBmb3IgdGhlIGdhdWdlIG1ldHJpYy5cbiAgICogQHBhcmFtIHZhbHVlVHlwZSBUeXBlIG9mIHZhbHVlIHRvIHNldC4gRGVmYXVsdHMgdG8gYGludGAuXG4gICAqIEBwYXJhbSB1bml0IFVuaXQgZm9yIHRoZSBnYXVnZSBtZXRyaWMuIE9wdGlvbmFsLlxuICAgKiBAcGFyYW0gZGVzY3JpcHRpb24gRGVzY3JpcHRpb24gZm9yIHRoZSBnYXVnZSBtZXRyaWMuIE9wdGlvbmFsLlxuICAgKi9cbiAgY3JlYXRlR2F1Z2UobmFtZTogc3RyaW5nLCB2YWx1ZVR5cGU/OiBOdW1lcmljTWV0cmljVmFsdWVUeXBlLCB1bml0Pzogc3RyaW5nLCBkZXNjcmlwdGlvbj86IHN0cmluZyk6IE1ldHJpY0dhdWdlO1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBjbG9uZSBvZiB0aGlzIG1ldGVyLCB3aXRoIGFkZGl0aW9uYWwgdGFncy4gQWxsIG1ldHJpY3MgY3JlYXRlZCBvZmYgdGhlIG1ldGVyIHdpbGxcbiAgICogaGF2ZSB0aGUgdGFncy5cbiAgICpcbiAgICogQHBhcmFtIHRhZ3MgVGFncyB0byBhcHBlbmQuXG4gICAqL1xuICB3aXRoVGFncyh0YWdzOiBNZXRyaWNUYWdzKTogTWV0cmljTWV0ZXI7XG59XG5cbi8qKlxuICogQmFzZSBpbnRlcmZhY2UgZm9yIGFsbCBtZXRyaWNzLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhlIE1ldHJpYyBBUEkgaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUgYW5kIG1heSBiZSBzdWJqZWN0IHRvIGNoYW5nZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNZXRyaWMge1xuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIG1ldHJpYy5cbiAgICovXG4gIG5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHVuaXQgb2YgdGhlIG1ldHJpYywgaWYgYW55LlxuICAgKi9cbiAgdW5pdD86IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBtZXRyaWMsIGlmIGFueS5cbiAgICovXG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIEEgbWV0cmljIHRoYXQgc3VwcG9ydHMgYWRkaW5nIHZhbHVlcyBhcyBhIGNvdW50ZXIuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGUgTWV0cmljIEFQSSBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSBhbmQgbWF5IGJlIHN1YmplY3QgdG8gY2hhbmdlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1ldHJpY0NvdW50ZXIgZXh0ZW5kcyBNZXRyaWMge1xuICAvKipcbiAgICogQWRkIHRoZSBnaXZlbiB2YWx1ZSB0byB0aGUgY291bnRlci5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIGFkZC5cbiAgICogQHBhcmFtIGV4dHJhVGFncyBFeHRyYSB0YWdzIGlmIGFueS5cbiAgICovXG4gIGFkZCh2YWx1ZTogbnVtYmVyLCBleHRyYVRhZ3M/OiBNZXRyaWNUYWdzKTogdm9pZDtcblxuICAvKipcbiAgICogUmV0dXJuIGEgY2xvbmUgb2YgdGhpcyBjb3VudGVyLCB3aXRoIGFkZGl0aW9uYWwgdGFncy5cbiAgICpcbiAgICogQHBhcmFtIHRhZ3MgVGFncyB0byBhcHBlbmQgdG8gZXhpc3RpbmcgdGFncy5cbiAgICovXG4gIHdpdGhUYWdzKHRhZ3M6IE1ldHJpY1RhZ3MpOiBNZXRyaWNDb3VudGVyO1xufVxuXG4vKipcbiAqIEEgbWV0cmljIHRoYXQgc3VwcG9ydHMgcmVjb3JkaW5nIHZhbHVlcyBvbiBhIGhpc3RvZ3JhbS5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoZSBNZXRyaWMgQVBJIGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlIGFuZCBtYXkgYmUgc3ViamVjdCB0byBjaGFuZ2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWV0cmljSGlzdG9ncmFtIGV4dGVuZHMgTWV0cmljIHtcbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIHZhbHVlIHRvIHJlY29yZC4gRWl0aGVyIGBpbnRgIG9yIGBmbG9hdGAuXG4gICAqL1xuICB2YWx1ZVR5cGU6IE51bWVyaWNNZXRyaWNWYWx1ZVR5cGU7XG5cbiAgLyoqXG4gICAqIFJlY29yZCB0aGUgZ2l2ZW4gdmFsdWUgb24gdGhlIGhpc3RvZ3JhbS5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIHJlY29yZC4gTXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFZhbHVlIHdpbGwgYmUgY2FzdGVkIHRvIHRoZSBnaXZlblxuICAgKiAgICAgICAgICAgICAge0BsaW5rIHZhbHVlVHlwZX0uIExvc3Mgb2YgcHJlY2lzaW9uIG1heSBvY2N1ciBpZiB0aGUgdmFsdWUgaXMgbm90IGFscmVhZHkgb2YgdGhlXG4gICAqICAgICAgICAgICAgICBjb3JyZWN0IHR5cGUuXG4gICAqIEBwYXJhbSBleHRyYVRhZ3MgRXh0cmEgdGFncyBpZiBhbnkuXG4gICAqL1xuICByZWNvcmQodmFsdWU6IG51bWJlciwgZXh0cmFUYWdzPzogTWV0cmljVGFncyk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGNsb25lIG9mIHRoaXMgaGlzdG9ncmFtLCB3aXRoIGFkZGl0aW9uYWwgdGFncy5cbiAgICpcbiAgICogQHBhcmFtIHRhZ3MgVGFncyB0byBhcHBlbmQgdG8gZXhpc3RpbmcgdGFncy5cbiAgICovXG4gIHdpdGhUYWdzKHRhZ3M6IE1ldHJpY1RhZ3MpOiBNZXRyaWNIaXN0b2dyYW07XG59XG5cbi8qKlxuICogQSBtZXRyaWMgdGhhdCBzdXBwb3J0cyBzZXR0aW5nIHZhbHVlcy5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoZSBNZXRyaWMgQVBJIGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlIGFuZCBtYXkgYmUgc3ViamVjdCB0byBjaGFuZ2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWV0cmljR2F1Z2UgZXh0ZW5kcyBNZXRyaWMge1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdmFsdWUgdG8gc2V0LiBFaXRoZXIgYGludGAgb3IgYGZsb2F0YC5cbiAgICovXG4gIHZhbHVlVHlwZTogTnVtZXJpY01ldHJpY1ZhbHVlVHlwZTtcblxuICAvKipcbiAgICogU2V0IHRoZSBnaXZlbiB2YWx1ZSBvbiB0aGUgZ2F1Z2UuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byBzZXQuXG4gICAqIEBwYXJhbSBleHRyYVRhZ3MgRXh0cmEgdGFncyBpZiBhbnkuXG4gICAqL1xuICBzZXQodmFsdWU6IG51bWJlciwgZXh0cmFUYWdzPzogTWV0cmljVGFncyk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGNsb25lIG9mIHRoaXMgZ2F1Z2UsIHdpdGggYWRkaXRpb25hbCB0YWdzLlxuICAgKlxuICAgKiBAcGFyYW0gdGFncyBUYWdzIHRvIGFwcGVuZCB0byBleGlzdGluZyB0YWdzLlxuICAgKi9cbiAgd2l0aFRhZ3ModGFnczogTWV0cmljVGFncyk6IE1ldHJpY0dhdWdlO1xufVxuXG4vKipcbiAqIFRhZ3MgdG8gYmUgYXR0YWNoZWQgdG8gc29tZSBtZXRyaWNzLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhlIE1ldHJpYyBBUEkgaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUgYW5kIG1heSBiZSBzdWJqZWN0IHRvIGNoYW5nZS5cbiAqL1xuZXhwb3J0IHR5cGUgTWV0cmljVGFncyA9IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4+O1xuXG5leHBvcnQgdHlwZSBOdW1lcmljTWV0cmljVmFsdWVUeXBlID0gJ2ludCcgfCAnZmxvYXQnO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQSBtZXRlciBpbXBsZW1lbnRhdGlvbiB0aGF0IGRvZXMgbm90aGluZy5cbiAqL1xuY2xhc3MgTm9vcE1ldHJpY01ldGVyIGltcGxlbWVudHMgTWV0cmljTWV0ZXIge1xuICBjcmVhdGVDb3VudGVyKG5hbWU6IHN0cmluZywgdW5pdD86IHN0cmluZywgZGVzY3JpcHRpb24/OiBzdHJpbmcpOiBNZXRyaWNDb3VudGVyIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZSxcbiAgICAgIHVuaXQsXG4gICAgICBkZXNjcmlwdGlvbixcblxuICAgICAgYWRkKF92YWx1ZSwgX2V4dHJhVGFncykge30sXG5cbiAgICAgIHdpdGhUYWdzKF9leHRyYVRhZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBjcmVhdGVIaXN0b2dyYW0oXG4gICAgbmFtZTogc3RyaW5nLFxuICAgIHZhbHVlVHlwZTogTnVtZXJpY01ldHJpY1ZhbHVlVHlwZSA9ICdpbnQnLFxuICAgIHVuaXQ/OiBzdHJpbmcsXG4gICAgZGVzY3JpcHRpb24/OiBzdHJpbmdcbiAgKTogTWV0cmljSGlzdG9ncmFtIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZSxcbiAgICAgIHZhbHVlVHlwZSxcbiAgICAgIHVuaXQsXG4gICAgICBkZXNjcmlwdGlvbixcblxuICAgICAgcmVjb3JkKF92YWx1ZSwgX2V4dHJhVGFncykge30sXG5cbiAgICAgIHdpdGhUYWdzKF9leHRyYVRhZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBjcmVhdGVHYXVnZShuYW1lOiBzdHJpbmcsIHZhbHVlVHlwZT86IE51bWVyaWNNZXRyaWNWYWx1ZVR5cGUsIHVuaXQ/OiBzdHJpbmcsIGRlc2NyaXB0aW9uPzogc3RyaW5nKTogTWV0cmljR2F1Z2Uge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lLFxuICAgICAgdmFsdWVUeXBlOiB2YWx1ZVR5cGUgPz8gJ2ludCcsXG4gICAgICB1bml0LFxuICAgICAgZGVzY3JpcHRpb24sXG5cbiAgICAgIHNldChfdmFsdWUsIF9leHRyYVRhZ3MpIHt9LFxuXG4gICAgICB3aXRoVGFncyhfZXh0cmFUYWdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgd2l0aFRhZ3MoX2V4dHJhVGFnczogTWV0cmljVGFncyk6IE1ldHJpY01ldGVyIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgbm9vcE1ldHJpY01ldGVyID0gbmV3IE5vb3BNZXRyaWNNZXRlcigpO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCB0eXBlIE1ldHJpY1RhZ3NPckZ1bmMgPSBNZXRyaWNUYWdzIHwgKCgpID0+IE1ldHJpY1RhZ3MpO1xuXG4vKipcbiAqIEEgbWV0ZXIgaW1wbGVtZW50YXRpb24gdGhhdCBhZGRzIHRhZ3MgYmVmb3JlIGRlbGVnYXRpbmcgY2FsbHMgdG8gYSBwYXJlbnQgbWV0ZXIuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGUgTWV0cmljIEFQSSBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSBhbmQgbWF5IGJlIHN1YmplY3QgdG8gY2hhbmdlLlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBNZXRyaWNNZXRlcldpdGhDb21wb3NlZFRhZ3MgaW1wbGVtZW50cyBNZXRyaWNNZXRlciB7XG4gIC8qKlxuICAgKiBSZXR1cm4gYSB7QGxpbmsgTWV0cmljTWV0ZXJ9IHRoYXQgYWRkcyB0YWdzIGJlZm9yZSBkZWxlZ2F0aW5nIGNhbGxzIHRvIGEgcGFyZW50IG1ldGVyLlxuICAgKlxuICAgKiBOZXcgdGFncyBtYXkgZWl0aGVyIGJlIHNwZWNpZmllZCBzdGF0aWNhbGx5IGFzIGEgZGVsdGEgb2JqZWN0LCBvciBhcyBhIGZ1bmN0aW9uIGV2YWx1YXRlZFxuICAgKiBldmVyeSB0aW1lIGEgbWV0cmljIGlzIHJlY29yZGVkIHRoYXQgd2lsbCByZXR1cm4gYSBkZWx0YSBvYmplY3QuXG4gICAqXG4gICAqIFNvbWUgb3B0aW1pemF0aW9ucyBhcmUgcGVyZm9ybWVkIHRvIGF2b2lkIGNyZWF0aW5nIHVubmVjZXNzYXJ5IG9iamVjdHMgYW5kIHRvIGtlZXAgcnVudGltZVxuICAgKiBvdmVyaGVhZCBhc3NvY2lhdGVkIHdpdGggcmVzb2x2aW5nIHRhZ3MgYXMgbG93IGFzIHBvc3NpYmxlLlxuICAgKlxuICAgKiBAcGFyYW0gbWV0ZXIgVGhlIHBhcmVudCBtZXRlciB0byBkZWxlZ2F0ZSBjYWxscyB0by5cbiAgICogQHBhcmFtIHRhZ3NPckZ1bmMgTmV3IHRhZ3MgbWF5IGVpdGhlciBiZSBzcGVjaWZpZWQgc3RhdGljYWxseSBhcyBhIGRlbHRhIG9iamVjdCwgb3IgYXMgYSBmdW5jdGlvblxuICAgKiAgICAgICAgICAgICAgICAgICBldmFsdWF0ZWQgZXZlcnkgdGltZSBhIG1ldHJpYyBpcyByZWNvcmRlZCB0aGF0IHdpbGwgcmV0dXJuIGEgZGVsdGEgb2JqZWN0LlxuICAgKiBAcGFyYW0gZm9yY2UgaWYgYHRydWVgLCB0aGVuIGEgYE1ldHJpY01ldGVyV2l0aENvbXBvc2VkVGFnc2Agd2lsbCBiZSBjcmVhdGVkIGV2ZW4gaWYgdGhlcmVcbiAgICogICAgICAgICAgICAgIGlzIG5vIHRhZ3MgdG8gYWRkLiBUaGlzIGlzIHVzZWZ1bCB0byBhZGQgdGFncyBzdXBwb3J0IHRvIGFuIHVuZGVybHlpbmcgbWV0ZXJcbiAgICogICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIHRoYXQgZG9lcyBub3Qgc3VwcG9ydCB0YWdzIGRpcmVjdGx5LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBjb21wb3NlKG1ldGVyOiBNZXRyaWNNZXRlciwgdGFnc09yRnVuYzogTWV0cmljVGFnc09yRnVuYywgZm9yY2U6IGJvb2xlYW4gPSBmYWxzZSk6IE1ldHJpY01ldGVyIHtcbiAgICBpZiAobWV0ZXIgaW5zdGFuY2VvZiBNZXRyaWNNZXRlcldpdGhDb21wb3NlZFRhZ3MpIHtcbiAgICAgIGNvbnN0IGNvbnRyaWJ1dG9ycyA9IGFwcGVuZFRvQ2hhaW4obWV0ZXIuY29udHJpYnV0b3JzLCB0YWdzT3JGdW5jKTtcbiAgICAgIC8vIElmIHRoZSBuZXcgY29udHJpYnV0b3IgcmVzdWx0cyBpbiBubyBhY3R1YWwgY2hhbmdlIHRvIHRoZSBjaGFpbiwgdGhlbiB3ZSBkb24ndCBuZWVkIGEgbmV3IG1ldGVyXG4gICAgICBpZiAoY29udHJpYnV0b3JzID09PSB1bmRlZmluZWQgJiYgIWZvcmNlKSByZXR1cm4gbWV0ZXI7XG4gICAgICByZXR1cm4gbmV3IE1ldHJpY01ldGVyV2l0aENvbXBvc2VkVGFncyhtZXRlci5wYXJlbnRNZXRlciwgY29udHJpYnV0b3JzID8/IFtdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29udHJpYnV0b3JzID0gYXBwZW5kVG9DaGFpbih1bmRlZmluZWQsIHRhZ3NPckZ1bmMpO1xuICAgICAgaWYgKGNvbnRyaWJ1dG9ycyA9PT0gdW5kZWZpbmVkICYmICFmb3JjZSkgcmV0dXJuIG1ldGVyO1xuICAgICAgcmV0dXJuIG5ldyBNZXRyaWNNZXRlcldpdGhDb21wb3NlZFRhZ3MobWV0ZXIsIGNvbnRyaWJ1dG9ycyA/PyBbXSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHBhcmVudE1ldGVyOiBNZXRyaWNNZXRlcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNvbnRyaWJ1dG9yczogTWV0cmljVGFnc09yRnVuY1tdXG4gICkge31cblxuICBjcmVhdGVDb3VudGVyKG5hbWU6IHN0cmluZywgdW5pdD86IHN0cmluZywgZGVzY3JpcHRpb24/OiBzdHJpbmcpOiBNZXRyaWNDb3VudGVyIHtcbiAgICBjb25zdCBwYXJlbnRDb3VudGVyID0gdGhpcy5wYXJlbnRNZXRlci5jcmVhdGVDb3VudGVyKG5hbWUsIHVuaXQsIGRlc2NyaXB0aW9uKTtcbiAgICByZXR1cm4gbmV3IE1ldHJpY0NvdW50ZXJXaXRoQ29tcG9zZWRUYWdzKHBhcmVudENvdW50ZXIsIHRoaXMuY29udHJpYnV0b3JzKTtcbiAgfVxuXG4gIGNyZWF0ZUhpc3RvZ3JhbShcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgdmFsdWVUeXBlOiBOdW1lcmljTWV0cmljVmFsdWVUeXBlID0gJ2ludCcsXG4gICAgdW5pdD86IHN0cmluZyxcbiAgICBkZXNjcmlwdGlvbj86IHN0cmluZ1xuICApOiBNZXRyaWNIaXN0b2dyYW0ge1xuICAgIGNvbnN0IHBhcmVudEhpc3RvZ3JhbSA9IHRoaXMucGFyZW50TWV0ZXIuY3JlYXRlSGlzdG9ncmFtKG5hbWUsIHZhbHVlVHlwZSwgdW5pdCwgZGVzY3JpcHRpb24pO1xuICAgIHJldHVybiBuZXcgTWV0cmljSGlzdG9ncmFtV2l0aENvbXBvc2VkVGFncyhwYXJlbnRIaXN0b2dyYW0sIHRoaXMuY29udHJpYnV0b3JzKTtcbiAgfVxuXG4gIGNyZWF0ZUdhdWdlKFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICB2YWx1ZVR5cGU6IE51bWVyaWNNZXRyaWNWYWx1ZVR5cGUgPSAnaW50JyxcbiAgICB1bml0Pzogc3RyaW5nLFxuICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nXG4gICk6IE1ldHJpY0dhdWdlIHtcbiAgICBjb25zdCBwYXJlbnRHYXVnZSA9IHRoaXMucGFyZW50TWV0ZXIuY3JlYXRlR2F1Z2UobmFtZSwgdmFsdWVUeXBlLCB1bml0LCBkZXNjcmlwdGlvbik7XG4gICAgcmV0dXJuIG5ldyBNZXRyaWNHYXVnZVdpdGhDb21wb3NlZFRhZ3MocGFyZW50R2F1Z2UsIHRoaXMuY29udHJpYnV0b3JzKTtcbiAgfVxuXG4gIHdpdGhUYWdzKHRhZ3M6IE1ldHJpY1RhZ3MpOiBNZXRyaWNNZXRlciB7XG4gICAgcmV0dXJuIE1ldHJpY01ldGVyV2l0aENvbXBvc2VkVGFncy5jb21wb3NlKHRoaXMsIHRhZ3MpO1xuICB9XG59XG5cbi8qKlxuICogQGV4cGVyaW1lbnRhbCBUaGUgTWV0cmljIEFQSSBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSBhbmQgbWF5IGJlIHN1YmplY3QgdG8gY2hhbmdlLlxuICovXG5jbGFzcyBNZXRyaWNDb3VudGVyV2l0aENvbXBvc2VkVGFncyBpbXBsZW1lbnRzIE1ldHJpY0NvdW50ZXIge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHBhcmVudENvdW50ZXI6IE1ldHJpY0NvdW50ZXIsXG4gICAgcHJpdmF0ZSBjb250cmlidXRvcnM6IE1ldHJpY1RhZ3NPckZ1bmNbXVxuICApIHt9XG5cbiAgYWRkKHZhbHVlOiBudW1iZXIsIGV4dHJhVGFncz86IE1ldHJpY1RhZ3MgfCB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICB0aGlzLnBhcmVudENvdW50ZXIuYWRkKHZhbHVlLCByZXNvbHZlVGFncyh0aGlzLmNvbnRyaWJ1dG9ycywgZXh0cmFUYWdzKSk7XG4gIH1cblxuICB3aXRoVGFncyhleHRyYVRhZ3M6IE1ldHJpY1RhZ3MpOiBNZXRyaWNDb3VudGVyIHtcbiAgICBjb25zdCBjb250cmlidXRvcnMgPSBhcHBlbmRUb0NoYWluKHRoaXMuY29udHJpYnV0b3JzLCBleHRyYVRhZ3MpO1xuICAgIGlmIChjb250cmlidXRvcnMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXM7XG4gICAgcmV0dXJuIG5ldyBNZXRyaWNDb3VudGVyV2l0aENvbXBvc2VkVGFncyh0aGlzLnBhcmVudENvdW50ZXIsIGNvbnRyaWJ1dG9ycyk7XG4gIH1cblxuICBnZXQgbmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnBhcmVudENvdW50ZXIubmFtZTtcbiAgfVxuXG4gIGdldCB1bml0KCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50Q291bnRlci51bml0O1xuICB9XG5cbiAgZ2V0IGRlc2NyaXB0aW9uKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50Q291bnRlci5kZXNjcmlwdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIEBleHBlcmltZW50YWwgVGhlIE1ldHJpYyBBUEkgaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUgYW5kIG1heSBiZSBzdWJqZWN0IHRvIGNoYW5nZS5cbiAqL1xuY2xhc3MgTWV0cmljSGlzdG9ncmFtV2l0aENvbXBvc2VkVGFncyBpbXBsZW1lbnRzIE1ldHJpY0hpc3RvZ3JhbSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcGFyZW50SGlzdG9ncmFtOiBNZXRyaWNIaXN0b2dyYW0sXG4gICAgcHJpdmF0ZSBjb250cmlidXRvcnM6IE1ldHJpY1RhZ3NPckZ1bmNbXVxuICApIHt9XG5cbiAgcmVjb3JkKHZhbHVlOiBudW1iZXIsIGV4dHJhVGFncz86IE1ldHJpY1RhZ3MpOiB2b2lkIHtcbiAgICB0aGlzLnBhcmVudEhpc3RvZ3JhbS5yZWNvcmQodmFsdWUsIHJlc29sdmVUYWdzKHRoaXMuY29udHJpYnV0b3JzLCBleHRyYVRhZ3MpKTtcbiAgfVxuXG4gIHdpdGhUYWdzKGV4dHJhVGFnczogTWV0cmljVGFncyk6IE1ldHJpY0hpc3RvZ3JhbSB7XG4gICAgY29uc3QgY29udHJpYnV0b3JzID0gYXBwZW5kVG9DaGFpbih0aGlzLmNvbnRyaWJ1dG9ycywgZXh0cmFUYWdzKTtcbiAgICBpZiAoY29udHJpYnV0b3JzID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzO1xuICAgIHJldHVybiBuZXcgTWV0cmljSGlzdG9ncmFtV2l0aENvbXBvc2VkVGFncyh0aGlzLnBhcmVudEhpc3RvZ3JhbSwgY29udHJpYnV0b3JzKTtcbiAgfVxuXG4gIGdldCBuYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50SGlzdG9ncmFtLm5hbWU7XG4gIH1cblxuICBnZXQgdmFsdWVUeXBlKCk6IE51bWVyaWNNZXRyaWNWYWx1ZVR5cGUge1xuICAgIHJldHVybiB0aGlzLnBhcmVudEhpc3RvZ3JhbS52YWx1ZVR5cGU7XG4gIH1cblxuICBnZXQgdW5pdCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnBhcmVudEhpc3RvZ3JhbS51bml0O1xuICB9XG5cbiAgZ2V0IGRlc2NyaXB0aW9uKCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50SGlzdG9ncmFtLmRlc2NyaXB0aW9uO1xuICB9XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIE1ldHJpY0dhdWdlV2l0aENvbXBvc2VkVGFncyBpbXBsZW1lbnRzIE1ldHJpY0dhdWdlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBwYXJlbnRHYXVnZTogTWV0cmljR2F1Z2UsXG4gICAgcHJpdmF0ZSBjb250cmlidXRvcnM6IE1ldHJpY1RhZ3NPckZ1bmNbXVxuICApIHt9XG5cbiAgc2V0KHZhbHVlOiBudW1iZXIsIGV4dHJhVGFncz86IE1ldHJpY1RhZ3MpOiB2b2lkIHtcbiAgICB0aGlzLnBhcmVudEdhdWdlLnNldCh2YWx1ZSwgcmVzb2x2ZVRhZ3ModGhpcy5jb250cmlidXRvcnMsIGV4dHJhVGFncykpO1xuICB9XG5cbiAgd2l0aFRhZ3MoZXh0cmFUYWdzOiBNZXRyaWNUYWdzKTogTWV0cmljR2F1Z2Uge1xuICAgIGNvbnN0IGNvbnRyaWJ1dG9ycyA9IGFwcGVuZFRvQ2hhaW4odGhpcy5jb250cmlidXRvcnMsIGV4dHJhVGFncyk7XG4gICAgaWYgKGNvbnRyaWJ1dG9ycyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcztcbiAgICByZXR1cm4gbmV3IE1ldHJpY0dhdWdlV2l0aENvbXBvc2VkVGFncyh0aGlzLnBhcmVudEdhdWdlLCBjb250cmlidXRvcnMpO1xuICB9XG5cbiAgZ2V0IG5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnRHYXVnZS5uYW1lO1xuICB9XG5cbiAgZ2V0IHZhbHVlVHlwZSgpOiBOdW1lcmljTWV0cmljVmFsdWVUeXBlIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnRHYXVnZS52YWx1ZVR5cGU7XG4gIH1cblxuICBnZXQgdW5pdCgpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnBhcmVudEdhdWdlLnVuaXQ7XG4gIH1cblxuICBnZXQgZGVzY3JpcHRpb24oKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnRHYXVnZS5kZXNjcmlwdGlvbjtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlVGFncyhjb250cmlidXRvcnM6IE1ldHJpY1RhZ3NPckZ1bmNbXSwgZXh0cmFUYWdzPzogTWV0cmljVGFncyk6IE1ldHJpY1RhZ3Mge1xuICBjb25zdCByZXNvbHZlZCA9IHt9O1xuICBmb3IgKGNvbnN0IGNvbnRyaWJ1dG9yIG9mIGNvbnRyaWJ1dG9ycykge1xuICAgIE9iamVjdC5hc3NpZ24ocmVzb2x2ZWQsIHR5cGVvZiBjb250cmlidXRvciA9PT0gJ2Z1bmN0aW9uJyA/IGNvbnRyaWJ1dG9yKCkgOiBjb250cmlidXRvcik7XG4gIH1cbiAgT2JqZWN0LmFzc2lnbihyZXNvbHZlZCwgZXh0cmFUYWdzKTtcbiAgcmV0dXJuIGZpbHRlck51bGxBbmRVbmRlZmluZWQocmVzb2x2ZWQpO1xufVxuXG4vKipcbiAqIEFwcGVuZCBhIHRhZ3MgY29udHJpYnV0b3IgdG8gdGhlIGNoYWluLCBtZXJnaW5nIGl0IHdpdGggdGhlIGZvcm1lciBsYXN0IGNvbnRyaWJ1dG9yIGlmIHBvc3NpYmxlLlxuICpcbiAqIElmIGFwcGVuZGluZyB0aGUgbmV3IGNvbnRyaWJ1dG9yIHJlc3VsdHMgaW4gbm8gYWN0dWFsIGNoYW5nZSB0byB0aGUgY2hhaW4gb2YgY29udHJpYnV0b3JzLCByZXR1cm5cbiAqIGBleGlzdGluZ0NvbnRyaWJ1dG9yc2A7IGluIHRoYXQgY2FzZSwgdGhlIGNhbGxlciBzaG91bGQgYXZvaWQgY3JlYXRpbmcgYSBuZXcgb2JqZWN0IGlmIHBvc3NpYmxlLlxuICovXG5mdW5jdGlvbiBhcHBlbmRUb0NoYWluKFxuICBleGlzdGluZ0NvbnRyaWJ1dG9yczogTWV0cmljVGFnc09yRnVuY1tdIHwgdW5kZWZpbmVkLFxuICBuZXdDb250cmlidXRvcjogTWV0cmljVGFnc09yRnVuY1xuKTogTWV0cmljVGFnc09yRnVuY1tdIHwgdW5kZWZpbmVkIHtcbiAgLy8gSWYgdGhlIG5ldyBjb250cmlidXRvciBpcyBhbiBlbXB0eSBvYmplY3QsIHRoZW4gaXQgcmVzdWx0cyBpbiBubyBhY3R1YWwgY2hhbmdlIHRvIHRoZSBjaGFpblxuICBpZiAodHlwZW9mIG5ld0NvbnRyaWJ1dG9yID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhuZXdDb250cmlidXRvcikubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGV4aXN0aW5nQ29udHJpYnV0b3JzO1xuICB9XG5cbiAgLy8gSWYgZXhpc3RpbmcgY2hhaW4gaXMgZW1wdHksIHRoZW4gdGhlIG5ldyBjb250cmlidXRvciBpcyB0aGUgY2hhaW5cbiAgaWYgKGV4aXN0aW5nQ29udHJpYnV0b3JzID09IG51bGwgfHwgZXhpc3RpbmdDb250cmlidXRvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtuZXdDb250cmlidXRvcl07XG4gIH1cblxuICAvLyBJZiBib3RoIGxhc3QgY29udHJpYnV0b3IgYW5kIG5ldyBjb250cmlidXRvciBhcmUgcGxhaW4gb2JqZWN0cywgbWVyZ2UgdGhlbSB0byBhIHNpbmdsZSBvYmplY3QuXG4gIGNvbnN0IGxhc3QgPSBleGlzdGluZ0NvbnRyaWJ1dG9yc1tleGlzdGluZ0NvbnRyaWJ1dG9ycy5sZW5ndGggLSAxXTtcbiAgaWYgKHR5cGVvZiBsYXN0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbmV3Q29udHJpYnV0b3IgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgbWVyZ2VkID0gbWVyZ2VPYmplY3RzKGxhc3QsIG5ld0NvbnRyaWJ1dG9yKTtcbiAgICBpZiAobWVyZ2VkID09PSBsYXN0KSByZXR1cm4gZXhpc3RpbmdDb250cmlidXRvcnM7XG4gICAgcmV0dXJuIFsuLi5leGlzdGluZ0NvbnRyaWJ1dG9ycy5zbGljZSgwLCAtMSksIG1lcmdlZCFdO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCBqdXN0IGFwcGVuZCB0aGUgbmV3IGNvbnRyaWJ1dG9yIHRvIHRoZSBjaGFpbi5cbiAgcmV0dXJuIFsuLi5leGlzdGluZ0NvbnRyaWJ1dG9ycywgbmV3Q29udHJpYnV0b3JdO1xufVxuIiwiaW1wb3J0IHR5cGUgeyB0ZW1wb3JhbCB9IGZyb20gJ0B0ZW1wb3JhbGlvL3Byb3RvJztcblxuLyoqXG4gKiBQcmlvcml0eSBjb250YWlucyBtZXRhZGF0YSB0aGF0IGNvbnRyb2xzIHJlbGF0aXZlIG9yZGVyaW5nIG9mIHRhc2sgcHJvY2Vzc2luZyB3aGVuIHRhc2tzIGFyZVxuICogYmFja2xvZ2dlZCBpbiBhIHF1ZXVlLiBJbml0aWFsbHksIFByaW9yaXR5IHdpbGwgYmUgdXNlZCBpbiBhY3Rpdml0eSBhbmQgd29ya2Zsb3cgdGFzayBxdWV1ZXMsXG4gKiB3aGljaCBhcmUgdHlwaWNhbGx5IHdoZXJlIGJhY2tsb2dzIGV4aXN0LlxuICogUHJpb3JpdHkgaXMgKGZvciBub3cpIGF0dGFjaGVkIHRvIHdvcmtmbG93cyBhbmQgYWN0aXZpdGllcy4gQWN0aXZpdGllcyBhbmQgY2hpbGQgd29ya2Zsb3dzXG4gKiBpbmhlcml0IFByaW9yaXR5IGZyb20gdGhlIHdvcmtmbG93IHRoYXQgY3JlYXRlZCB0aGVtLCBidXQgbWF5IG92ZXJyaWRlIGZpZWxkcyB3aGVuIHRoZXkgYXJlXG4gKiBzdGFydGVkIG9yIG1vZGlmaWVkLiBGb3IgZWFjaCBmaWVsZCBvZiBhIFByaW9yaXR5IG9uIGFuIGFjdGl2aXR5L3dvcmtmbG93LCBub3QgcHJlc2VudCBvciBlcXVhbFxuICogdG8gemVyby9lbXB0eSBzdHJpbmcgbWVhbnMgdG8gaW5oZXJpdCB0aGUgdmFsdWUgZnJvbSB0aGUgY2FsbGluZyB3b3JrZmxvdywgb3IgaWYgdGhlcmUgaXMgbm9cbiAqIGNhbGxpbmcgd29ya2Zsb3csIHRoZW4gdXNlIHRoZSBkZWZhdWx0IChkb2N1bWVudGVkIG9uIHRoZSBmaWVsZCkuXG4gKiBUaGUgb3ZlcmFsbCBzZW1hbnRpY3Mgb2YgUHJpb3JpdHkgYXJlOlxuICogMS4gRmlyc3QsIGNvbnNpZGVyIFwicHJpb3JpdHlfa2V5XCI6IGxvd2VyIG51bWJlciBnb2VzIGZpcnN0LlxuICogMi4gVGhlbiwgY29uc2lkZXIgZmFpcm5lc3M6IHRoZSBmYWlybmVzcyBtZWNoYW5pc20gYXR0ZW1wdHMgdG8gZGlzcGF0Y2ggdGFza3MgZm9yIGEgZ2l2ZW4ga2V5IGluXG4gKiAgICBwcm9wb3J0aW9uIHRvIGl0cyB3ZWlnaHQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJpb3JpdHkge1xuICAvKipcbiAgICogUHJpb3JpdHkga2V5IGlzIGEgcG9zaXRpdmUgaW50ZWdlciBmcm9tIDEgdG8gbiwgd2hlcmUgc21hbGxlciBpbnRlZ2Vyc1xuICAgKiBjb3JyZXNwb25kIHRvIGhpZ2hlciBwcmlvcml0aWVzICh0YXNrcyBydW4gc29vbmVyKS4gSW4gZ2VuZXJhbCwgdGFza3MgaW5cbiAgICogYSBxdWV1ZSBzaG91bGQgYmUgcHJvY2Vzc2VkIGluIGNsb3NlIHRvIHByaW9yaXR5IG9yZGVyLCBhbHRob3VnaCBzbWFsbFxuICAgKiBkZXZpYXRpb25zIGFyZSBwb3NzaWJsZS5cbiAgICpcbiAgICogVGhlIG1heGltdW0gcHJpb3JpdHkgdmFsdWUgKG1pbmltdW0gcHJpb3JpdHkpIGlzIGRldGVybWluZWQgYnkgc2VydmVyIGNvbmZpZ3VyYXRpb24sIGFuZFxuICAgKiBkZWZhdWx0cyB0byA1LlxuICAgKlxuICAgKiBUaGUgZGVmYXVsdCBwcmlvcml0eSBpcyAobWluK21heCkvMi4gV2l0aCB0aGUgZGVmYXVsdCBtYXggb2YgNSBhbmQgbWluIG9mIDEsIHRoYXQgY29tZXMgb3V0IHRvIDMuXG4gICAqL1xuICBwcmlvcml0eUtleT86IG51bWJlcjtcblxuICAvKipcbiAgICogRmFpcm5lc3NLZXkgaXMgYSBzaG9ydCBzdHJpbmcgdGhhdCdzIHVzZWQgYXMgYSBrZXkgZm9yIGEgZmFpcm5lc3NcbiAgICogYmFsYW5jaW5nIG1lY2hhbmlzbS4gSXQgbWF5IGNvcnJlc3BvbmQgdG8gYSB0ZW5hbnQgaWQsIG9yIHRvIGEgZml4ZWRcbiAgICogc3RyaW5nIGxpa2UgXCJoaWdoXCIgb3IgXCJsb3dcIi4gVGhlIGRlZmF1bHQgaXMgdGhlIGVtcHR5IHN0cmluZy5cbiAgICpcbiAgICogVGhlIGZhaXJuZXNzIG1lY2hhbmlzbSBhdHRlbXB0cyB0byBkaXNwYXRjaCB0YXNrcyBmb3IgYSBnaXZlbiBrZXkgaW5cbiAgICogcHJvcG9ydGlvbiB0byBpdHMgd2VpZ2h0LiBGb3IgZXhhbXBsZSwgdXNpbmcgYSB0aG91c2FuZCBkaXN0aW5jdCB0ZW5hbnRcbiAgICogaWRzLCBlYWNoIHdpdGggYSB3ZWlnaHQgb2YgMS4wICh0aGUgZGVmYXVsdCkgd2lsbCByZXN1bHQgaW4gZWFjaCB0ZW5hbnRcbiAgICogZ2V0dGluZyBhIHJvdWdobHkgZXF1YWwgc2hhcmUgb2YgdGFzayBkaXNwYXRjaCB0aHJvdWdocHV0LlxuICAgKlxuICAgKiBGYWlybmVzcyBrZXlzIGFyZSBsaW1pdGVkIHRvIDY0IGJ5dGVzLlxuICAgKi9cbiAgZmFpcm5lc3NLZXk/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEZhaXJuZXNzV2VpZ2h0IGZvciBhIHRhc2sgY2FuIGNvbWUgZnJvbSBtdWx0aXBsZSBzb3VyY2VzIGZvclxuICAgKiBmbGV4aWJpbGl0eS4gRnJvbSBoaWdoZXN0IHRvIGxvd2VzdCBwcmVjZWRlbmNlOlxuICAgKiAxLiBXZWlnaHRzIGZvciBhIHNtYWxsIHNldCBvZiBrZXlzIGNhbiBiZSBvdmVycmlkZGVuIGluIHRhc2sgcXVldWVcbiAgICogICAgY29uZmlndXJhdGlvbiB3aXRoIGFuIEFQSS5cbiAgICogMi4gSXQgY2FuIGJlIGF0dGFjaGVkIHRvIHRoZSB3b3JrZmxvdy9hY3Rpdml0eSBpbiB0aGlzIGZpZWxkLlxuICAgKiAzLiBUaGUgZGVmYXVsdCB3ZWlnaHQgb2YgMS4wIHdpbGwgYmUgdXNlZC5cbiAgICpcbiAgICogV2VpZ2h0IHZhbHVlcyBhcmUgY2xhbXBlZCB0byB0aGUgcmFuZ2UgWzAuMDAxLCAxMDAwXS5cbiAgICovXG4gIGZhaXJuZXNzV2VpZ2h0PzogbnVtYmVyO1xufVxuXG4vKipcbiAqIFR1cm4gYSBwcm90byBjb21wYXRpYmxlIFByaW9yaXR5IGludG8gYSBUUyBQcmlvcml0eVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlUHJpb3JpdHkocHJpb3JpdHk/OiB0ZW1wb3JhbC5hcGkuY29tbW9uLnYxLklQcmlvcml0eSB8IG51bGwpOiBQcmlvcml0eSB7XG4gIHJldHVybiB7XG4gICAgcHJpb3JpdHlLZXk6IHByaW9yaXR5Py5wcmlvcml0eUtleSA/PyB1bmRlZmluZWQsXG4gICAgZmFpcm5lc3NLZXk6IHByaW9yaXR5Py5mYWlybmVzc0tleSA/PyB1bmRlZmluZWQsXG4gICAgZmFpcm5lc3NXZWlnaHQ6IHByaW9yaXR5Py5mYWlybmVzc1dlaWdodCA/PyB1bmRlZmluZWQsXG4gIH07XG59XG5cbi8qKlxuICogVHVybiBhIFRTIFByaW9yaXR5IGludG8gYSBwcm90byBjb21wYXRpYmxlIFByaW9yaXR5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21waWxlUHJpb3JpdHkocHJpb3JpdHk6IFByaW9yaXR5KTogdGVtcG9yYWwuYXBpLmNvbW1vbi52MS5JUHJpb3JpdHkge1xuICBpZiAocHJpb3JpdHkucHJpb3JpdHlLZXkgIT09IHVuZGVmaW5lZCAmJiBwcmlvcml0eS5wcmlvcml0eUtleSAhPT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihwcmlvcml0eS5wcmlvcml0eUtleSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ByaW9yaXR5S2V5IG11c3QgYmUgYW4gaW50ZWdlcicpO1xuICAgIH1cbiAgICBpZiAocHJpb3JpdHkucHJpb3JpdHlLZXkgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncHJpb3JpdHlLZXkgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHByaW9yaXR5S2V5OiBwcmlvcml0eS5wcmlvcml0eUtleSA/PyAwLFxuICAgIGZhaXJuZXNzS2V5OiBwcmlvcml0eS5mYWlybmVzc0tleSA/PyAnJyxcbiAgICBmYWlybmVzc1dlaWdodDogcHJpb3JpdHkuZmFpcm5lc3NXZWlnaHQgPz8gMCxcbiAgfTtcbn1cbiIsImV4cG9ydCBjb25zdCBURU1QT1JBTF9SRVNFUlZFRF9QUkVGSVggPSAnX190ZW1wb3JhbF8nO1xuZXhwb3J0IGNvbnN0IFNUQUNLX1RSQUNFX1FVRVJZX05BTUUgPSAnX19zdGFja190cmFjZSc7XG5leHBvcnQgY29uc3QgRU5IQU5DRURfU1RBQ0tfVFJBQ0VfUVVFUllfTkFNRSA9ICdfX2VuaGFuY2VkX3N0YWNrX3RyYWNlJztcblxuLyoqXG4gKiBWYWxpZCBlbnRpdHkgdHlwZXMgdGhhdCBjYW4gYmUgY2hlY2tlZCBmb3IgcmVzZXJ2ZWQgbmFtZSB2aW9sYXRpb25zXG4gKi9cbmV4cG9ydCB0eXBlIFJlc2VydmVkTmFtZUVudGl0eVR5cGUgPSAncXVlcnknIHwgJ3NpZ25hbCcgfCAndXBkYXRlJyB8ICdhY3Rpdml0eScgfCAndGFzayBxdWV1ZScgfCAnc2luaycgfCAnd29ya2Zsb3cnO1xuXG4vKipcbiAqIFZhbGlkYXRlcyBpZiB0aGUgcHJvdmlkZWQgbmFtZSBjb250YWlucyBhbnkgcmVzZXJ2ZWQgcHJlZml4ZXMgb3IgbWF0Y2hlcyBhbnkgcmVzZXJ2ZWQgbmFtZXMuXG4gKiBUaHJvd3MgYSBUeXBlRXJyb3IgaWYgdmFsaWRhdGlvbiBmYWlscywgd2l0aCBhIHNwZWNpZmljIG1lc3NhZ2UgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBpc3N1ZVxuICogaXMgd2l0aCBhIHJlc2VydmVkIHByZWZpeCBvciBhbiBleGFjdCBtYXRjaCB0byBhIHJlc2VydmVkIG5hbWUuXG4gKlxuICogQHBhcmFtIHR5cGUgVGhlIGVudGl0eSB0eXBlIGJlaW5nIGNoZWNrZWRcbiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIHRvIGNoZWNrIGFnYWluc3QgcmVzZXJ2ZWQgcHJlZml4ZXMvbmFtZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRocm93SWZSZXNlcnZlZE5hbWUodHlwZTogUmVzZXJ2ZWROYW1lRW50aXR5VHlwZSwgbmFtZTogc3RyaW5nKTogdm9pZCB7XG4gIGlmIChuYW1lLnN0YXJ0c1dpdGgoVEVNUE9SQUxfUkVTRVJWRURfUFJFRklYKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbm5vdCB1c2UgJHt0eXBlfSBuYW1lOiAnJHtuYW1lfScsIHdpdGggcmVzZXJ2ZWQgcHJlZml4OiAnJHtURU1QT1JBTF9SRVNFUlZFRF9QUkVGSVh9J2ApO1xuICB9XG5cbiAgaWYgKG5hbWUgPT09IFNUQUNLX1RSQUNFX1FVRVJZX05BTUUgfHwgbmFtZSA9PT0gRU5IQU5DRURfU1RBQ0tfVFJBQ0VfUVVFUllfTkFNRSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbm5vdCB1c2UgJHt0eXBlfSBuYW1lOiAnJHtuYW1lfScsIHdoaWNoIGlzIGEgcmVzZXJ2ZWQgbmFtZWApO1xuICB9XG59XG4iLCJpbXBvcnQgdHlwZSB7IHRlbXBvcmFsIH0gZnJvbSAnQHRlbXBvcmFsaW8vcHJvdG8nO1xuaW1wb3J0IHsgVmFsdWVFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IER1cmF0aW9uLCBtc09wdGlvbmFsVG9OdW1iZXIsIG1zT3B0aW9uYWxUb1RzLCBtc1RvTnVtYmVyLCBtc1RvVHMsIG9wdGlvbmFsVHNUb01zIH0gZnJvbSAnLi90aW1lJztcblxuLyoqXG4gKiBPcHRpb25zIGZvciByZXRyeWluZyBXb3JrZmxvd3MgYW5kIEFjdGl2aXRpZXNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXRyeVBvbGljeSB7XG4gIC8qKlxuICAgKiBDb2VmZmljaWVudCB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgbmV4dCByZXRyeSBpbnRlcnZhbC5cbiAgICogVGhlIG5leHQgcmV0cnkgaW50ZXJ2YWwgaXMgcHJldmlvdXMgaW50ZXJ2YWwgbXVsdGlwbGllZCBieSB0aGlzIGNvZWZmaWNpZW50LlxuICAgKiBAbWluaW11bSAxXG4gICAqIEBkZWZhdWx0IDJcbiAgICovXG4gIGJhY2tvZmZDb2VmZmljaWVudD86IG51bWJlcjtcbiAgLyoqXG4gICAqIEludGVydmFsIG9mIHRoZSBmaXJzdCByZXRyeS5cbiAgICogSWYgY29lZmZpY2llbnQgaXMgMSB0aGVuIGl0IGlzIHVzZWQgZm9yIGFsbCByZXRyaWVzXG4gICAqIEBmb3JtYXQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvciB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXMgfCBtcy1mb3JtYXR0ZWQgc3RyaW5nfVxuICAgKiBAZGVmYXVsdCAxIHNlY29uZFxuICAgKi9cbiAgaW5pdGlhbEludGVydmFsPzogRHVyYXRpb247XG4gIC8qKlxuICAgKiBNYXhpbXVtIG51bWJlciBvZiBhdHRlbXB0cy4gV2hlbiBleGNlZWRlZCwgcmV0cmllcyBzdG9wIChldmVuIGlmIHtAbGluayBBY3Rpdml0eU9wdGlvbnMuc2NoZWR1bGVUb0Nsb3NlVGltZW91dH1cbiAgICogaGFzbid0IGJlZW4gcmVhY2hlZCkuXG4gICAqXG4gICAqIEBkZWZhdWx0IEluZmluaXR5XG4gICAqL1xuICBtYXhpbXVtQXR0ZW1wdHM/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBNYXhpbXVtIGludGVydmFsIGJldHdlZW4gcmV0cmllcy5cbiAgICogRXhwb25lbnRpYWwgYmFja29mZiBsZWFkcyB0byBpbnRlcnZhbCBpbmNyZWFzZS5cbiAgICogVGhpcyB2YWx1ZSBpcyB0aGUgY2FwIG9mIHRoZSBpbmNyZWFzZS5cbiAgICpcbiAgICogQGRlZmF1bHQgMTAweCBvZiB7QGxpbmsgaW5pdGlhbEludGVydmFsfVxuICAgKiBAZm9ybWF0IG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3Ige0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ31cbiAgICovXG4gIG1heGltdW1JbnRlcnZhbD86IER1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGFwcGxpY2F0aW9uIGZhaWx1cmVzIHR5cGVzIHRvIG5vdCByZXRyeS5cbiAgICovXG4gIG5vblJldHJ5YWJsZUVycm9yVHlwZXM/OiBzdHJpbmdbXTtcbn1cblxuLyoqXG4gKiBUdXJuIGEgVFMgUmV0cnlQb2xpY3kgaW50byBhIHByb3RvIGNvbXBhdGlibGUgUmV0cnlQb2xpY3lcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGVSZXRyeVBvbGljeShyZXRyeVBvbGljeTogUmV0cnlQb2xpY3kpOiB0ZW1wb3JhbC5hcGkuY29tbW9uLnYxLklSZXRyeVBvbGljeSB7XG4gIGlmIChyZXRyeVBvbGljeS5iYWNrb2ZmQ29lZmZpY2llbnQgIT0gbnVsbCAmJiByZXRyeVBvbGljeS5iYWNrb2ZmQ29lZmZpY2llbnQgPD0gMCkge1xuICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKCdSZXRyeVBvbGljeS5iYWNrb2ZmQ29lZmZpY2llbnQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCcpO1xuICB9XG4gIGlmIChyZXRyeVBvbGljeS5tYXhpbXVtQXR0ZW1wdHMgIT0gbnVsbCkge1xuICAgIGlmIChyZXRyeVBvbGljeS5tYXhpbXVtQXR0ZW1wdHMgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgLy8gZHJvcCBmaWVsZCAoSW5maW5pdHkgaXMgdGhlIGRlZmF1bHQpXG4gICAgICBjb25zdCB7IG1heGltdW1BdHRlbXB0czogXywgLi4ud2l0aG91dCB9ID0gcmV0cnlQb2xpY3k7XG4gICAgICByZXRyeVBvbGljeSA9IHdpdGhvdXQ7XG4gICAgfSBlbHNlIGlmIChyZXRyeVBvbGljeS5tYXhpbXVtQXR0ZW1wdHMgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoJ1JldHJ5UG9saWN5Lm1heGltdW1BdHRlbXB0cyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuICAgIH0gZWxzZSBpZiAoIU51bWJlci5pc0ludGVnZXIocmV0cnlQb2xpY3kubWF4aW11bUF0dGVtcHRzKSkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoJ1JldHJ5UG9saWN5Lm1heGltdW1BdHRlbXB0cyBtdXN0IGJlIGFuIGludGVnZXInKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgbWF4aW11bUludGVydmFsID0gbXNPcHRpb25hbFRvTnVtYmVyKHJldHJ5UG9saWN5Lm1heGltdW1JbnRlcnZhbCk7XG4gIGNvbnN0IGluaXRpYWxJbnRlcnZhbCA9IG1zVG9OdW1iZXIocmV0cnlQb2xpY3kuaW5pdGlhbEludGVydmFsID8/IDEwMDApO1xuICBpZiAobWF4aW11bUludGVydmFsID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoJ1JldHJ5UG9saWN5Lm1heGltdW1JbnRlcnZhbCBjYW5ub3QgYmUgMCcpO1xuICB9XG4gIGlmIChpbml0aWFsSW50ZXJ2YWwgPT09IDApIHtcbiAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcignUmV0cnlQb2xpY3kuaW5pdGlhbEludGVydmFsIGNhbm5vdCBiZSAwJyk7XG4gIH1cbiAgaWYgKG1heGltdW1JbnRlcnZhbCAhPSBudWxsICYmIG1heGltdW1JbnRlcnZhbCA8IGluaXRpYWxJbnRlcnZhbCkge1xuICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKCdSZXRyeVBvbGljeS5tYXhpbXVtSW50ZXJ2YWwgY2Fubm90IGJlIGxlc3MgdGhhbiBpdHMgaW5pdGlhbEludGVydmFsJyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtYXhpbXVtQXR0ZW1wdHM6IHJldHJ5UG9saWN5Lm1heGltdW1BdHRlbXB0cyxcbiAgICBpbml0aWFsSW50ZXJ2YWw6IG1zVG9Ucyhpbml0aWFsSW50ZXJ2YWwpLFxuICAgIG1heGltdW1JbnRlcnZhbDogbXNPcHRpb25hbFRvVHMobWF4aW11bUludGVydmFsKSxcbiAgICBiYWNrb2ZmQ29lZmZpY2llbnQ6IHJldHJ5UG9saWN5LmJhY2tvZmZDb2VmZmljaWVudCxcbiAgICBub25SZXRyeWFibGVFcnJvclR5cGVzOiByZXRyeVBvbGljeS5ub25SZXRyeWFibGVFcnJvclR5cGVzLFxuICB9O1xufVxuXG4vKipcbiAqIFR1cm4gYSBwcm90byBjb21wYXRpYmxlIFJldHJ5UG9saWN5IGludG8gYSBUUyBSZXRyeVBvbGljeVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb21waWxlUmV0cnlQb2xpY3koXG4gIHJldHJ5UG9saWN5PzogdGVtcG9yYWwuYXBpLmNvbW1vbi52MS5JUmV0cnlQb2xpY3kgfCBudWxsXG4pOiBSZXRyeVBvbGljeSB8IHVuZGVmaW5lZCB7XG4gIGlmICghcmV0cnlQb2xpY3kpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiYWNrb2ZmQ29lZmZpY2llbnQ6IHJldHJ5UG9saWN5LmJhY2tvZmZDb2VmZmljaWVudCA/PyB1bmRlZmluZWQsXG4gICAgbWF4aW11bUF0dGVtcHRzOiByZXRyeVBvbGljeS5tYXhpbXVtQXR0ZW1wdHMgPz8gdW5kZWZpbmVkLFxuICAgIG1heGltdW1JbnRlcnZhbDogb3B0aW9uYWxUc1RvTXMocmV0cnlQb2xpY3kubWF4aW11bUludGVydmFsKSxcbiAgICBpbml0aWFsSW50ZXJ2YWw6IG9wdGlvbmFsVHNUb01zKHJldHJ5UG9saWN5LmluaXRpYWxJbnRlcnZhbCksXG4gICAgbm9uUmV0cnlhYmxlRXJyb3JUeXBlczogcmV0cnlQb2xpY3kubm9uUmV0cnlhYmxlRXJyb3JUeXBlcyA/PyB1bmRlZmluZWQsXG4gIH07XG59XG4iLCJpbXBvcnQgdHlwZSB7IHRlbXBvcmFsIH0gZnJvbSAnQHRlbXBvcmFsaW8vcHJvdG8nO1xuaW1wb3J0IHsgbWFrZVByb3RvRW51bUNvbnZlcnRlcnMgfSBmcm9tICcuL2ludGVybmFsLXdvcmtmbG93JztcblxuLyoqIEBkZXByZWNhdGVkOiBVc2Uge0BsaW5rIFR5cGVkU2VhcmNoQXR0cmlidXRlc30gaW5zdGVhZCAqL1xuZXhwb3J0IHR5cGUgU2VhcmNoQXR0cmlidXRlVmFsdWVPclJlYWRvbmx5ID0gU2VhcmNoQXR0cmlidXRlVmFsdWUgfCBSZWFkb25seTxTZWFyY2hBdHRyaWJ1dGVWYWx1ZT4gfCB1bmRlZmluZWQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbi8qKiBAZGVwcmVjYXRlZDogVXNlIHtAbGluayBUeXBlZFNlYXJjaEF0dHJpYnV0ZXN9IGluc3RlYWQgKi9cbmV4cG9ydCB0eXBlIFNlYXJjaEF0dHJpYnV0ZXMgPSBSZWNvcmQ8c3RyaW5nLCBTZWFyY2hBdHRyaWJ1dGVWYWx1ZU9yUmVhZG9ubHk+OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4vKiogQGRlcHJlY2F0ZWQ6IFVzZSB7QGxpbmsgVHlwZWRTZWFyY2hBdHRyaWJ1dGVzfSBpbnN0ZWFkICovXG5leHBvcnQgdHlwZSBTZWFyY2hBdHRyaWJ1dGVWYWx1ZSA9IHN0cmluZ1tdIHwgbnVtYmVyW10gfCBib29sZWFuW10gfCBEYXRlW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cblxuZXhwb3J0IGNvbnN0IFNlYXJjaEF0dHJpYnV0ZVR5cGUgPSB7XG4gIFRFWFQ6ICdURVhUJyxcbiAgS0VZV09SRDogJ0tFWVdPUkQnLFxuICBJTlQ6ICdJTlQnLFxuICBET1VCTEU6ICdET1VCTEUnLFxuICBCT09MOiAnQk9PTCcsXG4gIERBVEVUSU1FOiAnREFURVRJTUUnLFxuICBLRVlXT1JEX0xJU1Q6ICdLRVlXT1JEX0xJU1QnLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IHR5cGUgU2VhcmNoQXR0cmlidXRlVHlwZSA9ICh0eXBlb2YgU2VhcmNoQXR0cmlidXRlVHlwZSlba2V5b2YgdHlwZW9mIFNlYXJjaEF0dHJpYnV0ZVR5cGVdO1xuXG4vLyBOb3RlOiBlbmNvZGVTZWFyY2hBdHRyaWJ1dGVJbmRleGVkVmFsdWVUeXBlIGV4cG9ydGVkIGZvciB1c2UgaW4gdGVzdHMgdG8gcmVnaXN0ZXIgc2VhcmNoIGF0dHJpYnV0ZXNcbi8vIHRzLXBydW5lLWlnbm9yZS1uZXh0XG5leHBvcnQgY29uc3QgW2VuY29kZVNlYXJjaEF0dHJpYnV0ZUluZGV4ZWRWYWx1ZVR5cGUsIF9dID0gbWFrZVByb3RvRW51bUNvbnZlcnRlcnM8XG4gIHRlbXBvcmFsLmFwaS5lbnVtcy52MS5JbmRleGVkVmFsdWVUeXBlLFxuICB0eXBlb2YgdGVtcG9yYWwuYXBpLmVudW1zLnYxLkluZGV4ZWRWYWx1ZVR5cGUsXG4gIGtleW9mIHR5cGVvZiB0ZW1wb3JhbC5hcGkuZW51bXMudjEuSW5kZXhlZFZhbHVlVHlwZSxcbiAgdHlwZW9mIFNlYXJjaEF0dHJpYnV0ZVR5cGUsXG4gICdJTkRFWEVEX1ZBTFVFX1RZUEVfJ1xuPihcbiAge1xuICAgIFtTZWFyY2hBdHRyaWJ1dGVUeXBlLlRFWFRdOiAxLFxuICAgIFtTZWFyY2hBdHRyaWJ1dGVUeXBlLktFWVdPUkRdOiAyLFxuICAgIFtTZWFyY2hBdHRyaWJ1dGVUeXBlLklOVF06IDMsXG4gICAgW1NlYXJjaEF0dHJpYnV0ZVR5cGUuRE9VQkxFXTogNCxcbiAgICBbU2VhcmNoQXR0cmlidXRlVHlwZS5CT09MXTogNSxcbiAgICBbU2VhcmNoQXR0cmlidXRlVHlwZS5EQVRFVElNRV06IDYsXG4gICAgW1NlYXJjaEF0dHJpYnV0ZVR5cGUuS0VZV09SRF9MSVNUXTogNyxcbiAgICBVTlNQRUNJRklFRDogMCxcbiAgfSBhcyBjb25zdCxcbiAgJ0lOREVYRURfVkFMVUVfVFlQRV8nXG4pO1xuXG5pbnRlcmZhY2UgSW5kZXhlZFZhbHVlVHlwZU1hcHBpbmcge1xuICBURVhUOiBzdHJpbmc7XG4gIEtFWVdPUkQ6IHN0cmluZztcbiAgSU5UOiBudW1iZXI7XG4gIERPVUJMRTogbnVtYmVyO1xuICBCT09MOiBib29sZWFuO1xuICBEQVRFVElNRTogRGF0ZTtcbiAgS0VZV09SRF9MSVNUOiBzdHJpbmdbXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRWYWx1ZUZvclR5cGU8VCBleHRlbmRzIFNlYXJjaEF0dHJpYnV0ZVR5cGU+KFxuICB0eXBlOiBULFxuICB2YWx1ZTogdW5rbm93blxuKTogdmFsdWUgaXMgSW5kZXhlZFZhbHVlVHlwZU1hcHBpbmdbVF0ge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFNlYXJjaEF0dHJpYnV0ZVR5cGUuVEVYVDpcbiAgICBjYXNlIFNlYXJjaEF0dHJpYnV0ZVR5cGUuS0VZV09SRDpcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICAgIGNhc2UgU2VhcmNoQXR0cmlidXRlVHlwZS5JTlQ6XG4gICAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG4gICAgY2FzZSBTZWFyY2hBdHRyaWJ1dGVUeXBlLkRPVUJMRTpcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICAgIGNhc2UgU2VhcmNoQXR0cmlidXRlVHlwZS5CT09MOlxuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuICAgIGNhc2UgU2VhcmNoQXR0cmlidXRlVHlwZS5EQVRFVElNRTpcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIERhdGU7XG4gICAgY2FzZSBTZWFyY2hBdHRyaWJ1dGVUeXBlLktFWVdPUkRfTElTVDpcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoQXR0cmlidXRlS2V5PFQgZXh0ZW5kcyBTZWFyY2hBdHRyaWJ1dGVUeXBlPiB7XG4gIG5hbWU6IHN0cmluZztcbiAgdHlwZTogVDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZVNlYXJjaEF0dHJpYnV0ZUtleTxUIGV4dGVuZHMgU2VhcmNoQXR0cmlidXRlVHlwZT4obmFtZTogc3RyaW5nLCB0eXBlOiBUKTogU2VhcmNoQXR0cmlidXRlS2V5PFQ+IHtcbiAgcmV0dXJuIHsgbmFtZSwgdHlwZSB9O1xufVxuXG5jbGFzcyBCYXNlU2VhcmNoQXR0cmlidXRlVmFsdWU8VCBleHRlbmRzIFNlYXJjaEF0dHJpYnV0ZVR5cGUsIFYgPSBJbmRleGVkVmFsdWVUeXBlTWFwcGluZ1tUXT4ge1xuICBwcml2YXRlIHJlYWRvbmx5IF90eXBlOiBUO1xuICBwcml2YXRlIHJlYWRvbmx5IF92YWx1ZTogVjtcblxuICBjb25zdHJ1Y3Rvcih0eXBlOiBULCB2YWx1ZTogVikge1xuICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBnZXQgdHlwZSgpOiBUIHtcbiAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgfVxuXG4gIGdldCB2YWx1ZSgpOiBWIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cbn1cblxuLy8gSW50ZXJuYWwgdHlwZSBmb3IgY2xhc3MgcHJpdmF0ZSBkYXRhLlxuLy8gRXhwb3J0ZWQgZm9yIHVzZSBpbiBwYXlsb2FkIGNvbnZlcnNpb24uXG5leHBvcnQgY2xhc3MgVHlwZWRTZWFyY2hBdHRyaWJ1dGVWYWx1ZTxUIGV4dGVuZHMgU2VhcmNoQXR0cmlidXRlVHlwZT4gZXh0ZW5kcyBCYXNlU2VhcmNoQXR0cmlidXRlVmFsdWU8VD4ge31cbi8vIHRzLXBydW5lLWlnbm9yZS1uZXh0XG5leHBvcnQgY2xhc3MgVHlwZWRTZWFyY2hBdHRyaWJ1dGVVcGRhdGVWYWx1ZTxUIGV4dGVuZHMgU2VhcmNoQXR0cmlidXRlVHlwZT4gZXh0ZW5kcyBCYXNlU2VhcmNoQXR0cmlidXRlVmFsdWU8XG4gIFQsXG4gIEluZGV4ZWRWYWx1ZVR5cGVNYXBwaW5nW1RdIHwgbnVsbFxuPiB7fVxuXG5leHBvcnQgdHlwZSBTZWFyY2hBdHRyaWJ1dGVQYWlyID0ge1xuICBbVCBpbiBTZWFyY2hBdHRyaWJ1dGVUeXBlXTogeyBrZXk6IFNlYXJjaEF0dHJpYnV0ZUtleTxUPjsgdmFsdWU6IEluZGV4ZWRWYWx1ZVR5cGVNYXBwaW5nW1RdIH07XG59W1NlYXJjaEF0dHJpYnV0ZVR5cGVdO1xuXG5leHBvcnQgdHlwZSBTZWFyY2hBdHRyaWJ1dGVVcGRhdGVQYWlyID0ge1xuICBbVCBpbiBTZWFyY2hBdHRyaWJ1dGVUeXBlXTogeyBrZXk6IFNlYXJjaEF0dHJpYnV0ZUtleTxUPjsgdmFsdWU6IEluZGV4ZWRWYWx1ZVR5cGVNYXBwaW5nW1RdIHwgbnVsbCB9O1xufVtTZWFyY2hBdHRyaWJ1dGVUeXBlXTtcblxuZXhwb3J0IGNsYXNzIFR5cGVkU2VhcmNoQXR0cmlidXRlcyB7XG4gIHByaXZhdGUgc2VhcmNoQXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgVHlwZWRTZWFyY2hBdHRyaWJ1dGVWYWx1ZTxTZWFyY2hBdHRyaWJ1dGVUeXBlPj4gPSB7fTtcblxuICBjb25zdHJ1Y3Rvcihpbml0aWFsQXR0cmlidXRlcz86IFNlYXJjaEF0dHJpYnV0ZVBhaXJbXSkge1xuICAgIGlmIChpbml0aWFsQXR0cmlidXRlcyA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgZm9yIChjb25zdCBwYWlyIG9mIGluaXRpYWxBdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAocGFpci5rZXkubmFtZSBpbiB0aGlzLnNlYXJjaEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgc2VhcmNoIGF0dHJpYnV0ZSBrZXk6ICR7cGFpci5rZXkubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2VhcmNoQXR0cmlidXRlc1twYWlyLmtleS5uYW1lXSA9IG5ldyBUeXBlZFNlYXJjaEF0dHJpYnV0ZVZhbHVlKHBhaXIua2V5LnR5cGUsIHBhaXIudmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGdldDxUIGV4dGVuZHMgU2VhcmNoQXR0cmlidXRlVHlwZT4oa2V5OiBTZWFyY2hBdHRyaWJ1dGVLZXk8VD4pOiBJbmRleGVkVmFsdWVUeXBlTWFwcGluZ1tUXSB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgYXR0ciA9IHRoaXMuc2VhcmNoQXR0cmlidXRlc1trZXkubmFtZV07XG4gICAgLy8gS2V5IG5vdCBmb3VuZCBvciB0eXBlIG1pc21hdGNoLlxuICAgIGlmIChhdHRyID09PSB1bmRlZmluZWQgfHwgIWlzVmFsaWRWYWx1ZUZvclR5cGUoa2V5LnR5cGUsIGF0dHIudmFsdWUpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gYXR0ci52YWx1ZTtcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIGEgZGVlcCBjb3B5IG9mIHRoZSBnaXZlbiBUeXBlZFNlYXJjaEF0dHJpYnV0ZXMgaW5zdGFuY2UgKi9cbiAgY29weSgpOiBUeXBlZFNlYXJjaEF0dHJpYnV0ZXMge1xuICAgIGNvbnN0IHN0YXRlOiBSZWNvcmQ8c3RyaW5nLCBUeXBlZFNlYXJjaEF0dHJpYnV0ZVZhbHVlPFNlYXJjaEF0dHJpYnV0ZVR5cGU+PiA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBba2V5LCBhdHRyXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnNlYXJjaEF0dHJpYnV0ZXMpKSB7XG4gICAgICAvLyBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzXG4gICAgICBsZXQgdmFsdWUgPSBhdHRyLnZhbHVlO1xuICAgICAgLy8gRm9yIG5vbi1wcmltaXRpdmUgdHlwZXMsIGNyZWF0ZSBhIGRlZXAgY29weVxuICAgICAgaWYgKGF0dHIudmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHZhbHVlID0gbmV3IERhdGUoYXR0ci52YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXR0ci52YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSBbLi4uYXR0ci52YWx1ZV07XG4gICAgICB9XG4gICAgICBzdGF0ZVtrZXldID0gbmV3IFR5cGVkU2VhcmNoQXR0cmlidXRlVmFsdWUoYXR0ci50eXBlLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIHJldHVybiB2YWx1ZSB3aXRoIG1hbnVhbGx5IGFzc2lnbmVkIHN0YXRlLlxuICAgIGNvbnN0IHJlcyA9IG5ldyBUeXBlZFNlYXJjaEF0dHJpYnV0ZXMoKTtcbiAgICByZXMuc2VhcmNoQXR0cmlidXRlcyA9IHN0YXRlO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogQGhpZGRlblxuICAgKiBSZXR1cm4gSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNsYXNzIGFzIFNlYXJjaEF0dHJpYnV0ZVBhaXJbXVxuICAgKiBEZWZhdWx0IHRvSlNPTiBtZXRob2QgaXMgbm90IHVzZWQgYmVjYXVzZSBpdCdzIEpTT04gcmVwcmVzZW50YXRpb24gaW5jbHVkZXMgcHJpdmF0ZSBzdGF0ZS5cbiAgICovXG4gIHRvSlNPTigpOiBTZWFyY2hBdHRyaWJ1dGVQYWlyW10ge1xuICAgIHJldHVybiB0aGlzLmdldEFsbCgpO1xuICB9XG5cbiAgLyoqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IFR5cGVkU2VhcmNoQXR0cmlidXRlcyBpbnN0YW5jZSB3aXRoIHRoZSB1cGRhdGVkIGF0dHJpYnV0ZXMuICovXG4gIHVwZGF0ZUNvcHkodXBkYXRlczogU2VhcmNoQXR0cmlidXRlVXBkYXRlUGFpcltdKTogVHlwZWRTZWFyY2hBdHRyaWJ1dGVzIHtcbiAgICAvLyBDcmVhdGUgYSBkZWVwIGNvcHkgb2YgdGhlIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAgY29uc3QgcmVzID0gdGhpcy5jb3B5KCk7XG4gICAgLy8gQXBwbHkgdXBkYXRlcy5cbiAgICByZXMudXBkYXRlKHVwZGF0ZXMpO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvLyBQZXJmb3JtcyBkaXJlY3QgbXV0YXRpb24gb24gdGhlIGN1cnJlbnQgaW5zdGFuY2UuXG4gIHByaXZhdGUgdXBkYXRlKHVwZGF0ZXM6IFNlYXJjaEF0dHJpYnV0ZVVwZGF0ZVBhaXJbXSkge1xuICAgIC8vIEFwcGx5IHVwZGF0ZXMuXG4gICAgZm9yIChjb25zdCBwYWlyIG9mIHVwZGF0ZXMpIHtcbiAgICAgIC8vIERlbGV0ZSBhdHRyaWJ1dGUuXG4gICAgICBpZiAocGFpci52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBEZWxldGUgb25seSBpZiB0aGUgdXBkYXRlIG1hdGNoZXMgYSBrZXkgYW5kIHR5cGUuXG4gICAgICAgIGNvbnN0IGF0dHJWYWwgPSB0aGlzLnNlYXJjaEF0dHJpYnV0ZXNbcGFpci5rZXkubmFtZV07XG4gICAgICAgIGlmIChhdHRyVmFsICYmIGF0dHJWYWwudHlwZSA9PT0gcGFpci5rZXkudHlwZSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnNlYXJjaEF0dHJpYnV0ZXNbcGFpci5rZXkubmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBBZGQgb3IgdXBkYXRlIGF0dHJpYnV0ZS5cbiAgICAgIHRoaXMuc2VhcmNoQXR0cmlidXRlc1twYWlyLmtleS5uYW1lXSA9IG5ldyBUeXBlZFNlYXJjaEF0dHJpYnV0ZVZhbHVlKHBhaXIua2V5LnR5cGUsIHBhaXIudmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGdldEFsbCgpOiBTZWFyY2hBdHRyaWJ1dGVQYWlyW10ge1xuICAgIGNvbnN0IHJlczogU2VhcmNoQXR0cmlidXRlUGFpcltdID0gW107XG4gICAgZm9yIChjb25zdCBba2V5LCBhdHRyXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnNlYXJjaEF0dHJpYnV0ZXMpKSB7XG4gICAgICBjb25zdCBhdHRyS2V5ID0geyBuYW1lOiBrZXksIHR5cGU6IGF0dHIudHlwZSB9O1xuICAgICAgLy8gU2FuaXR5IGNoZWNrLCBzaG91bGQgYWx3YXlzIGJlIGxlZ2FsLlxuICAgICAgaWYgKGlzVmFsaWRWYWx1ZUZvclR5cGUoYXR0cktleS50eXBlLCBhdHRyLnZhbHVlKSkge1xuICAgICAgICByZXMucHVzaCh7IGtleTogYXR0cktleSwgdmFsdWU6IGF0dHIudmFsdWUgfSBhcyBTZWFyY2hBdHRyaWJ1dGVQYWlyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXRLZXlGcm9tVW50eXBlZChcbiAgICBrZXk6IHN0cmluZyxcbiAgICB2YWx1ZTogU2VhcmNoQXR0cmlidXRlVmFsdWVPclJlYWRvbmx5IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgKTogU2VhcmNoQXR0cmlidXRlS2V5PFNlYXJjaEF0dHJpYnV0ZVR5cGU+IHwgdW5kZWZpbmVkIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFVucGFjayBzaW5nbGUtZWxlbWVudCBhcnJheXMuXG4gICAgY29uc3QgdmFsID0gdmFsdWUubGVuZ3RoID09PSAxID8gdmFsdWVbMF0gOiB2YWx1ZTtcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWwpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIC8vIENoZWNrIGlmIHZhbCBpcyBhbiBJU08gc3RyaW5nLCBpZiBzbywgcmV0dXJuIGEgREFURVRJTUUga2V5LlxuICAgICAgICBpZiAoIWlzTmFOKERhdGUucGFyc2UodmFsKSkgJiYgRGF0ZS5wYXJzZSh2YWwpID09PSBuZXcgRGF0ZSh2YWwpLmdldFRpbWUoKSkge1xuICAgICAgICAgIHJldHVybiB7IG5hbWU6IGtleSwgdHlwZTogU2VhcmNoQXR0cmlidXRlVHlwZS5EQVRFVElNRSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG5hbWU6IGtleSwgdHlwZTogU2VhcmNoQXR0cmlidXRlVHlwZS5URVhUIH07XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICB0eXBlOiBOdW1iZXIuaXNJbnRlZ2VyKHZhbCkgPyBTZWFyY2hBdHRyaWJ1dGVUeXBlLklOVCA6IFNlYXJjaEF0dHJpYnV0ZVR5cGUuRE9VQkxFLFxuICAgICAgICB9O1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiB7IG5hbWU6IGtleSwgdHlwZTogU2VhcmNoQXR0cmlidXRlVHlwZS5CT09MIH07XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgIHJldHVybiB7IG5hbWU6IGtleSwgdHlwZTogU2VhcmNoQXR0cmlidXRlVHlwZS5EQVRFVElNRSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkgJiYgdmFsLmV2ZXJ5KChpdGVtKSA9PiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbmFtZToga2V5LCB0eXBlOiBTZWFyY2hBdHRyaWJ1dGVUeXBlLktFWVdPUkRfTElTVCB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgdG9NZXRhZGF0YVR5cGUodHlwZTogU2VhcmNoQXR0cmlidXRlVHlwZSk6IHN0cmluZyB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFNlYXJjaEF0dHJpYnV0ZVR5cGUuVEVYVDpcbiAgICAgICAgcmV0dXJuICdUZXh0JztcbiAgICAgIGNhc2UgU2VhcmNoQXR0cmlidXRlVHlwZS5LRVlXT1JEOlxuICAgICAgICByZXR1cm4gJ0tleXdvcmQnO1xuICAgICAgY2FzZSBTZWFyY2hBdHRyaWJ1dGVUeXBlLklOVDpcbiAgICAgICAgcmV0dXJuICdJbnQnO1xuICAgICAgY2FzZSBTZWFyY2hBdHRyaWJ1dGVUeXBlLkRPVUJMRTpcbiAgICAgICAgcmV0dXJuICdEb3VibGUnO1xuICAgICAgY2FzZSBTZWFyY2hBdHRyaWJ1dGVUeXBlLkJPT0w6XG4gICAgICAgIHJldHVybiAnQm9vbCc7XG4gICAgICBjYXNlIFNlYXJjaEF0dHJpYnV0ZVR5cGUuREFURVRJTUU6XG4gICAgICAgIHJldHVybiAnRGF0ZXRpbWUnO1xuICAgICAgY2FzZSBTZWFyY2hBdHRyaWJ1dGVUeXBlLktFWVdPUkRfTElTVDpcbiAgICAgICAgcmV0dXJuICdLZXl3b3JkTGlzdCc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc2VhcmNoIGF0dHJpYnV0ZSB0eXBlOiAke3R5cGV9YCk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHRvU2VhcmNoQXR0cmlidXRlVHlwZSh0eXBlOiBzdHJpbmcpOiBTZWFyY2hBdHRyaWJ1dGVUeXBlIHwgdW5kZWZpbmVkIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ1RleHQnOlxuICAgICAgICByZXR1cm4gU2VhcmNoQXR0cmlidXRlVHlwZS5URVhUO1xuICAgICAgY2FzZSAnS2V5d29yZCc6XG4gICAgICAgIHJldHVybiBTZWFyY2hBdHRyaWJ1dGVUeXBlLktFWVdPUkQ7XG4gICAgICBjYXNlICdJbnQnOlxuICAgICAgICByZXR1cm4gU2VhcmNoQXR0cmlidXRlVHlwZS5JTlQ7XG4gICAgICBjYXNlICdEb3VibGUnOlxuICAgICAgICByZXR1cm4gU2VhcmNoQXR0cmlidXRlVHlwZS5ET1VCTEU7XG4gICAgICBjYXNlICdCb29sJzpcbiAgICAgICAgcmV0dXJuIFNlYXJjaEF0dHJpYnV0ZVR5cGUuQk9PTDtcbiAgICAgIGNhc2UgJ0RhdGV0aW1lJzpcbiAgICAgICAgcmV0dXJuIFNlYXJjaEF0dHJpYnV0ZVR5cGUuREFURVRJTUU7XG4gICAgICBjYXNlICdLZXl3b3JkTGlzdCc6XG4gICAgICAgIHJldHVybiBTZWFyY2hBdHRyaWJ1dGVUeXBlLktFWVdPUkRfTElTVDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBMb25nIGZyb20gJ2xvbmcnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGltcG9ydC9uby1uYW1lZC1hcy1kZWZhdWx0XG5pbXBvcnQgbXMsIHsgU3RyaW5nVmFsdWUgfSBmcm9tICdtcyc7XG5pbXBvcnQgdHlwZSB7IGdvb2dsZSB9IGZyb20gJ0B0ZW1wb3JhbGlvL3Byb3RvJztcbmltcG9ydCB7IFZhbHVlRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5cbi8vIE5PVEU6IHRoZXNlIGFyZSB0aGUgc2FtZSBpbnRlcmZhY2UgaW4gSlNcbi8vIGdvb2dsZS5wcm90b2J1Zi5JRHVyYXRpb247XG4vLyBnb29nbGUucHJvdG9idWYuSVRpbWVzdGFtcDtcbi8vIFRoZSBjb252ZXJzaW9uIGZ1bmN0aW9ucyBiZWxvdyBzaG91bGQgd29yayBmb3IgYm90aFxuXG5leHBvcnQgdHlwZSBUaW1lc3RhbXAgPSBnb29nbGUucHJvdG9idWYuSVRpbWVzdGFtcDtcblxuLyoqXG4gKiBBIGR1cmF0aW9uLCBleHByZXNzZWQgZWl0aGVyIGFzIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgb3IgYXMgYSB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXMgfCBtcy1mb3JtYXR0ZWQgc3RyaW5nfS5cbiAqL1xuZXhwb3J0IHR5cGUgRHVyYXRpb24gPSBTdHJpbmdWYWx1ZSB8IG51bWJlcjtcblxuZXhwb3J0IHR5cGUgeyBTdHJpbmdWYWx1ZSB9IGZyb20gJ21zJztcblxuLyoqXG4gKiBMb3NzeSBjb252ZXJzaW9uIGZ1bmN0aW9uIGZyb20gVGltZXN0YW1wIHRvIG51bWJlciBkdWUgdG8gcG9zc2libGUgb3ZlcmZsb3cuXG4gKiBJZiB0cyBpcyBudWxsIG9yIHVuZGVmaW5lZCByZXR1cm5zIHVuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9wdGlvbmFsVHNUb01zKHRzOiBUaW1lc3RhbXAgfCBudWxsIHwgdW5kZWZpbmVkKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHRzID09PSB1bmRlZmluZWQgfHwgdHMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB0c1RvTXModHMpO1xufVxuXG4vKipcbiAqIExvc3N5IGNvbnZlcnNpb24gZnVuY3Rpb24gZnJvbSBUaW1lc3RhbXAgdG8gbnVtYmVyIGR1ZSB0byBwb3NzaWJsZSBvdmVyZmxvdy5cbiAqIElmIHRzIGlzIG51bGwgb3IgdW5kZWZpbmVkLCB0aHJvd3MgYSBUeXBlRXJyb3IsIHdpdGggZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIG5hbWUgb2YgdGhlIGZpZWxkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVxdWlyZWRUc1RvTXModHM6IFRpbWVzdGFtcCB8IG51bGwgfCB1bmRlZmluZWQsIGZpZWxkTmFtZTogc3RyaW5nKTogbnVtYmVyIHtcbiAgaWYgKHRzID09PSB1bmRlZmluZWQgfHwgdHMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCAke2ZpZWxkTmFtZX0gdG8gYmUgYSB0aW1lc3RhbXAsIGdvdCAke3RzfWApO1xuICB9XG4gIHJldHVybiB0c1RvTXModHMpO1xufVxuXG4vKipcbiAqIExvc3N5IGNvbnZlcnNpb24gZnVuY3Rpb24gZnJvbSBUaW1lc3RhbXAgdG8gbnVtYmVyIGR1ZSB0byBwb3NzaWJsZSBvdmVyZmxvd1xuICovXG5leHBvcnQgZnVuY3Rpb24gdHNUb01zKHRzOiBUaW1lc3RhbXAgfCBudWxsIHwgdW5kZWZpbmVkKTogbnVtYmVyIHtcbiAgaWYgKHRzID09PSB1bmRlZmluZWQgfHwgdHMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIHRpbWVzdGFtcCwgZ290ICR7dHN9YCk7XG4gIH1cbiAgY29uc3QgeyBzZWNvbmRzLCBuYW5vcyB9ID0gdHM7XG4gIHJldHVybiAoc2Vjb25kcyB8fCBMb25nLlVaRVJPKVxuICAgIC5tdWwoMTAwMClcbiAgICAuYWRkKE1hdGguZmxvb3IoKG5hbm9zIHx8IDApIC8gMTAwMDAwMCkpXG4gICAgLnRvTnVtYmVyKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtc051bWJlclRvVHMobWlsbGlzOiBudW1iZXIpOiBUaW1lc3RhbXAge1xuICBjb25zdCBzZWNvbmRzID0gTWF0aC5mbG9vcihtaWxsaXMgLyAxMDAwKTtcbiAgY29uc3QgbmFub3MgPSAobWlsbGlzICUgMTAwMCkgKiAxMDAwMDAwO1xuICBpZiAoTnVtYmVyLmlzTmFOKHNlY29uZHMpIHx8IE51bWJlci5pc05hTihuYW5vcykpIHtcbiAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihgSW52YWxpZCBtaWxsaXMgJHttaWxsaXN9YCk7XG4gIH1cbiAgcmV0dXJuIHsgc2Vjb25kczogTG9uZy5mcm9tTnVtYmVyKHNlY29uZHMpLCBuYW5vcyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbXNUb1RzKHN0cjogRHVyYXRpb24pOiBUaW1lc3RhbXAge1xuICByZXR1cm4gbXNOdW1iZXJUb1RzKG1zVG9OdW1iZXIoc3RyKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtc09wdGlvbmFsVG9UcyhzdHI6IER1cmF0aW9uIHwgdW5kZWZpbmVkIHwgbnVsbCk6IFRpbWVzdGFtcCB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiBzdHIgPyBtc1RvVHMoc3RyKSA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1zT3B0aW9uYWxUb051bWJlcih2YWw6IER1cmF0aW9uIHwgdW5kZWZpbmVkKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkO1xuICByZXR1cm4gbXNUb051bWJlcih2YWwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbXNUb051bWJlcih2YWw6IER1cmF0aW9uKTogbnVtYmVyIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICByZXR1cm4gbXNXaXRoVmFsaWRhdGlvbih2YWwpO1xufVxuXG5mdW5jdGlvbiBtc1dpdGhWYWxpZGF0aW9uKHN0cjogU3RyaW5nVmFsdWUpOiBudW1iZXIge1xuICBjb25zdCBtaWxsaXMgPSBtcyhzdHIpO1xuICBpZiAobWlsbGlzID09IG51bGwgfHwgaXNOYU4obWlsbGlzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgZHVyYXRpb24gc3RyaW5nOiAnJHtzdHJ9J2ApO1xuICB9XG4gIHJldHVybiBtaWxsaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0c1RvRGF0ZSh0czogVGltZXN0YW1wKTogRGF0ZSB7XG4gIHJldHVybiBuZXcgRGF0ZSh0c1RvTXModHMpKTtcbn1cblxuLy8gdHMtcHJ1bmUtaWdub3JlLW5leHRcbmV4cG9ydCBmdW5jdGlvbiByZXF1aXJlZFRzVG9EYXRlKHRzOiBUaW1lc3RhbXAgfCBudWxsIHwgdW5kZWZpbmVkLCBmaWVsZE5hbWU6IHN0cmluZyk6IERhdGUge1xuICByZXR1cm4gbmV3IERhdGUocmVxdWlyZWRUc1RvTXModHMsIGZpZWxkTmFtZSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3B0aW9uYWxUc1RvRGF0ZSh0czogVGltZXN0YW1wIHwgbnVsbCB8IHVuZGVmaW5lZCk6IERhdGUgfCB1bmRlZmluZWQge1xuICBpZiAodHMgPT09IHVuZGVmaW5lZCB8fCB0cyA9PT0gbnVsbCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIG5ldyBEYXRlKHRzVG9Ncyh0cykpO1xufVxuXG4vLyB0cy1wcnVuZS1pZ25vcmUtbmV4dCAoaW1wb3J0ZWQgdmlhIHNjaGVkdWxlLWhlbHBlcnMudHMpXG5leHBvcnQgZnVuY3Rpb24gb3B0aW9uYWxEYXRlVG9UcyhkYXRlOiBEYXRlIHwgbnVsbCB8IHVuZGVmaW5lZCk6IFRpbWVzdGFtcCB8IHVuZGVmaW5lZCB7XG4gIGlmIChkYXRlID09PSB1bmRlZmluZWQgfHwgZGF0ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIG1zVG9UcyhkYXRlLmdldFRpbWUoKSk7XG59XG4iLCJleHBvcnQgdHlwZSBOb25OdWxsYWJsZU9iamVjdDxUPiA9IHsgW1AgaW4ga2V5b2YgVF0tPzogTm9uTnVsbGFibGU8VFtQXT4gfTtcblxuLyoqIFNob3J0aGFuZCBhbGlhcyAqL1xuZXhwb3J0IHR5cGUgQW55RnVuYyA9ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55O1xuXG4vKiogQSB0dXBsZSB3aXRob3V0IGl0cyBsYXN0IGVsZW1lbnQgKi9cbmV4cG9ydCB0eXBlIE9taXRMYXN0PFQ+ID0gVCBleHRlbmRzIFsuLi5pbmZlciBSRVNULCBhbnldID8gUkVTVCA6IG5ldmVyO1xuXG4vKiogRiB3aXRoIGFsbCBhcmd1bWVudHMgYnV0IHRoZSBsYXN0ICovXG5leHBvcnQgdHlwZSBPbWl0TGFzdFBhcmFtPEYgZXh0ZW5kcyBBbnlGdW5jPiA9ICguLi5hcmdzOiBPbWl0TGFzdDxQYXJhbWV0ZXJzPEY+PikgPT4gUmV0dXJuVHlwZTxGPjtcblxuZXhwb3J0IHR5cGUgT21pdEZpcnN0PFQ+ID0gVCBleHRlbmRzIFthbnksIC4uLmluZmVyIFJFU1RdID8gUkVTVCA6IG5ldmVyO1xuXG5leHBvcnQgdHlwZSBPbWl0Rmlyc3RQYXJhbTxUPiA9IFQgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IGFueVxuICA/ICguLi5hcmdzOiBPbWl0Rmlyc3Q8UGFyYW1ldGVyczxUPj4pID0+IFJldHVyblR5cGU8VD5cbiAgOiBuZXZlcjtcblxuLyoqIFJlcXVpcmUgdGhhdCBUIGhhcyBhdCBsZWFzdCBvbmUgb2YgdGhlIHByb3ZpZGVkIHByb3BlcnRpZXMgZGVmaW5lZCAqL1xuZXhwb3J0IHR5cGUgUmVxdWlyZUF0TGVhc3RPbmU8VCwgS2V5cyBleHRlbmRzIGtleW9mIFQgPSBrZXlvZiBUPiA9IFBpY2s8VCwgRXhjbHVkZTxrZXlvZiBULCBLZXlzPj4gJlxuICB7XG4gICAgW0sgaW4gS2V5c10tPzogUmVxdWlyZWQ8UGljazxULCBLPj4gJiBQYXJ0aWFsPFBpY2s8VCwgRXhjbHVkZTxLZXlzLCBLPj4+O1xuICB9W0tleXNdO1xuXG4vKiogVmVyaWZ5IHRoYXQgYW4gdHlwZSBfQ29weSBleHRlbmRzIF9PcmlnICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tFeHRlbmRzPF9PcmlnLCBfQ29weSBleHRlbmRzIF9PcmlnPigpOiB2b2lkIHtcbiAgLy8gbm9vcCwganVzdCB0eXBlIGNoZWNrXG59XG5cbmV4cG9ydCB0eXBlIFJlcGxhY2U8QmFzZSwgTmV3PiA9IE9taXQ8QmFzZSwga2V5b2YgTmV3PiAmIE5ldztcblxuLy8gRnJvbSBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3R5cGUtZmVzdC9ibG9iL21haW4vc291cmNlL3VuaW9uLXRvLWludGVyc2VjdGlvbi5kLnRzXG4vLyBNSVQgb3IgQ0MwLTEuMCDigJQgSXQgaXMgbWVhbnQgdG8gYmUgY29waWVkIGludG8geW91ciBjb2RlYmFzZSByYXRoZXIgdGhhbiBiZWluZyB1c2VkIGFzIGEgZGVwZW5kZW5jeS5cbmV4cG9ydCB0eXBlIFVuaW9uVG9JbnRlcnNlY3Rpb248VW5pb24+ID1cbiAgLy8gYGV4dGVuZHMgdW5rbm93bmAgaXMgYWx3YXlzIGdvaW5nIHRvIGJlIHRoZSBjYXNlIGFuZCBpcyB1c2VkIHRvIGNvbnZlcnQgdGhlIGBVbmlvbmAgaW50byBhXG4gIC8vIFtkaXN0cmlidXRpdmUgY29uZGl0aW9uYWwgdHlwZV0oaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svcmVsZWFzZS1ub3Rlcy90eXBlc2NyaXB0LTItOC5odG1sI2Rpc3RyaWJ1dGl2ZS1jb25kaXRpb25hbC10eXBlcykuXG4gIChcbiAgICBVbmlvbiBleHRlbmRzIHVua25vd25cbiAgICAgID8gLy8gVGhlIHVuaW9uIHR5cGUgaXMgdXNlZCBhcyB0aGUgb25seSBhcmd1bWVudCB0byBhIGZ1bmN0aW9uIHNpbmNlIHRoZSB1bmlvblxuICAgICAgICAvLyBvZiBmdW5jdGlvbiBhcmd1bWVudHMgaXMgYW4gaW50ZXJzZWN0aW9uLlxuICAgICAgICAoZGlzdHJpYnV0ZWRVbmlvbjogVW5pb24pID0+IHZvaWRcbiAgICAgIDogLy8gVGhpcyB3b24ndCBoYXBwZW4uXG4gICAgICAgIG5ldmVyXG4gICkgZXh0ZW5kcyAvLyBJbmZlciB0aGUgYEludGVyc2VjdGlvbmAgdHlwZSBzaW5jZSBUeXBlU2NyaXB0IHJlcHJlc2VudHMgdGhlIHBvc2l0aW9uYWxcbiAgLy8gYXJndW1lbnRzIG9mIHVuaW9ucyBvZiBmdW5jdGlvbnMgYXMgYW4gaW50ZXJzZWN0aW9uIG9mIHRoZSB1bmlvbi5cbiAgKG1lcmdlZEludGVyc2VjdGlvbjogaW5mZXIgSW50ZXJzZWN0aW9uKSA9PiB2b2lkXG4gICAgPyAvLyBUaGUgYCYgVW5pb25gIGlzIHRvIGFsbG93IGluZGV4aW5nIGJ5IHRoZSByZXN1bHRpbmcgdHlwZVxuICAgICAgSW50ZXJzZWN0aW9uICYgVW5pb25cbiAgICA6IG5ldmVyO1xuXG50eXBlIElzRXF1YWw8QSwgQj4gPSAoPEc+KCkgPT4gRyBleHRlbmRzIEEgPyAxIDogMikgZXh0ZW5kcyA8Rz4oKSA9PiBHIGV4dGVuZHMgQiA/IDEgOiAyID8gdHJ1ZSA6IGZhbHNlO1xuXG50eXBlIFByaW1pdGl2ZSA9IG51bGwgfCB1bmRlZmluZWQgfCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgc3ltYm9sIHwgYmlnaW50O1xuXG50eXBlIElzTnVsbDxUPiA9IFtUXSBleHRlbmRzIFtudWxsXSA/IHRydWUgOiBmYWxzZTtcblxudHlwZSBJc1Vua25vd248VD4gPSB1bmtub3duIGV4dGVuZHMgVCAvLyBgVGAgY2FuIGJlIGB1bmtub3duYCBvciBgYW55YFxuICA/IElzTnVsbDxUPiBleHRlbmRzIGZhbHNlIC8vIGBhbnlgIGNhbiBiZSBgbnVsbGAsIGJ1dCBgdW5rbm93bmAgY2FuJ3QgYmVcbiAgICA/IHRydWVcbiAgICA6IGZhbHNlXG4gIDogZmFsc2U7XG5cbnR5cGUgT2JqZWN0VmFsdWU8VCwgSz4gPSBLIGV4dGVuZHMga2V5b2YgVFxuICA/IFRbS11cbiAgOiBUb1N0cmluZzxLPiBleHRlbmRzIGtleW9mIFRcbiAgICA/IFRbVG9TdHJpbmc8Sz5dXG4gICAgOiBLIGV4dGVuZHMgYCR7aW5mZXIgTnVtYmVySyBleHRlbmRzIG51bWJlcn1gXG4gICAgICA/IE51bWJlcksgZXh0ZW5kcyBrZXlvZiBUXG4gICAgICAgID8gVFtOdW1iZXJLXVxuICAgICAgICA6IG5ldmVyXG4gICAgICA6IG5ldmVyO1xuXG50eXBlIFRvU3RyaW5nPFQ+ID0gVCBleHRlbmRzIHN0cmluZyB8IG51bWJlciA/IGAke1R9YCA6IG5ldmVyO1xuXG50eXBlIEtleXNPZlVuaW9uPE9iamVjdFR5cGU+ID0gT2JqZWN0VHlwZSBleHRlbmRzIHVua25vd24gPyBrZXlvZiBPYmplY3RUeXBlIDogbmV2ZXI7XG5cbnR5cGUgQXJyYXlFbGVtZW50PFQ+ID0gVCBleHRlbmRzIHJlYWRvbmx5IHVua25vd25bXSA/IFRbMF0gOiBuZXZlcjtcblxudHlwZSBFeGFjdE9iamVjdDxQYXJhbWV0ZXJUeXBlLCBJbnB1dFR5cGU+ID0ge1xuICBbS2V5IGluIGtleW9mIFBhcmFtZXRlclR5cGVdOiBFeGFjdDxQYXJhbWV0ZXJUeXBlW0tleV0sIE9iamVjdFZhbHVlPElucHV0VHlwZSwgS2V5Pj47XG59ICYgUmVjb3JkPEV4Y2x1ZGU8a2V5b2YgSW5wdXRUeXBlLCBLZXlzT2ZVbmlvbjxQYXJhbWV0ZXJUeXBlPj4sIG5ldmVyPjtcblxuZXhwb3J0IHR5cGUgRXhhY3Q8UGFyYW1ldGVyVHlwZSwgSW5wdXRUeXBlPiA9XG4gIC8vIEJlZm9yZSBkaXN0cmlidXRpbmcsIGNoZWNrIGlmIHRoZSB0d28gdHlwZXMgYXJlIGVxdWFsIGFuZCBpZiBzbywgcmV0dXJuIHRoZSBwYXJhbWV0ZXIgdHlwZSBpbW1lZGlhdGVseVxuICBJc0VxdWFsPFBhcmFtZXRlclR5cGUsIElucHV0VHlwZT4gZXh0ZW5kcyB0cnVlXG4gICAgPyBQYXJhbWV0ZXJUeXBlXG4gICAgOiAvLyBJZiB0aGUgcGFyYW1ldGVyIGlzIGEgcHJpbWl0aXZlLCByZXR1cm4gaXQgYXMgaXMgaW1tZWRpYXRlbHkgdG8gYXZvaWQgaXQgYmVpbmcgY29udmVydGVkIHRvIGEgY29tcGxleCB0eXBlXG4gICAgICBQYXJhbWV0ZXJUeXBlIGV4dGVuZHMgUHJpbWl0aXZlXG4gICAgICA/IFBhcmFtZXRlclR5cGVcbiAgICAgIDogLy8gSWYgdGhlIHBhcmFtZXRlciBpcyBhbiB1bmtub3duLCByZXR1cm4gaXQgYXMgaXMgaW1tZWRpYXRlbHkgdG8gYXZvaWQgaXQgYmVpbmcgY29udmVydGVkIHRvIGEgY29tcGxleCB0eXBlXG4gICAgICAgIElzVW5rbm93bjxQYXJhbWV0ZXJUeXBlPiBleHRlbmRzIHRydWVcbiAgICAgICAgPyB1bmtub3duXG4gICAgICAgIDogLy8gSWYgdGhlIHBhcmFtZXRlciBpcyBhIEZ1bmN0aW9uLCByZXR1cm4gaXQgYXMgaXMgYmVjYXVzZSB0aGlzIHR5cGUgaXMgbm90IGNhcGFibGUgb2YgaGFuZGxpbmcgZnVuY3Rpb24sIGxlYXZlIGl0IHRvIFR5cGVTY3JpcHRcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1mdW5jdGlvbi10eXBlXG4gICAgICAgICAgUGFyYW1ldGVyVHlwZSBleHRlbmRzIEZ1bmN0aW9uXG4gICAgICAgICAgPyBQYXJhbWV0ZXJUeXBlXG4gICAgICAgICAgOiAvLyBDb252ZXJ0IHVuaW9uIG9mIGFycmF5IHRvIGFycmF5IG9mIHVuaW9uOiBBW10gJiBCW10gPT4gKEEgJiBCKVtdXG4gICAgICAgICAgICBQYXJhbWV0ZXJUeXBlIGV4dGVuZHMgdW5rbm93bltdXG4gICAgICAgICAgICA/IEFycmF5PEV4YWN0PEFycmF5RWxlbWVudDxQYXJhbWV0ZXJUeXBlPiwgQXJyYXlFbGVtZW50PElucHV0VHlwZT4+PlxuICAgICAgICAgICAgOiAvLyBJbiBUeXBlU2NyaXB0LCBBcnJheSBpcyBhIHN1YnR5cGUgb2YgUmVhZG9ubHlBcnJheSwgc28gYWx3YXlzIHRlc3QgQXJyYXkgYmVmb3JlIFJlYWRvbmx5QXJyYXkuXG4gICAgICAgICAgICAgIFBhcmFtZXRlclR5cGUgZXh0ZW5kcyByZWFkb25seSB1bmtub3duW11cbiAgICAgICAgICAgICAgPyBSZWFkb25seUFycmF5PEV4YWN0PEFycmF5RWxlbWVudDxQYXJhbWV0ZXJUeXBlPiwgQXJyYXlFbGVtZW50PElucHV0VHlwZT4+PlxuICAgICAgICAgICAgICA6IEV4YWN0T2JqZWN0PFBhcmFtZXRlclR5cGUsIElucHV0VHlwZT47XG4vLyBFbmQgb2YgYm9ycm93IGZyb20gIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvdHlwZS1mZXN0L2Jsb2IvbWFpbi9zb3VyY2UvdW5pb24tdG8taW50ZXJzZWN0aW9uLmQudHNcblxuZXhwb3J0IHR5cGUgUmVtb3ZlUHJlZml4PFByZWZpeCBleHRlbmRzIHN0cmluZywgS2V5cyBleHRlbmRzIHN0cmluZz4gPSB7XG4gIFtrIGluIEtleXNdOiBrIGV4dGVuZHMgYCR7UHJlZml4fSR7aW5mZXIgU3VmZml4fWAgPyBTdWZmaXggOiBuZXZlcjtcbn1bS2V5c107XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1JlY29yZCh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eTxYIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sIFkgZXh0ZW5kcyBQcm9wZXJ0eUtleT4oXG4gIHJlY29yZDogWCxcbiAgcHJvcDogWVxuKTogcmVjb3JkIGlzIFggJiBSZWNvcmQ8WSwgdW5rbm93bj4ge1xuICByZXR1cm4gcHJvcCBpbiByZWNvcmQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0aWVzPFggZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiwgWSBleHRlbmRzIFByb3BlcnR5S2V5PihcbiAgcmVjb3JkOiBYLFxuICBwcm9wczogWVtdXG4pOiByZWNvcmQgaXMgWCAmIFJlY29yZDxZLCB1bmtub3duPiB7XG4gIHJldHVybiBwcm9wcy5ldmVyeSgocHJvcCkgPT4gcHJvcCBpbiByZWNvcmQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFcnJvcihlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIEVycm9yIHtcbiAgcmV0dXJuIChcbiAgICBpc1JlY29yZChlcnJvcikgJiZcbiAgICB0eXBlb2YgZXJyb3IubmFtZSA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycgJiZcbiAgICAoZXJyb3Iuc3RhY2sgPT0gbnVsbCB8fCB0eXBlb2YgZXJyb3Iuc3RhY2sgPT09ICdzdHJpbmcnKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBYm9ydEVycm9yKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgRXJyb3IgJiB7IG5hbWU6ICdBYm9ydEVycm9yJyB9IHtcbiAgcmV0dXJuIGlzRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJztcbn1cblxuLyoqXG4gKiBHZXQgYGVycm9yLm1lc3NhZ2VgIChvciBgdW5kZWZpbmVkYCBpZiBub3QgcHJlc2VudClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVycm9yTWVzc2FnZShlcnJvcjogdW5rbm93bik6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGlmIChpc0Vycm9yKGVycm9yKSkge1xuICAgIHJldHVybiBlcnJvci5tZXNzYWdlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuaW50ZXJmYWNlIEVycm9yV2l0aENvZGUge1xuICBjb2RlOiBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3JXaXRoQ29kZShlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIEVycm9yV2l0aENvZGUge1xuICByZXR1cm4gaXNSZWNvcmQoZXJyb3IpICYmIHR5cGVvZiBlcnJvci5jb2RlID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBHZXQgYGVycm9yLmNvZGVgIChvciBgdW5kZWZpbmVkYCBpZiBub3QgcHJlc2VudClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVycm9yQ29kZShlcnJvcjogdW5rbm93bik6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGlmIChpc0Vycm9yV2l0aENvZGUoZXJyb3IpKSB7XG4gICAgcmV0dXJuIGVycm9yLmNvZGU7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEFzc2VydHMgdGhhdCBzb21lIHR5cGUgaXMgdGhlIG5ldmVyIHR5cGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE5ldmVyKG1zZzogc3RyaW5nLCB4OiBuZXZlcik6IG5ldmVyIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihtc2cgKyAnOiAnICsgeCk7XG59XG5cbmV4cG9ydCB0eXBlIENsYXNzPEUgZXh0ZW5kcyBFcnJvcj4gPSB7XG4gIG5ldyAoLi4uYXJnczogYW55W10pOiBFO1xuICBwcm90b3R5cGU6IEU7XG59O1xuXG4vKipcbiAqIEEgZGVjb3JhdG9yIHRvIGJlIHVzZWQgb24gZXJyb3IgY2xhc3Nlcy4gSXQgYWRkcyB0aGUgJ25hbWUnIHByb3BlcnR5IEFORCBwcm92aWRlcyBhIGN1c3RvbVxuICogJ2luc3RhbmNlb2YnIGhhbmRsZXIgdGhhdCB3b3JrcyBjb3JyZWN0bHkgYWNyb3NzIGV4ZWN1dGlvbiBjb250ZXh0cy5cbiAqXG4gKiAjIyMgRGV0YWlscyAjIyNcbiAqXG4gKiBBY2NvcmRpbmcgdG8gdGhlIEVjbWFTY3JpcHQncyBzcGVjLCB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBKYXZhU2NyaXB0J3MgYHggaW5zdGFuY2VvZiBZYCBvcGVyYXRvciBpcyB0byB3YWxrIHVwIHRoZVxuICogcHJvdG90eXBlIGNoYWluIG9mIG9iamVjdCAneCcsIGNoZWNraW5nIGlmIGFueSBjb25zdHJ1Y3RvciBpbiB0aGF0IGhpZXJhcmNoeSBpcyBfZXhhY3RseSB0aGUgc2FtZSBvYmplY3RfIGFzIHRoZVxuICogY29uc3RydWN0b3IgZnVuY3Rpb24gJ1knLlxuICpcbiAqIFVuZm9ydHVuYXRlbHksIGl0IGhhcHBlbnMgaW4gdmFyaW91cyBzaXR1YXRpb25zIHRoYXQgZGlmZmVyZW50IGNvbnN0cnVjdG9yIGZ1bmN0aW9uIG9iamVjdHMgZ2V0IGNyZWF0ZWQgZm9yIHdoYXRcbiAqIGFwcGVhcnMgdG8gYmUgdGhlIHZlcnkgc2FtZSBjbGFzcy4gVGhpcyBsZWFkcyB0byBzdXJwcmlzaW5nIGJlaGF2aW9yIHdoZXJlIGBpbnN0YW5jZW9mYCByZXR1cm5zIGZhbHNlIHRob3VnaCBpdCBpc1xuICoga25vd24gdGhhdCB0aGUgb2JqZWN0IGlzIGluZGVlZCBhbiBpbnN0YW5jZSBvZiB0aGF0IGNsYXNzLiBPbmUgcGFydGljdWxhciBjYXNlIHdoZXJlIHRoaXMgaGFwcGVucyBpcyB3aGVuIGNvbnN0cnVjdG9yXG4gKiAnWScgYmVsb25ncyB0byBhIGRpZmZlcmVudCByZWFsbSB0aGFuIHRoZSBjb25zdHVjdG9yIHdpdGggd2hpY2ggJ3gnIHdhcyBpbnN0YW50aWF0ZWQuIEFub3RoZXIgY2FzZSBpcyB3aGVuIHR3byBjb3BpZXNcbiAqIG9mIHRoZSBzYW1lIGxpYnJhcnkgZ2V0cyBsb2FkZWQgaW4gdGhlIHNhbWUgcmVhbG0uXG4gKlxuICogSW4gcHJhY3RpY2UsIHRoaXMgdGVuZHMgdG8gY2F1c2UgaXNzdWVzIHdoZW4gY3Jvc3NpbmcgdGhlIHdvcmtmbG93LXNhbmRib3hpbmcgYm91bmRhcnkgKHNpbmNlIE5vZGUncyB2bSBtb2R1bGVcbiAqIHJlYWxseSBjcmVhdGVzIG5ldyBleGVjdXRpb24gcmVhbG1zKSwgYXMgd2VsbCBhcyB3aGVuIHJ1bm5pbmcgdGVzdHMgdXNpbmcgSmVzdCAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qZXN0anMvamVzdC9pc3N1ZXMvMjU0OVxuICogZm9yIHNvbWUgZGV0YWlscyBvbiB0aGF0IG9uZSkuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpbmplY3RzIGEgY3VzdG9tICdpbnN0YW5jZW9mJyBoYW5kbGVyIGludG8gdGhlIHByb3RvdHlwZSBvZiAnY2xhenonLCB3aGljaCBpcyBib3RoIGNyb3NzLXJlYWxtIHNhZmUgYW5kXG4gKiBjcm9zcy1jb3BpZXMtb2YtdGhlLXNhbWUtbGliIHNhZmUuIEl0IHdvcmtzIGJ5IGFkZGluZyBhIHNwZWNpYWwgc3ltYm9sIHByb3BlcnR5IHRvIHRoZSBwcm90b3R5cGUgb2YgJ2NsYXp6JywgYW5kIHRoZW5cbiAqIGNoZWNraW5nIGZvciB0aGUgcHJlc2VuY2Ugb2YgdGhhdCBzeW1ib2wuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvcjxFIGV4dGVuZHMgRXJyb3I+KG1hcmtlck5hbWU6IHN0cmluZyk6IChjbGF6ejogQ2xhc3M8RT4pID0+IHZvaWQge1xuICByZXR1cm4gKGNsYXp6OiBDbGFzczxFPik6IHZvaWQgPT4ge1xuICAgIGNvbnN0IG1hcmtlciA9IFN5bWJvbC5mb3IoYF9fdGVtcG9yYWxfaXMke21hcmtlck5hbWV9YCk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhenoucHJvdG90eXBlLCAnbmFtZScsIHsgdmFsdWU6IG1hcmtlck5hbWUsIGVudW1lcmFibGU6IHRydWUgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXp6LnByb3RvdHlwZSwgbWFya2VyLCB7IHZhbHVlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhenosIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG9iamVjdC1zaG9ydGhhbmRcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAodGhpczogYW55LCBlcnJvcjogb2JqZWN0KTogYm9vbGVhbiB7XG4gICAgICAgIGlmICh0aGlzID09PSBjbGF6eikge1xuICAgICAgICAgIHJldHVybiBpc1JlY29yZChlcnJvcikgJiYgKGVycm9yIGFzIGFueSlbbWFya2VyXSA9PT0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAndGhpcycgbXVzdCBiZSBhIF9zdWJjbGFzc18gb2YgY2xhenogdGhhdCBkb2Vzbid0IHJlZGVmaW5lZCBbU3ltYm9sLmhhc0luc3RhbmNlXSwgc28gdGhhdCBpdCBpbmhlcml0ZWRcbiAgICAgICAgICAvLyBmcm9tIGNsYXp6J3MgW1N5bWJvbC5oYXNJbnN0YW5jZV0uIElmIHdlIGRvbid0IGhhbmRsZSB0aGlzIHBhcnRpY3VsYXIgc2l0dWF0aW9uLCB0aGVuXG4gICAgICAgICAgLy8gYHggaW5zdGFuY2VvZiBTdWJjbGFzc09mUGFyZW50YCB3b3VsZCByZXR1cm4gdHJ1ZSBmb3IgYW55IGluc3RhbmNlIG9mICdQYXJlbnQnLCB3aGljaCBpcyBjbGVhcmx5IHdyb25nLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gSWRlYWxseSwgaXQnZCBiZSBwcmVmZXJhYmxlIHRvIGF2b2lkIHRoaXMgY2FzZSBlbnRpcmVseSwgYnkgbWFraW5nIHN1cmUgdGhhdCBhbGwgc3ViY2xhc3NlcyBvZiAnY2xhenonXG4gICAgICAgICAgLy8gcmVkZWZpbmUgW1N5bWJvbC5oYXNJbnN0YW5jZV0sIGJ1dCB3ZSBjYW4ndCBlbmZvcmNlIHRoYXQuIFdlIHRoZXJlZm9yZSBmYWxsYmFjayB0byB0aGUgZGVmYXVsdCBpbnN0YW5jZW9mXG4gICAgICAgICAgLy8gYmVoYXZpb3IgKHdoaWNoIGlzIE5PVCBjcm9zcy1yZWFsbSBzYWZlKS5cbiAgICAgICAgICByZXR1cm4gdGhpcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihlcnJvcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSk7XG4gIH07XG59XG4iLCJpbXBvcnQgdHlwZSB7IHRlbXBvcmFsIH0gZnJvbSAnQHRlbXBvcmFsaW8vcHJvdG8nO1xuaW1wb3J0IHsgY29udmVydE9wdGlvbmFsVG9QYXlsb2FkLCBQYXlsb2FkQ29udmVydGVyIH0gZnJvbSAnLi9jb252ZXJ0ZXIvcGF5bG9hZC1jb252ZXJ0ZXInO1xuXG4vKipcbiAqIFVzZXIgbWV0YWRhdGEgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gd29ya2Zsb3cgY29tbWFuZHMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXNlck1ldGFkYXRhIHtcbiAgLyoqIEBleHBlcmltZW50YWwgQSBmaXhlZCwgc2luZ2xlIGxpbmUgc3VtbWFyeSBvZiB0aGUgY29tbWFuZCdzIHB1cnBvc2UgKi9cbiAgc3RhdGljU3VtbWFyeT86IHN0cmluZztcbiAgLyoqIEBleHBlcmltZW50YWwgRml4ZWQgYWRkaXRpb25hbCBkZXRhaWxzIGFib3V0IHRoZSBjb21tYW5kIGZvciBsb25nZXItdGV4dCBkZXNjcmlwdGlvbiwgY2FuIHNwYW4gbXVsdGlwbGUgbGluZXMgKi9cbiAgc3RhdGljRGV0YWlscz86IHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZXJNZXRhZGF0YVRvUGF5bG9hZChcbiAgcGF5bG9hZENvbnZlcnRlcjogUGF5bG9hZENvbnZlcnRlcixcbiAgc3RhdGljU3VtbWFyeTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICBzdGF0aWNEZXRhaWxzOiBzdHJpbmcgfCB1bmRlZmluZWRcbik6IHRlbXBvcmFsLmFwaS5zZGsudjEuSVVzZXJNZXRhZGF0YSB8IHVuZGVmaW5lZCB7XG4gIGlmIChzdGF0aWNTdW1tYXJ5ID09IG51bGwgJiYgc3RhdGljRGV0YWlscyA9PSBudWxsKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIGNvbnN0IHN1bW1hcnkgPSBjb252ZXJ0T3B0aW9uYWxUb1BheWxvYWQocGF5bG9hZENvbnZlcnRlciwgc3RhdGljU3VtbWFyeSk7XG4gIGNvbnN0IGRldGFpbHMgPSBjb252ZXJ0T3B0aW9uYWxUb1BheWxvYWQocGF5bG9hZENvbnZlcnRlciwgc3RhdGljRGV0YWlscyk7XG5cbiAgaWYgKHN1bW1hcnkgPT0gbnVsbCAmJiBkZXRhaWxzID09IG51bGwpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgcmV0dXJuIHsgc3VtbWFyeSwgZGV0YWlscyB9O1xufVxuIiwiaW1wb3J0IHR5cGUgeyBjb3Jlc2RrIH0gZnJvbSAnQHRlbXBvcmFsaW8vcHJvdG8nO1xuaW1wb3J0IHR5cGUgeyBWZXJzaW9uaW5nSW50ZW50IGFzIFZlcnNpb25pbmdJbnRlbnRTdHJpbmcgfSBmcm9tICcuL3ZlcnNpb25pbmctaW50ZW50JztcbmltcG9ydCB7IGFzc2VydE5ldmVyLCBjaGVja0V4dGVuZHMgfSBmcm9tICcuL3R5cGUtaGVscGVycyc7XG5cbi8qIGVzbGludC1kaXNhYmxlIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uICovXG5cbi8vIEF2b2lkIGltcG9ydGluZyB0aGUgcHJvdG8gaW1wbGVtZW50YXRpb24gdG8gcmVkdWNlIHdvcmtmbG93IGJ1bmRsZSBzaXplXG4vLyBDb3BpZWQgZnJvbSBjb3Jlc2RrLmNvbW1vbi5WZXJzaW9uaW5nSW50ZW50XG4vKipcbiAqIFByb3RvYnVmIGVudW0gcmVwcmVzZW50YXRpb24gb2Yge0BsaW5rIFZlcnNpb25pbmdJbnRlbnRTdHJpbmd9LlxuICpcbiAqIEBkZXByZWNhdGVkIEluIGZhdm9yIG9mIHRoZSBuZXcgV29ya2VyIERlcGxveW1lbnQgQVBJLlxuICogQGV4cGVyaW1lbnRhbCBUaGUgV29ya2VyIFZlcnNpb25pbmcgQVBJIGlzIHN0aWxsIGJlaW5nIGRlc2lnbmVkLiBNYWpvciBjaGFuZ2VzIGFyZSBleHBlY3RlZC5cbiAqL1xuZXhwb3J0IGVudW0gVmVyc2lvbmluZ0ludGVudCB7XG4gIFVOU1BFQ0lGSUVEID0gMCxcbiAgQ09NUEFUSUJMRSA9IDEsXG4gIERFRkFVTFQgPSAyLFxufVxuXG5jaGVja0V4dGVuZHM8Y29yZXNkay5jb21tb24uVmVyc2lvbmluZ0ludGVudCwgVmVyc2lvbmluZ0ludGVudD4oKTtcbmNoZWNrRXh0ZW5kczxWZXJzaW9uaW5nSW50ZW50LCBjb3Jlc2RrLmNvbW1vbi5WZXJzaW9uaW5nSW50ZW50PigpO1xuXG5leHBvcnQgZnVuY3Rpb24gdmVyc2lvbmluZ0ludGVudFRvUHJvdG8oaW50ZW50OiBWZXJzaW9uaW5nSW50ZW50U3RyaW5nIHwgdW5kZWZpbmVkKTogVmVyc2lvbmluZ0ludGVudCB7XG4gIHN3aXRjaCAoaW50ZW50KSB7XG4gICAgY2FzZSAnREVGQVVMVCc6XG4gICAgICByZXR1cm4gVmVyc2lvbmluZ0ludGVudC5ERUZBVUxUO1xuICAgIGNhc2UgJ0NPTVBBVElCTEUnOlxuICAgICAgcmV0dXJuIFZlcnNpb25pbmdJbnRlbnQuQ09NUEFUSUJMRTtcbiAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgIHJldHVybiBWZXJzaW9uaW5nSW50ZW50LlVOU1BFQ0lGSUVEO1xuICAgIGRlZmF1bHQ6XG4gICAgICBhc3NlcnROZXZlcignVW5leHBlY3RlZCBWZXJzaW9uaW5nSW50ZW50JywgaW50ZW50KTtcbiAgfVxufVxuIiwiLyoqXG4gKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdXNlciBpbnRlbmRzIGNlcnRhaW4gY29tbWFuZHMgdG8gYmUgcnVuIG9uIGEgY29tcGF0aWJsZSB3b3JrZXIgQnVpbGQgSWQgdmVyc2lvbiBvciBub3QuXG4gKlxuICogYENPTVBBVElCTEVgIGluZGljYXRlcyB0aGF0IHRoZSBjb21tYW5kIHNob3VsZCBydW4gb24gYSB3b3JrZXIgd2l0aCBjb21wYXRpYmxlIHZlcnNpb24gaWYgcG9zc2libGUuIEl0IG1heSBub3QgYmVcbiAqIHBvc3NpYmxlIGlmIHRoZSB0YXJnZXQgdGFzayBxdWV1ZSBkb2VzIG5vdCBhbHNvIGhhdmUga25vd2xlZGdlIG9mIHRoZSBjdXJyZW50IHdvcmtlcidzIEJ1aWxkIElkLlxuICpcbiAqIGBERUZBVUxUYCBpbmRpY2F0ZXMgdGhhdCB0aGUgY29tbWFuZCBzaG91bGQgcnVuIG9uIHRoZSB0YXJnZXQgdGFzayBxdWV1ZSdzIGN1cnJlbnQgb3ZlcmFsbC1kZWZhdWx0IEJ1aWxkIElkLlxuICpcbiAqIFdoZXJlIHRoaXMgdHlwZSBpcyBhY2NlcHRlZCBvcHRpb25hbGx5LCBhbiB1bnNldCB2YWx1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgU0RLIHNob3VsZCBjaG9vc2UgdGhlIG1vc3Qgc2Vuc2libGUgZGVmYXVsdFxuICogYmVoYXZpb3IgZm9yIHRoZSB0eXBlIG9mIGNvbW1hbmQsIGFjY291bnRpbmcgZm9yIHdoZXRoZXIgdGhlIGNvbW1hbmQgd2lsbCBiZSBydW4gb24gdGhlIHNhbWUgdGFzayBxdWV1ZSBhcyB0aGVcbiAqIGN1cnJlbnQgd29ya2VyLiBUaGUgZGVmYXVsdCBiZWhhdmlvciBmb3Igc3RhcnRpbmcgV29ya2Zsb3dzIGlzIGBERUZBVUxUYC4gVGhlIGRlZmF1bHQgYmVoYXZpb3IgZm9yIFdvcmtmbG93cyBzdGFydGluZ1xuICogQWN0aXZpdGllcywgc3RhcnRpbmcgQ2hpbGQgV29ya2Zsb3dzLCBvciBDb250aW51aW5nIEFzIE5ldyBpcyBgQ09NUEFUSUJMRWAuXG4gKlxuICogQGRlcHJlY2F0ZWQgSW4gZmF2b3Igb2YgdGhlIG5ldyBXb3JrZXIgRGVwbG95bWVudCBBUEkuXG4gKiBAZXhwZXJpbWVudGFsIFRoZSBXb3JrZXIgVmVyc2lvbmluZyBBUEkgaXMgc3RpbGwgYmVpbmcgZGVzaWduZWQuIE1ham9yIGNoYW5nZXMgYXJlIGV4cGVjdGVkLlxuICovXG5leHBvcnQgdHlwZSBWZXJzaW9uaW5nSW50ZW50ID0gJ0NPTVBBVElCTEUnIHwgJ0RFRkFVTFQnO1xuIiwiaW1wb3J0IHR5cGUgeyB0ZW1wb3JhbCB9IGZyb20gJ0B0ZW1wb3JhbGlvL3Byb3RvJztcbmltcG9ydCB7IG1ha2VQcm90b0VudW1Db252ZXJ0ZXJzIH0gZnJvbSAnLi9pbnRlcm5hbC13b3JrZmxvdyc7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgdmVyc2lvbiBvZiBhIHNwZWNpZmljIHdvcmtlciBkZXBsb3ltZW50LlxuICpcbiAqIEBleHBlcmltZW50YWwgRGVwbG95bWVudCBiYXNlZCB2ZXJzaW9uaW5nIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtlckRlcGxveW1lbnRWZXJzaW9uIHtcbiAgcmVhZG9ubHkgYnVpbGRJZDogc3RyaW5nO1xuICByZWFkb25seSBkZXBsb3ltZW50TmFtZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIEByZXR1cm5zIFRoZSBjYW5vbmljYWwgcmVwcmVzZW50YXRpb24gb2YgYSBkZXBsb3ltZW50IHZlcnNpb24sIHdoaWNoIGlzIGEgc3RyaW5nIGluIHRoZSBmb3JtYXRcbiAqIGBkZXBsb3ltZW50TmFtZS5idWlsZElkYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQ2Fub25pY2FsU3RyaW5nKHZlcnNpb246IFdvcmtlckRlcGxveW1lbnRWZXJzaW9uKTogc3RyaW5nIHtcbiAgcmV0dXJuIGAke3ZlcnNpb24uZGVwbG95bWVudE5hbWV9LiR7dmVyc2lvbi5idWlsZElkfWA7XG59XG5cbi8qKlxuICogU3BlY2lmaWVzIHdoZW4gYSB3b3JrZmxvdyBtaWdodCBtb3ZlIGZyb20gYSB3b3JrZXIgb2Ygb25lIEJ1aWxkIElkIHRvIGFub3RoZXIuXG4gKlxuICogKiAnUElOTkVEJyAtIFRoZSB3b3JrZmxvdyB3aWxsIGJlIHBpbm5lZCB0byB0aGUgY3VycmVudCBCdWlsZCBJRCB1bmxlc3MgbWFudWFsbHkgbW92ZWQuXG4gKiAqICdBVVRPX1VQR1JBREUnIC0gVGhlIHdvcmtmbG93IHdpbGwgYXV0b21hdGljYWxseSBtb3ZlIHRvIHRoZSBsYXRlc3QgdmVyc2lvbiAoZGVmYXVsdCBCdWlsZCBJRFxuICogICAgb2YgdGhlIHRhc2sgcXVldWUpIHdoZW4gdGhlIG5leHQgdGFzayBpcyBkaXNwYXRjaGVkLlxuICpcbiAqIEBleHBlcmltZW50YWwgRGVwbG95bWVudCBiYXNlZCB2ZXJzaW9uaW5nIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuICovXG5leHBvcnQgY29uc3QgVmVyc2lvbmluZ0JlaGF2aW9yID0ge1xuICBQSU5ORUQ6ICdQSU5ORUQnLFxuICBBVVRPX1VQR1JBREU6ICdBVVRPX1VQR1JBREUnLFxufSBhcyBjb25zdDtcbmV4cG9ydCB0eXBlIFZlcnNpb25pbmdCZWhhdmlvciA9ICh0eXBlb2YgVmVyc2lvbmluZ0JlaGF2aW9yKVtrZXlvZiB0eXBlb2YgVmVyc2lvbmluZ0JlaGF2aW9yXTtcblxuZXhwb3J0IGNvbnN0IFtlbmNvZGVWZXJzaW9uaW5nQmVoYXZpb3IsIGRlY29kZVZlcnNpb25pbmdCZWhhdmlvcl0gPSBtYWtlUHJvdG9FbnVtQ29udmVydGVyczxcbiAgdGVtcG9yYWwuYXBpLmVudW1zLnYxLlZlcnNpb25pbmdCZWhhdmlvcixcbiAgdHlwZW9mIHRlbXBvcmFsLmFwaS5lbnVtcy52MS5WZXJzaW9uaW5nQmVoYXZpb3IsXG4gIGtleW9mIHR5cGVvZiB0ZW1wb3JhbC5hcGkuZW51bXMudjEuVmVyc2lvbmluZ0JlaGF2aW9yLFxuICB0eXBlb2YgVmVyc2lvbmluZ0JlaGF2aW9yLFxuICAnVkVSU0lPTklOR19CRUhBVklPUl8nXG4+KFxuICB7XG4gICAgW1ZlcnNpb25pbmdCZWhhdmlvci5QSU5ORURdOiAxLFxuICAgIFtWZXJzaW9uaW5nQmVoYXZpb3IuQVVUT19VUEdSQURFXTogMixcbiAgICBVTlNQRUNJRklFRDogMCxcbiAgfSBhcyBjb25zdCxcbiAgJ1ZFUlNJT05JTkdfQkVIQVZJT1JfJ1xuKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHZlcnNpb25pbmcgb3ZlcnJpZGVzLiBGb3IgZXhhbXBsZSwgd2hlbiBzdGFydGluZyB3b3JrZmxvd3MuXG4gKi9cbmV4cG9ydCB0eXBlIFZlcnNpb25pbmdPdmVycmlkZSA9IFBpbm5lZFZlcnNpb25pbmdPdmVycmlkZSB8ICdBVVRPX1VQR1JBREUnO1xuXG4vKipcbiAqIFdvcmtmbG93IHdpbGwgYmUgcGlubmVkIHRvIGEgc3BlY2lmaWMgZGVwbG95bWVudCB2ZXJzaW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBpbm5lZFZlcnNpb25pbmdPdmVycmlkZSB7XG4gIC8qKlxuICAgKiBUaGUgd29ya2VyIGRlcGxveW1lbnQgdmVyc2lvbiB0byBwaW4gdGhlIHdvcmtmbG93IHRvLlxuICAgKi9cbiAgcGlubmVkVG86IFdvcmtlckRlcGxveW1lbnRWZXJzaW9uO1xufVxuXG4vKipcbiAqIFRoZSB3b3JrZmxvdyB3aWxsIGF1dG8tdXBncmFkZSB0byB0aGUgY3VycmVudCBkZXBsb3ltZW50IHZlcnNpb24gb24gdGhlIG5leHQgd29ya2Zsb3cgdGFzay5cbiAqL1xuZXhwb3J0IHR5cGUgQXV0b1VwZ3JhZGVWZXJzaW9uaW5nT3ZlcnJpZGUgPSAnQVVUT19VUEdSQURFJztcbiIsImltcG9ydCB7IFZlcnNpb25pbmdCZWhhdmlvciB9IGZyb20gJy4vd29ya2VyLWRlcGxveW1lbnRzJztcblxuLyoqXG4gKiBPcHRpb25zIHRoYXQgY2FuIGJlIHVzZWQgd2hlbiBkZWZpbmluZyBhIHdvcmtmbG93IHZpYSB7QGxpbmsgc2V0V29ya2Zsb3dPcHRpb25zfS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBXb3JrZmxvd0RlZmluaXRpb25PcHRpb25zIHtcbiAgdmVyc2lvbmluZ0JlaGF2aW9yPzogVmVyc2lvbmluZ0JlaGF2aW9yO1xufVxuXG50eXBlIEFzeW5jRnVuY3Rpb248QXJncyBleHRlbmRzIGFueVtdLCBSZXR1cm5UeXBlPiA9ICguLi5hcmdzOiBBcmdzKSA9PiBQcm9taXNlPFJldHVyblR5cGU+O1xuZXhwb3J0IHR5cGUgV29ya2Zsb3dEZWZpbml0aW9uT3B0aW9uc09yR2V0dGVyID0gV29ya2Zsb3dEZWZpbml0aW9uT3B0aW9ucyB8ICgoKSA9PiBXb3JrZmxvd0RlZmluaXRpb25PcHRpb25zKTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEBoaWRkZW5cbiAqIEEgd29ya2Zsb3cgZnVuY3Rpb24gdGhhdCBoYXMgYmVlbiBkZWZpbmVkIHdpdGggb3B0aW9ucyBmcm9tIHtAbGluayBXb3JrZmxvd0RlZmluaXRpb25PcHRpb25zfS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBXb3JrZmxvd0Z1bmN0aW9uV2l0aE9wdGlvbnM8QXJncyBleHRlbmRzIGFueVtdLCBSZXR1cm5UeXBlPiBleHRlbmRzIEFzeW5jRnVuY3Rpb248QXJncywgUmV0dXJuVHlwZT4ge1xuICB3b3JrZmxvd0RlZmluaXRpb25PcHRpb25zOiBXb3JrZmxvd0RlZmluaXRpb25PcHRpb25zT3JHZXR0ZXI7XG59XG4iLCJpbXBvcnQgeyBXb3JrZmxvdywgV29ya2Zsb3dSZXN1bHRUeXBlLCBTaWduYWxEZWZpbml0aW9uIH0gZnJvbSAnLi9pbnRlcmZhY2VzJztcblxuLyoqXG4gKiBCYXNlIFdvcmtmbG93SGFuZGxlIGludGVyZmFjZSwgZXh0ZW5kZWQgaW4gd29ya2Zsb3cgYW5kIGNsaWVudCBsaWJzLlxuICpcbiAqIFRyYW5zZm9ybXMgYSB3b3JrZmxvdyBpbnRlcmZhY2UgYFRgIGludG8gYSBjbGllbnQgaW50ZXJmYWNlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJhc2VXb3JrZmxvd0hhbmRsZTxUIGV4dGVuZHMgV29ya2Zsb3c+IHtcbiAgLyoqXG4gICAqIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIFdvcmtmbG93IGV4ZWN1dGlvbiBjb21wbGV0ZXNcbiAgICovXG4gIHJlc3VsdCgpOiBQcm9taXNlPFdvcmtmbG93UmVzdWx0VHlwZTxUPj47XG5cbiAgLyoqXG4gICAqIFNpZ25hbCBhIHJ1bm5pbmcgV29ya2Zsb3cuXG4gICAqXG4gICAqIEBwYXJhbSBkZWYgYSBzaWduYWwgZGVmaW5pdGlvbiBhcyByZXR1cm5lZCBmcm9tIHtAbGluayBkZWZpbmVTaWduYWx9XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGF3YWl0IGhhbmRsZS5zaWduYWwoaW5jcmVtZW50U2lnbmFsLCAzKTtcbiAgICogYGBgXG4gICAqL1xuICBzaWduYWw8QXJncyBleHRlbmRzIGFueVtdID0gW10sIE5hbWUgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+KFxuICAgIGRlZjogU2lnbmFsRGVmaW5pdGlvbjxBcmdzLCBOYW1lPiB8IHN0cmluZyxcbiAgICAuLi5hcmdzOiBBcmdzXG4gICk6IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIFRoZSB3b3JrZmxvd0lkIG9mIHRoZSBjdXJyZW50IFdvcmtmbG93XG4gICAqL1xuICByZWFkb25seSB3b3JrZmxvd0lkOiBzdHJpbmc7XG59XG4iLCJpbXBvcnQgdHlwZSB7IHRlbXBvcmFsIH0gZnJvbSAnQHRlbXBvcmFsaW8vcHJvdG8nO1xuaW1wb3J0IHsgV29ya2Zsb3cgfSBmcm9tICcuL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgUmV0cnlQb2xpY3kgfSBmcm9tICcuL3JldHJ5LXBvbGljeSc7XG5pbXBvcnQgeyBEdXJhdGlvbiB9IGZyb20gJy4vdGltZSc7XG5pbXBvcnQgeyBtYWtlUHJvdG9FbnVtQ29udmVydGVycyB9IGZyb20gJy4vaW50ZXJuYWwtd29ya2Zsb3cnO1xuaW1wb3J0IHsgU2VhcmNoQXR0cmlidXRlUGFpciwgU2VhcmNoQXR0cmlidXRlcywgVHlwZWRTZWFyY2hBdHRyaWJ1dGVzIH0gZnJvbSAnLi9zZWFyY2gtYXR0cmlidXRlcyc7XG5pbXBvcnQgeyBQcmlvcml0eSB9IGZyb20gJy4vcHJpb3JpdHknO1xuaW1wb3J0IHsgV29ya2Zsb3dGdW5jdGlvbldpdGhPcHRpb25zIH0gZnJvbSAnLi93b3JrZmxvdy1kZWZpbml0aW9uLW9wdGlvbnMnO1xuXG4vKipcbiAqIERlZmluZXMgd2hhdCBoYXBwZW5zIHdoZW4gdHJ5aW5nIHRvIHN0YXJ0IGEgV29ya2Zsb3cgd2l0aCB0aGUgc2FtZSBJRCBhcyBhICpDbG9zZWQqIFdvcmtmbG93LlxuICpcbiAqIFNlZSB7QGxpbmsgV29ya2Zsb3dPcHRpb25zLndvcmtmbG93SWRDb25mbGljdFBvbGljeX0gZm9yIHdoYXQgaGFwcGVucyB3aGVuIHRyeWluZyB0byBzdGFydCBhXG4gKiBXb3JrZmxvdyB3aXRoIHRoZSBzYW1lIElEIGFzIGEgKlJ1bm5pbmcqIFdvcmtmbG93LlxuICpcbiAqIENvbmNlcHQ6IHtAbGluayBodHRwczovL2RvY3MudGVtcG9yYWwuaW8vY29uY2VwdHMvd2hhdC1pcy1hLXdvcmtmbG93LWlkLXJldXNlLXBvbGljeS8gfCBXb3JrZmxvdyBJZCBSZXVzZSBQb2xpY3l9XG4gKlxuICogKk5vdGU6IEl0IGlzIG5vdCBwb3NzaWJsZSB0byBoYXZlIHR3byBhY3RpdmVseSBydW5uaW5nIFdvcmtmbG93cyB3aXRoIHRoZSBzYW1lIElELipcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBXb3JrZmxvd0lkUmV1c2VQb2xpY3kgPSB7XG4gIC8qKlxuICAgKiBUaGUgV29ya2Zsb3cgY2FuIGJlIHN0YXJ0ZWQgaWYgdGhlIHByZXZpb3VzIFdvcmtmbG93IGlzIGluIGEgQ2xvc2VkIHN0YXRlLlxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgQUxMT1dfRFVQTElDQVRFOiAnQUxMT1dfRFVQTElDQVRFJyxcblxuICAvKipcbiAgICogVGhlIFdvcmtmbG93IGNhbiBiZSBzdGFydGVkIGlmIHRoZSBwcmV2aW91cyBXb3JrZmxvdyBpcyBpbiBhIENsb3NlZCBzdGF0ZSB0aGF0IGlzIG5vdCBDb21wbGV0ZWQuXG4gICAqL1xuICBBTExPV19EVVBMSUNBVEVfRkFJTEVEX09OTFk6ICdBTExPV19EVVBMSUNBVEVfRkFJTEVEX09OTFknLFxuXG4gIC8qKlxuICAgKiBUaGUgV29ya2Zsb3cgY2Fubm90IGJlIHN0YXJ0ZWQuXG4gICAqL1xuICBSRUpFQ1RfRFVQTElDQVRFOiAnUkVKRUNUX0RVUExJQ0FURScsXG5cbiAgLyoqXG4gICAqIFRlcm1pbmF0ZSB0aGUgY3VycmVudCBXb3JrZmxvdyBpZiBvbmUgaXMgYWxyZWFkeSBydW5uaW5nOyBvdGhlcndpc2UgYWxsb3cgcmV1c2luZyB0aGUgV29ya2Zsb3cgSUQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgV09SS0ZMT1dfSURfUkVVU0VfUE9MSUNZX0FMTE9XX0RVUExJQ0FURX0gaW5zdGVhZCwgYW5kXG4gICAqICAgICAgICAgICAgIHNldCBgV29ya2Zsb3dPcHRpb25zLndvcmtmbG93SWRDb25mbGljdFBvbGljeWAgdG9cbiAgICogICAgICAgICAgICAge0BsaW5rIFdvcmtmbG93SWRDb25mbGljdFBvbGljeS5XT1JLRkxPV19JRF9DT05GTElDVF9QT0xJQ1lfVEVSTUlOQVRFX0VYSVNUSU5HfS5cbiAgICogICAgICAgICAgICAgV2hlbiB1c2luZyB0aGlzIG9wdGlvbiwgYFdvcmtmbG93T3B0aW9ucy53b3JrZmxvd0lkQ29uZmxpY3RQb2xpY3lgIG11c3QgYmUgbGVmdCB1bnNwZWNpZmllZC5cbiAgICovXG4gIFRFUk1JTkFURV9JRl9SVU5OSU5HOiAnVEVSTUlOQVRFX0lGX1JVTk5JTkcnLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG5cbiAgLy8vIEFueXRoaW5nIGJlbG93IHRoaXMgbGluZSBoYXMgYmVlbiBkZXByZWNhdGVkXG5cbiAgLyoqXG4gICAqIE5vIG5lZWQgdG8gdXNlIHRoaXMuIElmIGEgYFdvcmtmbG93SWRSZXVzZVBvbGljeWAgaXMgc2V0IHRvIHRoaXMsIG9yIGlzIG5vdCBzZXQgYXQgYWxsLCB0aGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHVzZWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEVpdGhlciBsZWF2ZSBwcm9wZXJ0eSBgdW5kZWZpbmVkYCwgb3IgdXNlIHtAbGluayBBTExPV19EVVBMSUNBVEV9IGluc3RlYWQuXG4gICAqL1xuICBXT1JLRkxPV19JRF9SRVVTRV9QT0xJQ1lfVU5TUEVDSUZJRUQ6IHVuZGVmaW5lZCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuXG4gIC8qKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIEFMTE9XX0RVUExJQ0FURX0gaW5zdGVhZC4gKi9cbiAgV09SS0ZMT1dfSURfUkVVU0VfUE9MSUNZX0FMTE9XX0RVUExJQ0FURTogJ0FMTE9XX0RVUExJQ0FURScsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cblxuICAvKiogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBBTExPV19EVVBMSUNBVEVfRkFJTEVEX09OTFl9IGluc3RlYWQuICovXG4gIFdPUktGTE9XX0lEX1JFVVNFX1BPTElDWV9BTExPV19EVVBMSUNBVEVfRkFJTEVEX09OTFk6ICdBTExPV19EVVBMSUNBVEVfRkFJTEVEX09OTFknLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG5cbiAgLyoqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgUkVKRUNUX0RVUExJQ0FURX0gaW5zdGVhZC4gKi9cbiAgV09SS0ZMT1dfSURfUkVVU0VfUE9MSUNZX1JFSkVDVF9EVVBMSUNBVEU6ICdSRUpFQ1RfRFVQTElDQVRFJywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuXG4gIC8qKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIFRFUk1JTkFURV9JRl9SVU5OSU5HfSBpbnN0ZWFkLiAqL1xuICBXT1JLRkxPV19JRF9SRVVTRV9QT0xJQ1lfVEVSTUlOQVRFX0lGX1JVTk5JTkc6ICdURVJNSU5BVEVfSUZfUlVOTklORycsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbn0gYXMgY29uc3Q7XG5leHBvcnQgdHlwZSBXb3JrZmxvd0lkUmV1c2VQb2xpY3kgPSAodHlwZW9mIFdvcmtmbG93SWRSZXVzZVBvbGljeSlba2V5b2YgdHlwZW9mIFdvcmtmbG93SWRSZXVzZVBvbGljeV07XG5cbmV4cG9ydCBjb25zdCBbZW5jb2RlV29ya2Zsb3dJZFJldXNlUG9saWN5LCBkZWNvZGVXb3JrZmxvd0lkUmV1c2VQb2xpY3ldID0gbWFrZVByb3RvRW51bUNvbnZlcnRlcnM8XG4gIHRlbXBvcmFsLmFwaS5lbnVtcy52MS5Xb3JrZmxvd0lkUmV1c2VQb2xpY3ksXG4gIHR5cGVvZiB0ZW1wb3JhbC5hcGkuZW51bXMudjEuV29ya2Zsb3dJZFJldXNlUG9saWN5LFxuICBrZXlvZiB0eXBlb2YgdGVtcG9yYWwuYXBpLmVudW1zLnYxLldvcmtmbG93SWRSZXVzZVBvbGljeSxcbiAgdHlwZW9mIFdvcmtmbG93SWRSZXVzZVBvbGljeSxcbiAgJ1dPUktGTE9XX0lEX1JFVVNFX1BPTElDWV8nXG4+KFxuICB7XG4gICAgW1dvcmtmbG93SWRSZXVzZVBvbGljeS5BTExPV19EVVBMSUNBVEVdOiAxLFxuICAgIFtXb3JrZmxvd0lkUmV1c2VQb2xpY3kuQUxMT1dfRFVQTElDQVRFX0ZBSUxFRF9PTkxZXTogMixcbiAgICBbV29ya2Zsb3dJZFJldXNlUG9saWN5LlJFSkVDVF9EVVBMSUNBVEVdOiAzLFxuICAgIFtXb3JrZmxvd0lkUmV1c2VQb2xpY3kuVEVSTUlOQVRFX0lGX1JVTk5JTkddOiA0LCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgVU5TUEVDSUZJRUQ6IDAsXG4gIH0gYXMgY29uc3QsXG4gICdXT1JLRkxPV19JRF9SRVVTRV9QT0xJQ1lfJ1xuKTtcblxuLyoqXG4gKiBEZWZpbmVzIHdoYXQgaGFwcGVucyB3aGVuIHRyeWluZyB0byBzdGFydCBhIFdvcmtmbG93IHdpdGggdGhlIHNhbWUgSUQgYXMgYSAqUnVubmluZyogV29ya2Zsb3cuXG4gKlxuICogU2VlIHtAbGluayBXb3JrZmxvd09wdGlvbnMud29ya2Zsb3dJZFJldXNlUG9saWN5fSBmb3Igd2hhdCBoYXBwZW5zIHdoZW4gdHJ5aW5nIHRvIHN0YXJ0IGEgV29ya2Zsb3dcbiAqIHdpdGggdGhlIHNhbWUgSUQgYXMgYSAqQ2xvc2VkKiBXb3JrZmxvdy5cbiAqXG4gKiAqTm90ZTogSXQgaXMgbmV2ZXIgcG9zc2libGUgdG8gaGF2ZSB0d28gX2FjdGl2ZWx5IHJ1bm5pbmdfIFdvcmtmbG93cyB3aXRoIHRoZSBzYW1lIElELipcbiAqL1xuZXhwb3J0IHR5cGUgV29ya2Zsb3dJZENvbmZsaWN0UG9saWN5ID0gKHR5cGVvZiBXb3JrZmxvd0lkQ29uZmxpY3RQb2xpY3kpW2tleW9mIHR5cGVvZiBXb3JrZmxvd0lkQ29uZmxpY3RQb2xpY3ldO1xuZXhwb3J0IGNvbnN0IFdvcmtmbG93SWRDb25mbGljdFBvbGljeSA9IHtcbiAgLyoqXG4gICAqIERvIG5vdCBzdGFydCBhIG5ldyBXb3JrZmxvdy4gSW5zdGVhZCByYWlzZSBhIGBXb3JrZmxvd0V4ZWN1dGlvbkFscmVhZHlTdGFydGVkRXJyb3JgLlxuICAgKi9cbiAgRkFJTDogJ0ZBSUwnLFxuXG4gIC8qKlxuICAgKiBEbyBub3Qgc3RhcnQgYSBuZXcgV29ya2Zsb3cuIEluc3RlYWQgcmV0dXJuIGEgV29ya2Zsb3cgSGFuZGxlIGZvciB0aGUgYWxyZWFkeSBSdW5uaW5nIFdvcmtmbG93LlxuICAgKi9cbiAgVVNFX0VYSVNUSU5HOiAnVVNFX0VYSVNUSU5HJyxcblxuICAvKipcbiAgICogU3RhcnQgYSBuZXcgV29ya2Zsb3csIHRlcm1pbmF0aW5nIHRoZSBjdXJyZW50IHdvcmtmbG93IGlmIG9uZSBpcyBhbHJlYWR5IHJ1bm5pbmcuXG4gICAqL1xuICBURVJNSU5BVEVfRVhJU1RJTkc6ICdURVJNSU5BVEVfRVhJU1RJTkcnLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IFtlbmNvZGVXb3JrZmxvd0lkQ29uZmxpY3RQb2xpY3ksIGRlY29kZVdvcmtmbG93SWRDb25mbGljdFBvbGljeV0gPSBtYWtlUHJvdG9FbnVtQ29udmVydGVyczxcbiAgdGVtcG9yYWwuYXBpLmVudW1zLnYxLldvcmtmbG93SWRDb25mbGljdFBvbGljeSxcbiAgdHlwZW9mIHRlbXBvcmFsLmFwaS5lbnVtcy52MS5Xb3JrZmxvd0lkQ29uZmxpY3RQb2xpY3ksXG4gIGtleW9mIHR5cGVvZiB0ZW1wb3JhbC5hcGkuZW51bXMudjEuV29ya2Zsb3dJZENvbmZsaWN0UG9saWN5LFxuICB0eXBlb2YgV29ya2Zsb3dJZENvbmZsaWN0UG9saWN5LFxuICAnV09SS0ZMT1dfSURfQ09ORkxJQ1RfUE9MSUNZXydcbj4oXG4gIHtcbiAgICBbV29ya2Zsb3dJZENvbmZsaWN0UG9saWN5LkZBSUxdOiAxLFxuICAgIFtXb3JrZmxvd0lkQ29uZmxpY3RQb2xpY3kuVVNFX0VYSVNUSU5HXTogMixcbiAgICBbV29ya2Zsb3dJZENvbmZsaWN0UG9saWN5LlRFUk1JTkFURV9FWElTVElOR106IDMsXG4gICAgVU5TUEVDSUZJRUQ6IDAsXG4gIH0gYXMgY29uc3QsXG4gICdXT1JLRkxPV19JRF9DT05GTElDVF9QT0xJQ1lfJ1xuKTtcblxuZXhwb3J0IGludGVyZmFjZSBCYXNlV29ya2Zsb3dPcHRpb25zIHtcbiAgLyoqXG4gICAqIERlZmluZXMgd2hhdCBoYXBwZW5zIHdoZW4gdHJ5aW5nIHRvIHN0YXJ0IGEgV29ya2Zsb3cgd2l0aCB0aGUgc2FtZSBJRCBhcyBhICpDbG9zZWQqIFdvcmtmbG93LlxuICAgKlxuICAgKiAqTm90ZTogSXQgaXMgbm90IHBvc3NpYmxlIHRvIGhhdmUgdHdvIGFjdGl2ZWx5IHJ1bm5pbmcgV29ya2Zsb3dzIHdpdGggdGhlIHNhbWUgSUQuKlxuICAgKlxuICAgKiBAZGVmYXVsdCB7QGxpbmsgV29ya2Zsb3dJZFJldXNlUG9saWN5LldPUktGTE9XX0lEX1JFVVNFX1BPTElDWV9BTExPV19EVVBMSUNBVEV9XG4gICAqL1xuICB3b3JrZmxvd0lkUmV1c2VQb2xpY3k/OiBXb3JrZmxvd0lkUmV1c2VQb2xpY3k7XG5cbiAgLyoqXG4gICAqIERlZmluZXMgd2hhdCBoYXBwZW5zIHdoZW4gdHJ5aW5nIHRvIHN0YXJ0IGEgV29ya2Zsb3cgd2l0aCB0aGUgc2FtZSBJRCBhcyBhICpSdW5uaW5nKiBXb3JrZmxvdy5cbiAgICpcbiAgICogKk5vdGU6IEl0IGlzIG5vdCBwb3NzaWJsZSB0byBoYXZlIHR3byBhY3RpdmVseSBydW5uaW5nIFdvcmtmbG93cyB3aXRoIHRoZSBzYW1lIElELipcbiAgICpcbiAgICogQGRlZmF1bHQge0BsaW5rIFdvcmtmbG93SWRDb25mbGljdFBvbGljeS5XT1JLRkxPV19JRF9DT05GTElDVF9QT0xJQ1lfVU5TUEVDSUZJRUR9XG4gICAqL1xuICB3b3JrZmxvd0lkQ29uZmxpY3RQb2xpY3k/OiBXb3JrZmxvd0lkQ29uZmxpY3RQb2xpY3k7XG5cbiAgLyoqXG4gICAqIENvbnRyb2xzIGhvdyBhIFdvcmtmbG93IEV4ZWN1dGlvbiBpcyByZXRyaWVkLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBXb3JrZmxvdyBFeGVjdXRpb25zIGFyZSBub3QgcmV0cmllZC4gRG8gbm90IG92ZXJyaWRlIHRoaXMgYmVoYXZpb3IgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLlxuICAgKiB7QGxpbmsgaHR0cHM6Ly9kb2NzLnRlbXBvcmFsLmlvL2NvbmNlcHRzL3doYXQtaXMtYS1yZXRyeS1wb2xpY3kvIHwgTW9yZSBpbmZvcm1hdGlvbn0uXG4gICAqL1xuICByZXRyeT86IFJldHJ5UG9saWN5O1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBjcm9uIHNjaGVkdWxlIGZvciBXb3JrZmxvdy4gSWYgYSBjcm9uIHNjaGVkdWxlIGlzIHNwZWNpZmllZCwgdGhlIFdvcmtmbG93IHdpbGwgcnVuIGFzIGEgY3JvbiBiYXNlZCBvbiB0aGVcbiAgICogc2NoZWR1bGUuIFRoZSBzY2hlZHVsaW5nIHdpbGwgYmUgYmFzZWQgb24gVVRDIHRpbWUuIFRoZSBzY2hlZHVsZSBmb3IgdGhlIG5leHQgcnVuIG9ubHkgaGFwcGVucyBhZnRlciB0aGUgY3VycmVudFxuICAgKiBydW4gaXMgY29tcGxldGVkL2ZhaWxlZC90aW1lb3V0LiBJZiBhIFJldHJ5UG9saWN5IGlzIGFsc28gc3VwcGxpZWQsIGFuZCB0aGUgV29ya2Zsb3cgZmFpbGVkIG9yIHRpbWVkIG91dCwgdGhlXG4gICAqIFdvcmtmbG93IHdpbGwgYmUgcmV0cmllZCBiYXNlZCBvbiB0aGUgcmV0cnkgcG9saWN5LiBXaGlsZSB0aGUgV29ya2Zsb3cgaXMgcmV0cnlpbmcsIGl0IHdvbid0IHNjaGVkdWxlIGl0cyBuZXh0IHJ1bi5cbiAgICogSWYgdGhlIG5leHQgc2NoZWR1bGUgaXMgZHVlIHdoaWxlIHRoZSBXb3JrZmxvdyBpcyBydW5uaW5nIChvciByZXRyeWluZyksIHRoZW4gaXQgd2lsbCBza2lwIHRoYXQgc2NoZWR1bGUuIENyb25cbiAgICogV29ya2Zsb3cgd2lsbCBub3Qgc3RvcCB1bnRpbCBpdCBpcyB0ZXJtaW5hdGVkIG9yIGNhbmNlbGxlZCAoYnkgcmV0dXJuaW5nIHRlbXBvcmFsLkNhbmNlbGVkRXJyb3IpLlxuICAgKiBodHRwczovL2Nyb250YWIuZ3VydS8gaXMgdXNlZnVsIGZvciB0ZXN0aW5nIHlvdXIgY3JvbiBleHByZXNzaW9ucy5cbiAgICovXG4gIGNyb25TY2hlZHVsZT86IHN0cmluZztcblxuICAvKipcbiAgICogU3BlY2lmaWVzIGFkZGl0aW9uYWwgbm9uLWluZGV4ZWQgaW5mb3JtYXRpb24gdG8gYXR0YWNoIHRvIHRoZSBXb3JrZmxvdyBFeGVjdXRpb24uIFRoZSB2YWx1ZXMgY2FuIGJlIGFueXRoaW5nIHRoYXRcbiAgICogaXMgc2VyaWFsaXphYmxlIGJ5IHtAbGluayBEYXRhQ29udmVydGVyfS5cbiAgICovXG4gIG1lbW8/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIGFkZGl0aW9uYWwgaW5kZXhlZCBpbmZvcm1hdGlvbiB0byBhdHRhY2ggdG8gdGhlIFdvcmtmbG93IEV4ZWN1dGlvbi4gTW9yZSBpbmZvOlxuICAgKiBodHRwczovL2RvY3MudGVtcG9yYWwuaW8vZG9jcy90eXBlc2NyaXB0L3NlYXJjaC1hdHRyaWJ1dGVzXG4gICAqXG4gICAqIFZhbHVlcyBhcmUgYWx3YXlzIGNvbnZlcnRlZCB1c2luZyB7QGxpbmsgSnNvblBheWxvYWRDb252ZXJ0ZXJ9LCBldmVuIHdoZW4gYSBjdXN0b20gZGF0YSBjb252ZXJ0ZXIgaXMgcHJvdmlkZWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgdHlwZWRTZWFyY2hBdHRyaWJ1dGVzfSBpbnN0ZWFkLlxuICAgKi9cbiAgc2VhcmNoQXR0cmlidXRlcz86IFNlYXJjaEF0dHJpYnV0ZXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cblxuICAvKipcbiAgICogU3BlY2lmaWVzIGFkZGl0aW9uYWwgaW5kZXhlZCBpbmZvcm1hdGlvbiB0byBhdHRhY2ggdG8gdGhlIFdvcmtmbG93IEV4ZWN1dGlvbi4gTW9yZSBpbmZvOlxuICAgKiBodHRwczovL2RvY3MudGVtcG9yYWwuaW8vZG9jcy90eXBlc2NyaXB0L3NlYXJjaC1hdHRyaWJ1dGVzXG4gICAqXG4gICAqIFZhbHVlcyBhcmUgYWx3YXlzIGNvbnZlcnRlZCB1c2luZyB7QGxpbmsgSnNvblBheWxvYWRDb252ZXJ0ZXJ9LCBldmVuIHdoZW4gYSBjdXN0b20gZGF0YSBjb252ZXJ0ZXIgaXMgcHJvdmlkZWQuXG4gICAqIE5vdGUgdGhhdCBzZWFyY2ggYXR0cmlidXRlcyBhcmUgbm90IGVuY29kZWQsIGFzIHN1Y2gsIGRvIG5vdCBpbmNsdWRlIGFueSBzZW5zaXRpdmUgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIElmIGJvdGgge0BsaW5rIHNlYXJjaEF0dHJpYnV0ZXN9IGFuZCB7QGxpbmsgdHlwZWRTZWFyY2hBdHRyaWJ1dGVzfSBhcmUgcHJvdmlkZWQsIGNvbmZsaWN0aW5nIGtleXMgd2lsbCBiZSBvdmVyd3JpdHRlblxuICAgKiBieSB7QGxpbmsgdHlwZWRTZWFyY2hBdHRyaWJ1dGVzfS5cbiAgICovXG4gIHR5cGVkU2VhcmNoQXR0cmlidXRlcz86IFNlYXJjaEF0dHJpYnV0ZVBhaXJbXSB8IFR5cGVkU2VhcmNoQXR0cmlidXRlcztcblxuICAvKipcbiAgICogR2VuZXJhbCBmaXhlZCBkZXRhaWxzIGZvciB0aGlzIHdvcmtmbG93IGV4ZWN1dGlvbiB0aGF0IG1heSBhcHBlYXIgaW4gVUkvQ0xJLlxuICAgKiBUaGlzIGNhbiBiZSBpbiBUZW1wb3JhbCBtYXJrZG93biBmb3JtYXQgYW5kIGNhbiBzcGFuIG11bHRpcGxlIGxpbmVzLlxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsIFVzZXIgbWV0YWRhdGEgaXMgYSBuZXcgQVBJIGFuZCBzdXNjZXB0aWJsZSB0byBjaGFuZ2UuXG4gICAqL1xuICBzdGF0aWNEZXRhaWxzPzogc3RyaW5nO1xuICAvKipcbiAgICogQSBzaW5nbGUtbGluZSBmaXhlZCBzdW1tYXJ5IGZvciB0aGlzIHdvcmtmbG93IGV4ZWN1dGlvbiB0aGF0IG1heSBhcHBlYXIgaW4gdGhlIFVJL0NMSS5cbiAgICogVGhpcyBjYW4gYmUgaW4gc2luZ2xlLWxpbmUgVGVtcG9yYWwgbWFya2Rvd24gZm9ybWF0LlxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsIFVzZXIgbWV0YWRhdGEgaXMgYSBuZXcgQVBJIGFuZCBzdXNjZXB0aWJsZSB0byBjaGFuZ2UuXG4gICAqL1xuICBzdGF0aWNTdW1tYXJ5Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBQcmlvcml0eSBvZiBhIHdvcmtmbG93XG4gICAqL1xuICBwcmlvcml0eT86IFByaW9yaXR5O1xufVxuXG5leHBvcnQgdHlwZSBXaXRoV29ya2Zsb3dBcmdzPFcgZXh0ZW5kcyBXb3JrZmxvdywgVD4gPSBUICZcbiAgKFBhcmFtZXRlcnM8Vz4gZXh0ZW5kcyBbYW55LCAuLi5hbnlbXV1cbiAgICA/IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBXb3JrZmxvd1xuICAgICAgICAgKi9cbiAgICAgICAgYXJnczogUGFyYW1ldGVyczxXPiB8IFJlYWRvbmx5PFBhcmFtZXRlcnM8Vz4+O1xuICAgICAgfVxuICAgIDoge1xuICAgICAgICAvKipcbiAgICAgICAgICogQXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIFdvcmtmbG93XG4gICAgICAgICAqL1xuICAgICAgICBhcmdzPzogUGFyYW1ldGVyczxXPiB8IFJlYWRvbmx5PFBhcmFtZXRlcnM8Vz4+O1xuICAgICAgfSk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgV29ya2Zsb3dEdXJhdGlvbk9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHRpbWUgYWZ0ZXIgd2hpY2ggd29ya2Zsb3cgcnVuIGlzIGF1dG9tYXRpY2FsbHkgdGVybWluYXRlZCBieSBUZW1wb3JhbCBzZXJ2aWNlLiBEbyBub3RcbiAgICogcmVseSBvbiBydW4gdGltZW91dCBmb3IgYnVzaW5lc3MgbGV2ZWwgdGltZW91dHMuIEl0IGlzIHByZWZlcnJlZCB0byB1c2UgaW4gd29ya2Zsb3cgdGltZXJzXG4gICAqIGZvciB0aGlzIHB1cnBvc2UuXG4gICAqXG4gICAqIEBmb3JtYXQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvciB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXMgfCBtcy1mb3JtYXR0ZWQgc3RyaW5nfVxuICAgKi9cbiAgd29ya2Zsb3dSdW5UaW1lb3V0PzogRHVyYXRpb247XG5cbiAgLyoqXG4gICAqXG4gICAqIFRoZSB0aW1lIGFmdGVyIHdoaWNoIHdvcmtmbG93IGV4ZWN1dGlvbiAod2hpY2ggaW5jbHVkZXMgcnVuIHJldHJpZXMgYW5kIGNvbnRpbnVlIGFzIG5ldykgaXNcbiAgICogYXV0b21hdGljYWxseSB0ZXJtaW5hdGVkIGJ5IFRlbXBvcmFsIHNlcnZpY2UuIERvIG5vdCByZWx5IG9uIGV4ZWN1dGlvbiB0aW1lb3V0IGZvciBidXNpbmVzc1xuICAgKiBsZXZlbCB0aW1lb3V0cy4gSXQgaXMgcHJlZmVycmVkIHRvIHVzZSBpbiB3b3JrZmxvdyB0aW1lcnMgZm9yIHRoaXMgcHVycG9zZS5cbiAgICpcbiAgICogQGZvcm1hdCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9yIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tcyB8IG1zLWZvcm1hdHRlZCBzdHJpbmd9XG4gICAqL1xuICB3b3JrZmxvd0V4ZWN1dGlvblRpbWVvdXQ/OiBEdXJhdGlvbjtcblxuICAvKipcbiAgICogTWF4aW11bSBleGVjdXRpb24gdGltZSBvZiBhIHNpbmdsZSB3b3JrZmxvdyB0YXNrLiBEZWZhdWx0IGlzIDEwIHNlY29uZHMuXG4gICAqXG4gICAqIEBmb3JtYXQgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvciB7QGxpbmsgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbXMgfCBtcy1mb3JtYXR0ZWQgc3RyaW5nfVxuICAgKi9cbiAgd29ya2Zsb3dUYXNrVGltZW91dD86IER1cmF0aW9uO1xufVxuXG5leHBvcnQgdHlwZSBDb21tb25Xb3JrZmxvd09wdGlvbnMgPSBCYXNlV29ya2Zsb3dPcHRpb25zICYgV29ya2Zsb3dEdXJhdGlvbk9wdGlvbnM7XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0V29ya2Zsb3dUeXBlPFQgZXh0ZW5kcyBXb3JrZmxvdz4oXG4gIHdvcmtmbG93VHlwZU9yRnVuYzogc3RyaW5nIHwgVCB8IFdvcmtmbG93RnVuY3Rpb25XaXRoT3B0aW9uczxhbnlbXSwgYW55PlxuKTogc3RyaW5nIHtcbiAgaWYgKHR5cGVvZiB3b3JrZmxvd1R5cGVPckZ1bmMgPT09ICdzdHJpbmcnKSByZXR1cm4gd29ya2Zsb3dUeXBlT3JGdW5jIGFzIHN0cmluZztcbiAgaWYgKHR5cGVvZiB3b3JrZmxvd1R5cGVPckZ1bmMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAod29ya2Zsb3dUeXBlT3JGdW5jPy5uYW1lKSByZXR1cm4gd29ya2Zsb3dUeXBlT3JGdW5jLm5hbWU7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB3b3JrZmxvdyB0eXBlOiB0aGUgd29ya2Zsb3cgZnVuY3Rpb24gaXMgYW5vbnltb3VzJyk7XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICBgSW52YWxpZCB3b3JrZmxvdyB0eXBlOiBleHBlY3RlZCBlaXRoZXIgYSBzdHJpbmcgb3IgYSBmdW5jdGlvbiwgZ290ICcke3R5cGVvZiB3b3JrZmxvd1R5cGVPckZ1bmN9J2BcbiAgKTtcbn1cbiIsIi8vIEEgcG9ydCBvZiBhbiBhbGdvcml0aG0gYnkgSm9oYW5uZXMgQmFhZ8O4ZSA8YmFhZ29lQGJhYWdvZS5jb20+LCAyMDEwXG4vLyBodHRwOi8vYmFhZ29lLmNvbS9lbi9SYW5kb21NdXNpbmdzL2phdmFzY3JpcHQvXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbnF1aW5sYW4vYmV0dGVyLXJhbmRvbS1udW1iZXJzLWZvci1qYXZhc2NyaXB0LW1pcnJvclxuLy8gT3JpZ2luYWwgd29yayBpcyB1bmRlciBNSVQgbGljZW5zZSAtXG5cbi8vIENvcHlyaWdodCAoQykgMjAxMCBieSBKb2hhbm5lcyBCYWFnw7hlIDxiYWFnb2VAYmFhZ29lLm9yZz5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vLyBUYWtlbiBhbmQgbW9kaWZpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZGF2aWRiYXUvc2VlZHJhbmRvbS9ibG9iL3JlbGVhc2VkL2xpYi9hbGVhLmpzXG5cbmNsYXNzIEFsZWEge1xuICBwdWJsaWMgYzogbnVtYmVyO1xuICBwdWJsaWMgczA6IG51bWJlcjtcbiAgcHVibGljIHMxOiBudW1iZXI7XG4gIHB1YmxpYyBzMjogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHNlZWQ6IG51bWJlcltdKSB7XG4gICAgY29uc3QgbWFzaCA9IG5ldyBNYXNoKCk7XG4gICAgLy8gQXBwbHkgdGhlIHNlZWRpbmcgYWxnb3JpdGhtIGZyb20gQmFhZ29lLlxuICAgIHRoaXMuYyA9IDE7XG4gICAgdGhpcy5zMCA9IG1hc2gubWFzaChbMzJdKTtcbiAgICB0aGlzLnMxID0gbWFzaC5tYXNoKFszMl0pO1xuICAgIHRoaXMuczIgPSBtYXNoLm1hc2goWzMyXSk7XG4gICAgdGhpcy5zMCAtPSBtYXNoLm1hc2goc2VlZCk7XG4gICAgaWYgKHRoaXMuczAgPCAwKSB7XG4gICAgICB0aGlzLnMwICs9IDE7XG4gICAgfVxuICAgIHRoaXMuczEgLT0gbWFzaC5tYXNoKHNlZWQpO1xuICAgIGlmICh0aGlzLnMxIDwgMCkge1xuICAgICAgdGhpcy5zMSArPSAxO1xuICAgIH1cbiAgICB0aGlzLnMyIC09IG1hc2gubWFzaChzZWVkKTtcbiAgICBpZiAodGhpcy5zMiA8IDApIHtcbiAgICAgIHRoaXMuczIgKz0gMTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgbmV4dCgpOiBudW1iZXIge1xuICAgIGNvbnN0IHQgPSAyMDkxNjM5ICogdGhpcy5zMCArIHRoaXMuYyAqIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7IC8vIDJeLTMyXG4gICAgdGhpcy5zMCA9IHRoaXMuczE7XG4gICAgdGhpcy5zMSA9IHRoaXMuczI7XG4gICAgcmV0dXJuICh0aGlzLnMyID0gdCAtICh0aGlzLmMgPSB0IHwgMCkpO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIFJORyA9ICgpID0+IG51bWJlcjtcblxuZXhwb3J0IGZ1bmN0aW9uIGFsZWEoc2VlZDogbnVtYmVyW10pOiBSTkcge1xuICBjb25zdCB4ZyA9IG5ldyBBbGVhKHNlZWQpO1xuICByZXR1cm4geGcubmV4dC5iaW5kKHhnKTtcbn1cblxuZXhwb3J0IGNsYXNzIE1hc2gge1xuICBwcml2YXRlIG4gPSAweGVmYzgyNDlkO1xuXG4gIHB1YmxpYyBtYXNoKGRhdGE6IG51bWJlcltdKTogbnVtYmVyIHtcbiAgICBsZXQgeyBuIH0gPSB0aGlzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgbiArPSBkYXRhW2ldO1xuICAgICAgbGV0IGggPSAwLjAyNTE5NjAzMjgyNDE2OTM4ICogbjtcbiAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgaCAtPSBuO1xuICAgICAgaCAqPSBuO1xuICAgICAgbiA9IGggPj4+IDA7XG4gICAgICBoIC09IG47XG4gICAgICBuICs9IGggKiAweDEwMDAwMDAwMDsgLy8gMl4zMlxuICAgIH1cbiAgICB0aGlzLm4gPSBuO1xuICAgIHJldHVybiAobiA+Pj4gMCkgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuICB9XG59XG4iLCJpbXBvcnQgdHlwZSB7IEFzeW5jTG9jYWxTdG9yYWdlIGFzIEFMUyB9IGZyb20gJ25vZGU6YXN5bmNfaG9va3MnO1xuaW1wb3J0IHsgQ2FuY2VsbGVkRmFpbHVyZSwgRHVyYXRpb24sIElsbGVnYWxTdGF0ZUVycm9yIH0gZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uJztcbmltcG9ydCB7IG1zT3B0aW9uYWxUb051bWJlciB9IGZyb20gJ0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvdGltZSc7XG5pbXBvcnQgeyB1bnRyYWNrUHJvbWlzZSB9IGZyb20gJy4vc3RhY2staGVscGVycyc7XG5pbXBvcnQgeyBnZXRBY3RpdmF0b3IgfSBmcm9tICcuL2dsb2JhbC1hdHRyaWJ1dGVzJztcbmltcG9ydCB7IFNka0ZsYWdzIH0gZnJvbSAnLi9mbGFncyc7XG5cbi8vIEFzeW5jTG9jYWxTdG9yYWdlIGlzIGluamVjdGVkIHZpYSB2bSBtb2R1bGUgaW50byBnbG9iYWwgc2NvcGUuXG4vLyBJbiBjYXNlIFdvcmtmbG93IGNvZGUgaXMgaW1wb3J0ZWQgaW4gTm9kZS5qcyBjb250ZXh0LCByZXBsYWNlIHdpdGggYW4gZW1wdHkgY2xhc3MuXG5leHBvcnQgY29uc3QgQXN5bmNMb2NhbFN0b3JhZ2U6IG5ldyA8VD4oKSA9PiBBTFM8VD4gPSAoZ2xvYmFsVGhpcyBhcyBhbnkpLkFzeW5jTG9jYWxTdG9yYWdlID8/IGNsYXNzIHt9O1xuXG4vKiogTWFnaWMgc3ltYm9sIHVzZWQgdG8gY3JlYXRlIHRoZSByb290IHNjb3BlIC0gaW50ZW50aW9uYWxseSBub3QgZXhwb3J0ZWQgKi9cbmNvbnN0IE5PX1BBUkVOVCA9IFN5bWJvbCgnTk9fUEFSRU5UJyk7XG5cbi8qKlxuICogT3B0aW9uIGZvciBjb25zdHJ1Y3RpbmcgYSBDYW5jZWxsYXRpb25TY29wZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIENhbmNlbGxhdGlvblNjb3BlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaW1lIGluIG1pbGxpc2Vjb25kcyBiZWZvcmUgdGhlIHNjb3BlIGNhbmNlbGxhdGlvbiBpcyBhdXRvbWF0aWNhbGx5IHJlcXVlc3RlZFxuICAgKi9cbiAgdGltZW91dD86IER1cmF0aW9uO1xuXG4gIC8qKlxuICAgKiBJZiBmYWxzZSwgcHJldmVudCBvdXRlciBjYW5jZWxsYXRpb24gZnJvbSBwcm9wYWdhdGluZyB0byBpbm5lciBzY29wZXMsIEFjdGl2aXRpZXMsIHRpbWVycywgYW5kIFRyaWdnZXJzLCBkZWZhdWx0cyB0byB0cnVlLlxuICAgKiAoU2NvcGUgc3RpbGwgcHJvcGFnYXRlcyBDYW5jZWxsZWRGYWlsdXJlIHRocm93biBmcm9tIHdpdGhpbikuXG4gICAqL1xuICBjYW5jZWxsYWJsZTogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIENhbmNlbGxhdGlvblNjb3BlICh1c2VmdWwgZm9yIHJ1bm5pbmcgYmFja2dyb3VuZCB0YXNrcykuXG4gICAqIFRoZSBgTk9fUEFSRU5UYCBzeW1ib2wgaXMgcmVzZXJ2ZWQgZm9yIHRoZSByb290IHNjb3BlLlxuICAgKi9cbiAgcGFyZW50PzogQ2FuY2VsbGF0aW9uU2NvcGUgfCB0eXBlb2YgTk9fUEFSRU5UO1xufVxuXG4vKipcbiAqIENhbmNlbGxhdGlvbiBTY29wZXMgcHJvdmlkZSB0aGUgbWVjaGFuaWMgYnkgd2hpY2ggYSBXb3JrZmxvdyBtYXkgZ3JhY2VmdWxseSBoYW5kbGUgaW5jb21pbmcgcmVxdWVzdHMgZm9yIGNhbmNlbGxhdGlvblxuICogKGUuZy4gaW4gcmVzcG9uc2UgdG8ge0BsaW5rIFdvcmtmbG93SGFuZGxlLmNhbmNlbH0gb3IgdGhyb3VnaCB0aGUgVUkgb3IgQ0xJKSwgYXMgd2VsbCBhcyByZXF1ZXN0IGNhbmNlbGF0aW9uIG9mXG4gKiBjYW5jZWxsYWJsZSBvcGVyYXRpb25zIGl0IG93bnMgKGUuZy4gQWN0aXZpdGllcywgVGltZXJzLCBDaGlsZCBXb3JrZmxvd3MsIGV0YykuXG4gKlxuICogQ2FuY2VsbGF0aW9uIFNjb3BlcyBmb3JtIGEgdHJlZSwgd2l0aCB0aGUgV29ya2Zsb3cncyBtYWluIGZ1bmN0aW9uIHJ1bm5pbmcgaW4gdGhlIHJvb3Qgc2NvcGUgb2YgdGhhdCB0cmVlLlxuICogQnkgZGVmYXVsdCwgY2FuY2VsbGF0aW9uIHByb3BhZ2F0ZXMgZG93biBmcm9tIGEgcGFyZW50IHNjb3BlIHRvIGl0cyBjaGlsZHJlbiBhbmQgaXRzIGNhbmNlbGxhYmxlIG9wZXJhdGlvbnMuXG4gKiBBIG5vbi1jYW5jZWxsYWJsZSBzY29wZSBjYW4gcmVjZWl2ZSBjYW5jZWxsYXRpb24gcmVxdWVzdHMsIGJ1dCBpcyBuZXZlciBlZmZlY3RpdmVseSBjb25zaWRlcmVkIGFzIGNhbmNlbGxlZCxcbiAqIHRodXMgc2hpZWxkZGluZyBpdHMgY2hpbGRyZW4gYW5kIGNhbmNlbGxhYmxlIG9wZXJhdGlvbnMgZnJvbSBwcm9wYWdhdGlvbiBvZiBjYW5jZWxsYXRpb24gcmVxdWVzdHMgaXQgcmVjZWl2ZXMuXG4gKlxuICogU2NvcGVzIGFyZSBjcmVhdGVkIHVzaW5nIHRoZSBgQ2FuY2VsbGF0aW9uU2NvcGVgIGNvbnN0cnVjdG9yIG9yIHRoZSBzdGF0aWMgaGVscGVyIG1ldGhvZHMge0BsaW5rIGNhbmNlbGxhYmxlfSxcbiAqIHtAbGluayBub25DYW5jZWxsYWJsZX0gYW5kIHtAbGluayB3aXRoVGltZW91dH0uIGB3aXRoVGltZW91dGAgY3JlYXRlcyBhIHNjb3BlIHRoYXQgYXV0b21hdGljYWxseSBjYW5jZWxzIGl0c2VsZiBhZnRlclxuICogc29tZSBkdXJhdGlvbi5cbiAqXG4gKiBDYW5jZWxsYXRpb24gb2YgYSBjYW5jZWxsYWJsZSBzY29wZSByZXN1bHRzIGluIGFsbCBvcGVyYXRpb25zIGNyZWF0ZWQgZGlyZWN0bHkgaW4gdGhhdCBzY29wZSB0byB0aHJvdyBhXG4gKiB7QGxpbmsgQ2FuY2VsbGVkRmFpbHVyZX0gKGVpdGhlciBkaXJlY3RseSwgb3IgYXMgdGhlIGBjYXVzZWAgb2YgYW4ge0BsaW5rIEFjdGl2aXR5RmFpbHVyZX0gb3IgYVxuICoge0BsaW5rIENoaWxkV29ya2Zsb3dGYWlsdXJlfSkuIEZ1cnRoZXIgYXR0ZW1wdCB0byBjcmVhdGUgbmV3IGNhbmNlbGxhYmxlIHNjb3BlcyBvciBjYW5jZWxsYWJsZSBvcGVyYXRpb25zIHdpdGhpbiBhXG4gKiBzY29wZSB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkIHdpbGwgYWxzbyBpbW1lZGlhdGVseSB0aHJvdyBhIHtAbGluayBDYW5jZWxsZWRGYWlsdXJlfSBleGNlcHRpb24uIEl0IGlzIGhvd2V2ZXJcbiAqIHBvc3NpYmxlIHRvIGNyZWF0ZSBhIG5vbi1jYW5jZWxsYWJsZSBzY29wZSBhdCB0aGF0IHBvaW50OyB0aGlzIGlzIG9mdGVuIHVzZWQgdG8gZXhlY3V0ZSByb2xsYmFjayBvciBjbGVhbnVwXG4gKiBvcGVyYXRpb25zLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGB0c1xuICogYXN5bmMgZnVuY3Rpb24gbXlXb3JrZmxvdyguLi4pOiBQcm9taXNlPHZvaWQ+IHtcbiAqICAgdHJ5IHtcbiAqICAgICAvLyBUaGlzIGFjdGl2aXR5IHJ1bnMgaW4gdGhlIHJvb3QgY2FuY2VsbGF0aW9uIHNjb3BlLiBUaGVyZWZvcmUsIGEgY2FuY2VsYXRpb24gcmVxdWVzdCBvblxuICogICAgIC8vIHRoZSBXb3JrZmxvdyBleGVjdXRpb24gKGUuZy4gdGhyb3VnaCB0aGUgVUkgb3IgQ0xJKSBhdXRvbWF0aWNhbGx5IHByb3BhZ2F0ZXMgdG8gdGhpc1xuICogICAgIC8vIGFjdGl2aXR5LiBBc3N1bWluZyB0aGF0IHRoZSBhY3Rpdml0eSBwcm9wZXJseSBoYW5kbGUgdGhlIGNhbmNlbGxhdGlvbiByZXF1ZXN0LCB0aGVuIHRoZVxuICogICAgIC8vIGNhbGwgYmVsb3cgd2lsbCB0aHJvdyBhbiBgQWN0aXZpdHlGYWlsdXJlYCBleGNlcHRpb24sIHdpdGggYGNhdXNlYCBzZXRzIHRvIGFuXG4gKiAgICAgLy8gaW5zdGFuY2Ugb2YgYENhbmNlbGxlZEZhaWx1cmVgLlxuICogICAgIGF3YWl0IHNvbWVBY3Rpdml0eSgpO1xuICogICB9IGNhdGNoIChlKSB7XG4gKiAgICAgaWYgKGlzQ2FuY2VsbGF0aW9uKGUpKSB7XG4gKiAgICAgICAvLyBSdW4gY2xlYW51cCBhY3Rpdml0eSBpbiBhIG5vbi1jYW5jZWxsYWJsZSBzY29wZVxuICogICAgICAgYXdhaXQgQ2FuY2VsbGF0aW9uU2NvcGUubm9uQ2FuY2VsbGFibGUoYXN5bmMgKCkgPT4ge1xuICogICAgICAgICBhd2FpdCBjbGVhbnVwQWN0aXZpdHkoKTtcbiAqICAgICAgIH1cbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgdGhyb3cgZTtcbiAqICAgICB9XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEEgY2FuY2VsbGFibGUgc2NvcGUgbWF5IGJlIHByb2dyYW1hdGljYWxseSBjYW5jZWxsZWQgYnkgY2FsbGluZyB7QGxpbmsgY2FuY2VsfGBzY29wZS5jYW5jZWwoKWB9YC4gVGhpcyBtYXkgYmUgdXNlZCxcbiAqIGZvciBleGFtcGxlLCB0byBleHBsaWNpdGx5IHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIEFjdGl2aXR5IG9yIENoaWxkIFdvcmtmbG93OlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBjYW5jZWxsYWJsZUFjdGl2aXR5U2NvcGUgPSBuZXcgQ2FuY2VsbGF0aW9uU2NvcGUoKTtcbiAqIGNvbnN0IGFjdGl2aXR5UHJvbWlzZSA9IGNhbmNlbGxhYmxlQWN0aXZpdHlTY29wZS5ydW4oKCkgPT4gc29tZUFjdGl2aXR5KCkpO1xuICogY2FuY2VsbGFibGVBY3Rpdml0eVNjb3BlLmNhbmNlbCgpOyAvLyBDYW5jZWxzIHRoZSBhY3Rpdml0eVxuICogYXdhaXQgYWN0aXZpdHlQcm9taXNlOyAvLyBUaHJvd3MgYEFjdGl2aXR5RmFpbHVyZWAgd2l0aCBgY2F1c2VgIHNldCB0byBgQ2FuY2VsbGVkRmFpbHVyZWBcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQ2FuY2VsbGF0aW9uU2NvcGUge1xuICAvKipcbiAgICogVGltZSBpbiBtaWxsaXNlY29uZHMgYmVmb3JlIHRoZSBzY29wZSBjYW5jZWxsYXRpb24gaXMgYXV0b21hdGljYWxseSByZXF1ZXN0ZWRcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSB0aW1lb3V0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBJZiBmYWxzZSwgdGhlbiB0aGlzIHNjb3BlIHdpbGwgbmV2ZXIgYmUgY29uc2lkZXJlZCBjYW5jZWxsZWQsIGV2ZW4gaWYgYSBjYW5jZWxsYXRpb24gcmVxdWVzdCBpcyByZWNlaXZlZCAoZWl0aGVyXG4gICAqIGRpcmVjdGx5IGJ5IGNhbGxpbmcgYHNjb3BlLmNhbmNlbCgpYCBvciBpbmRpcmVjdGx5IGJ5IGNhbmNlbGxpbmcgYSBjYW5jZWxsYWJsZSBwYXJlbnQgc2NvcGUpLiBUaGlzIGVmZmVjdGl2ZWx5XG4gICAqIHNoaWVsZHMgdGhlIHNjb3BlJ3MgY2hpbGRyZW4gYW5kIGNhbmNlbGxhYmxlIG9wZXJhdGlvbnMgZnJvbSBwcm9wYWdhdGlvbiBvZiBjYW5jZWxsYXRpb24gcmVxdWVzdHMgbWFkZSBvbiB0aGVcbiAgICogbm9uLWNhbmNlbGxhYmxlIHNjb3BlLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIFByb21pc2UgcmV0dXJuZWQgYnkgdGhlIGBydW5gIGZ1bmN0aW9uIG9mIG5vbi1jYW5jZWxsYWJsZSBzY29wZSBtYXkgc3RpbGwgdGhyb3cgYSBgQ2FuY2VsbGVkRmFpbHVyZWBcbiAgICogaWYgc3VjaCBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gd2l0aGluIHRoYXQgc2NvcGUgKGUuZy4gYnkgZGlyZWN0bHkgY2FuY2VsbGluZyBhIGNhbmNlbGxhYmxlIGNoaWxkIHNjb3BlKS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBjYW5jZWxsYWJsZTogYm9vbGVhbjtcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgQ2FuY2VsbGF0aW9uU2NvcGUgKHVzZWZ1bCBmb3IgcnVubmluZyBiYWNrZ3JvdW5kIHRhc2tzKSwgZGVmYXVsdHMgdG8ge0BsaW5rIENhbmNlbGxhdGlvblNjb3BlLmN1cnJlbnR9KClcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBwYXJlbnQ/OiBDYW5jZWxsYXRpb25TY29wZTtcblxuICAvKipcbiAgICogQSBQcm9taXNlIHRoYXQgdGhyb3dzIHdoZW4gYSBjYW5jZWxsYWJsZSBzY29wZSByZWNlaXZlcyBhIGNhbmNlbGxhdGlvbiByZXF1ZXN0LCBlaXRoZXIgZGlyZWN0bHlcbiAgICogKGkuZS4gYHNjb3BlLmNhbmNlbCgpYCksIG9yIGluZGlyZWN0bHkgKGJ5IGNhbmNlbGxpbmcgYSBjYW5jZWxsYWJsZSBwYXJlbnQgc2NvcGUpLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgYSBub24tY2FuY2VsbGFibGUgc2NvcGUgbWF5IHJlY2VpdmUgY2FuY2VsbGF0aW9uIHJlcXVlc3RzLCByZXN1bHRpbmcgaW4gdGhlIGBjYW5jZWxSZXF1ZXN0ZWRgIHByb21pc2UgZm9yXG4gICAqIHRoYXQgc2NvcGUgdG8gdGhyb3csIHRob3VnaCB0aGUgc2NvcGUgd2lsbCBub3QgZWZmZWN0aXZlbHkgZ2V0IGNhbmNlbGxlZCAoaS5lLiBgY29uc2lkZXJlZENhbmNlbGxlZGAgd2lsbCBzdGlsbFxuICAgKiByZXR1cm4gYGZhbHNlYCwgYW5kIGNhbmNlbGxhdGlvbiB3aWxsIG5vdCBiZSBwcm9wYWdhdGVkIHRvIGNoaWxkIHNjb3BlcyBhbmQgY29udGFpbmVkIG9wZXJhdGlvbnMpLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGNhbmNlbFJlcXVlc3RlZDogUHJvbWlzZTxuZXZlcj47XG5cbiAgI2NhbmNlbFJlcXVlc3RlZCA9IGZhbHNlO1xuXG4gIC8vIFR5cGVzY3JpcHQgZG9lcyBub3QgdW5kZXJzdGFuZCB0aGF0IHRoZSBQcm9taXNlIGV4ZWN1dG9yIHJ1bnMgc3luY2hyb25vdXNseSBpbiB0aGUgY29uc3RydWN0b3JcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAvLyBAdHMtaWdub3JlXG4gIHByb3RlY3RlZCByZWFkb25seSByZWplY3Q6IChyZWFzb24/OiBhbnkpID0+IHZvaWQ7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucz86IENhbmNlbGxhdGlvblNjb3BlT3B0aW9ucykge1xuICAgIHRoaXMudGltZW91dCA9IG1zT3B0aW9uYWxUb051bWJlcihvcHRpb25zPy50aW1lb3V0KTtcbiAgICB0aGlzLmNhbmNlbGxhYmxlID0gb3B0aW9ucz8uY2FuY2VsbGFibGUgPz8gdHJ1ZTtcbiAgICB0aGlzLmNhbmNlbFJlcXVlc3RlZCA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFNDIGRvZXNuJ3QgdW5kZXJzdGFuZCB0aGF0IHRoZSBQcm9taXNlIGV4ZWN1dG9yIHJ1bnMgc3luY2hyb25vdXNseVxuICAgICAgdGhpcy5yZWplY3QgPSAoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMuI2NhbmNlbFJlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICB1bnRyYWNrUHJvbWlzZSh0aGlzLmNhbmNlbFJlcXVlc3RlZCk7XG4gICAgLy8gQXZvaWQgdW5oYW5kbGVkIHJlamVjdGlvbnNcbiAgICB1bnRyYWNrUHJvbWlzZSh0aGlzLmNhbmNlbFJlcXVlc3RlZC5jYXRjaCgoKSA9PiB1bmRlZmluZWQpKTtcbiAgICBpZiAob3B0aW9ucz8ucGFyZW50ICE9PSBOT19QQVJFTlQpIHtcbiAgICAgIHRoaXMucGFyZW50ID0gb3B0aW9ucz8ucGFyZW50IHx8IENhbmNlbGxhdGlvblNjb3BlLmN1cnJlbnQoKTtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5wYXJlbnQuY2FuY2VsbGFibGUgfHxcbiAgICAgICAgKHRoaXMucGFyZW50LiNjYW5jZWxSZXF1ZXN0ZWQgJiZcbiAgICAgICAgICAhZ2V0QWN0aXZhdG9yKCkuaGFzRmxhZyhTZGtGbGFncy5Ob25DYW5jZWxsYWJsZVNjb3Blc0FyZVNoaWVsZGVkRnJvbVByb3BhZ2F0aW9uKSlcbiAgICAgICkge1xuICAgICAgICB0aGlzLiNjYW5jZWxSZXF1ZXN0ZWQgPSB0aGlzLnBhcmVudC4jY2FuY2VsUmVxdWVzdGVkO1xuICAgICAgICB1bnRyYWNrUHJvbWlzZShcbiAgICAgICAgICB0aGlzLnBhcmVudC5jYW5jZWxSZXF1ZXN0ZWQuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWplY3QoZXJyKTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW50cmFja1Byb21pc2UoXG4gICAgICAgICAgdGhpcy5wYXJlbnQuY2FuY2VsUmVxdWVzdGVkLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmICghZ2V0QWN0aXZhdG9yKCkuaGFzRmxhZyhTZGtGbGFncy5Ob25DYW5jZWxsYWJsZVNjb3Blc0FyZVNoaWVsZGVkRnJvbVByb3BhZ2F0aW9uKSkge1xuICAgICAgICAgICAgICB0aGlzLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHNjb3BlIHdhcyBlZmZlY3RpdmVseSBjYW5jZWxsZWQuIEEgbm9uLWNhbmNlbGxhYmxlIHNjb3BlIGNhbiBuZXZlciBiZSBjb25zaWRlcmVkIGNhbmNlbGxlZC5cbiAgICovXG4gIHB1YmxpYyBnZXQgY29uc2lkZXJlZENhbmNlbGxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy4jY2FuY2VsUmVxdWVzdGVkICYmIHRoaXMuY2FuY2VsbGFibGU7XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGUgdGhlIHNjb3BlIGFzIGN1cnJlbnQgYW5kIHJ1biAgYGZuYFxuICAgKlxuICAgKiBBbnkgdGltZXJzLCBBY3Rpdml0aWVzLCBUcmlnZ2VycyBhbmQgQ2FuY2VsbGF0aW9uU2NvcGVzIGNyZWF0ZWQgaW4gdGhlIGJvZHkgb2YgYGZuYFxuICAgKiBhdXRvbWF0aWNhbGx5IGxpbmsgdGhlaXIgY2FuY2VsbGF0aW9uIHRvIHRoaXMgc2NvcGUuXG4gICAqXG4gICAqIEByZXR1cm4gdGhlIHJlc3VsdCBvZiBgZm5gXG4gICAqL1xuICBydW48VD4oZm46ICgpID0+IFByb21pc2U8VD4pOiBQcm9taXNlPFQ+IHtcbiAgICByZXR1cm4gc3RvcmFnZS5ydW4odGhpcywgdGhpcy5ydW5JbkNvbnRleHQuYmluZCh0aGlzLCBmbikgYXMgKCkgPT4gUHJvbWlzZTxUPik7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHRoYXQgcnVucyBhIGZ1bmN0aW9uIGluIEFzeW5jTG9jYWxTdG9yYWdlIGNvbnRleHQuXG4gICAqXG4gICAqIENvdWxkIGhhdmUgYmVlbiB3cml0dGVuIGFzIGFub255bW91cyBmdW5jdGlvbiwgbWFkZSBpbnRvIGEgbWV0aG9kIGZvciBpbXByb3ZlZCBzdGFjayB0cmFjZXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgcnVuSW5Db250ZXh0PFQ+KGZuOiAoKSA9PiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XG4gICAgbGV0IHRpbWVyU2NvcGU6IENhbmNlbGxhdGlvblNjb3BlIHwgdW5kZWZpbmVkO1xuICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIHRpbWVyU2NvcGUgPSBuZXcgQ2FuY2VsbGF0aW9uU2NvcGUoKTtcbiAgICAgIHVudHJhY2tQcm9taXNlKFxuICAgICAgICB0aW1lclNjb3BlXG4gICAgICAgICAgLnJ1bigoKSA9PiBzbGVlcCh0aGlzLnRpbWVvdXQgYXMgbnVtYmVyKSlcbiAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICgpID0+IHRoaXMuY2FuY2VsKCksXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgIC8vIHNjb3BlIHdhcyBhbHJlYWR5IGNhbmNlbGxlZCwgaWdub3JlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRpbWVyU2NvcGUgJiZcbiAgICAgICAgIXRpbWVyU2NvcGUuY29uc2lkZXJlZENhbmNlbGxlZCAmJlxuICAgICAgICBnZXRBY3RpdmF0b3IoKS5oYXNGbGFnKFNka0ZsYWdzLk5vbkNhbmNlbGxhYmxlU2NvcGVzQXJlU2hpZWxkZWRGcm9tUHJvcGFnYXRpb24pXG4gICAgICApIHtcbiAgICAgICAgdGltZXJTY29wZS5jYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byBjYW5jZWwgdGhlIHNjb3BlIGFuZCBsaW5rZWQgY2hpbGRyZW5cbiAgICovXG4gIGNhbmNlbCgpOiB2b2lkIHtcbiAgICB0aGlzLnJlamVjdChuZXcgQ2FuY2VsbGVkRmFpbHVyZSgnQ2FuY2VsbGF0aW9uIHNjb3BlIGNhbmNlbGxlZCcpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgXCJhY3RpdmVcIiBzY29wZVxuICAgKi9cbiAgc3RhdGljIGN1cnJlbnQoKTogQ2FuY2VsbGF0aW9uU2NvcGUge1xuICAgIC8vIFVzaW5nIGdsb2JhbHMgZGlyZWN0bHkgaW5zdGVhZCBvZiBhIGhlbHBlciBmdW5jdGlvbiB0byBhdm9pZCBjaXJjdWxhciBpbXBvcnRcbiAgICByZXR1cm4gc3RvcmFnZS5nZXRTdG9yZSgpID8/IChnbG9iYWxUaGlzIGFzIGFueSkuX19URU1QT1JBTF9BQ1RJVkFUT1JfXy5yb290U2NvcGU7XG4gIH1cblxuICAvKiogQWxpYXMgdG8gYG5ldyBDYW5jZWxsYXRpb25TY29wZSh7IGNhbmNlbGxhYmxlOiB0cnVlIH0pLnJ1bihmbilgICovXG4gIHN0YXRpYyBjYW5jZWxsYWJsZTxUPihmbjogKCkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICAgIHJldHVybiBuZXcgdGhpcyh7IGNhbmNlbGxhYmxlOiB0cnVlIH0pLnJ1bihmbik7XG4gIH1cblxuICAvKiogQWxpYXMgdG8gYG5ldyBDYW5jZWxsYXRpb25TY29wZSh7IGNhbmNlbGxhYmxlOiBmYWxzZSB9KS5ydW4oZm4pYCAqL1xuICBzdGF0aWMgbm9uQ2FuY2VsbGFibGU8VD4oZm46ICgpID0+IFByb21pc2U8VD4pOiBQcm9taXNlPFQ+IHtcbiAgICByZXR1cm4gbmV3IHRoaXMoeyBjYW5jZWxsYWJsZTogZmFsc2UgfSkucnVuKGZuKTtcbiAgfVxuXG4gIC8qKiBBbGlhcyB0byBgbmV3IENhbmNlbGxhdGlvblNjb3BlKHsgY2FuY2VsbGFibGU6IHRydWUsIHRpbWVvdXQgfSkucnVuKGZuKWAgKi9cbiAgc3RhdGljIHdpdGhUaW1lb3V0PFQ+KHRpbWVvdXQ6IER1cmF0aW9uLCBmbjogKCkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICAgIHJldHVybiBuZXcgdGhpcyh7IGNhbmNlbGxhYmxlOiB0cnVlLCB0aW1lb3V0IH0pLnJ1bihmbik7XG4gIH1cbn1cblxuY29uc3Qgc3RvcmFnZSA9IG5ldyBBc3luY0xvY2FsU3RvcmFnZTxDYW5jZWxsYXRpb25TY29wZT4oKTtcblxuLyoqXG4gKiBBdm9pZCBleHBvc2luZyB0aGUgc3RvcmFnZSBkaXJlY3RseSBzbyBpdCBkb2Vzbid0IGdldCBmcm96ZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVTdG9yYWdlKCk6IHZvaWQge1xuICBzdG9yYWdlLmRpc2FibGUoKTtcbn1cblxuZXhwb3J0IGNsYXNzIFJvb3RDYW5jZWxsYXRpb25TY29wZSBleHRlbmRzIENhbmNlbGxhdGlvblNjb3BlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoeyBjYW5jZWxsYWJsZTogdHJ1ZSwgcGFyZW50OiBOT19QQVJFTlQgfSk7XG4gIH1cblxuICBjYW5jZWwoKTogdm9pZCB7XG4gICAgdGhpcy5yZWplY3QobmV3IENhbmNlbGxlZEZhaWx1cmUoJ1dvcmtmbG93IGNhbmNlbGxlZCcpKTtcbiAgfVxufVxuXG4vKiogVGhpcyBmdW5jdGlvbiBpcyBoZXJlIHRvIGF2b2lkIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSBiZXR3ZWVuIHRoaXMgbW9kdWxlIGFuZCB3b3JrZmxvdy50cyAqL1xubGV0IHNsZWVwID0gKF86IER1cmF0aW9uKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFcnJvcignV29ya2Zsb3cgaGFzIG5vdCBiZWVuIHByb3Blcmx5IGluaXRpYWxpemVkJyk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJTbGVlcEltcGxlbWVudGF0aW9uKGZuOiB0eXBlb2Ygc2xlZXApOiB2b2lkIHtcbiAgc2xlZXAgPSBmbjtcbn1cbiIsImltcG9ydCB7IEFjdGl2aXR5RmFpbHVyZSwgQ2FuY2VsbGVkRmFpbHVyZSwgQ2hpbGRXb3JrZmxvd0ZhaWx1cmUsIE5leHVzT3BlcmF0aW9uRmFpbHVyZSB9IGZyb20gJ0B0ZW1wb3JhbGlvL2NvbW1vbic7XG5pbXBvcnQgeyBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvciB9IGZyb20gJ0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvdHlwZS1oZWxwZXJzJztcbmltcG9ydCB7IGNvcmVzZGsgfSBmcm9tICdAdGVtcG9yYWxpby9wcm90byc7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIHdvcmtmbG93IGVycm9yc1xuICovXG5AU3ltYm9sQmFzZWRJbnN0YW5jZU9mRXJyb3IoJ1dvcmtmbG93RXJyb3InKVxuZXhwb3J0IGNsYXNzIFdvcmtmbG93RXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG4vKipcbiAqIFRocm93biBpbiB3b3JrZmxvdyB3aGVuIGl0IHRyaWVzIHRvIGRvIHNvbWV0aGluZyB0aGF0IG5vbi1kZXRlcm1pbmlzdGljIHN1Y2ggYXMgY29uc3RydWN0IGEgV2Vha1JlZigpXG4gKi9cbkBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvcignRGV0ZXJtaW5pc21WaW9sYXRpb25FcnJvcicpXG5leHBvcnQgY2xhc3MgRGV0ZXJtaW5pc21WaW9sYXRpb25FcnJvciBleHRlbmRzIFdvcmtmbG93RXJyb3Ige31cblxuLyoqXG4gKiBBIGNsYXNzIHRoYXQgYWN0cyBhcyBhIG1hcmtlciBmb3IgdGhpcyBzcGVjaWFsIHJlc3VsdCB0eXBlXG4gKi9cbkBTeW1ib2xCYXNlZEluc3RhbmNlT2ZFcnJvcignTG9jYWxBY3Rpdml0eURvQmFja29mZicpXG5leHBvcnQgY2xhc3MgTG9jYWxBY3Rpdml0eURvQmFja29mZiBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGJhY2tvZmY6IGNvcmVzZGsuYWN0aXZpdHlfcmVzdWx0LklEb0JhY2tvZmYpIHtcbiAgICBzdXBlcigpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHByb3ZpZGVkIGBlcnJgIGlzIGNhdXNlZCBieSBjYW5jZWxsYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ2FuY2VsbGF0aW9uKGVycjogdW5rbm93bik6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIGVyciBpbnN0YW5jZW9mIENhbmNlbGxlZEZhaWx1cmUgfHxcbiAgICAoKGVyciBpbnN0YW5jZW9mIEFjdGl2aXR5RmFpbHVyZSB8fCBlcnIgaW5zdGFuY2VvZiBDaGlsZFdvcmtmbG93RmFpbHVyZSB8fCBlcnIgaW5zdGFuY2VvZiBOZXh1c09wZXJhdGlvbkZhaWx1cmUpICYmXG4gICAgICBlcnIuY2F1c2UgaW5zdGFuY2VvZiBDYW5jZWxsZWRGYWlsdXJlKVxuICApO1xufVxuIiwiaW1wb3J0IHR5cGUgeyBXb3JrZmxvd0luZm8gfSBmcm9tICcuL2ludGVyZmFjZXMnO1xuXG5leHBvcnQgdHlwZSBTZGtGbGFnID0ge1xuICBnZXQgaWQoKTogbnVtYmVyO1xuICBnZXQgZGVmYXVsdCgpOiBib29sZWFuO1xuICBnZXQgYWx0ZXJuYXRpdmVDb25kaXRpb25zKCk6IEFsdENvbmRpdGlvbkZuW10gfCB1bmRlZmluZWQ7XG59O1xuXG5jb25zdCBmbGFnc1JlZ2lzdHJ5OiBNYXA8bnVtYmVyLCBTZGtGbGFnPiA9IG5ldyBNYXAoKTtcblxuZXhwb3J0IGNvbnN0IFNka0ZsYWdzID0ge1xuICAvKipcbiAgICogVGhpcyBmbGFnIGdhdGVzIG11bHRpcGxlIGZpeGVzIHJlbGF0ZWQgdG8gY2FuY2VsbGF0aW9uIHNjb3BlcyBhbmQgdGltZXJzIGludHJvZHVjZWQgaW4gMS4xMC4yLzEuMTEuMDpcbiAgICogLSBDYW5jZWxsYXRpb24gb2YgYSBub24tY2FuY2VsbGFibGUgc2NvcGUgbm8gbG9uZ2VyIHByb3BhZ2F0ZXMgdG8gY2hpbGRyZW4gc2NvcGVzXG4gICAqICAgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vdGVtcG9yYWxpby9zZGstdHlwZXNjcmlwdC9pc3N1ZXMvMTQyMykuXG4gICAqIC0gQ2FuY2VsbGF0aW9uU2NvcGUud2l0aFRpbWVvdXQoZm4pIG5vdyBjYW5jZWwgdGhlIHRpbWVyIGlmIGBmbmAgY29tcGxldGVzIGJlZm9yZSBleHBpcmF0aW9uXG4gICAqICAgb2YgdGhlIHRpbWVvdXQsIHNpbWlsYXIgdG8gaG93IGBjb25kaXRpb24oZm4sIHRpbWVvdXQpYCB3b3Jrcy5cbiAgICogLSBUaW1lcnMgY3JlYXRlZCB1c2luZyBzZXRUaW1lb3V0IGNhbiBub3cgYmUgaW50ZXJjZXB0ZWQuXG4gICAqXG4gICAqIEBzaW5jZSBJbnRyb2R1Y2VkIGluIDEuMTAuMi8xLjExLjAuIEhvd2V2ZXIsIGR1ZSB0byBhbiBTREsgYnVnLCBTREtzIHYxLjExLjAgYW5kIHYxLjExLjEgd2VyZSBub3RcbiAgICogICAgICAgIHByb3Blcmx5IHdyaXRpbmcgYmFjayB0aGUgZmxhZ3MgdG8gaGlzdG9yeSwgcG9zc2libHkgcmVzdWx0aW5nIGluIE5ERSBvbiByZXBsYXkuIFdlIHRoZXJlZm9yZVxuICAgKiAgICAgICAgY29uc2lkZXIgdGhhdCBhIFdGVCBlbWl0dGVkIGJ5IFdvcmtlciB2MS4xMS4wIG9yIHYxLjExLjEgdG8gaW1wbGljaXRseSBoYXZlIHRoaXMgZmxhZyBvbi5cbiAgICovXG4gIE5vbkNhbmNlbGxhYmxlU2NvcGVzQXJlU2hpZWxkZWRGcm9tUHJvcGFnYXRpb246IGRlZmluZUZsYWcoMSwgdHJ1ZSwgW2J1aWxkSWRTZGtWZXJzaW9uTWF0Y2hlcygvMVxcLjExXFwuWzAxXS8pXSksXG5cbiAgLyoqXG4gICAqIFByaW9yIHRvIDEuMTEuMCwgd2hlbiBwcm9jZXNzaW5nIGEgV29ya2Zsb3cgYWN0aXZhdGlvbiwgdGhlIFNESyB3b3VsZCBleGVjdXRlIGBub3RpZnlIYXNQYXRjaGBcbiAgICogYW5kIGBzaWduYWxXb3JrZmxvd2Agam9icyBpbiBkaXN0aW5jdCBwaGFzZXMsIGJlZm9yZSBvdGhlciB0eXBlcyBvZiBqb2JzLiBUaGUgcHJpbWFyeSByZWFzb25cbiAgICogYmVoaW5kIHRoYXQgbXVsdGktcGhhc2UgYWxnb3JpdGhtIHdhcyB0byBhdm9pZCB0aGUgcG9zc2liaWxpdHkgdGhhdCBhIFdvcmtmbG93IGV4ZWN1dGlvbiBtaWdodFxuICAgKiBjb21wbGV0ZSBiZWZvcmUgYWxsIGluY29taW5nIHNpZ25hbHMgaGF2ZSBiZWVuIGRpc3BhdGNoZWQgKGF0IGxlYXN0IHRvIHRoZSBwb2ludCB0aGF0IHRoZVxuICAgKiBfc3luY2hyb25vdXNfIHBhcnQgb2YgdGhlIGhhbmRsZXIgZnVuY3Rpb24gaGFzIGJlZW4gZXhlY3V0ZWQpLlxuICAgKlxuICAgKiBUaGlzIGZsYWcgcmVwbGFjZXMgdGhhdCBtdWx0aS1waGFzZSBhbGdvcml0aG0gd2l0aCBhIHNpbXBsZXIgb25lIHdoZXJlIGpvYnMgYXJlIHNpbXBseSBzb3J0ZWQgYXNcbiAgICogYChzaWduYWxzIGFuZCB1cGRhdGVzKSAtPiBvdGhlcnNgLCBidXQgd2l0aG91dCBwcm9jZXNzaW5nIHRoZW0gYXMgZGlzdGluY3QgYmF0Y2hlcyAoaS5lLiB3aXRob3V0XG4gICAqIGxlYXZpbmcvcmVlbnRlcmluZyB0aGUgVk0gY29udGV4dCBiZXR3ZWVuIGVhY2ggZ3JvdXAsIHdoaWNoIGF1dG9tYXRpY2FsbHkgdHJpZ2dlcnMgdGhlIGV4ZWN1dGlvblxuICAgKiBvZiBhbGwgb3V0c3RhbmRpbmcgbWljcm90YXNrcykuIFRoYXQgc2luZ2xlLXBoYXNlIGFwcHJvYWNoIHJlc29sdmVzIGEgbnVtYmVyIG9mIHF1aXJrcyBvZiB0aGVcbiAgICogZm9ybWVyIGFsZ29yaXRobSwgYW5kIHlldCBzdGlsbCBzYXRpc2ZpZXMgdG8gdGhlIG9yaWdpbmFsIHJlcXVpcmVtZW50IG9mIGVuc3VyaW5nIHRoYXQgZXZlcnlcbiAgICogYHNpZ25hbFdvcmtmbG93YCBqb2JzIC0gYW5kIG5vdyBgZG9VcGRhdGVgIGpvYnMgYXMgd2VsbCAtIGhhdmUgYmVlbiBnaXZlbiBhIHByb3BlciBjaGFuY2UgdG9cbiAgICogZXhlY3V0ZSBiZWZvcmUgdGhlIFdvcmtmbG93IG1haW4gZnVuY3Rpb24gbWlnaHQgY29tcGxldGVzLlxuICAgKlxuICAgKiBAc2luY2UgSW50cm9kdWNlZCBpbiAxLjExLjAuIFRoaXMgY2hhbmdlIGlzIG5vdCByb2xsYmFjay1zYWZlLiBIb3dldmVyLCBkdWUgdG8gYW4gU0RLIGJ1ZywgU0RLc1xuICAgKiAgICAgICAgdjEuMTEuMCBhbmQgdjEuMTEuMSB3ZXJlIG5vdCBwcm9wZXJseSB3cml0aW5nIGJhY2sgdGhlIGZsYWdzIHRvIGhpc3RvcnksIHBvc3NpYmx5IHJlc3VsdGluZ1xuICAgKiAgICAgICAgaW4gTkRFIG9uIHJlcGxheS4gV2UgdGhlcmVmb3JlIGNvbnNpZGVyIHRoYXQgYSBXRlQgZW1pdHRlZCBieSBXb3JrZXIgdjEuMTEuMCBvciB2MS4xMS4xXG4gICAqICAgICAgICB0byBpbXBsaWNpdGVseSBoYXZlIHRoaXMgZmxhZyBvbi5cbiAgICovXG4gIFByb2Nlc3NXb3JrZmxvd0FjdGl2YXRpb25Kb2JzQXNTaW5nbGVCYXRjaDogZGVmaW5lRmxhZygyLCB0cnVlLCBbYnVpbGRJZFNka1ZlcnNpb25NYXRjaGVzKC8xXFwuMTFcXC5bMDFdLyldKSxcbn0gYXMgY29uc3Q7XG5cbmZ1bmN0aW9uIGRlZmluZUZsYWcoaWQ6IG51bWJlciwgZGVmOiBib29sZWFuLCBhbHRlcm5hdGl2ZUNvbmRpdGlvbnM/OiBBbHRDb25kaXRpb25GbltdKTogU2RrRmxhZyB7XG4gIGNvbnN0IGZsYWcgPSB7IGlkLCBkZWZhdWx0OiBkZWYsIGFsdGVybmF0aXZlQ29uZGl0aW9ucyB9O1xuICBmbGFnc1JlZ2lzdHJ5LnNldChpZCwgZmxhZyk7XG4gIHJldHVybiBmbGFnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0VmFsaWRGbGFnKGlkOiBudW1iZXIpOiB2b2lkIHtcbiAgaWYgKCFmbGFnc1JlZ2lzdHJ5LmhhcyhpZCkpIHRocm93IG5ldyBUeXBlRXJyb3IoYFVua25vd24gU0RLIGZsYWc6ICR7aWR9YCk7XG59XG5cbi8qKlxuICogQW4gU0RLIEZsYWcgQWx0ZXJuYXRlIENvbmRpdGlvbiBwcm92aWRlcyBhbiBhbHRlcm5hdGl2ZSB3YXkgb2YgZGV0ZXJtaW5pbmcgd2hldGhlciBhIGZsYWdcbiAqIHNob3VsZCBiZSBjb25zaWRlcmVkIGFzIGVuYWJsZWQgZm9yIHRoZSBjdXJyZW50IFdGVDsgZS5nLiBieSBsb29raW5nIGF0IHRoZSB2ZXJzaW9uIG9mIHRoZSBTREtcbiAqIHRoYXQgZW1pdHRlZCBhIFdGVC4gVGhlIG1haW4gdXNlIGNhc2UgZm9yIHRoaXMgaXMgdG8gcmV0cm9hY3RpdmVseSB0dXJuIG9uIHNvbWUgZmxhZ3MgZm9yIFdGVFxuICogZW1pdHRlZCBieSBwcmV2aW91cyBTREtzIHRoYXQgY29udGFpbmVkIGEgYnVnLlxuICpcbiAqIE5vdGUgdGhhdCBjb25kaXRpb25zIGFyZSBvbmx5IGV2YWx1YXRlZCB3aGlsZSByZXBsYXlpbmcsIGFuZCBvbmx5IGlmIHRoZSBjb3JyZXNwb25pbmcgZmxhZyBpc1xuICogbm90IGFscmVhZHkgc2V0LiBBbHNvLCBhbHRlcm5hdGUgY29uZGl0aW9ucyB3aWxsIG5vdCBjYXVzZSB0aGUgZmxhZyB0byBiZSBwZXJzaXN0ZWQgdG8gdGhlXG4gKiBcInVzZWQgZmxhZ3NcIiBzZXQsIHdoaWNoIG1lYW5zIHRoYXQgZnVydGhlciBXb3JrZmxvdyBUYXNrcyBtYXkgbm90IHJlZmxlY3QgdGhpcyBmbGFnIGlmIHRoZVxuICogY29uZGl0aW9uIG5vIGxvbmdlciBob2xkcy4gVGhpcyBpcyBzbyB0byBhdm9pZCBpbmNvcnJlY3QgYmVoYXZpb3JzIGluIGNhc2Ugd2hlcmUgYSBXb3JrZmxvd1xuICogRXhlY3V0aW9uIGhhcyBnb25lIHRocm91Z2ggYSBuZXdlciBTREsgdmVyc2lvbiB0aGVuIGFnYWluIHRocm91Z2ggYW4gb2xkZXIgb25lLlxuICovXG50eXBlIEFsdENvbmRpdGlvbkZuID0gKGN0eDogeyBpbmZvOiBXb3JrZmxvd0luZm8gfSkgPT4gYm9vbGVhbjtcblxuZnVuY3Rpb24gYnVpbGRJZFNka1ZlcnNpb25NYXRjaGVzKHZlcnNpb246IFJlZ0V4cCk6IEFsdENvbmRpdGlvbkZuIHtcbiAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGBeQHRlbXBvcmFsaW8vd29ya2VyQCgke3ZlcnNpb24uc291cmNlfSlbK11gKTtcbiAgcmV0dXJuICh7IGluZm8gfSkgPT4gaW5mby5jdXJyZW50QnVpbGRJZCAhPSBudWxsICYmIHJlZ2V4LnRlc3QoaW5mby5jdXJyZW50QnVpbGRJZCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbn1cbiIsImltcG9ydCB7IElsbGVnYWxTdGF0ZUVycm9yIH0gZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uJztcbmltcG9ydCB7IHR5cGUgQWN0aXZhdG9yIH0gZnJvbSAnLi9pbnRlcm5hbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVHZXRBY3RpdmF0b3JVbnR5cGVkKCk6IHVua25vd24ge1xuICByZXR1cm4gKGdsb2JhbFRoaXMgYXMgYW55KS5fX1RFTVBPUkFMX0FDVElWQVRPUl9fO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0QWN0aXZhdG9yVW50eXBlZChhY3RpdmF0b3I6IHVua25vd24pOiB2b2lkIHtcbiAgKGdsb2JhbFRoaXMgYXMgYW55KS5fX1RFTVBPUkFMX0FDVElWQVRPUl9fID0gYWN0aXZhdG9yO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVHZXRBY3RpdmF0b3IoKTogQWN0aXZhdG9yIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIG1heWJlR2V0QWN0aXZhdG9yVW50eXBlZCgpIGFzIEFjdGl2YXRvciB8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEluV29ya2Zsb3dDb250ZXh0KG1lc3NhZ2U6IHN0cmluZyk6IEFjdGl2YXRvciB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IG1heWJlR2V0QWN0aXZhdG9yKCk7XG4gIGlmIChhY3RpdmF0b3IgPT0gbnVsbCkgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gYWN0aXZhdG9yO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWN0aXZhdG9yKCk6IEFjdGl2YXRvciB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IG1heWJlR2V0QWN0aXZhdG9yKCk7XG4gIGlmIChhY3RpdmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFcnJvcignV29ya2Zsb3cgdW5pbml0aWFsaXplZCcpO1xuICB9XG4gIHJldHVybiBhY3RpdmF0b3I7XG59XG4iLCIvKipcbiAqIE92ZXJyaWRlcyBzb21lIGdsb2JhbCBvYmplY3RzIHRvIG1ha2UgdGhlbSBkZXRlcm1pbmlzdGljLlxuICpcbiAqIEBtb2R1bGVcbiAqL1xuaW1wb3J0IHsgbXNUb1RzIH0gZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uL2xpYi90aW1lJztcbmltcG9ydCB7IENhbmNlbGxhdGlvblNjb3BlIH0gZnJvbSAnLi9jYW5jZWxsYXRpb24tc2NvcGUnO1xuaW1wb3J0IHsgRGV0ZXJtaW5pc21WaW9sYXRpb25FcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IGdldEFjdGl2YXRvciB9IGZyb20gJy4vZ2xvYmFsLWF0dHJpYnV0ZXMnO1xuaW1wb3J0IHsgU2RrRmxhZ3MgfSBmcm9tICcuL2ZsYWdzJztcbmltcG9ydCB7IHNsZWVwIH0gZnJvbSAnLi93b3JrZmxvdyc7XG5pbXBvcnQgeyB1bnRyYWNrUHJvbWlzZSB9IGZyb20gJy4vc3RhY2staGVscGVycyc7XG5cbmNvbnN0IGdsb2JhbCA9IGdsb2JhbFRoaXMgYXMgYW55O1xuY29uc3QgT3JpZ2luYWxEYXRlID0gZ2xvYmFsVGhpcy5EYXRlO1xuXG5leHBvcnQgZnVuY3Rpb24gb3ZlcnJpZGVHbG9iYWxzKCk6IHZvaWQge1xuICAvLyBNb2NrIGFueSB3ZWFrIHJlZmVyZW5jZSBiZWNhdXNlIEdDIGlzIG5vbi1kZXRlcm1pbmlzdGljIGFuZCB0aGUgZWZmZWN0IGlzIG9ic2VydmFibGUgZnJvbSB0aGUgV29ya2Zsb3cuXG4gIC8vIFdvcmtmbG93IGRldmVsb3BlciB3aWxsIGdldCBhIG1lYW5pbmdmdWwgZXhjZXB0aW9uIGlmIHRoZXkgdHJ5IHRvIHVzZSB0aGVzZS5cbiAgZ2xvYmFsLldlYWtSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IERldGVybWluaXNtVmlvbGF0aW9uRXJyb3IoJ1dlYWtSZWYgY2Fubm90IGJlIHVzZWQgaW4gV29ya2Zsb3dzIGJlY2F1c2UgdjggR0MgaXMgbm9uLWRldGVybWluaXN0aWMnKTtcbiAgfTtcbiAgZ2xvYmFsLkZpbmFsaXphdGlvblJlZ2lzdHJ5ID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBEZXRlcm1pbmlzbVZpb2xhdGlvbkVycm9yKFxuICAgICAgJ0ZpbmFsaXphdGlvblJlZ2lzdHJ5IGNhbm5vdCBiZSB1c2VkIGluIFdvcmtmbG93cyBiZWNhdXNlIHY4IEdDIGlzIG5vbi1kZXRlcm1pbmlzdGljJ1xuICAgICk7XG4gIH07XG5cbiAgZ2xvYmFsLkRhdGUgPSBmdW5jdGlvbiAoLi4uYXJnczogdW5rbm93bltdKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIG5ldyAoT3JpZ2luYWxEYXRlIGFzIGFueSkoLi4uYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgT3JpZ2luYWxEYXRlKGdldEFjdGl2YXRvcigpLm5vdyk7XG4gIH07XG5cbiAgZ2xvYmFsLkRhdGUubm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRBY3RpdmF0b3IoKS5ub3c7XG4gIH07XG5cbiAgZ2xvYmFsLkRhdGUucGFyc2UgPSBPcmlnaW5hbERhdGUucGFyc2UuYmluZChPcmlnaW5hbERhdGUpO1xuICBnbG9iYWwuRGF0ZS5VVEMgPSBPcmlnaW5hbERhdGUuVVRDLmJpbmQoT3JpZ2luYWxEYXRlKTtcblxuICBnbG9iYWwuRGF0ZS5wcm90b3R5cGUgPSBPcmlnaW5hbERhdGUucHJvdG90eXBlO1xuXG4gIGNvbnN0IHRpbWVvdXRDYW5jZWxhdGlvblNjb3BlcyA9IG5ldyBNYXA8bnVtYmVyLCBDYW5jZWxsYXRpb25TY29wZT4oKTtcblxuICAvKipcbiAgICogQHBhcmFtIG1zIHNsZWVwIGR1cmF0aW9uIC0gIG51bWJlciBvZiBtaWxsaXNlY29uZHMuIElmIGdpdmVuIGEgbmVnYXRpdmUgbnVtYmVyLCB2YWx1ZSB3aWxsIGJlIHNldCB0byAxLlxuICAgKi9cbiAgZ2xvYmFsLnNldFRpbWVvdXQgPSBmdW5jdGlvbiAoY2I6ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55LCBtczogbnVtYmVyLCAuLi5hcmdzOiBhbnlbXSk6IG51bWJlciB7XG4gICAgbXMgPSBNYXRoLm1heCgxLCBtcyk7XG4gICAgY29uc3QgYWN0aXZhdG9yID0gZ2V0QWN0aXZhdG9yKCk7XG4gICAgaWYgKGFjdGl2YXRvci5oYXNGbGFnKFNka0ZsYWdzLk5vbkNhbmNlbGxhYmxlU2NvcGVzQXJlU2hpZWxkZWRGcm9tUHJvcGFnYXRpb24pKSB7XG4gICAgICAvLyBDYXB0dXJlIHRoZSBzZXF1ZW5jZSBudW1iZXIgdGhhdCBzbGVlcCB3aWxsIGFsbG9jYXRlXG4gICAgICBjb25zdCBzZXEgPSBhY3RpdmF0b3IubmV4dFNlcXMudGltZXI7XG4gICAgICBjb25zdCB0aW1lclNjb3BlID0gbmV3IENhbmNlbGxhdGlvblNjb3BlKHsgY2FuY2VsbGFibGU6IHRydWUgfSk7XG4gICAgICBjb25zdCBzbGVlcFByb21pc2UgPSB0aW1lclNjb3BlLnJ1bigoKSA9PiBzbGVlcChtcykpO1xuICAgICAgc2xlZXBQcm9taXNlLnRoZW4oXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICB0aW1lb3V0Q2FuY2VsYXRpb25TY29wZXMuZGVsZXRlKHNlcSk7XG4gICAgICAgICAgY2IoLi4uYXJncyk7XG4gICAgICAgIH0sXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICB0aW1lb3V0Q2FuY2VsYXRpb25TY29wZXMuZGVsZXRlKHNlcSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICB1bnRyYWNrUHJvbWlzZShzbGVlcFByb21pc2UpO1xuICAgICAgdGltZW91dENhbmNlbGF0aW9uU2NvcGVzLnNldChzZXEsIHRpbWVyU2NvcGUpO1xuICAgICAgcmV0dXJuIHNlcTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2VxID0gYWN0aXZhdG9yLm5leHRTZXFzLnRpbWVyKys7XG4gICAgICAvLyBDcmVhdGUgYSBQcm9taXNlIGZvciBBc3luY0xvY2FsU3RvcmFnZSB0byBiZSBhYmxlIHRvIHRyYWNrIHRoaXMgY29tcGxldGlvbiB1c2luZyBwcm9taXNlIGhvb2tzLlxuICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBhY3RpdmF0b3IuY29tcGxldGlvbnMudGltZXIuc2V0KHNlcSwgeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgICAgIGFjdGl2YXRvci5wdXNoQ29tbWFuZCh7XG4gICAgICAgICAgc3RhcnRUaW1lcjoge1xuICAgICAgICAgICAgc2VxLFxuICAgICAgICAgICAgc3RhcnRUb0ZpcmVUaW1lb3V0OiBtc1RvVHMobXMpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfSkudGhlbihcbiAgICAgICAgKCkgPT4gY2IoLi4uYXJncyksXG4gICAgICAgICgpID0+IHVuZGVmaW5lZCAvKiBpZ25vcmUgY2FuY2VsbGF0aW9uICovXG4gICAgICApO1xuICAgICAgcmV0dXJuIHNlcTtcbiAgICB9XG4gIH07XG5cbiAgZ2xvYmFsLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uIChoYW5kbGU6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IGFjdGl2YXRvciA9IGdldEFjdGl2YXRvcigpO1xuICAgIGNvbnN0IHRpbWVyU2NvcGUgPSB0aW1lb3V0Q2FuY2VsYXRpb25TY29wZXMuZ2V0KGhhbmRsZSk7XG4gICAgaWYgKHRpbWVyU2NvcGUpIHtcbiAgICAgIHRpbWVvdXRDYW5jZWxhdGlvblNjb3Blcy5kZWxldGUoaGFuZGxlKTtcbiAgICAgIHRpbWVyU2NvcGUuY2FuY2VsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjdGl2YXRvci5uZXh0U2Vxcy50aW1lcisrOyAvLyBTaG91bGRuJ3QgaW5jcmVhc2Ugc2VxIG51bWJlciwgYnV0IHRoYXQncyB0aGUgbGVnYWN5IGJlaGF2aW9yXG4gICAgICBhY3RpdmF0b3IuY29tcGxldGlvbnMudGltZXIuZGVsZXRlKGhhbmRsZSk7XG4gICAgICBhY3RpdmF0b3IucHVzaENvbW1hbmQoe1xuICAgICAgICBjYW5jZWxUaW1lcjoge1xuICAgICAgICAgIHNlcTogaGFuZGxlLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGFjdGl2YXRvci5yYW5kb20gaXMgbXV0YWJsZSwgZG9uJ3QgaGFyZGNvZGUgaXRzIHJlZmVyZW5jZVxuICBNYXRoLnJhbmRvbSA9ICgpID0+IGdldEFjdGl2YXRvcigpLnJhbmRvbSgpO1xufVxuIiwiLyoqXG4gKiBUaGlzIGxpYnJhcnkgcHJvdmlkZXMgdG9vbHMgcmVxdWlyZWQgZm9yIGF1dGhvcmluZyB3b3JrZmxvd3MuXG4gKlxuICogIyMgVXNhZ2VcbiAqIFNlZSB0aGUge0BsaW5rIGh0dHBzOi8vZG9jcy50ZW1wb3JhbC5pby90eXBlc2NyaXB0L2hlbGxvLXdvcmxkI3dvcmtmbG93cyB8IHR1dG9yaWFsfSBmb3Igd3JpdGluZyB5b3VyIGZpcnN0IHdvcmtmbG93LlxuICpcbiAqICMjIyBUaW1lcnNcbiAqXG4gKiBUaGUgcmVjb21tZW5kZWQgd2F5IG9mIHNjaGVkdWxpbmcgdGltZXJzIGlzIGJ5IHVzaW5nIHRoZSB7QGxpbmsgc2xlZXB9IGZ1bmN0aW9uLiBXZSd2ZSByZXBsYWNlZCBgc2V0VGltZW91dGAgYW5kXG4gKiBgY2xlYXJUaW1lb3V0YCB3aXRoIGRldGVybWluaXN0aWMgdmVyc2lvbnMgc28gdGhlc2UgYXJlIGFsc28gdXNhYmxlIGJ1dCBoYXZlIGEgbGltaXRhdGlvbiB0aGF0IHRoZXkgZG9uJ3QgcGxheSB3ZWxsXG4gKiB3aXRoIHtAbGluayBodHRwczovL2RvY3MudGVtcG9yYWwuaW8vdHlwZXNjcmlwdC9jYW5jZWxsYXRpb24tc2NvcGVzIHwgY2FuY2VsbGF0aW9uIHNjb3Blc30uXG4gKlxuICogPCEtLVNOSVBTVEFSVCB0eXBlc2NyaXB0LXNsZWVwLXdvcmtmbG93LS0+XG4gKiA8IS0tU05JUEVORC0tPlxuICpcbiAqICMjIyBBY3Rpdml0aWVzXG4gKlxuICogVG8gc2NoZWR1bGUgQWN0aXZpdGllcywgdXNlIHtAbGluayBwcm94eUFjdGl2aXRpZXN9IHRvIG9idGFpbiBhbiBBY3Rpdml0eSBmdW5jdGlvbiBhbmQgY2FsbC5cbiAqXG4gKiA8IS0tU05JUFNUQVJUIHR5cGVzY3JpcHQtc2NoZWR1bGUtYWN0aXZpdHktd29ya2Zsb3ctLT5cbiAqIDwhLS1TTklQRU5ELS0+XG4gKlxuICogIyMjIFVwZGF0ZXMsIFNpZ25hbHMgYW5kIFF1ZXJpZXNcbiAqXG4gKiBVc2Uge0BsaW5rIHNldEhhbmRsZXJ9IHRvIHNldCBoYW5kbGVycyBmb3IgVXBkYXRlcywgU2lnbmFscywgYW5kIFF1ZXJpZXMuXG4gKlxuICogVXBkYXRlIGFuZCBTaWduYWwgaGFuZGxlcnMgY2FuIGJlIGVpdGhlciBhc3luYyBvciBub24tYXN5bmMgZnVuY3Rpb25zLiBVcGRhdGUgaGFuZGxlcnMgbWF5IHJldHVybiBhIHZhbHVlLCBidXQgc2lnbmFsXG4gKiBoYW5kbGVycyBtYXkgbm90IChyZXR1cm4gYHZvaWRgIG9yIGBQcm9taXNlPHZvaWQ+YCkuIFlvdSBtYXkgdXNlIEFjdGl2aXRpZXMsIFRpbWVycywgY2hpbGQgV29ya2Zsb3dzLCBldGMgaW4gVXBkYXRlXG4gKiBhbmQgU2lnbmFsIGhhbmRsZXJzLCBidXQgdGhpcyBzaG91bGQgYmUgZG9uZSBjYXV0aW91c2x5OiBmb3IgZXhhbXBsZSwgbm90ZSB0aGF0IGlmIHlvdSBhd2FpdCBhc3luYyBvcGVyYXRpb25zIHN1Y2ggYXNcbiAqIHRoZXNlIGluIGFuIFVwZGF0ZSBvciBTaWduYWwgaGFuZGxlciwgdGhlbiB5b3UgYXJlIHJlc3BvbnNpYmxlIGZvciBlbnN1cmluZyB0aGF0IHRoZSB3b3JrZmxvdyBkb2VzIG5vdCBjb21wbGV0ZSBmaXJzdC5cbiAqXG4gKiBRdWVyeSBoYW5kbGVycyBtYXkgKipub3QqKiBiZSBhc3luYyBmdW5jdGlvbnMsIGFuZCBtYXkgKipub3QqKiBtdXRhdGUgYW55IHZhcmlhYmxlcyBvciB1c2UgQWN0aXZpdGllcywgVGltZXJzLFxuICogY2hpbGQgV29ya2Zsb3dzLCBldGMuXG4gKlxuICogIyMjIyBJbXBsZW1lbnRhdGlvblxuICpcbiAqIDwhLS1TTklQU1RBUlQgdHlwZXNjcmlwdC13b3JrZmxvdy11cGRhdGUtc2lnbmFsLXF1ZXJ5LWV4YW1wbGUtLT5cbiAqIDwhLS1TTklQRU5ELS0+XG4gKlxuICogIyMjIE1vcmVcbiAqXG4gKiAtIFtEZXRlcm1pbmlzdGljIGJ1aWx0LWluc10oaHR0cHM6Ly9kb2NzLnRlbXBvcmFsLmlvL3R5cGVzY3JpcHQvZGV0ZXJtaW5pc20jc291cmNlcy1vZi1ub24tZGV0ZXJtaW5pc20pXG4gKiAtIFtDYW5jZWxsYXRpb24gYW5kIHNjb3Blc10oaHR0cHM6Ly9kb2NzLnRlbXBvcmFsLmlvL3R5cGVzY3JpcHQvY2FuY2VsbGF0aW9uLXNjb3BlcylcbiAqICAgLSB7QGxpbmsgQ2FuY2VsbGF0aW9uU2NvcGV9XG4gKiAgIC0ge0BsaW5rIFRyaWdnZXJ9XG4gKiAtIFtTaW5rc10oaHR0cHM6Ly9kb2NzLnRlbXBvcmFsLmlvL2FwcGxpY2F0aW9uLWRldmVsb3BtZW50L29ic2VydmFiaWxpdHkvP2xhbmc9dHMjbG9nZ2luZylcbiAqICAgLSB7QGxpbmsgU2lua3N9XG4gKlxuICogQG1vZHVsZVxuICovXG5cbmV4cG9ydCB7XG4gIEFjdGl2aXR5Q2FuY2VsbGF0aW9uVHlwZSxcbiAgQWN0aXZpdHlGYWlsdXJlLFxuICBBY3Rpdml0eU9wdGlvbnMsXG4gIEFwcGxpY2F0aW9uRmFpbHVyZSxcbiAgQ2FuY2VsbGVkRmFpbHVyZSxcbiAgQ2hpbGRXb3JrZmxvd0ZhaWx1cmUsXG4gIGRlZmF1bHRQYXlsb2FkQ29udmVydGVyLFxuICBQYXlsb2FkQ29udmVydGVyLFxuICBSZXRyeVBvbGljeSxcbiAgcm9vdENhdXNlLFxuICBTZWFyY2hBdHRyaWJ1dGVzLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIFNlYXJjaEF0dHJpYnV0ZVZhbHVlLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIFNlcnZlckZhaWx1cmUsXG4gIFRlbXBvcmFsRmFpbHVyZSxcbiAgVGVybWluYXRlZEZhaWx1cmUsXG4gIFRpbWVvdXRGYWlsdXJlLFxufSBmcm9tICdAdGVtcG9yYWxpby9jb21tb24nO1xuZXhwb3J0ICogZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uL2xpYi9lcnJvcnMnO1xuZXhwb3J0IHtcbiAgQWN0aXZpdHlGdW5jdGlvbixcbiAgQWN0aXZpdHlJbnRlcmZhY2UsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgUGF5bG9hZCxcbiAgUXVlcnlEZWZpbml0aW9uLFxuICBTaWduYWxEZWZpbml0aW9uLFxuICBVbnR5cGVkQWN0aXZpdGllcyxcbiAgV29ya2Zsb3csXG4gIFdvcmtmbG93UXVlcnlUeXBlLFxuICBXb3JrZmxvd1Jlc3VsdFR5cGUsXG4gIFdvcmtmbG93UmV0dXJuVHlwZSxcbiAgV29ya2Zsb3dTaWduYWxUeXBlLFxufSBmcm9tICdAdGVtcG9yYWxpby9jb21tb24vbGliL2ludGVyZmFjZXMnO1xuZXhwb3J0ICogZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uL2xpYi93b3JrZmxvdy1oYW5kbGUnO1xuZXhwb3J0ICogZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uL2xpYi93b3JrZmxvdy1vcHRpb25zJztcbmV4cG9ydCB7IEFzeW5jTG9jYWxTdG9yYWdlLCBDYW5jZWxsYXRpb25TY29wZSwgQ2FuY2VsbGF0aW9uU2NvcGVPcHRpb25zIH0gZnJvbSAnLi9jYW5jZWxsYXRpb24tc2NvcGUnO1xuZXhwb3J0ICogZnJvbSAnLi9lcnJvcnMnO1xuZXhwb3J0ICogZnJvbSAnLi9pbnRlcmNlcHRvcnMnO1xuZXhwb3J0IHtcbiAgQ2hpbGRXb3JrZmxvd0NhbmNlbGxhdGlvblR5cGUsXG4gIENoaWxkV29ya2Zsb3dPcHRpb25zLFxuICBDb250aW51ZUFzTmV3LFxuICBDb250aW51ZUFzTmV3T3B0aW9ucyxcbiAgRW5oYW5jZWRTdGFja1RyYWNlLFxuICBTdGFja1RyYWNlRmlsZUxvY2F0aW9uLFxuICBTdGFja1RyYWNlRmlsZVNsaWNlLFxuICBQYXJlbnRDbG9zZVBvbGljeSxcbiAgUGFyZW50V29ya2Zsb3dJbmZvLFxuICBSb290V29ya2Zsb3dJbmZvLFxuICBTdGFja1RyYWNlU0RLSW5mbyxcbiAgU3RhY2tUcmFjZSxcbiAgVW5zYWZlV29ya2Zsb3dJbmZvLFxuICBXb3JrZmxvd0luZm8sXG59IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5leHBvcnQgeyBwcm94eVNpbmtzLCBTaW5rLCBTaW5rQ2FsbCwgU2lua0Z1bmN0aW9uLCBTaW5rcyB9IGZyb20gJy4vc2lua3MnO1xuZXhwb3J0IHsgbG9nIH0gZnJvbSAnLi9sb2dzJztcbmV4cG9ydCB7IFRyaWdnZXIgfSBmcm9tICcuL3RyaWdnZXInO1xuZXhwb3J0ICogZnJvbSAnLi93b3JrZmxvdyc7XG5leHBvcnQgeyBDaGlsZFdvcmtmbG93SGFuZGxlLCBFeHRlcm5hbFdvcmtmbG93SGFuZGxlIH0gZnJvbSAnLi93b3JrZmxvdy1oYW5kbGUnO1xuZXhwb3J0IHsgbWV0cmljTWV0ZXIgfSBmcm9tICcuL21ldHJpY3MnO1xuXG5leHBvcnQgeyBjcmVhdGVOZXh1c0NsaWVudCwgTmV4dXNDbGllbnRPcHRpb25zLCBOZXh1c0NsaWVudCwgTmV4dXNPcGVyYXRpb25IYW5kbGUgfSBmcm9tICcuL25leHVzJztcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBEZXByZWNhdGVkIEFQSXNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQge1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSBMb2dnZXJTaW5rcyBkaXJlY3RseS4gVG8gbG9nIGZyb20gV29ya2Zsb3cgY29kZSwgdXNlIHRoZSBgbG9nYCBvYmplY3RcbiAgICogICAgICAgICAgICAgZXhwb3J0ZWQgYnkgdGhlIGBAdGVtcG9yYWxpby93b3JrZmxvd2AgcGFja2FnZS4gVG8gY2FwdHVyZSBsb2cgbWVzc2FnZXMgZW1pdHRlZFxuICAgKiAgICAgICAgICAgICBieSBXb3JrZmxvdyBjb2RlLCBzZXQgdGhlIHtAbGluayBSdW50aW1lLmxvZ2dlcn0gcHJvcGVydHkuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgTG9nZ2VyU2lua3NEZXByZWNhdGVkIGFzIExvZ2dlclNpbmtzLFxufSBmcm9tICcuL2xvZ3MnO1xuIiwiLyoqXG4gKiBUeXBlIGRlZmluaXRpb25zIGZvciBXb3JrZmxvdyBpbnRlcmNlcHRvcnMuXG4gKlxuICogQG1vZHVsZVxuICovXG5cbmltcG9ydCB7XG4gIEFjdGl2aXR5T3B0aW9ucyxcbiAgRHVyYXRpb24sXG4gIEhlYWRlcnMsXG4gIExvY2FsQWN0aXZpdHlPcHRpb25zLFxuICBNZXRyaWNUYWdzLFxuICBOZXh0LFxuICBUaW1lc3RhbXAsXG4gIFdvcmtmbG93RXhlY3V0aW9uLFxufSBmcm9tICdAdGVtcG9yYWxpby9jb21tb24nO1xuaW1wb3J0IHR5cGUgeyBjb3Jlc2RrIH0gZnJvbSAnQHRlbXBvcmFsaW8vcHJvdG8nO1xuaW1wb3J0IHsgQ2hpbGRXb3JrZmxvd09wdGlvbnNXaXRoRGVmYXVsdHMsIENvbnRpbnVlQXNOZXdPcHRpb25zIH0gZnJvbSAnLi9pbnRlcmZhY2VzJztcblxuZXhwb3J0IHsgTmV4dCwgSGVhZGVycyB9O1xuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBpbnN0YW50aWF0ZXMge0BsaW5rIFdvcmtmbG93SW50ZXJjZXB0b3JzfS5cbiAqXG4gKiBXb3JrZmxvdyBpbnRlcmNlcHRvciBtb2R1bGVzIHNob3VsZCBleHBvcnQgYW4gYGludGVyY2VwdG9yc2AgZnVuY3Rpb24gb2YgdGhpcyB0eXBlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGV4cG9ydCBmdW5jdGlvbiBpbnRlcmNlcHRvcnMoKTogV29ya2Zsb3dJbnRlcmNlcHRvcnMge1xuICogICByZXR1cm4ge1xuICogICAgIGluYm91bmQ6IFtdLCAgIC8vIFBvcHVsYXRlIHdpdGggbGlzdCBvZiBpbmJvdW5kIGludGVyY2VwdG9yIGltcGxlbWVudGF0aW9uc1xuICogICAgIG91dGJvdW5kOiBbXSwgIC8vIFBvcHVsYXRlIHdpdGggbGlzdCBvZiBvdXRib3VuZCBpbnRlcmNlcHRvciBpbXBsZW1lbnRhdGlvbnNcbiAqICAgICBpbnRlcm5hbHM6IFtdLCAvLyBQb3B1bGF0ZSB3aXRoIGxpc3Qgb2YgaW50ZXJuYWxzIGludGVyY2VwdG9yIGltcGxlbWVudGF0aW9uc1xuICogICB9O1xuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCB0eXBlIFdvcmtmbG93SW50ZXJjZXB0b3JzRmFjdG9yeSA9ICgpID0+IFdvcmtmbG93SW50ZXJjZXB0b3JzO1xuXG4vKipcbiAqIEEgbWFwcGluZyBmcm9tIGludGVyY2VwdG9yIHR5cGUgdG8gYW4gb3B0aW9uYWwgbGlzdCBvZiBpbnRlcmNlcHRvciBpbXBsZW1lbnRhdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBXb3JrZmxvd0ludGVyY2VwdG9ycyB7XG4gIGluYm91bmQ/OiBXb3JrZmxvd0luYm91bmRDYWxsc0ludGVyY2VwdG9yW107XG4gIG91dGJvdW5kPzogV29ya2Zsb3dPdXRib3VuZENhbGxzSW50ZXJjZXB0b3JbXTtcbiAgaW50ZXJuYWxzPzogV29ya2Zsb3dJbnRlcm5hbHNJbnRlcmNlcHRvcltdO1xufVxuXG4vLyBXb3JrZmxvdyBJbmJvdW5kIENhbGxzIEludGVyY2VwdG9ycyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBJbXBsZW1lbnQgYW55IG9mIHRoZXNlIG1ldGhvZHMgdG8gaW50ZXJjZXB0IFdvcmtmbG93IGluYm91bmQgY2FsbHMgbGlrZSBleGVjdXRpb24sIGFuZCBzaWduYWwgYW5kIHF1ZXJ5IGhhbmRsaW5nLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtmbG93SW5ib3VuZENhbGxzSW50ZXJjZXB0b3Ige1xuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gV29ya2Zsb3cgZXhlY3V0ZSBtZXRob2QgaXMgY2FsbGVkXG4gICAqXG4gICAqIEByZXR1cm4gcmVzdWx0IG9mIHRoZSBXb3JrZmxvdyBleGVjdXRpb25cbiAgICovXG4gIGV4ZWN1dGU/OiAoaW5wdXQ6IFdvcmtmbG93RXhlY3V0ZUlucHV0LCBuZXh0OiBOZXh0PFdvcmtmbG93SW5ib3VuZENhbGxzSW50ZXJjZXB0b3IsICdleGVjdXRlJz4pID0+IFByb21pc2U8dW5rbm93bj47XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIFVwZGF0ZSBoYW5kbGVyIGlzIGNhbGxlZFxuICAgKlxuICAgKiBAcmV0dXJuIHJlc3VsdCBvZiB0aGUgVXBkYXRlXG4gICAqL1xuICBoYW5kbGVVcGRhdGU/OiAoaW5wdXQ6IFVwZGF0ZUlucHV0LCBuZXh0OiBOZXh0PFdvcmtmbG93SW5ib3VuZENhbGxzSW50ZXJjZXB0b3IsICdoYW5kbGVVcGRhdGUnPikgPT4gUHJvbWlzZTx1bmtub3duPjtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdXBkYXRlIHZhbGlkYXRvciBjYWxsZWRcbiAgICovXG4gIHZhbGlkYXRlVXBkYXRlPzogKGlucHV0OiBVcGRhdGVJbnB1dCwgbmV4dDogTmV4dDxXb3JrZmxvd0luYm91bmRDYWxsc0ludGVyY2VwdG9yLCAndmFsaWRhdGVVcGRhdGUnPikgPT4gdm9pZDtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gc2lnbmFsIGlzIGRlbGl2ZXJlZCB0byBhIFdvcmtmbG93IGV4ZWN1dGlvblxuICAgKi9cbiAgaGFuZGxlU2lnbmFsPzogKGlucHV0OiBTaWduYWxJbnB1dCwgbmV4dDogTmV4dDxXb3JrZmxvd0luYm91bmRDYWxsc0ludGVyY2VwdG9yLCAnaGFuZGxlU2lnbmFsJz4pID0+IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgV29ya2Zsb3cgaXMgcXVlcmllZFxuICAgKlxuICAgKiBAcmV0dXJuIHJlc3VsdCBvZiB0aGUgcXVlcnlcbiAgICovXG4gIGhhbmRsZVF1ZXJ5PzogKGlucHV0OiBRdWVyeUlucHV0LCBuZXh0OiBOZXh0PFdvcmtmbG93SW5ib3VuZENhbGxzSW50ZXJjZXB0b3IsICdoYW5kbGVRdWVyeSc+KSA9PiBQcm9taXNlPHVua25vd24+O1xufVxuXG4vKipcbiAqIElucHV0IGZvciB7QGxpbmsgV29ya2Zsb3dJbmJvdW5kQ2FsbHNJbnRlcmNlcHRvci5leGVjdXRlfS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBXb3JrZmxvd0V4ZWN1dGVJbnB1dCB7XG4gIHJlYWRvbmx5IGFyZ3M6IHVua25vd25bXTtcbiAgcmVhZG9ubHkgaGVhZGVyczogSGVhZGVycztcbn1cblxuLyoqXG4gKiBJbnB1dCBmb3Ige0BsaW5rIFdvcmtmbG93SW5ib3VuZENhbGxzSW50ZXJjZXB0b3IuaGFuZGxlVXBkYXRlfSBhbmQge0BsaW5rIFdvcmtmbG93SW5ib3VuZENhbGxzSW50ZXJjZXB0b3IudmFsaWRhdGVVcGRhdGV9LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZUlucHV0IHtcbiAgcmVhZG9ubHkgdXBkYXRlSWQ6IHN0cmluZztcbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuICByZWFkb25seSBhcmdzOiB1bmtub3duW107XG4gIHJlYWRvbmx5IGhlYWRlcnM6IEhlYWRlcnM7XG59XG5cbi8qKlxuICogSW5wdXQgZm9yIHtAbGluayBXb3JrZmxvd0luYm91bmRDYWxsc0ludGVyY2VwdG9yLmhhbmRsZVNpZ25hbH0uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2lnbmFsSW5wdXQge1xuICByZWFkb25seSBzaWduYWxOYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGFyZ3M6IHVua25vd25bXTtcbiAgcmVhZG9ubHkgaGVhZGVyczogSGVhZGVycztcbn1cblxuLyoqXG4gKiBJbnB1dCBmb3Ige0BsaW5rIFdvcmtmbG93SW5ib3VuZENhbGxzSW50ZXJjZXB0b3IuaGFuZGxlUXVlcnl9LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5SW5wdXQge1xuICByZWFkb25seSBxdWVyeUlkOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHF1ZXJ5TmFtZTogc3RyaW5nO1xuICByZWFkb25seSBhcmdzOiB1bmtub3duW107XG4gIHJlYWRvbmx5IGhlYWRlcnM6IEhlYWRlcnM7XG59XG5cbi8vIFdvcmtmbG93IE91dGJvdW5kIENhbGxzIEludGVyY2VwdG9ycyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBJbXBsZW1lbnQgYW55IG9mIHRoZXNlIG1ldGhvZHMgdG8gaW50ZXJjZXB0IFdvcmtmbG93IGNvZGUgY2FsbHMgdG8gdGhlIFRlbXBvcmFsIEFQSXMsIGxpa2Ugc2NoZWR1bGluZyBhbiBhY3Rpdml0eVxuICogYW5kIHN0YXJ0aW5nIGEgdGltZXIuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgV29ya2Zsb3dPdXRib3VuZENhbGxzSW50ZXJjZXB0b3Ige1xuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gV29ya2Zsb3cgc3RhcnRzIGEgdGltZXIuXG4gICAqL1xuICBzdGFydFRpbWVyPzogKGlucHV0OiBUaW1lcklucHV0LCBuZXh0OiBOZXh0PFdvcmtmbG93T3V0Ym91bmRDYWxsc0ludGVyY2VwdG9yLCAnc3RhcnRUaW1lcic+KSA9PiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBXb3JrZmxvdyBzY2hlZHVsZXMgYW4gQWN0aXZpdHkuXG4gICAqXG4gICAqIEByZXR1cm4gcmVzdWx0IG9mIHRoZSBhY3Rpdml0eSBleGVjdXRpb25cbiAgICovXG4gIHNjaGVkdWxlQWN0aXZpdHk/OiAoXG4gICAgaW5wdXQ6IEFjdGl2aXR5SW5wdXQsXG4gICAgbmV4dDogTmV4dDxXb3JrZmxvd091dGJvdW5kQ2FsbHNJbnRlcmNlcHRvciwgJ3NjaGVkdWxlQWN0aXZpdHknPlxuICApID0+IFByb21pc2U8dW5rbm93bj47XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIFdvcmtmbG93IHNjaGVkdWxlcyBhIGxvY2FsIEFjdGl2aXR5LlxuICAgKlxuICAgKiBAcmV0dXJuIHJlc3VsdCBvZiB0aGUgYWN0aXZpdHkgZXhlY3V0aW9uXG4gICAqL1xuICBzY2hlZHVsZUxvY2FsQWN0aXZpdHk/OiAoXG4gICAgaW5wdXQ6IExvY2FsQWN0aXZpdHlJbnB1dCxcbiAgICBuZXh0OiBOZXh0PFdvcmtmbG93T3V0Ym91bmRDYWxsc0ludGVyY2VwdG9yLCAnc2NoZWR1bGVMb2NhbEFjdGl2aXR5Jz5cbiAgKSA9PiBQcm9taXNlPHVua25vd24+O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBXb3JrZmxvdyBzdGFydHMgYSBOZXh1cyBPcGVyYXRpb24uXG4gICAqXG4gICAqIEBleHBlcmltZW50YWwgTmV4dXMgc3VwcG9ydCBpbiBUZW1wb3JhbCBTREsgaXMgZXhwZXJpbWVudGFsLlxuICAgKi9cbiAgc3RhcnROZXh1c09wZXJhdGlvbj86IChcbiAgICBpbnB1dDogU3RhcnROZXh1c09wZXJhdGlvbklucHV0LFxuICAgIG5leHQ6IE5leHQ8V29ya2Zsb3dPdXRib3VuZENhbGxzSW50ZXJjZXB0b3IsICdzdGFydE5leHVzT3BlcmF0aW9uJz5cbiAgKSA9PiBQcm9taXNlPFN0YXJ0TmV4dXNPcGVyYXRpb25PdXRwdXQ+O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBXb3JrZmxvdyBzdGFydHMgYSBjaGlsZCB3b3JrZmxvdyBleGVjdXRpb24uXG4gICAqXG4gICAqIFRoZSBpbnRlcmNlcHRvciBmdW5jdGlvbiByZXR1cm5zIDIgcHJvbWlzZXM6XG4gICAqIC0gVGhlIGZpcnN0IHJlc29sdmVzIHdpdGggdGhlIGBydW5JZGAgd2hlbiB0aGUgY2hpbGQgd29ya2Zsb3cgaGFzIHN0YXJ0ZWQgb3IgcmVqZWN0cyBpZiBmYWlsZWQgdG8gc3RhcnQuXG4gICAqIC0gVGhlIHNlY29uZCByZXNvbHZlcyB3aXRoIHRoZSB3b3JrZmxvdyByZXN1bHQgd2hlbiB0aGUgY2hpbGQgd29ya2Zsb3cgY29tcGxldGVzIG9yIHJlamVjdHMgb24gZmFpbHVyZS5cbiAgICovXG4gIHN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbj86IChcbiAgICBpbnB1dDogU3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uSW5wdXQsXG4gICAgbmV4dDogTmV4dDxXb3JrZmxvd091dGJvdW5kQ2FsbHNJbnRlcmNlcHRvciwgJ3N0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbic+XG4gICkgPT4gUHJvbWlzZTxbUHJvbWlzZTxzdHJpbmc+LCBQcm9taXNlPHVua25vd24+XT47XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIFdvcmtmbG93IHNpZ25hbHMgYSBjaGlsZCBvciBleHRlcm5hbCBXb3JrZmxvdy5cbiAgICovXG4gIHNpZ25hbFdvcmtmbG93PzogKFxuICAgIGlucHV0OiBTaWduYWxXb3JrZmxvd0lucHV0LFxuICAgIG5leHQ6IE5leHQ8V29ya2Zsb3dPdXRib3VuZENhbGxzSW50ZXJjZXB0b3IsICdzaWduYWxXb3JrZmxvdyc+XG4gICkgPT4gUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gV29ya2Zsb3cgY2FsbHMgY29udGludWVBc05ldy5cbiAgICovXG4gIGNvbnRpbnVlQXNOZXc/OiAoXG4gICAgaW5wdXQ6IENvbnRpbnVlQXNOZXdJbnB1dCxcbiAgICBuZXh0OiBOZXh0PFdvcmtmbG93T3V0Ym91bmRDYWxsc0ludGVyY2VwdG9yLCAnY29udGludWVBc05ldyc+XG4gICkgPT4gUHJvbWlzZTxuZXZlcj47XG5cbiAgLyoqXG4gICAqIENhbGxlZCBvbiBlYWNoIGludm9jYXRpb24gb2YgdGhlIGB3b3JrZmxvdy5sb2dgIG1ldGhvZHMuXG4gICAqXG4gICAqIFRoZSBhdHRyaWJ1dGVzIHJldHVybmVkIGluIHRoaXMgY2FsbCBhcmUgYXR0YWNoZWQgdG8gZXZlcnkgbG9nIG1lc3NhZ2UuXG4gICAqL1xuICBnZXRMb2dBdHRyaWJ1dGVzPzogKFxuICAgIGlucHV0OiBHZXRMb2dBdHRyaWJ1dGVzSW5wdXQsXG4gICAgbmV4dDogTmV4dDxXb3JrZmxvd091dGJvdW5kQ2FsbHNJbnRlcmNlcHRvciwgJ2dldExvZ0F0dHJpYnV0ZXMnPlxuICApID0+IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgb25jZSBldmVyeSB0aW1lIGEgbWV0cmljIGlzIGVtaXR0ZWQgZnJvbSBhIFdvcmtmbG93IG1ldHJpYyAoaWUuIGEgbWV0cmljIGNyZWF0ZWRcbiAgICogZnJvbSB7QGxpbmsgd29ya2Zsb3cubWV0cmljTWV0ZXJ9KS5cbiAgICpcbiAgICogVGFncyByZXR1cm5lZCBieSB0aGlzIGhvb2sgYXJlIF9wcmVwZW5kZWRfIHRvIHRhZ3MgZGVmaW5lZCBhdCB0aGUgbWV0cmljIGxldmVsIGFuZCB0YWdzXG4gICAqIGRlZmluZWQgb24gdGhlIGVtaXR0ZXIgZnVuY3Rpb24gaXRzZWxmLlxuICAgKi9cbiAgZ2V0TWV0cmljVGFncz86IChcbiAgICBpbnB1dDogR2V0TWV0cmljVGFnc0lucHV0LFxuICAgIG5leHQ6IE5leHQ8V29ya2Zsb3dPdXRib3VuZENhbGxzSW50ZXJjZXB0b3IsICdnZXRNZXRyaWNUYWdzJz5cbiAgKSA9PiBNZXRyaWNUYWdzO1xufVxuXG4vKipcbiAqIElucHV0IGZvciB7QGxpbmsgV29ya2Zsb3dPdXRib3VuZENhbGxzSW50ZXJjZXB0b3Iuc3RhcnRUaW1lcn1cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUaW1lcklucHV0IHtcbiAgcmVhZG9ubHkgZHVyYXRpb25NczogbnVtYmVyO1xuICByZWFkb25seSBzZXE6IG51bWJlcjtcbiAgcmVhZG9ubHkgb3B0aW9ucz86IFRpbWVyT3B0aW9ucztcbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBzdGFydGluZyBhIHRpbWVyIChpLmUuIHNsZWVwKVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRpbWVyT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBBIGZpeGVkLCBzaW5nbGUgbGluZSBzdW1tYXJ5IG9mIHRoZSBjb21tYW5kJ3MgcHVycG9zZVxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsIFVzZXIgbWV0YWRhdGEgaXMgYSBuZXcgQVBJIGFuZCBzdXNjZXB0aWJsZSB0byBjaGFuZ2UuXG4gICAqL1xuICByZWFkb25seSBzdW1tYXJ5Pzogc3RyaW5nO1xufVxuXG4vKipcbiAqIElucHV0IGZvciB7QGxpbmsgV29ya2Zsb3dPdXRib3VuZENhbGxzSW50ZXJjZXB0b3Iuc2NoZWR1bGVBY3Rpdml0eX0uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQWN0aXZpdHlJbnB1dCB7XG4gIHJlYWRvbmx5IGFjdGl2aXR5VHlwZTogc3RyaW5nO1xuICByZWFkb25seSBhcmdzOiB1bmtub3duW107XG4gIHJlYWRvbmx5IG9wdGlvbnM6IEFjdGl2aXR5T3B0aW9ucztcbiAgcmVhZG9ubHkgaGVhZGVyczogSGVhZGVycztcbiAgcmVhZG9ubHkgc2VxOiBudW1iZXI7XG59XG5cbi8qKlxuICogSW5wdXQgZm9yIHtAbGluayBXb3JrZmxvd091dGJvdW5kQ2FsbHNJbnRlcmNlcHRvci5zY2hlZHVsZUxvY2FsQWN0aXZpdHl9LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIExvY2FsQWN0aXZpdHlJbnB1dCB7XG4gIHJlYWRvbmx5IGFjdGl2aXR5VHlwZTogc3RyaW5nO1xuICByZWFkb25seSBhcmdzOiB1bmtub3duW107XG4gIHJlYWRvbmx5IG9wdGlvbnM6IExvY2FsQWN0aXZpdHlPcHRpb25zO1xuICByZWFkb25seSBoZWFkZXJzOiBIZWFkZXJzO1xuICByZWFkb25seSBzZXE6IG51bWJlcjtcbiAgcmVhZG9ubHkgb3JpZ2luYWxTY2hlZHVsZVRpbWU/OiBUaW1lc3RhbXA7XG4gIHJlYWRvbmx5IGF0dGVtcHQ6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBJbnB1dCBmb3Ige0BsaW5rIFdvcmtmbG93T3V0Ym91bmRDYWxsc0ludGVyY2VwdG9yLnN0YXJ0TmV4dXNPcGVyYXRpb259LlxuICpcbiAqIEBleHBlcmltZW50YWwgTmV4dXMgc3VwcG9ydCBpbiBUZW1wb3JhbCBTREsgaXMgZXhwZXJpbWVudGFsLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN0YXJ0TmV4dXNPcGVyYXRpb25JbnB1dCB7XG4gIHJlYWRvbmx5IGlucHV0OiB1bmtub3duO1xuICByZWFkb25seSBlbmRwb2ludDogc3RyaW5nO1xuICByZWFkb25seSBzZXJ2aWNlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IG9wdGlvbnM6IFN0YXJ0TmV4dXNPcGVyYXRpb25PcHRpb25zO1xuICByZWFkb25seSBvcGVyYXRpb246IHN0cmluZztcbiAgcmVhZG9ubHkgc2VxOiBudW1iZXI7XG4gIHJlYWRvbmx5IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3Igc3RhcnRpbmcgYSBOZXh1cyBPcGVyYXRpb24uXG4gKlxuICogQGV4cGVyaW1lbnRhbCBOZXh1cyBzdXBwb3J0IGluIFRlbXBvcmFsIFNESyBpcyBleHBlcmltZW50YWwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3RhcnROZXh1c09wZXJhdGlvbk9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIGVuZCB0byBlbmQgdGltZW91dCBmb3IgdGhlIE5leHVzIE9wZXJhdGlvbi5cbiAgICpcbiAgICogT3B0aW9uYWw6IGRlZmF1bHRzIHRvIHRoZSBtYXhpbXVtIGFsbG93ZWQgYnkgdGhlIFRlbXBvcmFsIHNlcnZlci5cbiAgICovXG4gIHJlYWRvbmx5IHNjaGVkdWxlVG9DbG9zZVRpbWVvdXQ/OiBEdXJhdGlvbjtcblxuICAvKipcbiAgICogQSBmaXhlZCwgc2luZ2xlLWxpbmUgc3VtbWFyeSBmb3IgdGhpcyBOZXh1cyBPcGVyYXRpb24gdGhhdCBtYXkgYXBwZWFyIGluIHRoZSBVSS9DTEkuXG4gICAqIFRoaXMgY2FuIGJlIGluIHNpbmdsZS1saW5lIFRlbXBvcmFsIG1hcmtkb3duIGZvcm1hdC5cbiAgICpcbiAgICogQGV4cGVyaW1lbnRhbCBVc2VyIG1ldGFkYXRhIGlzIGEgbmV3IEFQSSBhbmQgc3VzY2VwdGlibGUgdG8gY2hhbmdlLlxuICAgKi9cbiAgcmVhZG9ubHkgc3VtbWFyeT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBPdXRwdXQgZm9yIHtAbGluayBXb3JrZmxvd091dGJvdW5kQ2FsbHNJbnRlcmNlcHRvci5zdGFydE5leHVzT3BlcmF0aW9ufS5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIE5leHVzIHN1cHBvcnQgaW4gVGVtcG9yYWwgU0RLIGlzIGV4cGVyaW1lbnRhbC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdGFydE5leHVzT3BlcmF0aW9uT3V0cHV0IHtcbiAgLyoqXG4gICAqIFRoZSB0b2tlbiBmb3IgdGhlIE5leHVzIE9wZXJhdGlvbi5cbiAgICpcbiAgICogVW5kZWZpbmVkIGlmIHRoZSBOZXh1cyBPcGVyYXRpb24gY29tcGxldGVkIHN5bmNocm9ub3VzbHksIGluIHdoaWNoIGNhc2UgdGhlIHtAbGluayByZXN1bHR9XG4gICAqIHdpbGwgYmUgaW1tZWRpYXRlbHkgcmVzb2x2ZWQuXG4gICAqL1xuICByZWFkb25seSB0b2tlbj86IHN0cmluZztcblxuICAvKipcbiAgICogQSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHdoZW4gdGhlIE5leHVzIE9wZXJhdGlvbiBjb21wbGV0ZXMsIGVpdGhlciB3aXRoIHRoZSByZXN1bHQgb2YgdGhlXG4gICAqIE9wZXJhdGlvbiBpZiBpdCBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LCBvciBhIGZhaWx1cmUgaWYgdGhlIE5leHVzIE9wZXJhdGlvbiBmYWlsZWQuXG4gICAqL1xuICByZWFkb25seSByZXN1bHQ6IFByb21pc2U8dW5rbm93bj47XG59XG5cbi8qKlxuICogSW5wdXQgZm9yIHtAbGluayBXb3JrZmxvd091dGJvdW5kQ2FsbHNJbnRlcmNlcHRvci5zdGFydENoaWxkV29ya2Zsb3dFeGVjdXRpb259LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbklucHV0IHtcbiAgcmVhZG9ubHkgd29ya2Zsb3dUeXBlOiBzdHJpbmc7XG4gIHJlYWRvbmx5IG9wdGlvbnM6IENoaWxkV29ya2Zsb3dPcHRpb25zV2l0aERlZmF1bHRzO1xuICByZWFkb25seSBoZWFkZXJzOiBIZWFkZXJzO1xuICByZWFkb25seSBzZXE6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBJbnB1dCBmb3Ige0BsaW5rIFdvcmtmbG93T3V0Ym91bmRDYWxsc0ludGVyY2VwdG9yLnNpZ25hbFdvcmtmbG93fS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTaWduYWxXb3JrZmxvd0lucHV0IHtcbiAgcmVhZG9ubHkgc2VxOiBudW1iZXI7XG4gIHJlYWRvbmx5IHNpZ25hbE5hbWU6IHN0cmluZztcbiAgcmVhZG9ubHkgYXJnczogdW5rbm93bltdO1xuICByZWFkb25seSBoZWFkZXJzOiBIZWFkZXJzO1xuICByZWFkb25seSB0YXJnZXQ6XG4gICAgfCB7XG4gICAgICAgIHJlYWRvbmx5IHR5cGU6ICdleHRlcm5hbCc7XG4gICAgICAgIHJlYWRvbmx5IHdvcmtmbG93RXhlY3V0aW9uOiBXb3JrZmxvd0V4ZWN1dGlvbjtcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgcmVhZG9ubHkgdHlwZTogJ2NoaWxkJztcbiAgICAgICAgcmVhZG9ubHkgY2hpbGRXb3JrZmxvd0lkOiBzdHJpbmc7XG4gICAgICB9O1xufVxuXG4vKipcbiAqIElucHV0IGZvciB7QGxpbmsgV29ya2Zsb3dPdXRib3VuZENhbGxzSW50ZXJjZXB0b3IuY29udGludWVBc05ld30uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29udGludWVBc05ld0lucHV0IHtcbiAgcmVhZG9ubHkgYXJnczogdW5rbm93bltdO1xuICByZWFkb25seSBoZWFkZXJzOiBIZWFkZXJzO1xuICByZWFkb25seSBvcHRpb25zOiBDb250aW51ZUFzTmV3SW5wdXRPcHRpb25zO1xufVxuXG4vKipcbiAqIElucHV0IGZvciB7QGxpbmsgV29ya2Zsb3dPdXRib3VuZENhbGxzSW50ZXJjZXB0b3IuY29udGludWVBc05ld30uXG4gKi9cbmV4cG9ydCB0eXBlIENvbnRpbnVlQXNOZXdJbnB1dE9wdGlvbnMgPSBDb250aW51ZUFzTmV3T3B0aW9ucyAmIFJlcXVpcmVkPFBpY2s8Q29udGludWVBc05ld09wdGlvbnMsICd3b3JrZmxvd1R5cGUnPj47XG5cbi8qKlxuICogSW5wdXQgZm9yIHtAbGluayBXb3JrZmxvd091dGJvdW5kQ2FsbHNJbnRlcmNlcHRvci5nZXRMb2dBdHRyaWJ1dGVzfS5cbiAqL1xuZXhwb3J0IHR5cGUgR2V0TG9nQXR0cmlidXRlc0lucHV0ID0gUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG5cbi8qKlxuICogSW5wdXQgZm9yIHtAbGluayBXb3JrZmxvd091dGJvdW5kQ2FsbHNJbnRlcmNlcHRvci5nZXRNZXRyaWNUYWdzfS5cbiAqL1xuZXhwb3J0IHR5cGUgR2V0TWV0cmljVGFnc0lucHV0ID0gTWV0cmljVGFncztcblxuLy8gV29ya2Zsb3cgSW50ZXJuYWxzIEludGVyY2VwdG9ycyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogSW50ZXJjZXB0b3IgZm9yIHRoZSBpbnRlcm5hbHMgb2YgdGhlIFdvcmtmbG93IHJ1bnRpbWUuXG4gKlxuICogVXNlIHRvIG1hbmlwdWxhdGUgb3IgdHJhY2UgV29ya2Zsb3cgYWN0aXZhdGlvbnMuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIEFQSSBpcyBmb3IgYWR2YW5jZWQgdXNlIGNhc2VzIGFuZCBtYXkgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgV29ya2Zsb3dJbnRlcm5hbHNJbnRlcmNlcHRvciB7XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgV29ya2Zsb3cgcnVudGltZSBydW5zIGEgV29ya2Zsb3dBY3RpdmF0aW9uSm9iLlxuICAgKi9cbiAgYWN0aXZhdGU/KGlucHV0OiBBY3RpdmF0ZUlucHV0LCBuZXh0OiBOZXh0PHRoaXMsICdhY3RpdmF0ZSc+KTogdm9pZDtcblxuICAvKipcbiAgICogQ2FsbGVkIGFmdGVyIGFsbCBgV29ya2Zsb3dBY3RpdmF0aW9uSm9iYHMgaGF2ZSBiZWVuIHByb2Nlc3NlZCBmb3IgYW4gYWN0aXZhdGlvbi5cbiAgICpcbiAgICogQ2FuIG1hbmlwdWxhdGUgdGhlIGNvbW1hbmRzIGdlbmVyYXRlZCBieSB0aGUgV29ya2Zsb3dcbiAgICovXG4gIGNvbmNsdWRlQWN0aXZhdGlvbj8oaW5wdXQ6IENvbmNsdWRlQWN0aXZhdGlvbklucHV0LCBuZXh0OiBOZXh0PHRoaXMsICdjb25jbHVkZUFjdGl2YXRpb24nPik6IENvbmNsdWRlQWN0aXZhdGlvbk91dHB1dDtcblxuICAvKipcbiAgICogQ2FsbGVkIGJlZm9yZSBkaXNwb3NpbmcgdGhlIFdvcmtmbG93IGlzb2xhdGUgY29udGV4dC5cbiAgICpcbiAgICogSW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHBlcmZvcm0gYW55IHJlc291cmNlIGNsZWFudXAuXG4gICAqL1xuICBkaXNwb3NlPyhpbnB1dDogRGlzcG9zZUlucHV0LCBuZXh0OiBOZXh0PHRoaXMsICdkaXNwb3NlJz4pOiB2b2lkO1xufVxuXG4vKipcbiAqIElucHV0IGZvciB7QGxpbmsgV29ya2Zsb3dJbnRlcm5hbHNJbnRlcmNlcHRvci5hY3RpdmF0ZX1cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBY3RpdmF0ZUlucHV0IHtcbiAgcmVhZG9ubHkgYWN0aXZhdGlvbjogY29yZXNkay53b3JrZmxvd19hY3RpdmF0aW9uLklXb3JrZmxvd0FjdGl2YXRpb247XG4gIHJlYWRvbmx5IGJhdGNoSW5kZXg6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBJbnB1dCBmb3Ige0BsaW5rIFdvcmtmbG93SW50ZXJuYWxzSW50ZXJjZXB0b3IuZGlzcG9zZX1cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1vYmplY3QtdHlwZVxuZXhwb3J0IGludGVyZmFjZSBEaXNwb3NlSW5wdXQge31cblxuLyoqXG4gKiBJbnB1dCBmb3Ige0BsaW5rIFdvcmtmbG93SW50ZXJuYWxzSW50ZXJjZXB0b3IuY29uY2x1ZGVBY3RpdmF0aW9ufVxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbmNsdWRlQWN0aXZhdGlvbklucHV0IHtcbiAgcmVhZG9ubHkgY29tbWFuZHM6IGNvcmVzZGsud29ya2Zsb3dfY29tbWFuZHMuSVdvcmtmbG93Q29tbWFuZFtdO1xufVxuXG4vKipcbiAqIE91dHB1dCBmb3Ige0BsaW5rIFdvcmtmbG93SW50ZXJuYWxzSW50ZXJjZXB0b3IuY29uY2x1ZGVBY3RpdmF0aW9ufVxuICovXG5leHBvcnQgdHlwZSBDb25jbHVkZUFjdGl2YXRpb25PdXRwdXQgPSBDb25jbHVkZUFjdGl2YXRpb25JbnB1dDtcbiIsImltcG9ydCB0eXBlIHsgUmF3U291cmNlTWFwIH0gZnJvbSAnc291cmNlLW1hcCc7XG5pbXBvcnQge1xuICBSZXRyeVBvbGljeSxcbiAgQ29tbW9uV29ya2Zsb3dPcHRpb25zLFxuICBIYW5kbGVyVW5maW5pc2hlZFBvbGljeSxcbiAgU2VhcmNoQXR0cmlidXRlcyxcbiAgU2lnbmFsRGVmaW5pdGlvbixcbiAgVXBkYXRlRGVmaW5pdGlvbixcbiAgUXVlcnlEZWZpbml0aW9uLFxuICBEdXJhdGlvbixcbiAgVmVyc2lvbmluZ0ludGVudCxcbiAgVHlwZWRTZWFyY2hBdHRyaWJ1dGVzLFxuICBTZWFyY2hBdHRyaWJ1dGVQYWlyLFxuICBQcmlvcml0eSxcbiAgV29ya2VyRGVwbG95bWVudFZlcnNpb24sXG4gIFZlcnNpb25pbmdCZWhhdmlvcixcbn0gZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uJztcbmltcG9ydCB7IFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yIH0gZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uL2xpYi90eXBlLWhlbHBlcnMnO1xuaW1wb3J0IHsgbWFrZVByb3RvRW51bUNvbnZlcnRlcnMgfSBmcm9tICdAdGVtcG9yYWxpby9jb21tb24vbGliL2ludGVybmFsLXdvcmtmbG93L2VudW1zLWhlbHBlcnMnO1xuaW1wb3J0IHR5cGUgeyBjb3Jlc2RrIH0gZnJvbSAnQHRlbXBvcmFsaW8vcHJvdG8nO1xuXG4vKipcbiAqIFdvcmtmbG93IEV4ZWN1dGlvbiBpbmZvcm1hdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtmbG93SW5mbyB7XG4gIC8qKlxuICAgKiBJRCBvZiB0aGUgV29ya2Zsb3csIHRoaXMgY2FuIGJlIHNldCBieSB0aGUgY2xpZW50IGR1cmluZyBXb3JrZmxvdyBjcmVhdGlvbi5cbiAgICogQSBzaW5nbGUgV29ya2Zsb3cgbWF5IHJ1biBtdWx0aXBsZSB0aW1lcyBlLmcuIHdoZW4gc2NoZWR1bGVkIHdpdGggY3Jvbi5cbiAgICovXG4gIHJlYWRvbmx5IHdvcmtmbG93SWQ6IHN0cmluZztcblxuICAvKipcbiAgICogSUQgb2YgYSBzaW5nbGUgV29ya2Zsb3cgcnVuXG4gICAqL1xuICByZWFkb25seSBydW5JZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXb3JrZmxvdyBmdW5jdGlvbidzIG5hbWVcbiAgICovXG4gIHJlYWRvbmx5IHdvcmtmbG93VHlwZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBJbmRleGVkIGluZm9ybWF0aW9uIGF0dGFjaGVkIHRvIHRoZSBXb3JrZmxvdyBFeGVjdXRpb25cbiAgICpcbiAgICogVGhpcyB2YWx1ZSBtYXkgY2hhbmdlIGR1cmluZyB0aGUgbGlmZXRpbWUgb2YgYW4gRXhlY3V0aW9uLlxuICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIHR5cGVkU2VhcmNoQXR0cmlidXRlc30gaW5zdGVhZC5cbiAgICovXG4gIHJlYWRvbmx5IHNlYXJjaEF0dHJpYnV0ZXM6IFNlYXJjaEF0dHJpYnV0ZXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cblxuICAvKipcbiAgICogSW5kZXhlZCBpbmZvcm1hdGlvbiBhdHRhY2hlZCB0byB0aGUgV29ya2Zsb3cgRXhlY3V0aW9uLCBleHBvc2VkIHRocm91Z2ggYW4gaW50ZXJmYWNlLlxuICAgKlxuICAgKiBUaGlzIHZhbHVlIG1heSBjaGFuZ2UgZHVyaW5nIHRoZSBsaWZldGltZSBvZiBhbiBFeGVjdXRpb24uXG4gICAqL1xuICByZWFkb25seSB0eXBlZFNlYXJjaEF0dHJpYnV0ZXM6IFR5cGVkU2VhcmNoQXR0cmlidXRlcztcblxuICAvKipcbiAgICogTm9uLWluZGV4ZWQgaW5mb3JtYXRpb24gYXR0YWNoZWQgdG8gdGhlIFdvcmtmbG93IEV4ZWN1dGlvblxuICAgKi9cbiAgcmVhZG9ubHkgbWVtbz86IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuXG4gIC8qKlxuICAgKiBQYXJlbnQgV29ya2Zsb3cgaW5mbyAocHJlc2VudCBpZiB0aGlzIGlzIGEgQ2hpbGQgV29ya2Zsb3cpXG4gICAqL1xuICByZWFkb25seSBwYXJlbnQ/OiBQYXJlbnRXb3JrZmxvd0luZm87XG5cbiAgLyoqXG4gICAqIFRoZSByb290IHdvcmtmbG93IGV4ZWN1dGlvbiwgZGVmaW5lZCBhcyBmb2xsb3dzOlxuICAgKiAxLiBBIHdvcmtmbG93IHdpdGhvdXQgYSBwYXJlbnQgd29ya2Zsb3cgaXMgaXRzIG93biByb290IHdvcmtmbG93LlxuICAgKiAyLiBBIHdvcmtmbG93IHdpdGggYSBwYXJlbnQgd29ya2Zsb3cgaGFzIHRoZSBzYW1lIHJvb3Qgd29ya2Zsb3cgYXNcbiAgICogaXRzIHBhcmVudC5cbiAgICpcbiAgICogV2hlbiB0aGVyZSBpcyBubyBwYXJlbnQgd29ya2Zsb3csIGkuZS4sIHRoZSB3b3JrZmxvdyBpcyBpdHMgb3duIHJvb3Qgd29ya2Zsb3csXG4gICAqIHRoaXMgZmllbGQgaXMgYHVuZGVmaW5lZGAuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBDb250aW51ZS1hcy1OZXcgKG9yIHJlc2V0KSBwcm9wYWdhdGVzIHRoZSB3b3JrZmxvdyBwYXJlbnRhZ2UgcmVsYXRpb25zaGlwLFxuICAgKiBhbmQgdGhlcmVmb3JlLCB3aGV0aGVyIHRoZSBuZXcgd29ya2Zsb3cgaGFzIHRoZSBzYW1lIHJvb3Qgd29ya2Zsb3cgYXMgdGhlIG9yaWdpbmFsIG9uZVxuICAgKiBkZXBlbmRzIG9uIHdoZXRoZXIgaXQgaGFkIGEgcGFyZW50LlxuICAgKlxuICAgKi9cbiAgcmVhZG9ubHkgcm9vdD86IFJvb3RXb3JrZmxvd0luZm87XG5cbiAgLyoqXG4gICAqIFJlc3VsdCBmcm9tIHRoZSBwcmV2aW91cyBSdW4gKHByZXNlbnQgaWYgdGhpcyBpcyBhIENyb24gV29ya2Zsb3cgb3Igd2FzIENvbnRpbnVlZCBBcyBOZXcpLlxuICAgKlxuICAgKiBBbiBhcnJheSBvZiB2YWx1ZXMsIHNpbmNlIG90aGVyIFNES3MgbWF5IHJldHVybiBtdWx0aXBsZSB2YWx1ZXMgZnJvbSBhIFdvcmtmbG93LlxuICAgKi9cbiAgcmVhZG9ubHkgbGFzdFJlc3VsdD86IHVua25vd247XG5cbiAgLyoqXG4gICAqIEZhaWx1cmUgZnJvbSB0aGUgcHJldmlvdXMgUnVuIChwcmVzZW50IHdoZW4gdGhpcyBSdW4gaXMgYSByZXRyeSwgb3IgdGhlIGxhc3QgUnVuIG9mIGEgQ3JvbiBXb3JrZmxvdyBmYWlsZWQpXG4gICAqL1xuICByZWFkb25seSBsYXN0RmFpbHVyZT86IEVycm9yO1xuXG4gIC8qKlxuICAgKiBMZW5ndGggb2YgV29ya2Zsb3cgaGlzdG9yeSB1cCB1bnRpbCB0aGUgY3VycmVudCBXb3JrZmxvdyBUYXNrLlxuICAgKlxuICAgKiBUaGlzIHZhbHVlIGNoYW5nZXMgZHVyaW5nIHRoZSBsaWZldGltZSBvZiBhbiBFeGVjdXRpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgc2FmZWx5IHVzZSB0aGlzIGluZm9ybWF0aW9uIHRvIGRlY2lkZSB3aGVuIHRvIHtAbGluayBjb250aW51ZUFzTmV3fS5cbiAgICovXG4gIHJlYWRvbmx5IGhpc3RvcnlMZW5ndGg6IG51bWJlcjtcblxuICAvKipcbiAgICogU2l6ZSBvZiBXb3JrZmxvdyBoaXN0b3J5IGluIGJ5dGVzIHVudGlsIHRoZSBjdXJyZW50IFdvcmtmbG93IFRhc2suXG4gICAqXG4gICAqIFRoaXMgdmFsdWUgY2hhbmdlcyBkdXJpbmcgdGhlIGxpZmV0aW1lIG9mIGFuIEV4ZWN1dGlvbi5cbiAgICpcbiAgICogU3VwcG9ydGVkIG9ubHkgb24gVGVtcG9yYWwgU2VydmVyIDEuMjArLCBhbHdheXMgemVybyBvbiBvbGRlciBzZXJ2ZXJzLlxuICAgKlxuICAgKiBZb3UgbWF5IHNhZmVseSB1c2UgdGhpcyBpbmZvcm1hdGlvbiB0byBkZWNpZGUgd2hlbiB0byB7QGxpbmsgY29udGludWVBc05ld30uXG4gICAqL1xuICByZWFkb25seSBoaXN0b3J5U2l6ZTogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBBIGhpbnQgcHJvdmlkZWQgYnkgdGhlIGN1cnJlbnQgV29ya2Zsb3dUYXNrU3RhcnRlZCBldmVudCByZWNvbW1lbmRpbmcgd2hldGhlciB0b1xuICAgKiB7QGxpbmsgY29udGludWVBc05ld30uXG4gICAqXG4gICAqIFRoaXMgdmFsdWUgY2hhbmdlcyBkdXJpbmcgdGhlIGxpZmV0aW1lIG9mIGFuIEV4ZWN1dGlvbi5cbiAgICpcbiAgICogU3VwcG9ydGVkIG9ubHkgb24gVGVtcG9yYWwgU2VydmVyIDEuMjArLCBhbHdheXMgYGZhbHNlYCBvbiBvbGRlciBzZXJ2ZXJzLlxuICAgKi9cbiAgcmVhZG9ubHkgY29udGludWVBc05ld1N1Z2dlc3RlZDogYm9vbGVhbjtcblxuICAvKipcbiAgICogVGFzayBxdWV1ZSB0aGlzIFdvcmtmbG93IGlzIGV4ZWN1dGluZyBvblxuICAgKi9cbiAgcmVhZG9ubHkgdGFza1F1ZXVlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE5hbWVzcGFjZSB0aGlzIFdvcmtmbG93IGlzIGV4ZWN1dGluZyBpblxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZXNwYWNlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFJ1biBJZCBvZiB0aGUgZmlyc3QgUnVuIGluIHRoaXMgRXhlY3V0aW9uIENoYWluXG4gICAqL1xuICByZWFkb25seSBmaXJzdEV4ZWN1dGlvblJ1bklkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBsYXN0IFJ1biBJZCBpbiB0aGlzIEV4ZWN1dGlvbiBDaGFpblxuICAgKi9cbiAgcmVhZG9ubHkgY29udGludWVkRnJvbUV4ZWN1dGlvblJ1bklkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaW1lIGF0IHdoaWNoIHRoaXMgW1dvcmtmbG93IEV4ZWN1dGlvbiBDaGFpbl0oaHR0cHM6Ly9kb2NzLnRlbXBvcmFsLmlvL3dvcmtmbG93cyN3b3JrZmxvdy1leGVjdXRpb24tY2hhaW4pIHdhcyBzdGFydGVkXG4gICAqL1xuICByZWFkb25seSBzdGFydFRpbWU6IERhdGU7XG5cbiAgLyoqXG4gICAqIFRpbWUgYXQgd2hpY2ggdGhlIGN1cnJlbnQgV29ya2Zsb3cgUnVuIHN0YXJ0ZWRcbiAgICovXG4gIHJlYWRvbmx5IHJ1blN0YXJ0VGltZTogRGF0ZTtcblxuICAvKipcbiAgICogTWlsbGlzZWNvbmRzIGFmdGVyIHdoaWNoIHRoZSBXb3JrZmxvdyBFeGVjdXRpb24gaXMgYXV0b21hdGljYWxseSB0ZXJtaW5hdGVkIGJ5IFRlbXBvcmFsIFNlcnZlci4gU2V0IHZpYSB7QGxpbmsgV29ya2Zsb3dPcHRpb25zLndvcmtmbG93RXhlY3V0aW9uVGltZW91dH0uXG4gICAqL1xuICByZWFkb25seSBleGVjdXRpb25UaW1lb3V0TXM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRpbWUgYXQgd2hpY2ggdGhlIFdvcmtmbG93IEV4ZWN1dGlvbiBleHBpcmVzXG4gICAqL1xuICByZWFkb25seSBleGVjdXRpb25FeHBpcmF0aW9uVGltZT86IERhdGU7XG5cbiAgLyoqXG4gICAqIE1pbGxpc2Vjb25kcyBhZnRlciB3aGljaCB0aGUgV29ya2Zsb3cgUnVuIGlzIGF1dG9tYXRpY2FsbHkgdGVybWluYXRlZCBieSBUZW1wb3JhbCBTZXJ2ZXIuIFNldCB2aWEge0BsaW5rIFdvcmtmbG93T3B0aW9ucy53b3JrZmxvd1J1blRpbWVvdXR9LlxuICAgKi9cbiAgcmVhZG9ubHkgcnVuVGltZW91dE1zPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBNYXhpbXVtIGV4ZWN1dGlvbiB0aW1lIG9mIGEgV29ya2Zsb3cgVGFzayBpbiBtaWxsaXNlY29uZHMuIFNldCB2aWEge0BsaW5rIFdvcmtmbG93T3B0aW9ucy53b3JrZmxvd1Rhc2tUaW1lb3V0fS5cbiAgICovXG4gIHJlYWRvbmx5IHRhc2tUaW1lb3V0TXM6IG51bWJlcjtcblxuICAvKipcbiAgICogUmV0cnkgUG9saWN5IGZvciB0aGlzIEV4ZWN1dGlvbi4gU2V0IHZpYSB7QGxpbmsgV29ya2Zsb3dPcHRpb25zLnJldHJ5fS5cbiAgICovXG4gIHJlYWRvbmx5IHJldHJ5UG9saWN5PzogUmV0cnlQb2xpY3k7XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyBhdCAxIGFuZCBpbmNyZW1lbnRzIGZvciBldmVyeSByZXRyeSBpZiB0aGVyZSBpcyBhIGByZXRyeVBvbGljeWBcbiAgICovXG4gIHJlYWRvbmx5IGF0dGVtcHQ6IG51bWJlcjtcblxuICAvKipcbiAgICogQ3JvbiBTY2hlZHVsZSBmb3IgdGhpcyBFeGVjdXRpb24uIFNldCB2aWEge0BsaW5rIFdvcmtmbG93T3B0aW9ucy5jcm9uU2NoZWR1bGV9LlxuICAgKi9cbiAgcmVhZG9ubHkgY3JvblNjaGVkdWxlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBNaWxsaXNlY29uZHMgYmV0d2VlbiBDcm9uIFJ1bnNcbiAgICovXG4gIHJlYWRvbmx5IGNyb25TY2hlZHVsZVRvU2NoZWR1bGVJbnRlcnZhbD86IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIEJ1aWxkIElEIG9mIHRoZSB3b3JrZXIgd2hpY2ggZXhlY3V0ZWQgdGhlIGN1cnJlbnQgV29ya2Zsb3cgVGFzay4gTWF5IGJlIHVuZGVmaW5lZCBpZiB0aGVcbiAgICogdGFzayB3YXMgY29tcGxldGVkIGJ5IGEgd29ya2VyIHdpdGhvdXQgYSBCdWlsZCBJRC4gSWYgdGhpcyB3b3JrZXIgaXMgdGhlIG9uZSBleGVjdXRpbmcgdGhpc1xuICAgKiB0YXNrIGZvciB0aGUgZmlyc3QgdGltZSBhbmQgaGFzIGEgQnVpbGQgSUQgc2V0LCB0aGVuIGl0cyBJRCB3aWxsIGJlIHVzZWQuIFRoaXMgdmFsdWUgbWF5IGNoYW5nZVxuICAgKiBvdmVyIHRoZSBsaWZldGltZSBvZiB0aGUgd29ya2Zsb3cgcnVuLCBidXQgaXMgZGV0ZXJtaW5pc3RpYyBhbmQgc2FmZSB0byB1c2UgZm9yIGJyYW5jaGluZy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBjdXJyZW50RGVwbG95bWVudFZlcnNpb25gIGluc3RlYWRcbiAgICovXG4gIHJlYWRvbmx5IGN1cnJlbnRCdWlsZElkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgRGVwbG95bWVudCBWZXJzaW9uIG9mIHRoZSB3b3JrZXIgd2hpY2ggZXhlY3V0ZWQgdGhlIGN1cnJlbnQgV29ya2Zsb3cgVGFzay4gTWF5IGJlIHVuZGVmaW5lZFxuICAgKiBpZiB0aGUgdGFzayB3YXMgY29tcGxldGVkIGJ5IGEgd29ya2VyIHdpdGhvdXQgYSBEZXBsb3ltZW50IFZlcnNpb24uIElmIHRoaXMgd29ya2VyIGlzIHRoZSBvbmVcbiAgICogZXhlY3V0aW5nIHRoaXMgdGFzayBmb3IgdGhlIGZpcnN0IHRpbWUgYW5kIGhhcyBhIERlcGxveW1lbnQgVmVyc2lvbiBzZXQsIHRoZW4gaXRzIElEIHdpbGwgYmVcbiAgICogdXNlZC4gVGhpcyB2YWx1ZSBtYXkgY2hhbmdlIG92ZXIgdGhlIGxpZmV0aW1lIG9mIHRoZSB3b3JrZmxvdyBydW4sIGJ1dCBpcyBkZXRlcm1pbmlzdGljIGFuZFxuICAgKiBzYWZlIHRvIHVzZSBmb3IgYnJhbmNoaW5nLlxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsIERlcGxveW1lbnQgYmFzZWQgdmVyc2lvbmluZyBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cbiAgICovXG4gIHJlYWRvbmx5IGN1cnJlbnREZXBsb3ltZW50VmVyc2lvbj86IFdvcmtlckRlcGxveW1lbnRWZXJzaW9uO1xuXG4gIHJlYWRvbmx5IHVuc2FmZTogVW5zYWZlV29ya2Zsb3dJbmZvO1xuXG4gIC8qKlxuICAgKiBQcmlvcml0eSBvZiB0aGlzIHdvcmtmbG93XG4gICAqL1xuICByZWFkb25seSBwcmlvcml0eT86IFByaW9yaXR5O1xufVxuXG4vKipcbiAqIFVuc2FmZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBXb3JrZmxvdyBFeGVjdXRpb24uXG4gKlxuICogTmV2ZXIgcmVseSBvbiB0aGlzIGluZm9ybWF0aW9uIGluIFdvcmtmbG93IGxvZ2ljIGFzIGl0IHdpbGwgY2F1c2Ugbm9uLWRldGVybWluaXN0aWMgYmVoYXZpb3IuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVW5zYWZlV29ya2Zsb3dJbmZvIHtcbiAgLyoqXG4gICAqIEN1cnJlbnQgc3lzdGVtIHRpbWUgaW4gbWlsbGlzZWNvbmRzXG4gICAqXG4gICAqIFRoZSBzYWZlIHZlcnNpb24gb2YgdGltZSBpcyBgbmV3IERhdGUoKWAgYW5kIGBEYXRlLm5vdygpYCwgd2hpY2ggYXJlIHNldCBvbiB0aGUgZmlyc3QgaW52b2NhdGlvbiBvZiBhIFdvcmtmbG93XG4gICAqIFRhc2sgYW5kIHN0YXkgY29uc3RhbnQgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgVGFzayBhbmQgZHVyaW5nIHJlcGxheS5cbiAgICovXG4gIHJlYWRvbmx5IG5vdzogKCkgPT4gbnVtYmVyO1xuXG4gIHJlYWRvbmx5IGlzUmVwbGF5aW5nOiBib29sZWFuO1xufVxuXG4vKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IGEgd29ya2Zsb3cgdXBkYXRlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFVwZGF0ZUluZm8ge1xuICAvKipcbiAgICogIEEgd29ya2Zsb3ctdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgdXBkYXRlLlxuICAgKi9cbiAgcmVhZG9ubHkgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogIFRoZSB1cGRhdGUgdHlwZSBuYW1lLlxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhcmVudFdvcmtmbG93SW5mbyB7XG4gIHdvcmtmbG93SWQ6IHN0cmluZztcbiAgcnVuSWQ6IHN0cmluZztcbiAgbmFtZXNwYWNlOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm9vdFdvcmtmbG93SW5mbyB7XG4gIHdvcmtmbG93SWQ6IHN0cmluZztcbiAgcnVuSWQ6IHN0cmluZztcbn1cblxuLyoqXG4gKiBOb3QgYW4gYWN0dWFsIGVycm9yLCB1c2VkIGJ5IHRoZSBXb3JrZmxvdyBydW50aW1lIHRvIGFib3J0IGV4ZWN1dGlvbiB3aGVuIHtAbGluayBjb250aW51ZUFzTmV3fSBpcyBjYWxsZWRcbiAqL1xuQFN5bWJvbEJhc2VkSW5zdGFuY2VPZkVycm9yKCdDb250aW51ZUFzTmV3JylcbmV4cG9ydCBjbGFzcyBDb250aW51ZUFzTmV3IGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgY29tbWFuZDogY29yZXNkay53b3JrZmxvd19jb21tYW5kcy5JQ29udGludWVBc05ld1dvcmtmbG93RXhlY3V0aW9uKSB7XG4gICAgc3VwZXIoJ1dvcmtmbG93IGNvbnRpbnVlZCBhcyBuZXcnKTtcbiAgfVxufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGNvbnRpbnVpbmcgYSBXb3JrZmxvdyBhcyBuZXdcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb250aW51ZUFzTmV3T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIFdvcmtmbG93IHR5cGUgbmFtZSwgZS5nLiB0aGUgZmlsZW5hbWUgaW4gdGhlIE5vZGUuanMgU0RLIG9yIGNsYXNzIG5hbWUgaW4gSmF2YVxuICAgKi9cbiAgd29ya2Zsb3dUeXBlPzogc3RyaW5nO1xuICAvKipcbiAgICogVGFzayBxdWV1ZSB0byBjb250aW51ZSB0aGUgV29ya2Zsb3cgaW5cbiAgICovXG4gIHRhc2tRdWV1ZT86IHN0cmluZztcbiAgLyoqXG4gICAqIFRpbWVvdXQgZm9yIHRoZSBlbnRpcmUgV29ya2Zsb3cgcnVuXG4gICAqIEBmb3JtYXQge0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ31cbiAgICovXG4gIHdvcmtmbG93UnVuVGltZW91dD86IER1cmF0aW9uO1xuICAvKipcbiAgICogVGltZW91dCBmb3IgYSBzaW5nbGUgV29ya2Zsb3cgdGFza1xuICAgKiBAZm9ybWF0IHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tcyB8IG1zLWZvcm1hdHRlZCBzdHJpbmd9XG4gICAqL1xuICB3b3JrZmxvd1Rhc2tUaW1lb3V0PzogRHVyYXRpb247XG4gIC8qKlxuICAgKiBOb24tc2VhcmNoYWJsZSBhdHRyaWJ1dGVzIHRvIGF0dGFjaCB0byBuZXh0IFdvcmtmbG93IHJ1blxuICAgKi9cbiAgbWVtbz86IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAvKipcbiAgICogU2VhcmNoYWJsZSBhdHRyaWJ1dGVzIHRvIGF0dGFjaCB0byBuZXh0IFdvcmtmbG93IHJ1blxuICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIHR5cGVkU2VhcmNoQXR0cmlidXRlc30gaW5zdGVhZC5cbiAgICovXG4gIHNlYXJjaEF0dHJpYnV0ZXM/OiBTZWFyY2hBdHRyaWJ1dGVzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgYWRkaXRpb25hbCBpbmRleGVkIGluZm9ybWF0aW9uIHRvIGF0dGFjaCB0byB0aGUgV29ya2Zsb3cgRXhlY3V0aW9uLiBNb3JlIGluZm86XG4gICAqIGh0dHBzOi8vZG9jcy50ZW1wb3JhbC5pby9kb2NzL3R5cGVzY3JpcHQvc2VhcmNoLWF0dHJpYnV0ZXNcbiAgICpcbiAgICogVmFsdWVzIGFyZSBhbHdheXMgY29udmVydGVkIHVzaW5nIHtAbGluayBKc29uUGF5bG9hZENvbnZlcnRlcn0sIGV2ZW4gd2hlbiBhIGN1c3RvbSBkYXRhIGNvbnZlcnRlciBpcyBwcm92aWRlZC5cbiAgICogTm90ZSB0aGF0IHNlYXJjaCBhdHRyaWJ1dGVzIGFyZSBub3QgZW5jb2RlZCwgYXMgc3VjaCwgZG8gbm90IGluY2x1ZGUgYW55IHNlbnNpdGl2ZSBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogSWYgYm90aCB7QGxpbmsgc2VhcmNoQXR0cmlidXRlc30gYW5kIHtAbGluayB0eXBlZFNlYXJjaEF0dHJpYnV0ZXN9IGFyZSBwcm92aWRlZCwgY29uZmxpY3Rpbmcga2V5cyB3aWxsIGJlIG92ZXJ3cml0dGVuXG4gICAqIGJ5IHtAbGluayB0eXBlZFNlYXJjaEF0dHJpYnV0ZXN9LlxuICAgKi9cbiAgdHlwZWRTZWFyY2hBdHRyaWJ1dGVzPzogU2VhcmNoQXR0cmlidXRlUGFpcltdIHwgVHlwZWRTZWFyY2hBdHRyaWJ1dGVzO1xuICAvKipcbiAgICogV2hlbiB1c2luZyB0aGUgV29ya2VyIFZlcnNpb25pbmcgZmVhdHVyZSwgc3BlY2lmaWVzIHdoZXRoZXIgdGhpcyBXb3JrZmxvdyBzaG91bGRcbiAgICogQ29udGludWUtYXMtTmV3IG9udG8gYSB3b3JrZXIgd2l0aCBhIGNvbXBhdGlibGUgQnVpbGQgSWQgb3Igbm90LiBTZWUge0BsaW5rIFZlcnNpb25pbmdJbnRlbnR9LlxuICAgKlxuICAgKiBAZGVmYXVsdCAnQ09NUEFUSUJMRSdcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgSW4gZmF2b3Igb2YgdGhlIG5ldyBXb3JrZXIgRGVwbG95bWVudCBBUEkuXG4gICAqIEBleHBlcmltZW50YWwgVGhlIFdvcmtlciBWZXJzaW9uaW5nIEFQSSBpcyBzdGlsbCBiZWluZyBkZXNpZ25lZC4gTWFqb3IgY2hhbmdlcyBhcmUgZXhwZWN0ZWQuXG4gICAqL1xuICB2ZXJzaW9uaW5nSW50ZW50PzogVmVyc2lvbmluZ0ludGVudDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxufVxuXG4vKipcbiAqIFNwZWNpZmllczpcbiAqIC0gd2hldGhlciBjYW5jZWxsYXRpb24gcmVxdWVzdHMgYXJlIHNlbnQgdG8gdGhlIENoaWxkXG4gKiAtIHdoZXRoZXIgYW5kIHdoZW4gYSB7QGxpbmsgQ2FuY2VsZWRGYWlsdXJlfSBpcyB0aHJvd24gZnJvbSB7QGxpbmsgZXhlY3V0ZUNoaWxkfSBvclxuICogICB7QGxpbmsgQ2hpbGRXb3JrZmxvd0hhbmRsZS5yZXN1bHR9XG4gKlxuICogQGRlZmF1bHQge0BsaW5rIENoaWxkV29ya2Zsb3dDYW5jZWxsYXRpb25UeXBlLldBSVRfQ0FOQ0VMTEFUSU9OX0NPTVBMRVRFRH1cbiAqL1xuZXhwb3J0IHR5cGUgQ2hpbGRXb3JrZmxvd0NhbmNlbGxhdGlvblR5cGUgPVxuICAodHlwZW9mIENoaWxkV29ya2Zsb3dDYW5jZWxsYXRpb25UeXBlKVtrZXlvZiB0eXBlb2YgQ2hpbGRXb3JrZmxvd0NhbmNlbGxhdGlvblR5cGVdO1xuZXhwb3J0IGNvbnN0IENoaWxkV29ya2Zsb3dDYW5jZWxsYXRpb25UeXBlID0ge1xuICAvKipcbiAgICogRG9uJ3Qgc2VuZCBhIGNhbmNlbGxhdGlvbiByZXF1ZXN0IHRvIHRoZSBDaGlsZC5cbiAgICovXG4gIEFCQU5ET046ICdBQkFORE9OJyxcblxuICAvKipcbiAgICogU2VuZCBhIGNhbmNlbGxhdGlvbiByZXF1ZXN0IHRvIHRoZSBDaGlsZC4gSW1tZWRpYXRlbHkgdGhyb3cgdGhlIGVycm9yLlxuICAgKi9cbiAgVFJZX0NBTkNFTDogJ1RSWV9DQU5DRUwnLFxuXG4gIC8qKlxuICAgKiBTZW5kIGEgY2FuY2VsbGF0aW9uIHJlcXVlc3QgdG8gdGhlIENoaWxkLiBUaGUgQ2hpbGQgbWF5IHJlc3BlY3QgY2FuY2VsbGF0aW9uLCBpbiB3aGljaCBjYXNlIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duXG4gICAqIHdoZW4gY2FuY2VsbGF0aW9uIGhhcyBjb21wbGV0ZWQsIGFuZCB7QGxpbmsgaXNDYW5jZWxsYXRpb259KGVycm9yKSB3aWxsIGJlIHRydWUuIE9uIHRoZSBvdGhlciBoYW5kLCB0aGUgQ2hpbGQgbWF5XG4gICAqIGlnbm9yZSB0aGUgY2FuY2VsbGF0aW9uIHJlcXVlc3QsIGluIHdoaWNoIGNhc2UgYW4gZXJyb3IgbWlnaHQgYmUgdGhyb3duIHdpdGggYSBkaWZmZXJlbnQgY2F1c2UsIG9yIHRoZSBDaGlsZCBtYXlcbiAgICogY29tcGxldGUgc3VjY2Vzc2Z1bGx5LlxuICAgKlxuICAgKiBAZGVmYXVsdFxuICAgKi9cbiAgV0FJVF9DQU5DRUxMQVRJT05fQ09NUExFVEVEOiAnV0FJVF9DQU5DRUxMQVRJT05fQ09NUExFVEVEJyxcblxuICAvKipcbiAgICogU2VuZCBhIGNhbmNlbGxhdGlvbiByZXF1ZXN0IHRvIHRoZSBDaGlsZC4gVGhyb3cgdGhlIGVycm9yIG9uY2UgdGhlIFNlcnZlciByZWNlaXZlcyB0aGUgQ2hpbGQgY2FuY2VsbGF0aW9uIHJlcXVlc3QuXG4gICAqL1xuICBXQUlUX0NBTkNFTExBVElPTl9SRVFVRVNURUQ6ICdXQUlUX0NBTkNFTExBVElPTl9SRVFVRVNURUQnLFxufSBhcyBjb25zdDtcblxuLy8gdHMtcHJ1bmUtaWdub3JlLW5leHRcbmV4cG9ydCBjb25zdCBbZW5jb2RlQ2hpbGRXb3JrZmxvd0NhbmNlbGxhdGlvblR5cGUsIGRlY29kZUNoaWxkV29ya2Zsb3dDYW5jZWxsYXRpb25UeXBlXSA9IG1ha2VQcm90b0VudW1Db252ZXJ0ZXJzPFxuICBjb3Jlc2RrLmNoaWxkX3dvcmtmbG93LkNoaWxkV29ya2Zsb3dDYW5jZWxsYXRpb25UeXBlLFxuICB0eXBlb2YgY29yZXNkay5jaGlsZF93b3JrZmxvdy5DaGlsZFdvcmtmbG93Q2FuY2VsbGF0aW9uVHlwZSxcbiAga2V5b2YgdHlwZW9mIGNvcmVzZGsuY2hpbGRfd29ya2Zsb3cuQ2hpbGRXb3JrZmxvd0NhbmNlbGxhdGlvblR5cGUsXG4gIHR5cGVvZiBDaGlsZFdvcmtmbG93Q2FuY2VsbGF0aW9uVHlwZSxcbiAgJydcbj4oXG4gIHtcbiAgICBbQ2hpbGRXb3JrZmxvd0NhbmNlbGxhdGlvblR5cGUuQUJBTkRPTl06IDAsXG4gICAgW0NoaWxkV29ya2Zsb3dDYW5jZWxsYXRpb25UeXBlLlRSWV9DQU5DRUxdOiAxLFxuICAgIFtDaGlsZFdvcmtmbG93Q2FuY2VsbGF0aW9uVHlwZS5XQUlUX0NBTkNFTExBVElPTl9DT01QTEVURURdOiAyLFxuICAgIFtDaGlsZFdvcmtmbG93Q2FuY2VsbGF0aW9uVHlwZS5XQUlUX0NBTkNFTExBVElPTl9SRVFVRVNURURdOiAzLFxuICB9IGFzIGNvbnN0LFxuICAnJ1xuKTtcblxuLyoqXG4gKiBIb3cgYSBDaGlsZCBXb3JrZmxvdyByZWFjdHMgdG8gdGhlIFBhcmVudCBXb3JrZmxvdyByZWFjaGluZyBhIENsb3NlZCBzdGF0ZS5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RvY3MudGVtcG9yYWwuaW8vY29uY2VwdHMvd2hhdC1pcy1hLXBhcmVudC1jbG9zZS1wb2xpY3kvIHwgUGFyZW50IENsb3NlIFBvbGljeX1cbiAqL1xuZXhwb3J0IHR5cGUgUGFyZW50Q2xvc2VQb2xpY3kgPSAodHlwZW9mIFBhcmVudENsb3NlUG9saWN5KVtrZXlvZiB0eXBlb2YgUGFyZW50Q2xvc2VQb2xpY3ldO1xuZXhwb3J0IGNvbnN0IFBhcmVudENsb3NlUG9saWN5ID0ge1xuICAvKipcbiAgICogV2hlbiB0aGUgUGFyZW50IGlzIENsb3NlZCwgdGhlIENoaWxkIGlzIFRlcm1pbmF0ZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0XG4gICAqL1xuICBURVJNSU5BVEU6ICdURVJNSU5BVEUnLFxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBQYXJlbnQgaXMgQ2xvc2VkLCBub3RoaW5nIGlzIGRvbmUgdG8gdGhlIENoaWxkLlxuICAgKi9cbiAgQUJBTkRPTjogJ0FCQU5ET04nLFxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBQYXJlbnQgaXMgQ2xvc2VkLCB0aGUgQ2hpbGQgaXMgQ2FuY2VsbGVkLlxuICAgKi9cbiAgUkVRVUVTVF9DQU5DRUw6ICdSRVFVRVNUX0NBTkNFTCcsXG5cbiAgLy8vIEFueXRoaW5nIGJlbG93IHRoaXMgbGluZSBoYXMgYmVlbiBkZXByZWNhdGVkXG5cbiAgLyoqXG4gICAqIElmIGEgYFBhcmVudENsb3NlUG9saWN5YCBpcyBzZXQgdG8gdGhpcywgb3IgaXMgbm90IHNldCBhdCBhbGwsIHRoZSBzZXJ2ZXIgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHVzZWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEVpdGhlciBsZWF2ZSBwcm9wZXJ0eSBgdW5kZWZpbmVkYCwgb3Igc2V0IGFuIGV4cGxpY2l0IHBvbGljeSBpbnN0ZWFkLlxuICAgKi9cbiAgUEFSRU5UX0NMT1NFX1BPTElDWV9VTlNQRUNJRklFRDogdW5kZWZpbmVkLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIFBhcmVudCBpcyBDbG9zZWQsIHRoZSBDaGlsZCBpcyBUZXJtaW5hdGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIFBhcmVudENsb3NlUG9saWN5LlRFUk1JTkFURX0gaW5zdGVhZC5cbiAgICovXG4gIFBBUkVOVF9DTE9TRV9QT0xJQ1lfVEVSTUlOQVRFOiAnVEVSTUlOQVRFJywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBQYXJlbnQgaXMgQ2xvc2VkLCBub3RoaW5nIGlzIGRvbmUgdG8gdGhlIENoaWxkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIFBhcmVudENsb3NlUG9saWN5LkFCQU5ET059IGluc3RlYWQuXG4gICAqL1xuICBQQVJFTlRfQ0xPU0VfUE9MSUNZX0FCQU5ET046ICdBQkFORE9OJywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBQYXJlbnQgaXMgQ2xvc2VkLCB0aGUgQ2hpbGQgaXMgQ2FuY2VsbGVkLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIFBhcmVudENsb3NlUG9saWN5LlJFUVVFU1RfQ0FOQ0VMfSBpbnN0ZWFkLlxuICAgKi9cbiAgUEFSRU5UX0NMT1NFX1BPTElDWV9SRVFVRVNUX0NBTkNFTDogJ1JFUVVFU1RfQ0FOQ0VMJywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxufSBhcyBjb25zdDtcblxuLy8gdHMtcHJ1bmUtaWdub3JlLW5leHRcbmV4cG9ydCBjb25zdCBbZW5jb2RlUGFyZW50Q2xvc2VQb2xpY3ksIGRlY29kZVBhcmVudENsb3NlUG9saWN5XSA9IG1ha2VQcm90b0VudW1Db252ZXJ0ZXJzPFxuICBjb3Jlc2RrLmNoaWxkX3dvcmtmbG93LlBhcmVudENsb3NlUG9saWN5LFxuICB0eXBlb2YgY29yZXNkay5jaGlsZF93b3JrZmxvdy5QYXJlbnRDbG9zZVBvbGljeSxcbiAga2V5b2YgdHlwZW9mIGNvcmVzZGsuY2hpbGRfd29ya2Zsb3cuUGFyZW50Q2xvc2VQb2xpY3ksXG4gIHR5cGVvZiBQYXJlbnRDbG9zZVBvbGljeSxcbiAgJ1BBUkVOVF9DTE9TRV9QT0xJQ1lfJ1xuPihcbiAge1xuICAgIFtQYXJlbnRDbG9zZVBvbGljeS5URVJNSU5BVEVdOiAxLFxuICAgIFtQYXJlbnRDbG9zZVBvbGljeS5BQkFORE9OXTogMixcbiAgICBbUGFyZW50Q2xvc2VQb2xpY3kuUkVRVUVTVF9DQU5DRUxdOiAzLFxuICAgIFVOU1BFQ0lGSUVEOiAwLFxuICB9IGFzIGNvbnN0LFxuICAnUEFSRU5UX0NMT1NFX1BPTElDWV8nXG4pO1xuXG5leHBvcnQgaW50ZXJmYWNlIENoaWxkV29ya2Zsb3dPcHRpb25zIGV4dGVuZHMgT21pdDxDb21tb25Xb3JrZmxvd09wdGlvbnMsICd3b3JrZmxvd0lkQ29uZmxpY3RQb2xpY3knPiB7XG4gIC8qKlxuICAgKiBXb3JrZmxvdyBpZCB0byB1c2Ugd2hlbiBzdGFydGluZy4gSWYgbm90IHNwZWNpZmllZCBhIFVVSUQgaXMgZ2VuZXJhdGVkLiBOb3RlIHRoYXQgaXQgaXNcbiAgICogZGFuZ2Vyb3VzIGFzIGluIGNhc2Ugb2YgY2xpZW50IHNpZGUgcmV0cmllcyBubyBkZWR1cGxpY2F0aW9uIHdpbGwgaGFwcGVuIGJhc2VkIG9uIHRoZVxuICAgKiBnZW5lcmF0ZWQgaWQuIFNvIHByZWZlciBhc3NpZ25pbmcgYnVzaW5lc3MgbWVhbmluZ2Z1bCBpZHMgaWYgcG9zc2libGUuXG4gICAqL1xuICB3b3JrZmxvd0lkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUYXNrIHF1ZXVlIHRvIHVzZSBmb3IgV29ya2Zsb3cgdGFza3MuIEl0IHNob3VsZCBtYXRjaCBhIHRhc2sgcXVldWUgc3BlY2lmaWVkIHdoZW4gY3JlYXRpbmcgYVxuICAgKiBgV29ya2VyYCB0aGF0IGhvc3RzIHRoZSBXb3JrZmxvdyBjb2RlLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCBhIGNoaWxkIGlzIHNjaGVkdWxlZCBvbiB0aGUgc2FtZSBUYXNrIFF1ZXVlIGFzIHRoZSBwYXJlbnQuXG4gICAqL1xuICB0YXNrUXVldWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllczpcbiAgICogLSB3aGV0aGVyIGNhbmNlbGxhdGlvbiByZXF1ZXN0cyBhcmUgc2VudCB0byB0aGUgQ2hpbGRcbiAgICogLSB3aGV0aGVyIGFuZCB3aGVuIGFuIGVycm9yIGlzIHRocm93biBmcm9tIHtAbGluayBleGVjdXRlQ2hpbGR9IG9yXG4gICAqICAge0BsaW5rIENoaWxkV29ya2Zsb3dIYW5kbGUucmVzdWx0fVxuICAgKlxuICAgKiBAZGVmYXVsdCB7QGxpbmsgQ2hpbGRXb3JrZmxvd0NhbmNlbGxhdGlvblR5cGUuV0FJVF9DQU5DRUxMQVRJT05fQ09NUExFVEVEfVxuICAgKi9cbiAgY2FuY2VsbGF0aW9uVHlwZT86IENoaWxkV29ya2Zsb3dDYW5jZWxsYXRpb25UeXBlO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgaG93IHRoZSBDaGlsZCByZWFjdHMgdG8gdGhlIFBhcmVudCBXb3JrZmxvdyByZWFjaGluZyBhIENsb3NlZCBzdGF0ZS5cbiAgICpcbiAgICogQGRlZmF1bHQge0BsaW5rIFBhcmVudENsb3NlUG9saWN5LlBBUkVOVF9DTE9TRV9QT0xJQ1lfVEVSTUlOQVRFfVxuICAgKi9cbiAgcGFyZW50Q2xvc2VQb2xpY3k/OiBQYXJlbnRDbG9zZVBvbGljeTtcblxuICAvKipcbiAgICogV2hlbiB1c2luZyB0aGUgV29ya2VyIFZlcnNpb25pbmcgZmVhdHVyZSwgc3BlY2lmaWVzIHdoZXRoZXIgdGhpcyBDaGlsZCBXb3JrZmxvdyBzaG91bGQgcnVuIG9uXG4gICAqIGEgd29ya2VyIHdpdGggYSBjb21wYXRpYmxlIEJ1aWxkIElkIG9yIG5vdC4gU2VlIHtAbGluayBWZXJzaW9uaW5nSW50ZW50fS5cbiAgICpcbiAgICogQGRlZmF1bHQgJ0NPTVBBVElCTEUnXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEluIGZhdm9yIG9mIHRoZSBuZXcgV29ya2VyIERlcGxveW1lbnQgQVBJLlxuICAgKiBAZXhwZXJpbWVudGFsIFRoZSBXb3JrZXIgVmVyc2lvbmluZyBBUEkgaXMgc3RpbGwgYmVpbmcgZGVzaWduZWQuIE1ham9yIGNoYW5nZXMgYXJlIGV4cGVjdGVkLlxuICAgKi9cbiAgdmVyc2lvbmluZ0ludGVudD86IFZlcnNpb25pbmdJbnRlbnQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbn1cblxuZXhwb3J0IHR5cGUgUmVxdWlyZWRDaGlsZFdvcmtmbG93T3B0aW9ucyA9IFJlcXVpcmVkPFBpY2s8Q2hpbGRXb3JrZmxvd09wdGlvbnMsICd3b3JrZmxvd0lkJyB8ICdjYW5jZWxsYXRpb25UeXBlJz4+ICYge1xuICBhcmdzOiB1bmtub3duW107XG59O1xuXG5leHBvcnQgdHlwZSBDaGlsZFdvcmtmbG93T3B0aW9uc1dpdGhEZWZhdWx0cyA9IENoaWxkV29ya2Zsb3dPcHRpb25zICYgUmVxdWlyZWRDaGlsZFdvcmtmbG93T3B0aW9ucztcblxuZXhwb3J0IGludGVyZmFjZSBTdGFja1RyYWNlU0RLSW5mbyB7XG4gIG5hbWU6IHN0cmluZztcbiAgdmVyc2lvbjogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzbGljZSBvZiBhIGZpbGUgc3RhcnRpbmcgYXQgbGluZU9mZnNldFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN0YWNrVHJhY2VGaWxlU2xpY2Uge1xuICAvKipcbiAgICogT25seSB1c2VkIHBvc3NpYmxlIHRvIHRyaW0gdGhlIGZpbGUgd2l0aG91dCBicmVha2luZyBzeW50YXggaGlnaGxpZ2h0aW5nLlxuICAgKi9cbiAgbGluZV9vZmZzZXQ6IG51bWJlcjtcbiAgLyoqXG4gICAqIHNsaWNlIG9mIGEgZmlsZSB3aXRoIGBcXG5gIChuZXdsaW5lKSBsaW5lIHRlcm1pbmF0b3IuXG4gICAqL1xuICBjb250ZW50OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQSBwb2ludGVyIHRvIGEgbG9jYXRpb24gaW4gYSBmaWxlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3RhY2tUcmFjZUZpbGVMb2NhdGlvbiB7XG4gIC8qKlxuICAgKiBQYXRoIHRvIHNvdXJjZSBmaWxlIChhYnNvbHV0ZSBvciByZWxhdGl2ZSkuXG4gICAqIFdoZW4gdXNpbmcgYSByZWxhdGl2ZSBwYXRoLCBtYWtlIHN1cmUgYWxsIHBhdGhzIGFyZSByZWxhdGl2ZSB0byB0aGUgc2FtZSByb290LlxuICAgKi9cbiAgZmlsZV9wYXRoPzogc3RyaW5nO1xuICAvKipcbiAgICogSWYgcG9zc2libGUsIFNESyBzaG91bGQgc2VuZCB0aGlzLCByZXF1aXJlZCBmb3IgZGlzcGxheWluZyB0aGUgY29kZSBsb2NhdGlvbi5cbiAgICovXG4gIGxpbmU/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBJZiBwb3NzaWJsZSwgU0RLIHNob3VsZCBzZW5kIHRoaXMuXG4gICAqL1xuICBjb2x1bW4/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBGdW5jdGlvbiBuYW1lIHRoaXMgbGluZSBiZWxvbmdzIHRvIChpZiBhcHBsaWNhYmxlKS5cbiAgICogVXNlZCBmb3IgZmFsbGluZyBiYWNrIHRvIHN0YWNrIHRyYWNlIHZpZXcuXG4gICAqL1xuICBmdW5jdGlvbl9uYW1lPzogc3RyaW5nO1xuICAvKipcbiAgICogRmxhZyB0byBtYXJrIHRoaXMgYXMgaW50ZXJuYWwgU0RLIGNvZGUgYW5kIGhpZGUgYnkgZGVmYXVsdCBpbiB0aGUgVUkuXG4gICAqL1xuICBpbnRlcm5hbF9jb2RlOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0YWNrVHJhY2Uge1xuICBsb2NhdGlvbnM6IFN0YWNrVHJhY2VGaWxlTG9jYXRpb25bXTtcbn1cblxuLyoqXG4gKiBVc2VkIGFzIHRoZSByZXN1bHQgZm9yIHRoZSBlbmhhbmNlZCBzdGFjayB0cmFjZSBxdWVyeVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVuaGFuY2VkU3RhY2tUcmFjZSB7XG4gIHNkazogU3RhY2tUcmFjZVNES0luZm87XG4gIC8qKlxuICAgKiBNYXBwaW5nIG9mIGZpbGUgcGF0aCB0byBmaWxlIGNvbnRlbnRzLlxuICAgKiBTREsgbWF5IGNob29zZSB0byBzZW5kIG5vLCBzb21lIG9yIGFsbCBzb3VyY2VzLlxuICAgKiBTb3VyY2VzIG1pZ2h0IGJlIHRyaW1tZWQsIGFuZCBzb21lIHRpbWUgb25seSB0aGUgZmlsZShzKSBvZiB0aGUgdG9wIGVsZW1lbnQgb2YgdGhlIHRyYWNlIHdpbGwgYmUgc2VudC5cbiAgICovXG4gIHNvdXJjZXM6IFJlY29yZDxzdHJpbmcsIFN0YWNrVHJhY2VGaWxlU2xpY2VbXT47XG4gIHN0YWNrczogU3RhY2tUcmFjZVtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtmbG93Q3JlYXRlT3B0aW9ucyB7XG4gIGluZm86IFdvcmtmbG93SW5mbztcbiAgcmFuZG9tbmVzc1NlZWQ6IG51bWJlcltdO1xuICBub3c6IG51bWJlcjtcbiAgc2hvd1N0YWNrVHJhY2VTb3VyY2VzOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtmbG93Q3JlYXRlT3B0aW9uc0ludGVybmFsIGV4dGVuZHMgV29ya2Zsb3dDcmVhdGVPcHRpb25zIHtcbiAgc291cmNlTWFwOiBSYXdTb3VyY2VNYXA7XG4gIHJlZ2lzdGVyZWRBY3Rpdml0eU5hbWVzOiBTZXQ8c3RyaW5nPjtcbiAgZ2V0VGltZU9mRGF5KCk6IGJpZ2ludDtcbn1cblxuLyoqXG4gKiBBIGhhbmRsZXIgZnVuY3Rpb24gY2FwYWJsZSBvZiBhY2NlcHRpbmcgdGhlIGFyZ3VtZW50cyBmb3IgYSBnaXZlbiBVcGRhdGVEZWZpbml0aW9uLCBTaWduYWxEZWZpbml0aW9uIG9yIFF1ZXJ5RGVmaW5pdGlvbi5cbiAqL1xuZXhwb3J0IHR5cGUgSGFuZGxlcjxcbiAgUmV0LFxuICBBcmdzIGV4dGVuZHMgYW55W10sXG4gIFQgZXh0ZW5kcyBVcGRhdGVEZWZpbml0aW9uPFJldCwgQXJncz4gfCBTaWduYWxEZWZpbml0aW9uPEFyZ3M+IHwgUXVlcnlEZWZpbml0aW9uPFJldCwgQXJncz4sXG4+ID0gVCBleHRlbmRzIFVwZGF0ZURlZmluaXRpb248aW5mZXIgUiwgaW5mZXIgQT5cbiAgPyAoLi4uYXJnczogQSkgPT4gUiB8IFByb21pc2U8Uj5cbiAgOiBUIGV4dGVuZHMgU2lnbmFsRGVmaW5pdGlvbjxpbmZlciBBPlxuICAgID8gKC4uLmFyZ3M6IEEpID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+XG4gICAgOiBUIGV4dGVuZHMgUXVlcnlEZWZpbml0aW9uPGluZmVyIFIsIGluZmVyIEE+XG4gICAgICA/ICguLi5hcmdzOiBBKSA9PiBSXG4gICAgICA6IG5ldmVyO1xuXG4vKipcbiAqIEEgaGFuZGxlciBmdW5jdGlvbiBhY2NlcHRpbmcgc2lnbmFsIGNhbGxzIGZvciBub24tcmVnaXN0ZXJlZCBzaWduYWwgbmFtZXMuXG4gKi9cbmV4cG9ydCB0eXBlIERlZmF1bHRTaWduYWxIYW5kbGVyID0gKHNpZ25hbE5hbWU6IHN0cmluZywgLi4uYXJnczogdW5rbm93bltdKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPjtcblxuLyoqXG4gKiBBIGhhbmRsZXIgZnVuY3Rpb24gYWNjZXB0aW5nIHVwZGF0ZSBjYWxscyBmb3Igbm9uLXJlZ2lzdGVyZWQgdXBkYXRlIG5hbWVzLlxuICovXG5leHBvcnQgdHlwZSBEZWZhdWx0VXBkYXRlSGFuZGxlciA9ICh1cGRhdGVOYW1lOiBzdHJpbmcsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gUHJvbWlzZTx1bmtub3duPiB8IHVua25vd247XG5cbi8qKlxuICogQSBoYW5kbGVyIGZ1bmN0aW9uIGFjY2VwdGluZyBxdWVyeSBjYWxscyBmb3Igbm9uLXJlZ2lzdGVyZWQgcXVlcnkgbmFtZXMuXG4gKi9cbmV4cG9ydCB0eXBlIERlZmF1bHRRdWVyeUhhbmRsZXIgPSAocXVlcnlOYW1lOiBzdHJpbmcsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdW5rbm93bjtcblxuLyoqXG4gKiBBIHZhbGlkYXRpb24gZnVuY3Rpb24gY2FwYWJsZSBvZiBhY2NlcHRpbmcgdGhlIGFyZ3VtZW50cyBmb3IgYSBnaXZlbiBVcGRhdGVEZWZpbml0aW9uLlxuICovXG5leHBvcnQgdHlwZSBVcGRhdGVWYWxpZGF0b3I8QXJncyBleHRlbmRzIGFueVtdPiA9ICguLi5hcmdzOiBBcmdzKSA9PiB2b2lkO1xuXG4vKipcbiAqIEEgZGVzY3JpcHRpb24gb2YgYSBxdWVyeSBoYW5kbGVyLlxuICovXG5leHBvcnQgdHlwZSBRdWVyeUhhbmRsZXJPcHRpb25zID0geyBkZXNjcmlwdGlvbj86IHN0cmluZyB9O1xuXG4vKipcbiAqIEEgZGVzY3JpcHRpb24gb2YgYSBzaWduYWwgaGFuZGxlci5cbiAqL1xuZXhwb3J0IHR5cGUgU2lnbmFsSGFuZGxlck9wdGlvbnMgPSB7IGRlc2NyaXB0aW9uPzogc3RyaW5nOyB1bmZpbmlzaGVkUG9saWN5PzogSGFuZGxlclVuZmluaXNoZWRQb2xpY3kgfTtcblxuLyoqXG4gKiBBIHZhbGlkYXRvciBhbmQgZGVzY3JpcHRpb24gb2YgYW4gdXBkYXRlIGhhbmRsZXIuXG4gKi9cbmV4cG9ydCB0eXBlIFVwZGF0ZUhhbmRsZXJPcHRpb25zPEFyZ3MgZXh0ZW5kcyBhbnlbXT4gPSB7XG4gIHZhbGlkYXRvcj86IFVwZGF0ZVZhbGlkYXRvcjxBcmdzPjtcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIHVuZmluaXNoZWRQb2xpY3k/OiBIYW5kbGVyVW5maW5pc2hlZFBvbGljeTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWN0aXZhdGlvbkNvbXBsZXRpb24ge1xuICBjb21tYW5kczogY29yZXNkay53b3JrZmxvd19jb21tYW5kcy5JV29ya2Zsb3dDb21tYW5kW107XG4gIHVzZWRJbnRlcm5hbEZsYWdzOiBudW1iZXJbXTtcbiAgdmVyc2lvbmluZ0JlaGF2aW9yPzogVmVyc2lvbmluZ0JlaGF2aW9yO1xufVxuIiwiaW1wb3J0IHR5cGUgeyBSYXdTb3VyY2VNYXAgfSBmcm9tICdzb3VyY2UtbWFwJztcbmltcG9ydCB7XG4gIGRlZmF1bHRGYWlsdXJlQ29udmVydGVyLFxuICBGYWlsdXJlQ29udmVydGVyLFxuICBQYXlsb2FkQ29udmVydGVyLFxuICBhcnJheUZyb21QYXlsb2FkcyxcbiAgZGVmYXVsdFBheWxvYWRDb252ZXJ0ZXIsXG4gIGVuc3VyZVRlbXBvcmFsRmFpbHVyZSxcbiAgSGFuZGxlclVuZmluaXNoZWRQb2xpY3ksXG4gIElsbGVnYWxTdGF0ZUVycm9yLFxuICBUZW1wb3JhbEZhaWx1cmUsXG4gIFdvcmtmbG93LFxuICBXb3JrZmxvd0V4ZWN1dGlvbkFscmVhZHlTdGFydGVkRXJyb3IsXG4gIFdvcmtmbG93UXVlcnlBbm5vdGF0ZWRUeXBlLFxuICBXb3JrZmxvd1NpZ25hbEFubm90YXRlZFR5cGUsXG4gIFdvcmtmbG93VXBkYXRlQW5ub3RhdGVkVHlwZSxcbiAgUHJvdG9GYWlsdXJlLFxuICBBcHBsaWNhdGlvbkZhaWx1cmUsXG4gIFdvcmtmbG93VXBkYXRlVHlwZSxcbiAgV29ya2Zsb3dVcGRhdGVWYWxpZGF0b3JUeXBlLFxuICBtYXBGcm9tUGF5bG9hZHMsXG4gIGZyb21QYXlsb2Fkc0F0SW5kZXgsXG4gIFJhd1ZhbHVlLFxuICBXb3JrZmxvd0Z1bmN0aW9uV2l0aE9wdGlvbnMsXG4gIFZlcnNpb25pbmdCZWhhdmlvcixcbiAgV29ya2Zsb3dEZWZpbml0aW9uT3B0aW9ucyxcbn0gZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uJztcbmltcG9ydCB7XG4gIGRlY29kZVNlYXJjaEF0dHJpYnV0ZXMsXG4gIGRlY29kZVR5cGVkU2VhcmNoQXR0cmlidXRlcyxcbn0gZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uL2xpYi9jb252ZXJ0ZXIvcGF5bG9hZC1zZWFyY2gtYXR0cmlidXRlcyc7XG5pbXBvcnQgeyBjb21wb3NlSW50ZXJjZXB0b3JzIH0gZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uL2xpYi9pbnRlcmNlcHRvcnMnO1xuaW1wb3J0IHsgbWFrZVByb3RvRW51bUNvbnZlcnRlcnMgfSBmcm9tICdAdGVtcG9yYWxpby9jb21tb24vbGliL2ludGVybmFsLXdvcmtmbG93JztcbmltcG9ydCB0eXBlIHsgY29yZXNkaywgdGVtcG9yYWwgfSBmcm9tICdAdGVtcG9yYWxpby9wcm90byc7XG5pbXBvcnQge1xuICBURU1QT1JBTF9SRVNFUlZFRF9QUkVGSVgsXG4gIFNUQUNLX1RSQUNFX1FVRVJZX05BTUUsXG4gIEVOSEFOQ0VEX1NUQUNLX1RSQUNFX1FVRVJZX05BTUUsXG59IGZyb20gJ0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvcmVzZXJ2ZWQnO1xuaW1wb3J0IHsgYWxlYSwgUk5HIH0gZnJvbSAnLi9hbGVhJztcbmltcG9ydCB7IFJvb3RDYW5jZWxsYXRpb25TY29wZSB9IGZyb20gJy4vY2FuY2VsbGF0aW9uLXNjb3BlJztcbmltcG9ydCB7IFVwZGF0ZVNjb3BlIH0gZnJvbSAnLi91cGRhdGUtc2NvcGUnO1xuaW1wb3J0IHsgRGV0ZXJtaW5pc21WaW9sYXRpb25FcnJvciwgTG9jYWxBY3Rpdml0eURvQmFja29mZiwgaXNDYW5jZWxsYXRpb24gfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQge1xuICBRdWVyeUlucHV0LFxuICBTaWduYWxJbnB1dCxcbiAgU3RhcnROZXh1c09wZXJhdGlvbk91dHB1dCxcbiAgVXBkYXRlSW5wdXQsXG4gIFdvcmtmbG93RXhlY3V0ZUlucHV0LFxuICBXb3JrZmxvd0ludGVyY2VwdG9ycyxcbn0gZnJvbSAnLi9pbnRlcmNlcHRvcnMnO1xuaW1wb3J0IHtcbiAgQ29udGludWVBc05ldyxcbiAgRGVmYXVsdFNpZ25hbEhhbmRsZXIsXG4gIFN0YWNrVHJhY2VTREtJbmZvLFxuICBTdGFja1RyYWNlRmlsZVNsaWNlLFxuICBTdGFja1RyYWNlRmlsZUxvY2F0aW9uLFxuICBXb3JrZmxvd0luZm8sXG4gIFdvcmtmbG93Q3JlYXRlT3B0aW9uc0ludGVybmFsLFxuICBBY3RpdmF0aW9uQ29tcGxldGlvbixcbiAgRGVmYXVsdFVwZGF0ZUhhbmRsZXIsXG4gIERlZmF1bHRRdWVyeUhhbmRsZXIsXG4gIEVuaGFuY2VkU3RhY2tUcmFjZSxcbn0gZnJvbSAnLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IHR5cGUgU2lua0NhbGwgfSBmcm9tICcuL3NpbmtzJztcbmltcG9ydCB7IHVudHJhY2tQcm9taXNlIH0gZnJvbSAnLi9zdGFjay1oZWxwZXJzJztcbmltcG9ydCBwa2cgZnJvbSAnLi9wa2cnO1xuaW1wb3J0IHsgU2RrRmxhZywgYXNzZXJ0VmFsaWRGbGFnIH0gZnJvbSAnLi9mbGFncyc7XG5pbXBvcnQgeyBleGVjdXRlV2l0aExpZmVjeWNsZUxvZ2dpbmcsIGxvZyB9IGZyb20gJy4vbG9ncyc7XG5cbmNvbnN0IFN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbkZhaWxlZENhdXNlID0ge1xuICBXT1JLRkxPV19BTFJFQURZX0VYSVNUUzogJ1dPUktGTE9XX0FMUkVBRFlfRVhJU1RTJyxcbn0gYXMgY29uc3Q7XG50eXBlIFN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbkZhaWxlZENhdXNlID1cbiAgKHR5cGVvZiBTdGFydENoaWxkV29ya2Zsb3dFeGVjdXRpb25GYWlsZWRDYXVzZSlba2V5b2YgdHlwZW9mIFN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbkZhaWxlZENhdXNlXTtcblxuY29uc3QgW19lbmNvZGVTdGFydENoaWxkV29ya2Zsb3dFeGVjdXRpb25GYWlsZWRDYXVzZSwgZGVjb2RlU3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uRmFpbGVkQ2F1c2VdID1cbiAgbWFrZVByb3RvRW51bUNvbnZlcnRlcnM8XG4gICAgY29yZXNkay5jaGlsZF93b3JrZmxvdy5TdGFydENoaWxkV29ya2Zsb3dFeGVjdXRpb25GYWlsZWRDYXVzZSxcbiAgICB0eXBlb2YgY29yZXNkay5jaGlsZF93b3JrZmxvdy5TdGFydENoaWxkV29ya2Zsb3dFeGVjdXRpb25GYWlsZWRDYXVzZSxcbiAgICBrZXlvZiB0eXBlb2YgY29yZXNkay5jaGlsZF93b3JrZmxvdy5TdGFydENoaWxkV29ya2Zsb3dFeGVjdXRpb25GYWlsZWRDYXVzZSxcbiAgICB0eXBlb2YgU3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uRmFpbGVkQ2F1c2UsXG4gICAgJ1NUQVJUX0NISUxEX1dPUktGTE9XX0VYRUNVVElPTl9GQUlMRURfQ0FVU0VfJ1xuICA+KFxuICAgIHtcbiAgICAgIFtTdGFydENoaWxkV29ya2Zsb3dFeGVjdXRpb25GYWlsZWRDYXVzZS5XT1JLRkxPV19BTFJFQURZX0VYSVNUU106IDEsXG4gICAgICBVTlNQRUNJRklFRDogMCxcbiAgICB9IGFzIGNvbnN0LFxuICAgICdTVEFSVF9DSElMRF9XT1JLRkxPV19FWEVDVVRJT05fRkFJTEVEX0NBVVNFXydcbiAgKTtcblxuZXhwb3J0IGludGVyZmFjZSBTdGFjayB7XG4gIGZvcm1hdHRlZDogc3RyaW5nO1xuICBzdHJ1Y3R1cmVkOiBTdGFja1RyYWNlRmlsZUxvY2F0aW9uW107XG59XG5cbi8qKlxuICogR2xvYmFsIHN0b3JlIHRvIHRyYWNrIHByb21pc2Ugc3RhY2tzIGZvciBzdGFjayB0cmFjZSBxdWVyeVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFByb21pc2VTdGFja1N0b3JlIHtcbiAgY2hpbGRUb1BhcmVudDogTWFwPFByb21pc2U8dW5rbm93bj4sIFNldDxQcm9taXNlPHVua25vd24+Pj47XG4gIHByb21pc2VUb1N0YWNrOiBNYXA8UHJvbWlzZTx1bmtub3duPiwgU3RhY2s+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBsZXRpb248U3VjY2Vzcz4ge1xuICByZXNvbHZlKHZhbDogU3VjY2Vzcyk6IHZvaWQ7XG4gIHJlamVjdChyZWFzb246IEVycm9yKTogdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb25kaXRpb24ge1xuICBmbigpOiBib29sZWFuO1xuXG4gIHJlc29sdmUoKTogdm9pZDtcbn1cblxuZXhwb3J0IHR5cGUgQWN0aXZhdGlvbkhhbmRsZXJGdW5jdGlvbjxLIGV4dGVuZHMga2V5b2YgY29yZXNkay53b3JrZmxvd19hY3RpdmF0aW9uLklXb3JrZmxvd0FjdGl2YXRpb25Kb2I+ID0gKFxuICBhY3RpdmF0aW9uOiBOb25OdWxsYWJsZTxjb3Jlc2RrLndvcmtmbG93X2FjdGl2YXRpb24uSVdvcmtmbG93QWN0aXZhdGlvbkpvYltLXT5cbikgPT4gdm9pZDtcblxuLyoqXG4gKiBWZXJpZmllcyBhbGwgYWN0aXZhdGlvbiBqb2IgaGFuZGxpbmcgbWV0aG9kcyBhcmUgaW1wbGVtZW50ZWRcbiAqL1xuZXhwb3J0IHR5cGUgQWN0aXZhdGlvbkhhbmRsZXIgPSB7XG4gIFtQIGluIGtleW9mIGNvcmVzZGsud29ya2Zsb3dfYWN0aXZhdGlvbi5JV29ya2Zsb3dBY3RpdmF0aW9uSm9iXTogQWN0aXZhdGlvbkhhbmRsZXJGdW5jdGlvbjxQPjtcbn07XG5cbi8qKlxuICogSW5mb3JtYXRpb24gYWJvdXQgYW4gdXBkYXRlIG9yIHNpZ25hbCBoYW5kbGVyIGV4ZWN1dGlvbi5cbiAqL1xuaW50ZXJmYWNlIE1lc3NhZ2VIYW5kbGVyRXhlY3V0aW9uIHtcbiAgbmFtZTogc3RyaW5nO1xuICB1bmZpbmlzaGVkUG9saWN5OiBIYW5kbGVyVW5maW5pc2hlZFBvbGljeTtcbiAgaWQ/OiBzdHJpbmc7XG59XG5cbnR5cGUgSW5mZXJNYXBWYWx1ZTxUPiA9IFQgZXh0ZW5kcyBNYXA8bnVtYmVyLCBpbmZlciBWPiA/IFYgOiBuZXZlcjtcblxuLyoqXG4gKiBLZWVwcyBhbGwgb2YgdGhlIFdvcmtmbG93IHJ1bnRpbWUgc3RhdGUgbGlrZSBwZW5kaW5nIGNvbXBsZXRpb25zIGZvciBhY3Rpdml0aWVzIGFuZCB0aW1lcnMuXG4gKlxuICogSW1wbGVtZW50cyBoYW5kbGVycyBmb3IgYWxsIHdvcmtmbG93IGFjdGl2YXRpb24gam9icy5cbiAqXG4gKiBOb3RlIHRoYXQgbW9zdCBtZXRob2RzIGluIHRoaXMgY2xhc3MgYXJlIG1lYW50IHRvIGJlIGNhbGxlZCBvbmx5IGZyb20gd2l0aGluIHRoZSBWTS5cbiAqXG4gKiBIb3dldmVyLCBhIGZldyBtZXRob2RzIG1heSBiZSBjYWxsZWQgZGlyZWN0bHkgZnJvbSBvdXRzaWRlIHRoZSBWTSAoZXNzZW50aWFsbHkgZnJvbSBgdm0tc2hhcmVkLnRzYCkuXG4gKiBUaGVzZSBtZXRob2RzIGFyZSBzcGVjaWZpY2FsbHkgbWFya2VkIHdpdGggYSBjb21tZW50IGFuZCByZXF1aXJlIGNhcmVmdWwgY29uc2lkZXJhdGlvbiwgYXMgdGhlXG4gKiBleGVjdXRpb24gY29udGV4dCBtYXkgbm90IHByb3Blcmx5IHJlZmxlY3QgdGhhdCBvZiB0aGUgdGFyZ2V0IHdvcmtmbG93IGV4ZWN1dGlvbiAoZS5nLjogd2l0aCBSZXVzYWJsZVxuICogVk1zLCB0aGUgYGdsb2JhbGAgbWF5IG5vdCBoYXZlIGJlZW4gc3dhcHBlZCB0byB0aG9zZSBvZiB0aGF0IHdvcmtmbG93IGV4ZWN1dGlvbjsgdGhlIGFjdGl2ZSBtaWNyb3Rhc2tcbiAqIHF1ZXVlIG1heSBiZSB0aGF0IG9mIHRoZSB0aHJlYWQvcHJvY2VzcywgcmF0aGVyIHRoYW4gdGhlIHF1ZXVlIG9mIHRoYXQgVk0gY29udGV4dDsgZXRjKS4gQ29uc2VxdWVudGx5LFxuICogbWV0aG9kcyB0aGF0IGFyZSBtZWFudCB0byBiZSBjYWxsZWQgZnJvbSBvdXRzaWRlIG9mIHRoZSBWTSBtdXN0IG5vdCBkbyBhbnkgb2YgdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAtIEFjY2VzcyBhbnkgZ2xvYmFsIHZhcmlhYmxlO1xuICogLSBDcmVhdGUgUHJvbWlzZSBvYmplY3RzLCB1c2UgYXN5bmMvYXdhaXQsIG9yIG90aGVyd2lzZSBzY2hlZHVsZSBtaWNyb3Rhc2tzO1xuICogLSBDYWxsIHVzZXItZGVmaW5lZCBmdW5jdGlvbnMsIGluY2x1ZGluZyBhbnkgZm9ybSBvZiBpbnRlcmNlcHRvci5cbiAqL1xuZXhwb3J0IGNsYXNzIEFjdGl2YXRvciBpbXBsZW1lbnRzIEFjdGl2YXRpb25IYW5kbGVyIHtcbiAgLyoqXG4gICAqIENhY2hlIGZvciBtb2R1bGVzIC0gcmVmZXJlbmNlZCBpbiByZXVzYWJsZS12bS50c1xuICAgKi9cbiAgcmVhZG9ubHkgbW9kdWxlQ2FjaGUgPSBuZXcgTWFwPHN0cmluZywgdW5rbm93bj4oKTtcblxuICAvKipcbiAgICogTWFwIG9mIHRhc2sgc2VxdWVuY2UgdG8gYSBDb21wbGV0aW9uXG4gICAqL1xuICByZWFkb25seSBjb21wbGV0aW9ucyA9IHtcbiAgICB0aW1lcjogbmV3IE1hcDxudW1iZXIsIENvbXBsZXRpb248dm9pZD4+KCksXG4gICAgYWN0aXZpdHk6IG5ldyBNYXA8bnVtYmVyLCBDb21wbGV0aW9uPHVua25vd24+PigpLFxuICAgIG5leHVzT3BlcmF0aW9uU3RhcnQ6IG5ldyBNYXA8bnVtYmVyLCBDb21wbGV0aW9uPFN0YXJ0TmV4dXNPcGVyYXRpb25PdXRwdXQ+PigpLFxuICAgIG5leHVzT3BlcmF0aW9uQ29tcGxldGU6IG5ldyBNYXA8bnVtYmVyLCBDb21wbGV0aW9uPHVua25vd24+PigpLFxuICAgIGNoaWxkV29ya2Zsb3dTdGFydDogbmV3IE1hcDxudW1iZXIsIENvbXBsZXRpb248c3RyaW5nPj4oKSxcbiAgICBjaGlsZFdvcmtmbG93Q29tcGxldGU6IG5ldyBNYXA8bnVtYmVyLCBDb21wbGV0aW9uPHVua25vd24+PigpLFxuICAgIHNpZ25hbFdvcmtmbG93OiBuZXcgTWFwPG51bWJlciwgQ29tcGxldGlvbjx2b2lkPj4oKSxcbiAgICBjYW5jZWxXb3JrZmxvdzogbmV3IE1hcDxudW1iZXIsIENvbXBsZXRpb248dm9pZD4+KCksXG4gIH07XG5cbiAgLyoqXG4gICAqIEhvbGRzIGJ1ZmZlcmVkIFVwZGF0ZSBjYWxscyB1bnRpbCBhIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZFxuICAgKi9cbiAgcmVhZG9ubHkgYnVmZmVyZWRVcGRhdGVzID0gQXJyYXk8Y29yZXNkay53b3JrZmxvd19hY3RpdmF0aW9uLklEb1VwZGF0ZT4oKTtcblxuICAvKipcbiAgICogSG9sZHMgYnVmZmVyZWQgc2lnbmFsIGNhbGxzIHVudGlsIGEgaGFuZGxlciBpcyByZWdpc3RlcmVkXG4gICAqL1xuICByZWFkb25seSBidWZmZXJlZFNpZ25hbHMgPSBBcnJheTxjb3Jlc2RrLndvcmtmbG93X2FjdGl2YXRpb24uSVNpZ25hbFdvcmtmbG93PigpO1xuXG4gIC8qKlxuICAgKiBNYXBwaW5nIG9mIHVwZGF0ZSBuYW1lIHRvIGhhbmRsZXIgYW5kIHZhbGlkYXRvclxuICAgKi9cbiAgcmVhZG9ubHkgdXBkYXRlSGFuZGxlcnMgPSBuZXcgTWFwPHN0cmluZywgV29ya2Zsb3dVcGRhdGVBbm5vdGF0ZWRUeXBlPigpO1xuXG4gIC8qKlxuICAgKiBNYXBwaW5nIG9mIHNpZ25hbCBuYW1lIHRvIGhhbmRsZXJcbiAgICovXG4gIHJlYWRvbmx5IHNpZ25hbEhhbmRsZXJzID0gbmV3IE1hcDxzdHJpbmcsIFdvcmtmbG93U2lnbmFsQW5ub3RhdGVkVHlwZT4oKTtcblxuICAvKipcbiAgICogTWFwcGluZyBvZiBpbi1wcm9ncmVzcyB1cGRhdGVzIHRvIGhhbmRsZXIgZXhlY3V0aW9uIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgcmVhZG9ubHkgaW5Qcm9ncmVzc1VwZGF0ZXMgPSBuZXcgTWFwPHN0cmluZywgTWVzc2FnZUhhbmRsZXJFeGVjdXRpb24+KCk7XG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgb2YgaW4tcHJvZ3Jlc3Mgc2lnbmFscyB0byBoYW5kbGVyIGV4ZWN1dGlvbiBpbmZvcm1hdGlvbi5cbiAgICovXG4gIHJlYWRvbmx5IGluUHJvZ3Jlc3NTaWduYWxzID0gbmV3IE1hcDxudW1iZXIsIE1lc3NhZ2VIYW5kbGVyRXhlY3V0aW9uPigpO1xuXG4gIC8qKlxuICAgKiBBIHNlcXVlbmNlIG51bWJlciBwcm92aWRpbmcgdW5pcXVlIGlkZW50aWZpZXJzIGZvciBzaWduYWwgaGFuZGxlciBleGVjdXRpb25zLlxuICAgKi9cbiAgcHJvdGVjdGVkIHNpZ25hbEhhbmRsZXJFeGVjdXRpb25TZXEgPSAwO1xuXG4gIC8qKlxuICAgKiBBIHNpZ25hbCBoYW5kbGVyIHRoYXQgY2F0Y2hlcyBjYWxscyBmb3Igbm9uLXJlZ2lzdGVyZWQgc2lnbmFsIG5hbWVzLlxuICAgKi9cbiAgZGVmYXVsdFNpZ25hbEhhbmRsZXI/OiBEZWZhdWx0U2lnbmFsSGFuZGxlcjtcblxuICAvKipcbiAgICogQSB1cGRhdGUgaGFuZGxlciB0aGF0IGNhdGNoZXMgY2FsbHMgZm9yIG5vbi1yZWdpc3RlcmVkIHVwZGF0ZSBuYW1lcy5cbiAgICovXG4gIGRlZmF1bHRVcGRhdGVIYW5kbGVyPzogRGVmYXVsdFVwZGF0ZUhhbmRsZXI7XG5cbiAgLyoqXG4gICAqIEEgcXVlcnkgaGFuZGxlciB0aGF0IGNhdGNoZXMgY2FsbHMgZm9yIG5vbi1yZWdpc3RlcmVkIHF1ZXJ5IG5hbWVzLlxuICAgKi9cbiAgZGVmYXVsdFF1ZXJ5SGFuZGxlcj86IERlZmF1bHRRdWVyeUhhbmRsZXI7XG5cbiAgLyoqXG4gICAqIFNvdXJjZSBtYXAgZmlsZSBmb3IgbG9va2luZyB1cCB0aGUgc291cmNlIGZpbGVzIGluIHJlc3BvbnNlIHRvIF9fZW5oYW5jZWRfc3RhY2tfdHJhY2VcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBzb3VyY2VNYXA6IFJhd1NvdXJjZU1hcDtcblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdG8gc2VuZCB0aGUgc291cmNlcyBpbiBlbmhhbmNlZCBzdGFjayB0cmFjZSBxdWVyeSByZXNwb25zZXNcbiAgICovXG4gIHByb3RlY3RlZCByZWFkb25seSBzaG93U3RhY2tUcmFjZVNvdXJjZXM7XG5cbiAgcmVhZG9ubHkgcHJvbWlzZVN0YWNrU3RvcmU6IFByb21pc2VTdGFja1N0b3JlID0ge1xuICAgIHByb21pc2VUb1N0YWNrOiBuZXcgTWFwKCksXG4gICAgY2hpbGRUb1BhcmVudDogbmV3IE1hcCgpLFxuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgZXJyb3IgdGhhdCBjYXVzZWQgdGhlIGN1cnJlbnQgV29ya2Zsb3cgVGFzayB0byBmYWlsLiBTZXRzIGlmIGEgbm9uLWBUZW1wb3JhbEZhaWx1cmVgXG4gICAqIGVycm9yIGJ1YmJsZXMgdXAgb3V0IG9mIHRoZSBXb3JrZmxvdyBmdW5jdGlvbiwgb3Igb3V0IG9mIGEgU2lnbmFsIG9yIFVwZGF0ZSBoYW5kbGVyLiBXZVxuICAgKiBjYXB0dXJlIGVycm9ycyB0aGlzIHdheSBiZWNhdXNlIHRob3NlIGZ1bmN0aW9ucyBhcmUgbm90IHRlY2huaWNhbGx5IGF3YWl0ZWQgd2hlbiBzdGFydGVkLFxuICAgKiBidXQgbGVmdCB0byBydW4gYXN5bmNocm9ub3VzbHkuIFRoZXJlIGlzIHRoZXJlZm9yZSBubyByZWFsIFwicGFyZW50XCIgZnVuY3Rpb24gdGhhdCBjYW5cbiAgICogZGlyZWN0bHkgaGFuZGxlIHRob3NlIGVycm9ycywgYW5kIG5vdCBjYXB0dXJpbmcgaXQgd291bGQgcmVzdWx0IGluIGFuIFVuaGFuZGxlZCBQcm9taXNlXG4gICAqIFJlamVjdGlvbi4gU28gaW5zdGVhZCwgd2UgYnVmZmVyIHRoZSBlcnJvciBoZXJlLCB0byB0aGVuIGJlIHByb2Nlc3NlZCBpbiB0aGUgY29udGV4dFxuICAgKiBvZiBvdXIgb3duIHN5bmNocm9ub3VzIEFjdGl2YXRpb24gaGFuZGxpbmcgZXZlbnQgbG9vcC5cbiAgICpcbiAgICogT3VyIGNvZGUgZG9lcyBhIGJlc3QgZWZmb3J0IHRvIHN0b3AgcHJvY2Vzc2luZyB0aGUgY3VycmVudCBhY3RpdmF0aW9uIGFzIHNvb24gYXMgcG9zc2libGVcbiAgICogYWZ0ZXIgdGhpcyBmaWVsZCBpcyBzZXQ6XG4gICAqICAtIElmIGFuIGVycm9yIGlzIHRocm93biB3aGlsZSBleGVjdXRpbmcgY29kZSBzeW5jaHJvbm91c2x5IChlLmcuIGFueXRoaW5nIGJlZm9yZSB0aGVcbiAgICogICAgZmlyc3QgYGF3YWl0YCBzdGF0ZW1lbnQgaW4gYSBXb3JrZmxvdyBmdW5jdGlvbiBvciBhIHNpZ25hbC91cGRhdGUgaGFuZGxlciksIHRoZSBlcnJvclxuICAgKiAgICB3aWxsIGJlIF9pbW1lZGlhdGVseV8gcmV0aHJvd24sIHdoaWNoIHdpbGwgcHJldmVudCBleGVjdXRpb24gb2YgZnVydGhlciBqb2JzIGluIHRoZVxuICAgKiAgICBjdXJyZW50IGFjdGl2YXRpb24uIFdlIGtub3cgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgY29kZSBzeW5jaHJvbm91c2x5IHRoYW5rcyB0byB0aGVcbiAgICogICAgYHJldGhyb3dTeW5jaHJvbm91c2x5YCBmbGFnIGJlbG93LlxuICAgKiAgLSBJdCBhbiBlcnJvciBpcyB0aHJvd24gd2hpbGUgZXhlY3V0aW5nIG1pY3JvdGFza3MsIHRoZW4gdGhlIGVycm9yIHdpbGwgYmUgcmV0aHJvd24gb25cbiAgICogICAgdGhlIG5leHQgY2FsbCB0byBgdHJ5VW5ibG9ja0NvbmRpdGlvbnMoKWAuXG4gICAqXG4gICAqIFVuZm9ydHVuYXRlbHksIHRoZXJlJ3Mgbm8gd2F5IGZvciB1cyB0byBwcmV2ZW50IGZ1cnRoZXIgZXhlY3V0aW9uIG9mIG1pY3JvdGFza3MgdGhhdCBoYXZlXG4gICAqIGFscmVhZHkgYmVlbiBzY2hlZHVsZWQsIG5vciB0aG9zZSB0aGF0IHdpbGwgYmUgcmVjdXJzaXZlbHkgc2NoZWR1bGVkIGZyb20gdGhvc2UgbWljcm90YXNrcy5cbiAgICogU2hvdWxkIG1vcmUgZXJyb3JzIGdldCB0aHJvd24gd2hpbGUgc2V0dGxpbmcgbWljcm90YXNrcywgdGhvc2Ugd2lsbCBiZSBpZ25vcmVkIChpLmUuIG9ubHlcbiAgICogdGhlIGZpcnN0IGNhcHR1cmVkIGVycm9yIGlzIHByZXNlcnZlZCkuXG4gICAqL1xuICBwdWJsaWMgd29ya2Zsb3dUYXNrRXJyb3I6IHVua25vd247XG5cbiAgLyoqXG4gICAqIFNldCB0byB0cnVlIHdoZW4gcnVubmluZyBzeW5jaHJvbm91cyBjb2RlIChlLmcuIHdoaWxlIHByb2Nlc3NpbmcgYWN0aXZhdGlvbiBqb2JzIGFuZCB3aGVuIGNhbGxpbmdcbiAgICogYHRyeVVuYmxvY2tDb25kaXRpb25zKClgKS4gV2hpbGUgdGhpcyBmbGFnIGlzIHNldCwgaXQgaXMgc2FmZSB0byBsZXQgZXJyb3JzIGJ1YmJsZSB1cC5cbiAgICovXG4gIHB1YmxpYyByZXRocm93U3luY2hyb25vdXNseSA9IGZhbHNlO1xuXG4gIHB1YmxpYyByZWFkb25seSByb290U2NvcGUgPSBuZXcgUm9vdENhbmNlbGxhdGlvblNjb3BlKCk7XG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgb2YgcXVlcnkgbmFtZSB0byBoYW5kbGVyXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgcXVlcnlIYW5kbGVycyA9IG5ldyBNYXA8c3RyaW5nLCBXb3JrZmxvd1F1ZXJ5QW5ub3RhdGVkVHlwZT4oW1xuICAgIFtcbiAgICAgIFNUQUNLX1RSQUNFX1FVRVJZX05BTUUsXG4gICAgICB7XG4gICAgICAgIGhhbmRsZXI6ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJhd1ZhbHVlPHN0cmluZz4oXG4gICAgICAgICAgICB0aGlzLmdldFN0YWNrVHJhY2VzKClcbiAgICAgICAgICAgICAgLm1hcCgocykgPT4gcy5mb3JtYXR0ZWQpXG4gICAgICAgICAgICAgIC5qb2luKCdcXG5cXG4nKVxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnUmV0dXJucyBhIHNlbnNpYmxlIHN0YWNrIHRyYWNlLicsXG4gICAgICB9LFxuICAgIF0sXG4gICAgW1xuICAgICAgRU5IQU5DRURfU1RBQ0tfVFJBQ0VfUVVFUllfTkFNRSxcbiAgICAgIHtcbiAgICAgICAgaGFuZGxlcjogKCk6IFJhd1ZhbHVlID0+IHtcbiAgICAgICAgICBjb25zdCB7IHNvdXJjZU1hcCB9ID0gdGhpcztcbiAgICAgICAgICBjb25zdCBzZGs6IFN0YWNrVHJhY2VTREtJbmZvID0geyBuYW1lOiAndHlwZXNjcmlwdCcsIHZlcnNpb246IHBrZy52ZXJzaW9uIH07XG4gICAgICAgICAgY29uc3Qgc3RhY2tzID0gdGhpcy5nZXRTdGFja1RyYWNlcygpLm1hcCgoeyBzdHJ1Y3R1cmVkOiBsb2NhdGlvbnMgfSkgPT4gKHsgbG9jYXRpb25zIH0pKTtcbiAgICAgICAgICBjb25zdCBzb3VyY2VzOiBSZWNvcmQ8c3RyaW5nLCBTdGFja1RyYWNlRmlsZVNsaWNlW10+ID0ge307XG4gICAgICAgICAgaWYgKHRoaXMuc2hvd1N0YWNrVHJhY2VTb3VyY2VzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgbG9jYXRpb25zIH0gb2Ygc3RhY2tzKSB7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgeyBmaWxlX3BhdGggfSBvZiBsb2NhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbGVfcGF0aCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHNvdXJjZU1hcD8uc291cmNlc0NvbnRlbnQ/Lltzb3VyY2VNYXA/LnNvdXJjZXMuaW5kZXhPZihmaWxlX3BhdGgpXTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHNvdXJjZXNbZmlsZV9wYXRoXSA9IFtcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZV9vZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBSYXdWYWx1ZTxFbmhhbmNlZFN0YWNrVHJhY2U+KHsgc2RrLCBzdGFja3MsIHNvdXJjZXMgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnUmV0dXJucyBhIHN0YWNrIHRyYWNlIGFubm90YXRlZCB3aXRoIHNvdXJjZSBpbmZvcm1hdGlvbi4nLFxuICAgICAgfSxcbiAgICBdLFxuICAgIFtcbiAgICAgICdfX3RlbXBvcmFsX3dvcmtmbG93X21ldGFkYXRhJyxcbiAgICAgIHtcbiAgICAgICAgaGFuZGxlcjogKCk6IFJhd1ZhbHVlID0+IHtcbiAgICAgICAgICBjb25zdCB3b3JrZmxvd1R5cGUgPSB0aGlzLmluZm8ud29ya2Zsb3dUeXBlO1xuICAgICAgICAgIGNvbnN0IHF1ZXJ5RGVmaW5pdGlvbnMgPSBBcnJheS5mcm9tKHRoaXMucXVlcnlIYW5kbGVycy5lbnRyaWVzKCkpLm1hcCgoW25hbWUsIHZhbHVlXSkgPT4gKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogdmFsdWUuZGVzY3JpcHRpb24sXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIGNvbnN0IHNpZ25hbERlZmluaXRpb25zID0gQXJyYXkuZnJvbSh0aGlzLnNpZ25hbEhhbmRsZXJzLmVudHJpZXMoKSkubWFwKChbbmFtZSwgdmFsdWVdKSA9PiAoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB2YWx1ZS5kZXNjcmlwdGlvbixcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgY29uc3QgdXBkYXRlRGVmaW5pdGlvbnMgPSBBcnJheS5mcm9tKHRoaXMudXBkYXRlSGFuZGxlcnMuZW50cmllcygpKS5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+ICh7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHZhbHVlLmRlc2NyaXB0aW9uLFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICByZXR1cm4gbmV3IFJhd1ZhbHVlPHRlbXBvcmFsLmFwaS5zZGsudjEuSVdvcmtmbG93TWV0YWRhdGE+KHtcbiAgICAgICAgICAgIGRlZmluaXRpb246IHtcbiAgICAgICAgICAgICAgdHlwZTogd29ya2Zsb3dUeXBlLFxuICAgICAgICAgICAgICBxdWVyeURlZmluaXRpb25zLFxuICAgICAgICAgICAgICBzaWduYWxEZWZpbml0aW9ucyxcbiAgICAgICAgICAgICAgdXBkYXRlRGVmaW5pdGlvbnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3VycmVudERldGFpbHM6IHRoaXMuY3VycmVudERldGFpbHMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnUmV0dXJucyBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyB3b3JrZmxvdy4nLFxuICAgICAgfSxcbiAgICBdLFxuICBdKTtcblxuICAvKipcbiAgICogTG9hZGVkIGluIHtAbGluayBpbml0UnVudGltZX1cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBpbnRlcmNlcHRvcnM6IFJlcXVpcmVkPFdvcmtmbG93SW50ZXJjZXB0b3JzPiA9IHtcbiAgICBpbmJvdW5kOiBbXSxcbiAgICBvdXRib3VuZDogW10sXG4gICAgaW50ZXJuYWxzOiBbXSxcbiAgfTtcblxuICAvKipcbiAgICogQnVmZmVyIHRoYXQgc3RvcmVzIGFsbCBnZW5lcmF0ZWQgY29tbWFuZHMsIHJlc2V0IGFmdGVyIGVhY2ggYWN0aXZhdGlvblxuICAgKi9cbiAgcHJvdGVjdGVkIGNvbW1hbmRzOiBjb3Jlc2RrLndvcmtmbG93X2NvbW1hbmRzLklXb3JrZmxvd0NvbW1hbmRbXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBTdG9yZXMgYWxsIHtAbGluayBjb25kaXRpb259cyB0aGF0IGhhdmVuJ3QgYmVlbiB1bmJsb2NrZWQgeWV0XG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgYmxvY2tlZENvbmRpdGlvbnMgPSBuZXcgTWFwPG51bWJlciwgQ29uZGl0aW9uPigpO1xuXG4gIC8qKlxuICAgKiBJcyB0aGlzIFdvcmtmbG93IGNvbXBsZXRlZD9cbiAgICpcbiAgICogQSBXb3JrZmxvdyB3aWxsIGJlIGNvbnNpZGVyZWQgY29tcGxldGVkIGlmIGl0IGdlbmVyYXRlcyBhIGNvbW1hbmQgdGhhdCB0aGVcbiAgICogc3lzdGVtIGNvbnNpZGVycyBhcyBhIGZpbmFsIFdvcmtmbG93IGNvbW1hbmQgKGUuZy5cbiAgICogY29tcGxldGVXb3JrZmxvd0V4ZWN1dGlvbiBvciBmYWlsV29ya2Zsb3dFeGVjdXRpb24pLlxuICAgKi9cbiAgcHVibGljIGNvbXBsZXRlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBXYXMgdGhpcyBXb3JrZmxvdyBjYW5jZWxsZWQ/XG4gICAqL1xuICBwcm90ZWN0ZWQgY2FuY2VsbGVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFRoZSBuZXh0IChpbmNyZW1lbnRhbCkgc2VxdWVuY2UgdG8gYXNzaWduIHdoZW4gZ2VuZXJhdGluZyBjb21wbGV0YWJsZSBjb21tYW5kc1xuICAgKi9cbiAgcHVibGljIG5leHRTZXFzID0ge1xuICAgIHRpbWVyOiAxLFxuICAgIGFjdGl2aXR5OiAxLFxuICAgIGNoaWxkV29ya2Zsb3c6IDEsXG4gICAgc2lnbmFsV29ya2Zsb3c6IDEsXG4gICAgY2FuY2VsV29ya2Zsb3c6IDEsXG4gICAgY29uZGl0aW9uOiAxLFxuICAgIG5leHVzT3BlcmF0aW9uOiAxLFxuICAgIC8vIFVzZWQgaW50ZXJuYWxseSB0byBrZWVwIHRyYWNrIG9mIGFjdGl2ZSBzdGFjayB0cmFjZXNcbiAgICBzdGFjazogMSxcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBpcyBzZXQgZXZlcnkgdGltZSB0aGUgd29ya2Zsb3cgZXhlY3V0ZXMgYW4gYWN0aXZhdGlvblxuICAgKiBNYXkgYmUgYWNjZXNzZWQgYW5kIG1vZGlmaWVkIGZyb20gb3V0c2lkZSB0aGUgVk0uXG4gICAqL1xuICBub3c6IG51bWJlcjtcblxuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IFdvcmtmbG93LCBpbml0aWFsaXplZCB3aGVuIGEgV29ya2Zsb3cgaXMgc3RhcnRlZFxuICAgKi9cbiAgcHVibGljIHdvcmtmbG93PzogV29ya2Zsb3cgfCBXb3JrZmxvd0Z1bmN0aW9uV2l0aE9wdGlvbnM8YW55W10sIGFueT47XG5cbiAgLyoqXG4gICAqIEluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IFdvcmtmbG93XG4gICAqIE1heSBiZSBhY2Nlc3NlZCBmcm9tIG91dHNpZGUgdGhlIFZNLlxuICAgKi9cbiAgcHVibGljIGluZm86IFdvcmtmbG93SW5mbztcblxuICAvKipcbiAgICogQSBkZXRlcm1pbmlzdGljIFJORywgdXNlZCBieSB0aGUgaXNvbGF0ZSdzIG92ZXJyaWRkZW4gTWF0aC5yYW5kb21cbiAgICovXG4gIHB1YmxpYyByYW5kb206IFJORztcblxuICBwdWJsaWMgcGF5bG9hZENvbnZlcnRlcjogUGF5bG9hZENvbnZlcnRlciA9IGRlZmF1bHRQYXlsb2FkQ29udmVydGVyO1xuICBwdWJsaWMgZmFpbHVyZUNvbnZlcnRlcjogRmFpbHVyZUNvbnZlcnRlciA9IGRlZmF1bHRGYWlsdXJlQ29udmVydGVyO1xuXG4gIC8qKlxuICAgKiBQYXRjaGVzIHdlIGtub3cgdGhlIHN0YXR1cyBvZiBmb3IgdGhpcyB3b3JrZmxvdywgYXMgaW4ge0BsaW5rIHBhdGNoZWR9XG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IGtub3duUHJlc2VudFBhdGNoZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAvKipcbiAgICogUGF0Y2hlcyB3ZSBzZW50IHRvIGNvcmUge0BsaW5rIHBhdGNoZWR9XG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IHNlbnRQYXRjaGVzID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBrbm93bkZsYWdzID0gbmV3IFNldDxudW1iZXI+KCk7XG5cbiAgLyoqXG4gICAqIEJ1ZmZlcmVkIHNpbmsgY2FsbHMgcGVyIGFjdGl2YXRpb25cbiAgICovXG4gIHNpbmtDYWxscyA9IEFycmF5PFNpbmtDYWxsPigpO1xuXG4gIC8qKlxuICAgKiBBIG5hbm9zZWNvbmQgcmVzb2x1dGlvbiB0aW1lIGZ1bmN0aW9uLCBleHRlcm5hbGx5IGluamVjdGVkLiBUaGlzIGlzIHVzZWQgdG9cbiAgICogcHJlY2lzZWx5IHNvcnQgbG9ncyBlbnRyaWVzIGVtaXR0ZWQgZnJvbSB0aGUgV29ya2Zsb3cgQ29udGV4dCB2cyB0aG9zZSBlbWl0dGVkXG4gICAqIGZyb20gb3RoZXIgc291cmNlcyAoZS5nLiBtYWluIHRocmVhZCwgQ29yZSwgZXRjKS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBnZXRUaW1lT2ZEYXk6ICgpID0+IGJpZ2ludDtcblxuICBwdWJsaWMgcmVhZG9ubHkgcmVnaXN0ZXJlZEFjdGl2aXR5TmFtZXM6IFNldDxzdHJpbmc+O1xuXG4gIHB1YmxpYyBjdXJyZW50RGV0YWlsczogc3RyaW5nID0gJyc7XG5cbiAgcHVibGljIHZlcnNpb25pbmdCZWhhdmlvcj86IFZlcnNpb25pbmdCZWhhdmlvcjtcbiAgcHVibGljIHdvcmtmbG93RGVmaW5pdGlvbk9wdGlvbnNHZXR0ZXI/OiAoKSA9PiBXb3JrZmxvd0RlZmluaXRpb25PcHRpb25zO1xuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBpbmZvLFxuICAgIG5vdyxcbiAgICBzaG93U3RhY2tUcmFjZVNvdXJjZXMsXG4gICAgc291cmNlTWFwLFxuICAgIGdldFRpbWVPZkRheSxcbiAgICByYW5kb21uZXNzU2VlZCxcbiAgICByZWdpc3RlcmVkQWN0aXZpdHlOYW1lcyxcbiAgfTogV29ya2Zsb3dDcmVhdGVPcHRpb25zSW50ZXJuYWwpIHtcbiAgICB0aGlzLmdldFRpbWVPZkRheSA9IGdldFRpbWVPZkRheTtcbiAgICB0aGlzLmluZm8gPSBpbmZvO1xuICAgIHRoaXMubm93ID0gbm93O1xuICAgIHRoaXMuc2hvd1N0YWNrVHJhY2VTb3VyY2VzID0gc2hvd1N0YWNrVHJhY2VTb3VyY2VzO1xuICAgIHRoaXMuc291cmNlTWFwID0gc291cmNlTWFwO1xuICAgIHRoaXMucmFuZG9tID0gYWxlYShyYW5kb21uZXNzU2VlZCk7XG4gICAgdGhpcy5yZWdpc3RlcmVkQWN0aXZpdHlOYW1lcyA9IHJlZ2lzdGVyZWRBY3Rpdml0eU5hbWVzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1heSBiZSBpbnZva2VkIGZyb20gb3V0c2lkZSB0aGUgVk0uXG4gICAqL1xuICBtdXRhdGVXb3JrZmxvd0luZm8oZm46IChpbmZvOiBXb3JrZmxvd0luZm8pID0+IFdvcmtmbG93SW5mbyk6IHZvaWQge1xuICAgIHRoaXMuaW5mbyA9IGZuKHRoaXMuaW5mbyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0U3RhY2tUcmFjZXMoKTogU3RhY2tbXSB7XG4gICAgY29uc3QgeyBjaGlsZFRvUGFyZW50LCBwcm9taXNlVG9TdGFjayB9ID0gdGhpcy5wcm9taXNlU3RhY2tTdG9yZTtcbiAgICBjb25zdCBpbnRlcm5hbE5vZGVzID0gWy4uLmNoaWxkVG9QYXJlbnQudmFsdWVzKCldLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHAgb2YgY3Vycikge1xuICAgICAgICBhY2MuYWRkKHApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBuZXcgU2V0KCkpO1xuICAgIGNvbnN0IHN0YWNrcyA9IG5ldyBNYXA8c3RyaW5nLCBTdGFjaz4oKTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkVG9QYXJlbnQua2V5cygpKSB7XG4gICAgICBpZiAoIWludGVybmFsTm9kZXMuaGFzKGNoaWxkKSkge1xuICAgICAgICBjb25zdCBzdGFjayA9IHByb21pc2VUb1N0YWNrLmdldChjaGlsZCk7XG4gICAgICAgIGlmICghc3RhY2sgfHwgIXN0YWNrLmZvcm1hdHRlZCkgY29udGludWU7XG4gICAgICAgIHN0YWNrcy5zZXQoc3RhY2suZm9ybWF0dGVkLCBzdGFjayk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIE5vdCAxMDAlIHN1cmUgd2hlcmUgdGhpcyBjb21lcyBmcm9tLCBqdXN0IGZpbHRlciBpdCBvdXRcbiAgICBzdGFja3MuZGVsZXRlKCcgICAgYXQgUHJvbWlzZS50aGVuICg8YW5vbnltb3VzPiknKTtcbiAgICBzdGFja3MuZGVsZXRlKCcgICAgYXQgUHJvbWlzZS50aGVuICg8YW5vbnltb3VzPilcXG4nKTtcbiAgICByZXR1cm4gWy4uLnN0YWNrc10ubWFwKChbXywgc3RhY2tdKSA9PiBzdGFjayk7XG4gIH1cblxuICAvKipcbiAgICogTWF5IGJlIGludm9rZWQgZnJvbSBvdXRzaWRlIHRoZSBWTS5cbiAgICovXG4gIGdldEFuZFJlc2V0U2lua0NhbGxzKCk6IFNpbmtDYWxsW10ge1xuICAgIGNvbnN0IHsgc2lua0NhbGxzIH0gPSB0aGlzO1xuICAgIHRoaXMuc2lua0NhbGxzID0gW107XG4gICAgcmV0dXJuIHNpbmtDYWxscztcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWZmZXIgYSBXb3JrZmxvdyBjb21tYW5kIHRvIGJlIGNvbGxlY3RlZCBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGFjdGl2YXRpb24uXG4gICAqXG4gICAqIFByZXZlbnRzIGNvbW1hbmRzIGZyb20gYmVpbmcgYWRkZWQgYWZ0ZXIgV29ya2Zsb3cgY29tcGxldGlvbi5cbiAgICovXG4gIHB1c2hDb21tYW5kKGNtZDogY29yZXNkay53b3JrZmxvd19jb21tYW5kcy5JV29ya2Zsb3dDb21tYW5kLCBjb21wbGV0ZSA9IGZhbHNlKTogdm9pZCB7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKGNtZCk7XG4gICAgaWYgKGNvbXBsZXRlKSB7XG4gICAgICB0aGlzLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgY29uY2x1ZGVBY3RpdmF0aW9uKCk6IEFjdGl2YXRpb25Db21wbGV0aW9uIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tbWFuZHM6IHRoaXMuY29tbWFuZHMuc3BsaWNlKDApLFxuICAgICAgdXNlZEludGVybmFsRmxhZ3M6IFsuLi50aGlzLmtub3duRmxhZ3NdLFxuICAgICAgdmVyc2lvbmluZ0JlaGF2aW9yOiB0aGlzLnZlcnNpb25pbmdCZWhhdmlvcixcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHN0YXJ0V29ya2Zsb3dOZXh0SGFuZGxlcih7IGFyZ3MgfTogV29ya2Zsb3dFeGVjdXRlSW5wdXQpOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHsgd29ya2Zsb3cgfSA9IHRoaXM7XG4gICAgaWYgKHdvcmtmbG93ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFcnJvcignV29ya2Zsb3cgdW5pbml0aWFsaXplZCcpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgd29ya2Zsb3coLi4uYXJncyk7XG4gIH1cblxuICBwdWJsaWMgc3RhcnRXb3JrZmxvdyhhY3RpdmF0aW9uOiBjb3Jlc2RrLndvcmtmbG93X2FjdGl2YXRpb24uSUluaXRpYWxpemVXb3JrZmxvdyk6IHZvaWQge1xuICAgIGNvbnN0IGV4ZWN1dGUgPSBjb21wb3NlSW50ZXJjZXB0b3JzKHRoaXMuaW50ZXJjZXB0b3JzLmluYm91bmQsICdleGVjdXRlJywgdGhpcy5zdGFydFdvcmtmbG93TmV4dEhhbmRsZXIuYmluZCh0aGlzKSk7XG5cbiAgICB1bnRyYWNrUHJvbWlzZShcbiAgICAgIGV4ZWN1dGVXaXRoTGlmZWN5Y2xlTG9nZ2luZygoKSA9PlxuICAgICAgICBleGVjdXRlKHtcbiAgICAgICAgICBoZWFkZXJzOiBhY3RpdmF0aW9uLmhlYWRlcnMgPz8ge30sXG4gICAgICAgICAgYXJnczogYXJyYXlGcm9tUGF5bG9hZHModGhpcy5wYXlsb2FkQ29udmVydGVyLCBhY3RpdmF0aW9uLmFyZ3VtZW50cyksXG4gICAgICAgIH0pXG4gICAgICApLnRoZW4odGhpcy5jb21wbGV0ZVdvcmtmbG93LmJpbmQodGhpcyksIHRoaXMuaGFuZGxlV29ya2Zsb3dGYWlsdXJlLmJpbmQodGhpcykpXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBpbml0aWFsaXplV29ya2Zsb3coYWN0aXZhdGlvbjogY29yZXNkay53b3JrZmxvd19hY3RpdmF0aW9uLklJbml0aWFsaXplV29ya2Zsb3cpOiB2b2lkIHtcbiAgICBjb25zdCB7IGNvbnRpbnVlZEZhaWx1cmUsIGxhc3RDb21wbGV0aW9uUmVzdWx0LCBtZW1vLCBzZWFyY2hBdHRyaWJ1dGVzIH0gPSBhY3RpdmF0aW9uO1xuXG4gICAgLy8gTW9zdCB0aGluZ3MgcmVsYXRlZCB0byBpbml0aWFsaXphdGlvbiBoYXZlIGFscmVhZHkgYmVlbiBoYW5kbGVkIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgIHRoaXMubXV0YXRlV29ya2Zsb3dJbmZvKChpbmZvKSA9PiAoe1xuICAgICAgLi4uaW5mbyxcblxuICAgICAgc2VhcmNoQXR0cmlidXRlczogZGVjb2RlU2VhcmNoQXR0cmlidXRlcyhzZWFyY2hBdHRyaWJ1dGVzPy5pbmRleGVkRmllbGRzKSxcbiAgICAgIHR5cGVkU2VhcmNoQXR0cmlidXRlczogZGVjb2RlVHlwZWRTZWFyY2hBdHRyaWJ1dGVzKHNlYXJjaEF0dHJpYnV0ZXM/LmluZGV4ZWRGaWVsZHMpLFxuXG4gICAgICBtZW1vOiBtYXBGcm9tUGF5bG9hZHModGhpcy5wYXlsb2FkQ29udmVydGVyLCBtZW1vPy5maWVsZHMpLFxuICAgICAgbGFzdFJlc3VsdDogZnJvbVBheWxvYWRzQXRJbmRleCh0aGlzLnBheWxvYWRDb252ZXJ0ZXIsIDAsIGxhc3RDb21wbGV0aW9uUmVzdWx0Py5wYXlsb2FkcyksXG4gICAgICBsYXN0RmFpbHVyZTpcbiAgICAgICAgY29udGludWVkRmFpbHVyZSAhPSBudWxsXG4gICAgICAgICAgPyB0aGlzLmZhaWx1cmVDb252ZXJ0ZXIuZmFpbHVyZVRvRXJyb3IoY29udGludWVkRmFpbHVyZSwgdGhpcy5wYXlsb2FkQ29udmVydGVyKVxuICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgIH0pKTtcbiAgICBpZiAodGhpcy53b3JrZmxvd0RlZmluaXRpb25PcHRpb25zR2V0dGVyKSB7XG4gICAgICB0aGlzLnZlcnNpb25pbmdCZWhhdmlvciA9IHRoaXMud29ya2Zsb3dEZWZpbml0aW9uT3B0aW9uc0dldHRlcigpLnZlcnNpb25pbmdCZWhhdmlvcjtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgY2FuY2VsV29ya2Zsb3coX2FjdGl2YXRpb246IGNvcmVzZGsud29ya2Zsb3dfYWN0aXZhdGlvbi5JQ2FuY2VsV29ya2Zsb3cpOiB2b2lkIHtcbiAgICB0aGlzLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgdGhpcy5yb290U2NvcGUuY2FuY2VsKCk7XG4gIH1cblxuICBwdWJsaWMgZmlyZVRpbWVyKGFjdGl2YXRpb246IGNvcmVzZGsud29ya2Zsb3dfYWN0aXZhdGlvbi5JRmlyZVRpbWVyKTogdm9pZCB7XG4gICAgLy8gVGltZXJzIGFyZSBhIHNwZWNpYWwgY2FzZSB3aGVyZSB0aGVpciBjb21wbGV0aW9uIG1pZ2h0IG5vdCBiZSBpbiBXb3JrZmxvdyBzdGF0ZSxcbiAgICAvLyB0aGlzIGlzIGR1ZSB0byBpbW1lZGlhdGUgdGltZXIgY2FuY2VsbGF0aW9uIHRoYXQgZG9lc24ndCBnbyB3YWl0IGZvciBDb3JlLlxuICAgIGNvbnN0IGNvbXBsZXRpb24gPSB0aGlzLm1heWJlQ29uc3VtZUNvbXBsZXRpb24oJ3RpbWVyJywgZ2V0U2VxKGFjdGl2YXRpb24pKTtcbiAgICBjb21wbGV0aW9uPy5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gIH1cblxuICBwdWJsaWMgcmVzb2x2ZUFjdGl2aXR5KGFjdGl2YXRpb246IGNvcmVzZGsud29ya2Zsb3dfYWN0aXZhdGlvbi5JUmVzb2x2ZUFjdGl2aXR5KTogdm9pZCB7XG4gICAgaWYgKCFhY3RpdmF0aW9uLnJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignR290IFJlc29sdmVBY3Rpdml0eSBhY3RpdmF0aW9uIHdpdGggbm8gcmVzdWx0Jyk7XG4gICAgfVxuICAgIGNvbnN0IHsgcmVzb2x2ZSwgcmVqZWN0IH0gPSB0aGlzLmNvbnN1bWVDb21wbGV0aW9uKCdhY3Rpdml0eScsIGdldFNlcShhY3RpdmF0aW9uKSk7XG4gICAgaWYgKGFjdGl2YXRpb24ucmVzdWx0LmNvbXBsZXRlZCkge1xuICAgICAgY29uc3QgY29tcGxldGVkID0gYWN0aXZhdGlvbi5yZXN1bHQuY29tcGxldGVkO1xuICAgICAgY29uc3QgcmVzdWx0ID0gY29tcGxldGVkLnJlc3VsdCA/IHRoaXMucGF5bG9hZENvbnZlcnRlci5mcm9tUGF5bG9hZChjb21wbGV0ZWQucmVzdWx0KSA6IHVuZGVmaW5lZDtcbiAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9IGVsc2UgaWYgKGFjdGl2YXRpb24ucmVzdWx0LmZhaWxlZCkge1xuICAgICAgY29uc3QgeyBmYWlsdXJlIH0gPSBhY3RpdmF0aW9uLnJlc3VsdC5mYWlsZWQ7XG4gICAgICBpZiAoZmFpbHVyZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dvdCBmYWlsZWQgcmVzdWx0IHdpdGggbm8gZmFpbHVyZSBhdHRyaWJ1dGUnKTtcbiAgICAgIH1cbiAgICAgIHJlamVjdCh0aGlzLmZhaWx1cmVUb0Vycm9yKGZhaWx1cmUpKTtcbiAgICB9IGVsc2UgaWYgKGFjdGl2YXRpb24ucmVzdWx0LmNhbmNlbGxlZCkge1xuICAgICAgY29uc3QgeyBmYWlsdXJlIH0gPSBhY3RpdmF0aW9uLnJlc3VsdC5jYW5jZWxsZWQ7XG4gICAgICBpZiAoZmFpbHVyZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dvdCBjYW5jZWxsZWQgcmVzdWx0IHdpdGggbm8gZmFpbHVyZSBhdHRyaWJ1dGUnKTtcbiAgICAgIH1cbiAgICAgIHJlamVjdCh0aGlzLmZhaWx1cmVUb0Vycm9yKGZhaWx1cmUpKTtcbiAgICB9IGVsc2UgaWYgKGFjdGl2YXRpb24ucmVzdWx0LmJhY2tvZmYpIHtcbiAgICAgIHJlamVjdChuZXcgTG9jYWxBY3Rpdml0eURvQmFja29mZihhY3RpdmF0aW9uLnJlc3VsdC5iYWNrb2ZmKSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlc29sdmVDaGlsZFdvcmtmbG93RXhlY3V0aW9uU3RhcnQoXG4gICAgYWN0aXZhdGlvbjogY29yZXNkay53b3JrZmxvd19hY3RpdmF0aW9uLklSZXNvbHZlQ2hpbGRXb3JrZmxvd0V4ZWN1dGlvblN0YXJ0XG4gICk6IHZvaWQge1xuICAgIGNvbnN0IHsgcmVzb2x2ZSwgcmVqZWN0IH0gPSB0aGlzLmNvbnN1bWVDb21wbGV0aW9uKCdjaGlsZFdvcmtmbG93U3RhcnQnLCBnZXRTZXEoYWN0aXZhdGlvbikpO1xuICAgIGlmIChhY3RpdmF0aW9uLnN1Y2NlZWRlZCkge1xuICAgICAgaWYgKCFhY3RpdmF0aW9uLnN1Y2NlZWRlZC5ydW5JZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdHb3QgUmVzb2x2ZUNoaWxkV29ya2Zsb3dFeGVjdXRpb25TdGFydCB3aXRoIG5vIHJ1bklkJyk7XG4gICAgICB9XG4gICAgICByZXNvbHZlKGFjdGl2YXRpb24uc3VjY2VlZGVkLnJ1bklkKTtcbiAgICB9IGVsc2UgaWYgKGFjdGl2YXRpb24uZmFpbGVkKSB7XG4gICAgICBpZiAoZGVjb2RlU3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uRmFpbGVkQ2F1c2UoYWN0aXZhdGlvbi5mYWlsZWQuY2F1c2UpICE9PSAnV09SS0ZMT1dfQUxSRUFEWV9FWElTVFMnKSB7XG4gICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFcnJvcignR290IHVua25vd24gU3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uRmFpbGVkQ2F1c2UnKTtcbiAgICAgIH1cbiAgICAgIGlmICghKGFjdGl2YXRpb24uc2VxICYmIGFjdGl2YXRpb24uZmFpbGVkLndvcmtmbG93SWQgJiYgYWN0aXZhdGlvbi5mYWlsZWQud29ya2Zsb3dUeXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNaXNzaW5nIGF0dHJpYnV0ZXMgaW4gYWN0aXZhdGlvbiBqb2InKTtcbiAgICAgIH1cbiAgICAgIHJlamVjdChcbiAgICAgICAgbmV3IFdvcmtmbG93RXhlY3V0aW9uQWxyZWFkeVN0YXJ0ZWRFcnJvcihcbiAgICAgICAgICAnV29ya2Zsb3cgZXhlY3V0aW9uIGFscmVhZHkgc3RhcnRlZCcsXG4gICAgICAgICAgYWN0aXZhdGlvbi5mYWlsZWQud29ya2Zsb3dJZCxcbiAgICAgICAgICBhY3RpdmF0aW9uLmZhaWxlZC53b3JrZmxvd1R5cGVcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGFjdGl2YXRpb24uY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoIWFjdGl2YXRpb24uY2FuY2VsbGVkLmZhaWx1cmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignR290IG5vIGZhaWx1cmUgaW4gY2FuY2VsbGVkIHZhcmlhbnQnKTtcbiAgICAgIH1cbiAgICAgIHJlamVjdCh0aGlzLmZhaWx1cmVUb0Vycm9yKGFjdGl2YXRpb24uY2FuY2VsbGVkLmZhaWx1cmUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignR290IFJlc29sdmVDaGlsZFdvcmtmbG93RXhlY3V0aW9uU3RhcnQgd2l0aCBubyBzdGF0dXMnKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgcmVzb2x2ZUNoaWxkV29ya2Zsb3dFeGVjdXRpb24oYWN0aXZhdGlvbjogY29yZXNkay53b3JrZmxvd19hY3RpdmF0aW9uLklSZXNvbHZlQ2hpbGRXb3JrZmxvd0V4ZWN1dGlvbik6IHZvaWQge1xuICAgIGlmICghYWN0aXZhdGlvbi5yZXN1bHQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dvdCBSZXNvbHZlQ2hpbGRXb3JrZmxvd0V4ZWN1dGlvbiBhY3RpdmF0aW9uIHdpdGggbm8gcmVzdWx0Jyk7XG4gICAgfVxuICAgIGNvbnN0IHsgcmVzb2x2ZSwgcmVqZWN0IH0gPSB0aGlzLmNvbnN1bWVDb21wbGV0aW9uKCdjaGlsZFdvcmtmbG93Q29tcGxldGUnLCBnZXRTZXEoYWN0aXZhdGlvbikpO1xuICAgIGlmIChhY3RpdmF0aW9uLnJlc3VsdC5jb21wbGV0ZWQpIHtcbiAgICAgIGNvbnN0IGNvbXBsZXRlZCA9IGFjdGl2YXRpb24ucmVzdWx0LmNvbXBsZXRlZDtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBsZXRlZC5yZXN1bHQgPyB0aGlzLnBheWxvYWRDb252ZXJ0ZXIuZnJvbVBheWxvYWQoY29tcGxldGVkLnJlc3VsdCkgOiB1bmRlZmluZWQ7XG4gICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgfSBlbHNlIGlmIChhY3RpdmF0aW9uLnJlc3VsdC5mYWlsZWQpIHtcbiAgICAgIGNvbnN0IHsgZmFpbHVyZSB9ID0gYWN0aXZhdGlvbi5yZXN1bHQuZmFpbGVkO1xuICAgICAgaWYgKGZhaWx1cmUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdHb3QgZmFpbGVkIHJlc3VsdCB3aXRoIG5vIGZhaWx1cmUgYXR0cmlidXRlJyk7XG4gICAgICB9XG4gICAgICByZWplY3QodGhpcy5mYWlsdXJlVG9FcnJvcihmYWlsdXJlKSk7XG4gICAgfSBlbHNlIGlmIChhY3RpdmF0aW9uLnJlc3VsdC5jYW5jZWxsZWQpIHtcbiAgICAgIGNvbnN0IHsgZmFpbHVyZSB9ID0gYWN0aXZhdGlvbi5yZXN1bHQuY2FuY2VsbGVkO1xuICAgICAgaWYgKGZhaWx1cmUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdHb3QgY2FuY2VsbGVkIHJlc3VsdCB3aXRoIG5vIGZhaWx1cmUgYXR0cmlidXRlJyk7XG4gICAgICB9XG4gICAgICByZWplY3QodGhpcy5mYWlsdXJlVG9FcnJvcihmYWlsdXJlKSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlc29sdmVOZXh1c09wZXJhdGlvblN0YXJ0KGFjdGl2YXRpb246IGNvcmVzZGsud29ya2Zsb3dfYWN0aXZhdGlvbi5JUmVzb2x2ZU5leHVzT3BlcmF0aW9uU3RhcnQpOiB2b2lkIHtcbiAgICBjb25zdCBzZXEgPSBnZXRTZXEoYWN0aXZhdGlvbik7XG4gICAgY29uc3QgeyByZXNvbHZlLCByZWplY3QgfSA9IHRoaXMuY29uc3VtZUNvbXBsZXRpb24oJ25leHVzT3BlcmF0aW9uU3RhcnQnLCBzZXEpO1xuXG4gICAgaWYgKCFhY3RpdmF0aW9uLmZhaWxlZCkge1xuICAgICAgY29uc3QgY29tcGxldGVQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLmNvbXBsZXRpb25zLm5leHVzT3BlcmF0aW9uQ29tcGxldGUuc2V0KHNlcSwge1xuICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgcmVqZWN0LFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdW50cmFja1Byb21pc2UoY29tcGxldGVQcm9taXNlKTtcbiAgICAgIHVudHJhY2tQcm9taXNlKGNvbXBsZXRlUHJvbWlzZS5jYXRjaCgoKSA9PiB1bmRlZmluZWQpKTtcblxuICAgICAgcmVzb2x2ZSh7IHRva2VuOiBhY3RpdmF0aW9uLm9wZXJhdGlvblRva2VuISwgcmVzdWx0OiBjb21wbGV0ZVByb21pc2UgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlamVjdCh0aGlzLmZhaWx1cmVUb0Vycm9yKGFjdGl2YXRpb24uZmFpbGVkKSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlc29sdmVOZXh1c09wZXJhdGlvbihhY3RpdmF0aW9uOiBjb3Jlc2RrLndvcmtmbG93X2FjdGl2YXRpb24uSVJlc29sdmVOZXh1c09wZXJhdGlvbik6IHZvaWQge1xuICAgIGNvbnN0IHNlcSA9IGdldFNlcShhY3RpdmF0aW9uKTtcblxuICAgIGlmIChhY3RpdmF0aW9uLnJlc3VsdD8uY29tcGxldGVkKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnBheWxvYWRDb252ZXJ0ZXIuZnJvbVBheWxvYWQoYWN0aXZhdGlvbi5yZXN1bHQuY29tcGxldGVkKTtcblxuICAgICAgLy8gSXQgaXMgcG9zc2libGUgZm9yIFJlc29sdmVOZXh1c09wZXJhdGlvbiB0byBiZSByZWNlaXZlZCB3aXRob3V0IGEgcHJpb3IgUmVzb2x2ZU5leHVzT3BlcmF0aW9uU3RhcnQsXG4gICAgICAvLyBlLmcuIGJlY2F1c2UgdGhlIGhhbmRsZXIgY29tcGxldGVkIHRoZSBPcGVyYXRpb24gc3luY2hyb25vdXNseS5cbiAgICAgIGNvbnN0IHN0YXJ0Q29tcGxldGlvbiA9IHRoaXMubWF5YmVDb25zdW1lQ29tcGxldGlvbignbmV4dXNPcGVyYXRpb25TdGFydCcsIHNlcSk7XG4gICAgICBpZiAoc3RhcnRDb21wbGV0aW9uKSB7XG4gICAgICAgIHN0YXJ0Q29tcGxldGlvbi5yZXNvbHZlKHsgcmVzdWx0OiBQcm9taXNlLnJlc29sdmUocmVzdWx0KSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29uc3VtZUNvbXBsZXRpb24oJ25leHVzT3BlcmF0aW9uQ29tcGxldGUnLCBzZXEpLnJlc29sdmUocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGVycjogRXJyb3I7XG4gICAgICBpZiAoYWN0aXZhdGlvbi5yZXN1bHQ/LmZhaWxlZCkge1xuICAgICAgICBlcnIgPSB0aGlzLmZhaWx1cmVUb0Vycm9yKGFjdGl2YXRpb24ucmVzdWx0LmZhaWxlZCk7XG4gICAgICB9IGVsc2UgaWYgKGFjdGl2YXRpb24ucmVzdWx0Py5jYW5jZWxsZWQpIHtcbiAgICAgICAgZXJyID0gdGhpcy5mYWlsdXJlVG9FcnJvcihhY3RpdmF0aW9uLnJlc3VsdC5jYW5jZWxsZWQpO1xuICAgICAgfSBlbHNlIGlmIChhY3RpdmF0aW9uLnJlc3VsdD8udGltZWRPdXQpIHtcbiAgICAgICAgZXJyID0gdGhpcy5mYWlsdXJlVG9FcnJvcihhY3RpdmF0aW9uLnJlc3VsdC50aW1lZE91dCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbXBsZXRpb24gPVxuICAgICAgICB0aGlzLm1heWJlQ29uc3VtZUNvbXBsZXRpb24oJ25leHVzT3BlcmF0aW9uU3RhcnQnLCBzZXEpID8/XG4gICAgICAgIHRoaXMuY29uc3VtZUNvbXBsZXRpb24oJ25leHVzT3BlcmF0aW9uQ29tcGxldGUnLCBzZXEpO1xuICAgICAgY29tcGxldGlvbi5yZWplY3QoZXJyISk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW50ZW50aW9uYWxseSBub24tYXN5bmMgZnVuY3Rpb24gc28gdGhpcyBoYW5kbGVyIGRvZXNuJ3Qgc2hvdyB1cCBpbiB0aGUgc3RhY2sgdHJhY2VcbiAgcHJvdGVjdGVkIHF1ZXJ5V29ya2Zsb3dOZXh0SGFuZGxlcih7IHF1ZXJ5TmFtZSwgYXJncyB9OiBRdWVyeUlucHV0KTogUHJvbWlzZTx1bmtub3duPiB7XG4gICAgbGV0IGZuID0gdGhpcy5xdWVyeUhhbmRsZXJzLmdldChxdWVyeU5hbWUpPy5oYW5kbGVyO1xuICAgIGlmIChmbiA9PT0gdW5kZWZpbmVkICYmIHRoaXMuZGVmYXVsdFF1ZXJ5SGFuZGxlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmbiA9IHRoaXMuZGVmYXVsdFF1ZXJ5SGFuZGxlci5iaW5kKHVuZGVmaW5lZCwgcXVlcnlOYW1lKTtcbiAgICB9XG4gICAgLy8gTm8gaGFuZGxlciBvciBkZWZhdWx0IHJlZ2lzdGVyZWQsIGZhaWwuXG4gICAgaWYgKGZuID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGtub3duUXVlcnlUeXBlcyA9IFsuLi50aGlzLnF1ZXJ5SGFuZGxlcnMua2V5cygpXS5qb2luKCcgJyk7XG4gICAgICAvLyBGYWlsIHRoZSBxdWVyeVxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICBuZXcgUmVmZXJlbmNlRXJyb3IoXG4gICAgICAgICAgYFdvcmtmbG93IGRpZCBub3QgcmVnaXN0ZXIgYSBoYW5kbGVyIGZvciAke3F1ZXJ5TmFtZX0uIFJlZ2lzdGVyZWQgcXVlcmllczogWyR7a25vd25RdWVyeVR5cGVzfV1gXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIEV4ZWN1dGUgaGFuZGxlci5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmV0ID0gZm4oLi4uYXJncyk7XG4gICAgICBpZiAocmV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IERldGVybWluaXNtVmlvbGF0aW9uRXJyb3IoJ1F1ZXJ5IGhhbmRsZXJzIHNob3VsZCBub3QgcmV0dXJuIGEgUHJvbWlzZScpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmV0KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBxdWVyeVdvcmtmbG93KGFjdGl2YXRpb246IGNvcmVzZGsud29ya2Zsb3dfYWN0aXZhdGlvbi5JUXVlcnlXb3JrZmxvdyk6IHZvaWQge1xuICAgIGNvbnN0IHsgcXVlcnlUeXBlLCBxdWVyeUlkLCBoZWFkZXJzIH0gPSBhY3RpdmF0aW9uO1xuICAgIGlmICghKHF1ZXJ5VHlwZSAmJiBxdWVyeUlkKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyBxdWVyeSBhY3RpdmF0aW9uIGF0dHJpYnV0ZXMnKTtcbiAgICB9XG5cbiAgICAvLyBJZiBxdWVyeSBoYXMgX190ZW1wb3JhbF8gcHJlZml4IGJ1dCBubyBoYW5kbGVyIGV4aXN0cywgdGhyb3cgZXJyb3JcbiAgICBpZiAocXVlcnlUeXBlLnN0YXJ0c1dpdGgoVEVNUE9SQUxfUkVTRVJWRURfUFJFRklYKSAmJiAhdGhpcy5xdWVyeUhhbmRsZXJzLmhhcyhxdWVyeVR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW5ub3QgdXNlIHF1ZXJ5IG5hbWU6ICcke3F1ZXJ5VHlwZX0nLCB3aXRoIHJlc2VydmVkIHByZWZpeDogJyR7VEVNUE9SQUxfUkVTRVJWRURfUFJFRklYfSdgKTtcbiAgICB9XG5cbiAgICAvLyBTa2lwIGludGVyY2VwdG9ycyBpZiBpdCdzIGFuIGludGVybmFsIHF1ZXJ5LlxuICAgIGNvbnN0IGlzSW50ZXJuYWxRdWVyeSA9XG4gICAgICBxdWVyeVR5cGUuc3RhcnRzV2l0aChURU1QT1JBTF9SRVNFUlZFRF9QUkVGSVgpIHx8XG4gICAgICBxdWVyeVR5cGUgPT09IFNUQUNLX1RSQUNFX1FVRVJZX05BTUUgfHxcbiAgICAgIHF1ZXJ5VHlwZSA9PT0gRU5IQU5DRURfU1RBQ0tfVFJBQ0VfUVVFUllfTkFNRTtcbiAgICBjb25zdCBpbnRlcmNlcHRvcnMgPSBpc0ludGVybmFsUXVlcnkgPyBbXSA6IHRoaXMuaW50ZXJjZXB0b3JzLmluYm91bmQ7XG4gICAgY29uc3QgZXhlY3V0ZSA9IGNvbXBvc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3JzLCAnaGFuZGxlUXVlcnknLCB0aGlzLnF1ZXJ5V29ya2Zsb3dOZXh0SGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICBleGVjdXRlKHtcbiAgICAgIHF1ZXJ5TmFtZTogcXVlcnlUeXBlLFxuICAgICAgYXJnczogYXJyYXlGcm9tUGF5bG9hZHModGhpcy5wYXlsb2FkQ29udmVydGVyLCBhY3RpdmF0aW9uLmFyZ3VtZW50cyksXG4gICAgICBxdWVyeUlkLFxuICAgICAgaGVhZGVyczogaGVhZGVycyA/PyB7fSxcbiAgICB9KS50aGVuKFxuICAgICAgKHJlc3VsdCkgPT4gdGhpcy5jb21wbGV0ZVF1ZXJ5KHF1ZXJ5SWQsIHJlc3VsdCksXG4gICAgICAocmVhc29uKSA9PiB0aGlzLmZhaWxRdWVyeShxdWVyeUlkLCByZWFzb24pXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBkb1VwZGF0ZShhY3RpdmF0aW9uOiBjb3Jlc2RrLndvcmtmbG93X2FjdGl2YXRpb24uSURvVXBkYXRlKTogdm9pZCB7XG4gICAgY29uc3QgeyBpZDogdXBkYXRlSWQsIHByb3RvY29sSW5zdGFuY2VJZCwgbmFtZSwgaGVhZGVycywgcnVuVmFsaWRhdG9yIH0gPSBhY3RpdmF0aW9uO1xuICAgIGlmICghdXBkYXRlSWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pc3NpbmcgYWN0aXZhdGlvbiB1cGRhdGUgaWQnKTtcbiAgICB9XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNaXNzaW5nIGFjdGl2YXRpb24gdXBkYXRlIG5hbWUnKTtcbiAgICB9XG4gICAgaWYgKCFwcm90b2NvbEluc3RhbmNlSWQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01pc3NpbmcgYWN0aXZhdGlvbiB1cGRhdGUgcHJvdG9jb2xJbnN0YW5jZUlkJyk7XG4gICAgfVxuXG4gICAgLy8gSWYgdXBkYXRlIGhhcyBfX3RlbXBvcmFsXyBwcmVmaXggYnV0IG5vIGhhbmRsZXIgZXhpc3RzLCB0aHJvdyBlcnJvclxuICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoVEVNUE9SQUxfUkVTRVJWRURfUFJFRklYKSAmJiAhdGhpcy51cGRhdGVIYW5kbGVycy5nZXQobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbm5vdCB1c2UgdXBkYXRlIG5hbWU6ICcke25hbWV9Jywgd2l0aCByZXNlcnZlZCBwcmVmaXg6ICcke1RFTVBPUkFMX1JFU0VSVkVEX1BSRUZJWH0nYCk7XG4gICAgfVxuXG4gICAgLy8gU2tpcCBpbnRlcmNlcHRvcnMgaWYgaXQncyBhbiBpbnRlcm5hbCB1cGRhdGUuXG4gICAgY29uc3QgaXNJbnRlcm5hbFVwZGF0ZSA9XG4gICAgICBuYW1lLnN0YXJ0c1dpdGgoVEVNUE9SQUxfUkVTRVJWRURfUFJFRklYKSB8fFxuICAgICAgbmFtZSA9PT0gU1RBQ0tfVFJBQ0VfUVVFUllfTkFNRSB8fFxuICAgICAgbmFtZSA9PT0gRU5IQU5DRURfU1RBQ0tfVFJBQ0VfUVVFUllfTkFNRTtcbiAgICBjb25zdCBpbnRlcmNlcHRvcnMgPSBpc0ludGVybmFsVXBkYXRlID8gW10gOiB0aGlzLmludGVyY2VwdG9ycy5pbmJvdW5kO1xuXG4gICAgY29uc3QgZW50cnkgPVxuICAgICAgdGhpcy51cGRhdGVIYW5kbGVycy5nZXQobmFtZSkgPz9cbiAgICAgICh0aGlzLmRlZmF1bHRVcGRhdGVIYW5kbGVyXG4gICAgICAgID8ge1xuICAgICAgICAgICAgaGFuZGxlcjogdGhpcy5kZWZhdWx0VXBkYXRlSGFuZGxlci5iaW5kKHVuZGVmaW5lZCwgbmFtZSksXG4gICAgICAgICAgICB2YWxpZGF0b3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gYSB3YXJuaW5nIHBvbGljeS5cbiAgICAgICAgICAgIHVuZmluaXNoZWRQb2xpY3k6IEhhbmRsZXJVbmZpbmlzaGVkUG9saWN5LldBUk5fQU5EX0FCQU5ET04sXG4gICAgICAgICAgfVxuICAgICAgICA6IG51bGwpO1xuXG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbiBlbnRyeSBmcm9tIGVpdGhlciBzb3VyY2UsIGJ1ZmZlciBhbmQgcmV0dXJuXG4gICAgaWYgKGVudHJ5ID09IG51bGwpIHtcbiAgICAgIHRoaXMuYnVmZmVyZWRVcGRhdGVzLnB1c2goYWN0aXZhdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWFrZUlucHV0ID0gKCk6IFVwZGF0ZUlucHV0ID0+ICh7XG4gICAgICB1cGRhdGVJZCxcbiAgICAgIGFyZ3M6IGFycmF5RnJvbVBheWxvYWRzKHRoaXMucGF5bG9hZENvbnZlcnRlciwgYWN0aXZhdGlvbi5pbnB1dCksXG4gICAgICBuYW1lLFxuICAgICAgaGVhZGVyczogaGVhZGVycyA/PyB7fSxcbiAgICB9KTtcblxuICAgIC8vIFRoZSBpbXBsZW1lbnRhdGlvbiBiZWxvdyBpcyByZXNwb25zaWJsZSBmb3IgdXBob2xkaW5nLCBhbmQgY29uc3RyYWluZWRcbiAgICAvLyBieSwgdGhlIGZvbGxvd2luZyBjb250cmFjdDpcbiAgICAvL1xuICAgIC8vIDEuIElmIG5vIHZhbGlkYXRvciBpcyBwcmVzZW50IHRoZW4gdmFsaWRhdGlvbiBpbnRlcmNlcHRvcnMgd2lsbCBub3QgYmUgcnVuLlxuICAgIC8vXG4gICAgLy8gMi4gRHVyaW5nIHZhbGlkYXRpb24sIGFueSBlcnJvciBtdXN0IGZhaWwgdGhlIFVwZGF0ZTsgZHVyaW5nIHRoZSBVcGRhdGVcbiAgICAvLyAgICBpdHNlbGYsIFRlbXBvcmFsIGVycm9ycyBmYWlsIHRoZSBVcGRhdGUgd2hlcmVhcyBvdGhlciBlcnJvcnMgZmFpbCB0aGVcbiAgICAvLyAgICBhY3RpdmF0aW9uLlxuICAgIC8vXG4gICAgLy8gMy4gVGhlIGhhbmRsZXIgbXVzdCBub3Qgc2VlIGFueSBtdXRhdGlvbnMgb2YgdGhlIGFyZ3VtZW50cyBtYWRlIGJ5IHRoZVxuICAgIC8vICAgIHZhbGlkYXRvci5cbiAgICAvL1xuICAgIC8vIDQuIEFueSBlcnJvciB3aGVuIGRlY29kaW5nL2Rlc2VyaWFsaXppbmcgaW5wdXQgbXVzdCBiZSBjYXVnaHQgYW5kIHJlc3VsdFxuICAgIC8vICAgIGluIHJlamVjdGlvbiBvZiB0aGUgVXBkYXRlIGJlZm9yZSBpdCBpcyBhY2NlcHRlZCwgZXZlbiBpZiB0aGVyZSBpcyBub1xuICAgIC8vICAgIHZhbGlkYXRvci5cbiAgICAvL1xuICAgIC8vIDUuIFRoZSBpbml0aWFsIHN5bmNocm9ub3VzIHBvcnRpb24gb2YgdGhlIChhc3luYykgVXBkYXRlIGhhbmRsZXIgc2hvdWxkXG4gICAgLy8gICAgYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIChzeW5jKSB2YWxpZGF0b3IgY29tcGxldGVzIHN1Y2ggdGhhdCB0aGVyZSBpc1xuICAgIC8vICAgIG1pbmltYWwgb3Bwb3J0dW5pdHkgZm9yIGEgZGlmZmVyZW50IGNvbmN1cnJlbnQgdGFzayB0byBiZSBzY2hlZHVsZWRcbiAgICAvLyAgICBiZXR3ZWVuIHRoZW0uXG4gICAgLy9cbiAgICAvLyA2LiBUaGUgc3RhY2sgdHJhY2UgdmlldyBwcm92aWRlZCBpbiB0aGUgVGVtcG9yYWwgVUkgbXVzdCBub3QgYmUgcG9sbHV0ZWRcbiAgICAvLyAgICBieSBwcm9taXNlcyB0aGF0IGRvIG5vdCBkZXJpdmUgZnJvbSB1c2VyIGNvZGUuIFRoaXMgaW1wbGllcyB0aGF0XG4gICAgLy8gICAgYXN5bmMvYXdhaXQgc3ludGF4IG1heSBub3QgYmUgdXNlZC5cbiAgICAvL1xuICAgIC8vIE5vdGUgdGhhdCB0aGVyZSBpcyBhIGRlbGliZXJhdGVseSB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24gYmVsb3cuXG4gICAgLy8gVGhlc2UgYXJlIGNhdWdodCBlbHNld2hlcmUgYW5kIGZhaWwgdGhlIGNvcnJlc3BvbmRpbmcgYWN0aXZhdGlvbi5cbiAgICBjb25zdCBkb1VwZGF0ZUltcGwgPSBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgaW5wdXQ6IFVwZGF0ZUlucHV0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHJ1blZhbGlkYXRvciAmJiBlbnRyeS52YWxpZGF0b3IpIHtcbiAgICAgICAgICBjb25zdCB2YWxpZGF0ZSA9IGNvbXBvc2VJbnRlcmNlcHRvcnMoXG4gICAgICAgICAgICBpbnRlcmNlcHRvcnMsXG4gICAgICAgICAgICAndmFsaWRhdGVVcGRhdGUnLFxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVVwZGF0ZU5leHRIYW5kbGVyLmJpbmQodGhpcywgZW50cnkudmFsaWRhdG9yKVxuICAgICAgICAgICk7XG4gICAgICAgICAgdmFsaWRhdGUobWFrZUlucHV0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gbWFrZUlucHV0KCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLnJlamVjdFVwZGF0ZShwcm90b2NvbEluc3RhbmNlSWQsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hY2NlcHRVcGRhdGUocHJvdG9jb2xJbnN0YW5jZUlkKTtcbiAgICAgIGNvbnN0IGV4ZWN1dGUgPSBjb21wb3NlSW50ZXJjZXB0b3JzKFxuICAgICAgICBpbnRlcmNlcHRvcnMsXG4gICAgICAgICdoYW5kbGVVcGRhdGUnLFxuICAgICAgICB0aGlzLnVwZGF0ZU5leHRIYW5kbGVyLmJpbmQodGhpcywgZW50cnkuaGFuZGxlcilcbiAgICAgICk7XG4gICAgICBjb25zdCB7IHVuZmluaXNoZWRQb2xpY3kgfSA9IGVudHJ5O1xuICAgICAgdGhpcy5pblByb2dyZXNzVXBkYXRlcy5zZXQodXBkYXRlSWQsIHsgbmFtZSwgdW5maW5pc2hlZFBvbGljeSwgaWQ6IHVwZGF0ZUlkIH0pO1xuICAgICAgY29uc3QgcmVzID0gZXhlY3V0ZShpbnB1dClcbiAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4gdGhpcy5jb21wbGV0ZVVwZGF0ZShwcm90b2NvbEluc3RhbmNlSWQsIHJlc3VsdCkpXG4gICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUZW1wb3JhbEZhaWx1cmUpIHtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0VXBkYXRlKHByb3RvY29sSW5zdGFuY2VJZCwgZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVdvcmtmbG93RmFpbHVyZShlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuZmluYWxseSgoKSA9PiB0aGlzLmluUHJvZ3Jlc3NVcGRhdGVzLmRlbGV0ZSh1cGRhdGVJZCkpO1xuICAgICAgdW50cmFja1Byb21pc2UocmVzKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICB1bnRyYWNrUHJvbWlzZShVcGRhdGVTY29wZS51cGRhdGVXaXRoSW5mbyh1cGRhdGVJZCwgbmFtZSwgZG9VcGRhdGVJbXBsKSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgdXBkYXRlTmV4dEhhbmRsZXIoaGFuZGxlcjogV29ya2Zsb3dVcGRhdGVUeXBlLCB7IGFyZ3MgfTogVXBkYXRlSW5wdXQpOiBQcm9taXNlPHVua25vd24+IHtcbiAgICByZXR1cm4gYXdhaXQgaGFuZGxlciguLi5hcmdzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCB2YWxpZGF0ZVVwZGF0ZU5leHRIYW5kbGVyKHZhbGlkYXRvcjogV29ya2Zsb3dVcGRhdGVWYWxpZGF0b3JUeXBlIHwgdW5kZWZpbmVkLCB7IGFyZ3MgfTogVXBkYXRlSW5wdXQpOiB2b2lkIHtcbiAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICB2YWxpZGF0b3IoLi4uYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGRpc3BhdGNoQnVmZmVyZWRVcGRhdGVzKCk6IHZvaWQge1xuICAgIGNvbnN0IGJ1ZmZlcmVkVXBkYXRlcyA9IHRoaXMuYnVmZmVyZWRVcGRhdGVzO1xuICAgIHdoaWxlIChidWZmZXJlZFVwZGF0ZXMubGVuZ3RoKSB7XG4gICAgICAvLyBXZSBoYXZlIGEgZGVmYXVsdCB1cGRhdGUgaGFuZGxlciwgc28gYWxsIHVwZGF0ZXMgYXJlIGRpc3BhdGNoYWJsZS5cbiAgICAgIGlmICh0aGlzLmRlZmF1bHRVcGRhdGVIYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZSA9IGJ1ZmZlcmVkVXBkYXRlcy5zaGlmdCgpO1xuICAgICAgICAvLyBMb2dpY2FsbHksIHRoaXMgbXVzdCBiZSBkZWZpbmVkIGFzIHdlJ3JlIGluIHRoZSBsb29wLlxuICAgICAgICAvLyBCdXQgVHlwZXNjcmlwdCBkb2Vzbid0IGtub3cgdGhhdCBzbyB3ZSB1c2UgYSBub24tbnVsbCBhc3NlcnRpb24gKCEpLlxuICAgICAgICB0aGlzLmRvVXBkYXRlKHVwZGF0ZSEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZm91bmRJbmRleCA9IGJ1ZmZlcmVkVXBkYXRlcy5maW5kSW5kZXgoKHVwZGF0ZSkgPT4gdGhpcy51cGRhdGVIYW5kbGVycy5oYXModXBkYXRlLm5hbWUgYXMgc3RyaW5nKSk7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkge1xuICAgICAgICAgIC8vIE5vIGJ1ZmZlcmVkIFVwZGF0ZXMgaGF2ZSBhIGhhbmRsZXIgeWV0LlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFt1cGRhdGVdID0gYnVmZmVyZWRVcGRhdGVzLnNwbGljZShmb3VuZEluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5kb1VwZGF0ZSh1cGRhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyByZWplY3RCdWZmZXJlZFVwZGF0ZXMoKTogdm9pZCB7XG4gICAgd2hpbGUgKHRoaXMuYnVmZmVyZWRVcGRhdGVzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdXBkYXRlID0gdGhpcy5idWZmZXJlZFVwZGF0ZXMuc2hpZnQoKTtcbiAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgdGhpcy5yZWplY3RVcGRhdGUoXG4gICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvbiAqL1xuICAgICAgICAgIHVwZGF0ZS5wcm90b2NvbEluc3RhbmNlSWQhLFxuICAgICAgICAgIEFwcGxpY2F0aW9uRmFpbHVyZS5ub25SZXRyeWFibGUoYE5vIHJlZ2lzdGVyZWQgaGFuZGxlciBmb3IgdXBkYXRlOiAke3VwZGF0ZS5uYW1lfWApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIHNpZ25hbFdvcmtmbG93TmV4dEhhbmRsZXIoeyBzaWduYWxOYW1lLCBhcmdzIH06IFNpZ25hbElucHV0KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgZm4gPSB0aGlzLnNpZ25hbEhhbmRsZXJzLmdldChzaWduYWxOYW1lKT8uaGFuZGxlcjtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHJldHVybiBhd2FpdCBmbiguLi5hcmdzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGVmYXVsdFNpZ25hbEhhbmRsZXIpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmRlZmF1bHRTaWduYWxIYW5kbGVyKHNpZ25hbE5hbWUsIC4uLmFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXJyb3IoYE5vIHJlZ2lzdGVyZWQgc2lnbmFsIGhhbmRsZXIgZm9yIHNpZ25hbDogJHtzaWduYWxOYW1lfWApO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzaWduYWxXb3JrZmxvdyhhY3RpdmF0aW9uOiBjb3Jlc2RrLndvcmtmbG93X2FjdGl2YXRpb24uSVNpZ25hbFdvcmtmbG93KTogdm9pZCB7XG4gICAgY29uc3QgeyBzaWduYWxOYW1lLCBoZWFkZXJzIH0gPSBhY3RpdmF0aW9uO1xuICAgIGlmICghc2lnbmFsTmFtZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyBhY3RpdmF0aW9uIHNpZ25hbE5hbWUnKTtcbiAgICB9XG5cbiAgICAvLyBJZiBzaWduYWwgaGFzIF9fdGVtcG9yYWxfIHByZWZpeCBidXQgbm8gaGFuZGxlciBleGlzdHMsIHRocm93IGVycm9yXG4gICAgaWYgKHNpZ25hbE5hbWUuc3RhcnRzV2l0aChURU1QT1JBTF9SRVNFUlZFRF9QUkVGSVgpICYmICF0aGlzLnNpZ25hbEhhbmRsZXJzLmhhcyhzaWduYWxOYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgYENhbm5vdCB1c2Ugc2lnbmFsIG5hbWU6ICcke3NpZ25hbE5hbWV9Jywgd2l0aCByZXNlcnZlZCBwcmVmaXg6ICcke1RFTVBPUkFMX1JFU0VSVkVEX1BSRUZJWH0nYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBTa2lwIGludGVyY2VwdG9ycyBpZiBpdCdzIGFuIGludGVybmFsIHNpZ25hbC5cbiAgICBjb25zdCBpc0ludGVybmFsU2lnbmFsID1cbiAgICAgIHNpZ25hbE5hbWUuc3RhcnRzV2l0aChURU1QT1JBTF9SRVNFUlZFRF9QUkVGSVgpIHx8XG4gICAgICBzaWduYWxOYW1lID09PSBTVEFDS19UUkFDRV9RVUVSWV9OQU1FIHx8XG4gICAgICBzaWduYWxOYW1lID09PSBFTkhBTkNFRF9TVEFDS19UUkFDRV9RVUVSWV9OQU1FO1xuICAgIGNvbnN0IGludGVyY2VwdG9ycyA9IGlzSW50ZXJuYWxTaWduYWwgPyBbXSA6IHRoaXMuaW50ZXJjZXB0b3JzLmluYm91bmQ7XG5cbiAgICBpZiAoIXRoaXMuc2lnbmFsSGFuZGxlcnMuaGFzKHNpZ25hbE5hbWUpICYmICF0aGlzLmRlZmF1bHRTaWduYWxIYW5kbGVyKSB7XG4gICAgICB0aGlzLmJ1ZmZlcmVkU2lnbmFscy5wdXNoKGFjdGl2YXRpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGZhbGwgdGhyb3VnaCB0byB0aGUgZGVmYXVsdCBzaWduYWwgaGFuZGxlciB0aGVuIHRoZSB1bmZpbmlzaGVkXG4gICAgLy8gcG9saWN5IGlzIFdBUk5fQU5EX0FCQU5ET047IHVzZXJzIGN1cnJlbnRseSBoYXZlIG5vIHdheSB0byBzaWxlbmNlIGFueVxuICAgIC8vIGVuc3Vpbmcgd2FybmluZ3MuXG4gICAgY29uc3QgdW5maW5pc2hlZFBvbGljeSA9XG4gICAgICB0aGlzLnNpZ25hbEhhbmRsZXJzLmdldChzaWduYWxOYW1lKT8udW5maW5pc2hlZFBvbGljeSA/PyBIYW5kbGVyVW5maW5pc2hlZFBvbGljeS5XQVJOX0FORF9BQkFORE9OO1xuXG4gICAgY29uc3Qgc2lnbmFsRXhlY3V0aW9uTnVtID0gdGhpcy5zaWduYWxIYW5kbGVyRXhlY3V0aW9uU2VxKys7XG4gICAgdGhpcy5pblByb2dyZXNzU2lnbmFscy5zZXQoc2lnbmFsRXhlY3V0aW9uTnVtLCB7IG5hbWU6IHNpZ25hbE5hbWUsIHVuZmluaXNoZWRQb2xpY3kgfSk7XG4gICAgY29uc3QgZXhlY3V0ZSA9IGNvbXBvc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3JzLCAnaGFuZGxlU2lnbmFsJywgdGhpcy5zaWduYWxXb3JrZmxvd05leHRIYW5kbGVyLmJpbmQodGhpcykpO1xuICAgIGV4ZWN1dGUoe1xuICAgICAgYXJnczogYXJyYXlGcm9tUGF5bG9hZHModGhpcy5wYXlsb2FkQ29udmVydGVyLCBhY3RpdmF0aW9uLmlucHV0KSxcbiAgICAgIHNpZ25hbE5hbWUsXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzID8/IHt9LFxuICAgIH0pXG4gICAgICAuY2F0Y2godGhpcy5oYW5kbGVXb3JrZmxvd0ZhaWx1cmUuYmluZCh0aGlzKSlcbiAgICAgIC5maW5hbGx5KCgpID0+IHRoaXMuaW5Qcm9ncmVzc1NpZ25hbHMuZGVsZXRlKHNpZ25hbEV4ZWN1dGlvbk51bSkpO1xuICB9XG5cbiAgcHVibGljIGRpc3BhdGNoQnVmZmVyZWRTaWduYWxzKCk6IHZvaWQge1xuICAgIGNvbnN0IGJ1ZmZlcmVkU2lnbmFscyA9IHRoaXMuYnVmZmVyZWRTaWduYWxzO1xuICAgIHdoaWxlIChidWZmZXJlZFNpZ25hbHMubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5kZWZhdWx0U2lnbmFsSGFuZGxlcikge1xuICAgICAgICAvLyBXZSBoYXZlIGEgZGVmYXVsdCBzaWduYWwgaGFuZGxlciwgc28gYWxsIHNpZ25hbHMgYXJlIGRpc3BhdGNoYWJsZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICB0aGlzLnNpZ25hbFdvcmtmbG93KGJ1ZmZlcmVkU2lnbmFscy5zaGlmdCgpISk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBmb3VuZEluZGV4ID0gYnVmZmVyZWRTaWduYWxzLmZpbmRJbmRleCgoc2lnbmFsKSA9PiB0aGlzLnNpZ25hbEhhbmRsZXJzLmhhcyhzaWduYWwuc2lnbmFsTmFtZSBhcyBzdHJpbmcpKTtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBicmVhaztcbiAgICAgICAgY29uc3QgW3NpZ25hbF0gPSBidWZmZXJlZFNpZ25hbHMuc3BsaWNlKGZvdW5kSW5kZXgsIDEpO1xuICAgICAgICB0aGlzLnNpZ25hbFdvcmtmbG93KHNpZ25hbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlc29sdmVTaWduYWxFeHRlcm5hbFdvcmtmbG93KGFjdGl2YXRpb246IGNvcmVzZGsud29ya2Zsb3dfYWN0aXZhdGlvbi5JUmVzb2x2ZVNpZ25hbEV4dGVybmFsV29ya2Zsb3cpOiB2b2lkIHtcbiAgICBjb25zdCB7IHJlc29sdmUsIHJlamVjdCB9ID0gdGhpcy5jb25zdW1lQ29tcGxldGlvbignc2lnbmFsV29ya2Zsb3cnLCBnZXRTZXEoYWN0aXZhdGlvbikpO1xuICAgIGlmIChhY3RpdmF0aW9uLmZhaWx1cmUpIHtcbiAgICAgIHJlamVjdCh0aGlzLmZhaWx1cmVUb0Vycm9yKGFjdGl2YXRpb24uZmFpbHVyZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlc29sdmVSZXF1ZXN0Q2FuY2VsRXh0ZXJuYWxXb3JrZmxvdyhcbiAgICBhY3RpdmF0aW9uOiBjb3Jlc2RrLndvcmtmbG93X2FjdGl2YXRpb24uSVJlc29sdmVSZXF1ZXN0Q2FuY2VsRXh0ZXJuYWxXb3JrZmxvd1xuICApOiB2b2lkIHtcbiAgICBjb25zdCB7IHJlc29sdmUsIHJlamVjdCB9ID0gdGhpcy5jb25zdW1lQ29tcGxldGlvbignY2FuY2VsV29ya2Zsb3cnLCBnZXRTZXEoYWN0aXZhdGlvbikpO1xuICAgIGlmIChhY3RpdmF0aW9uLmZhaWx1cmUpIHtcbiAgICAgIHJlamVjdCh0aGlzLmZhaWx1cmVUb0Vycm9yKGFjdGl2YXRpb24uZmFpbHVyZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHdhcm5JZlVuZmluaXNoZWRIYW5kbGVycygpOiB2b2lkIHtcbiAgICBpZiAodGhpcy53b3JrZmxvd1Rhc2tFcnJvcikgcmV0dXJuO1xuXG4gICAgY29uc3QgZ2V0V2FybmFibGUgPSAoaGFuZGxlckV4ZWN1dGlvbnM6IEl0ZXJhYmxlPE1lc3NhZ2VIYW5kbGVyRXhlY3V0aW9uPik6IE1lc3NhZ2VIYW5kbGVyRXhlY3V0aW9uW10gPT4ge1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20oaGFuZGxlckV4ZWN1dGlvbnMpLmZpbHRlcihcbiAgICAgICAgKGV4KSA9PiBleC51bmZpbmlzaGVkUG9saWN5ID09PSBIYW5kbGVyVW5maW5pc2hlZFBvbGljeS5XQVJOX0FORF9BQkFORE9OXG4gICAgICApO1xuICAgIH07XG5cbiAgICBjb25zdCB3YXJuYWJsZVVwZGF0ZXMgPSBnZXRXYXJuYWJsZSh0aGlzLmluUHJvZ3Jlc3NVcGRhdGVzLnZhbHVlcygpKTtcbiAgICBpZiAod2FybmFibGVVcGRhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGxvZy53YXJuKG1ha2VVbmZpbmlzaGVkVXBkYXRlSGFuZGxlck1lc3NhZ2Uod2FybmFibGVVcGRhdGVzKSk7XG4gICAgfVxuXG4gICAgY29uc3Qgd2FybmFibGVTaWduYWxzID0gZ2V0V2FybmFibGUodGhpcy5pblByb2dyZXNzU2lnbmFscy52YWx1ZXMoKSk7XG4gICAgaWYgKHdhcm5hYmxlU2lnbmFscy5sZW5ndGggPiAwKSB7XG4gICAgICBsb2cud2FybihtYWtlVW5maW5pc2hlZFNpZ25hbEhhbmRsZXJNZXNzYWdlKHdhcm5hYmxlU2lnbmFscykpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyB1cGRhdGVSYW5kb21TZWVkKGFjdGl2YXRpb246IGNvcmVzZGsud29ya2Zsb3dfYWN0aXZhdGlvbi5JVXBkYXRlUmFuZG9tU2VlZCk6IHZvaWQge1xuICAgIGlmICghYWN0aXZhdGlvbi5yYW5kb21uZXNzU2VlZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYWN0aXZhdGlvbiB3aXRoIHJhbmRvbW5lc3NTZWVkIGF0dHJpYnV0ZScpO1xuICAgIH1cbiAgICB0aGlzLnJhbmRvbSA9IGFsZWEoYWN0aXZhdGlvbi5yYW5kb21uZXNzU2VlZC50b0J5dGVzKCkpO1xuICB9XG5cbiAgcHVibGljIG5vdGlmeUhhc1BhdGNoKGFjdGl2YXRpb246IGNvcmVzZGsud29ya2Zsb3dfYWN0aXZhdGlvbi5JTm90aWZ5SGFzUGF0Y2gpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaW5mby51bnNhZmUuaXNSZXBsYXlpbmcpXG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXJyb3IoJ1VuZXhwZWN0ZWQgbm90aWZ5SGFzUGF0Y2ggam9iIG9uIG5vbi1yZXBsYXkgYWN0aXZhdGlvbicpO1xuICAgIGlmICghYWN0aXZhdGlvbi5wYXRjaElkKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3RpZnlIYXNQYXRjaCBtaXNzaW5nIHBhdGNoIGlkJyk7XG4gICAgdGhpcy5rbm93blByZXNlbnRQYXRjaGVzLmFkZChhY3RpdmF0aW9uLnBhdGNoSWQpO1xuICB9XG5cbiAgcHVibGljIHBhdGNoSW50ZXJuYWwocGF0Y2hJZDogc3RyaW5nLCBkZXByZWNhdGVkOiBib29sZWFuKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMud29ya2Zsb3cgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUVycm9yKCdQYXRjaGVzIGNhbm5vdCBiZSB1c2VkIGJlZm9yZSBXb3JrZmxvdyBzdGFydHMnKTtcbiAgICB9XG4gICAgY29uc3QgdXNlUGF0Y2ggPSAhdGhpcy5pbmZvLnVuc2FmZS5pc1JlcGxheWluZyB8fCB0aGlzLmtub3duUHJlc2VudFBhdGNoZXMuaGFzKHBhdGNoSWQpO1xuICAgIC8vIEF2b2lkIHNlbmRpbmcgY29tbWFuZHMgZm9yIHBhdGNoZXMgY29yZSBhbHJlYWR5IGtub3dzIGFib3V0LlxuICAgIC8vIFRoaXMgb3B0aW1pemF0aW9uIGVuYWJsZXMgZGV2ZWxvcG1lbnQgb2YgYXV0b21hdGljIHBhdGNoaW5nIHRvb2xzLlxuICAgIGlmICh1c2VQYXRjaCAmJiAhdGhpcy5zZW50UGF0Y2hlcy5oYXMocGF0Y2hJZCkpIHtcbiAgICAgIHRoaXMucHVzaENvbW1hbmQoe1xuICAgICAgICBzZXRQYXRjaE1hcmtlcjogeyBwYXRjaElkLCBkZXByZWNhdGVkIH0sXG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VudFBhdGNoZXMuYWRkKHBhdGNoSWQpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlUGF0Y2g7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIGVhcmx5IHdoaWxlIGhhbmRsaW5nIGFuIGFjdGl2YXRpb24gdG8gcmVnaXN0ZXIga25vd24gZmxhZ3MuXG4gICAqIE1heSBiZSBpbnZva2VkIGZyb20gb3V0c2lkZSB0aGUgVk0uXG4gICAqL1xuICBwdWJsaWMgYWRkS25vd25GbGFncyhmbGFnczogbnVtYmVyW10pOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGZsYWcgb2YgZmxhZ3MpIHtcbiAgICAgIGFzc2VydFZhbGlkRmxhZyhmbGFnKTtcbiAgICAgIHRoaXMua25vd25GbGFncy5hZGQoZmxhZyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIFNESyBGbGFnIG1heSBiZSBjb25zaWRlcmVkIGFzIGVuYWJsZWQgZm9yIHRoZSBjdXJyZW50IFdvcmtmbG93IFRhc2suXG4gICAqXG4gICAqIFNESyBmbGFncyBwbGF5IGEgcm9sZSBzaW1pbGFyIHRvIHRoZSBgcGF0Y2hlZCgpYCBBUEksIGJ1dCBhcmUgbWVhbnQgZm9yIGludGVybmFsIHVzYWdlIGJ5IHRoZVxuICAgKiBTREsgaXRzZWxmLiBUaGV5IG1ha2UgaXQgcG9zc2libGUgZm9yIHRoZSBTREsgdG8gZXZvbHZlIGl0cyBiZWhhdmlvcnMgb3ZlciB0aW1lLCB3aGlsZSBzdGlsbFxuICAgKiBtYWludGFpbmluZyBjb21wYXRpYmlsaXR5IHdpdGggV29ya2Zsb3cgaGlzdG9yaWVzIHByb2R1Y2VkIGJ5IG9sZGVyIFNES3MsIHdpdGhvdXQgY2F1c2luZ1xuICAgKiBkZXRlcm1pbmlzbSB2aW9sYXRpb25zLlxuICAgKlxuICAgKiBNYXkgYmUgaW52b2tlZCBmcm9tIG91dHNpZGUgdGhlIFZNLlxuICAgKi9cbiAgcHVibGljIGhhc0ZsYWcoZmxhZzogU2RrRmxhZyk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLmtub3duRmxhZ3MuaGFzKGZsYWcuaWQpKSByZXR1cm4gdHJ1ZTtcblxuICAgIC8vIElmIG5vdCByZXBsYXlpbmcsIGVuYWJsZSB0aGUgZmxhZyBpZiBpdCBpcyBjb25maWd1cmVkIHRvIGJlIGVuYWJsZWQgYnkgZGVmYXVsdC4gU2V0dGluZyBhXG4gICAgLy8gZmxhZydzIGRlZmF1bHQgdG8gZmFsc2UgYWxsb3dzIHByb2dyZXNzaXZlIHJvbGxvdXQgb2YgbmV3IGZlYXR1cmUgZmxhZ3MsIHdpdGggdGhlIHBvc3NpYmlsaXR5XG4gICAgLy8gb2YgcmV2ZXJ0aW5nIGJhY2sgdG8gYSB2ZXJzaW9uIG9mIHRoZSBTREsgd2hlcmUgdGhlIGZsYWcgaXMgc3VwcG9ydGVkIGJ1dCBkaXNhYmxlZCBieSBkZWZhdWx0LlxuICAgIC8vIEl0IGlzIGFsc28gdXNlZnVsIGZvciB0ZXN0aW5nIHB1cnBvc2UuXG4gICAgaWYgKCF0aGlzLmluZm8udW5zYWZlLmlzUmVwbGF5aW5nICYmIGZsYWcuZGVmYXVsdCkge1xuICAgICAgdGhpcy5rbm93bkZsYWdzLmFkZChmbGFnLmlkKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFdoZW4gcmVwbGF5aW5nLCBhIGZsYWcgaXMgY29uc2lkZXJlZCBlbmFibGVkIGlmIGl0IHdhcyBlbmFibGVkIGR1cmluZyB0aGUgb3JpZ2luYWwgZXhlY3V0aW9uIG9mXG4gICAgLy8gdGhhdCBXb3JrZmxvdyBUYXNrOyB0aGlzIGlzIG5vcm1hbGx5IGRldGVybWluZWQgYnkgdGhlIHByZXNlbmNlIG9mIHRoZSBmbGFnIElEIGluIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgLy8gV0ZUIENvbXBsZXRlZCdzIGBzZGtNZXRhZGF0YS5sYW5nVXNlZEZsYWdzYC5cbiAgICAvL1xuICAgIC8vIFNESyBGbGFnIEFsdGVybmF0ZSBDb25kaXRpb24gcHJvdmlkZXMgYW4gYWx0ZXJuYXRpdmUgd2F5IG9mIGRldGVybWluaW5nIHdoZXRoZXIgYSBmbGFnIHNob3VsZFxuICAgIC8vIGJlIGNvbnNpZGVyZWQgYXMgZW5hYmxlZCBmb3IgdGhlIGN1cnJlbnQgV0ZUOyBlLmcuIGJ5IGxvb2tpbmcgYXQgdGhlIHZlcnNpb24gb2YgdGhlIFNESyB0aGF0XG4gICAgLy8gZW1pdHRlZCBhIFdGVC4gVGhlIG1haW4gdXNlIGNhc2UgZm9yIHRoaXMgaXMgdG8gcmV0cm9hY3RpdmVseSB0dXJuIG9uIHNvbWUgZmxhZ3MgZm9yIFdGVCBlbWl0dGVkXG4gICAgLy8gYnkgcHJldmlvdXMgU0RLcyB0aGF0IGNvbnRhaW5lZCBhIGJ1Zy4gQWx0IENvbmRpdGlvbnMgc2hvdWxkIG9ubHkgYmUgdXNlZCBhcyBhIGxhc3QgcmVzb3J0LlxuICAgIC8vXG4gICAgLy8gTm90ZSB0aGF0IGNvbmRpdGlvbnMgYXJlIG9ubHkgZXZhbHVhdGVkIHdoaWxlIHJlcGxheWluZy4gQWxzbywgYWx0ZXJuYXRlIGNvbmRpdGlvbnMgd2lsbCBub3RcbiAgICAvLyBjYXVzZSB0aGUgZmxhZyB0byBiZSBwZXJzaXN0ZWQgdG8gdGhlIFwidXNlZCBmbGFnc1wiIHNldCwgd2hpY2ggbWVhbnMgdGhhdCBmdXJ0aGVyIFdvcmtmbG93IFRhc2tzXG4gICAgLy8gbWF5IG5vdCByZWZsZWN0IHRoaXMgZmxhZyBpZiB0aGUgY29uZGl0aW9uIG5vIGxvbmdlciBob2xkcy4gVGhpcyBpcyBzbyB0byBhdm9pZCBpbmNvcnJlY3RcbiAgICAvLyBiZWhhdmlvcnMgaW4gY2FzZSB3aGVyZSBhIFdvcmtmbG93IEV4ZWN1dGlvbiBoYXMgZ29uZSB0aHJvdWdoIGEgbmV3ZXIgU0RLIHZlcnNpb24gdGhlbiBhZ2FpblxuICAgIC8vIHRocm91Z2ggYW4gb2xkZXIgb25lLlxuICAgIGlmICh0aGlzLmluZm8udW5zYWZlLmlzUmVwbGF5aW5nICYmIGZsYWcuYWx0ZXJuYXRpdmVDb25kaXRpb25zKSB7XG4gICAgICBmb3IgKGNvbnN0IGNvbmQgb2YgZmxhZy5hbHRlcm5hdGl2ZUNvbmRpdGlvbnMpIHtcbiAgICAgICAgaWYgKGNvbmQoeyBpbmZvOiB0aGlzLmluZm8gfSkpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyByZW1vdmVGcm9tQ2FjaGUoKTogdm9pZCB7XG4gICAgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUVycm9yKCdyZW1vdmVGcm9tQ2FjaGUgYWN0aXZhdGlvbiBqb2Igc2hvdWxkIG5vdCByZWFjaCB3b3JrZmxvdycpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgZmFpbHVyZXMgaW50byBhIGNvbW1hbmQgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyLlxuICAgKiBVc2VkIHRvIGhhbmRsZSBhbnkgZmFpbHVyZSBlbWl0dGVkIGJ5IHRoZSBXb3JrZmxvdy5cbiAgICovXG4gIGhhbmRsZVdvcmtmbG93RmFpbHVyZShlcnJvcjogdW5rbm93bik6IHZvaWQge1xuICAgIGlmICh0aGlzLmNhbmNlbGxlZCAmJiBpc0NhbmNlbGxhdGlvbihlcnJvcikpIHtcbiAgICAgIHRoaXMucHVzaENvbW1hbmQoeyBjYW5jZWxXb3JrZmxvd0V4ZWN1dGlvbjoge30gfSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIENvbnRpbnVlQXNOZXcpIHtcbiAgICAgIHRoaXMucHVzaENvbW1hbmQoeyBjb250aW51ZUFzTmV3V29ya2Zsb3dFeGVjdXRpb246IGVycm9yLmNvbW1hbmQgfSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIFRlbXBvcmFsRmFpbHVyZSkge1xuICAgICAgLy8gRmFpbCB0aGUgd29ya2Zsb3cuIFdlIGRvIG5vdCB3YW50IHRvIGlzc3VlIHVuZmluaXNoZWRIYW5kbGVycyB3YXJuaW5ncy4gVG8gYWNoaWV2ZSB0aGF0LCB3ZVxuICAgICAgLy8gbWFyayBhbGwgaGFuZGxlcnMgYXMgY29tcGxldGVkIG5vdy5cbiAgICAgIHRoaXMuaW5Qcm9ncmVzc1NpZ25hbHMuY2xlYXIoKTtcbiAgICAgIHRoaXMuaW5Qcm9ncmVzc1VwZGF0ZXMuY2xlYXIoKTtcbiAgICAgIHRoaXMucHVzaENvbW1hbmQoXG4gICAgICAgIHtcbiAgICAgICAgICBmYWlsV29ya2Zsb3dFeGVjdXRpb246IHtcbiAgICAgICAgICAgIGZhaWx1cmU6IHRoaXMuZXJyb3JUb0ZhaWx1cmUoZXJyb3IpLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVjb3JkV29ya2Zsb3dUYXNrRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIHJlY29yZFdvcmtmbG93VGFza0Vycm9yKGVycm9yOiB1bmtub3duKTogdm9pZCB7XG4gICAgLy8gT25seSBrZWVwIHRoZSBmaXJzdCBlcnJvciB0aGF0IGJ1YmJsZXMgdXA7IHN1YnNlcXVlbnQgZXJyb3JzIHdpbGwgYmUgaWdub3JlZC5cbiAgICBpZiAodGhpcy53b3JrZmxvd1Rhc2tFcnJvciA9PT0gdW5kZWZpbmVkKSB0aGlzLndvcmtmbG93VGFza0Vycm9yID0gZXJyb3I7XG5cbiAgICAvLyBJbW1lZGlhdGVseSByZXRocm93IHRoZSBlcnJvciBpZiB3ZSBrbm93IGl0IGlzIHNhZmUgdG8gZG8gc28gKGkuZS4gd2UgYXJlIG5vdCBydW5uaW5nIGFzeW5jXG4gICAgLy8gbWljcm90YXNrcykuIE90aGVyd2lzZSwgdGhlIGVycm9yIHdpbGwgYmUgcmV0aHJvd24gd2hlbmV2ZXIgd2UgZ2V0IGFuIG9wcG9ydHVuaXR5IHRvIGRvIHNvLFxuICAgIC8vIGUuZy4gdGhlIG5leHQgdGltZSBgdHJ5VW5ibG9ja0NvbmRpdGlvbnMoKWAgaXMgY2FsbGVkLlxuICAgIGlmICh0aGlzLnJldGhyb3dTeW5jaHJvbm91c2x5KSB0aGlzLm1heWJlUmV0aHJvd1dvcmtmbG93VGFza0Vycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogSWYgYSBXb3JrZmxvdyBUYXNrIGVycm9yIHdhcyBjYXB0dXJlZCwgYW5kIHdlIGFyZSBydW5uaW5nIGluIHN5bmNocm9ub3VzIG1vZGUsXG4gICAqIHRoZW4gYnViYmxlIGl0IHVwIG5vdy4gVGhpcyBpcyBzYWZlIHRvIGNhbGwgZXZlbiBpZiB0aGVyZSBpcyBubyBlcnJvciB0byByZXRocm93LlxuICAgKi9cbiAgbWF5YmVSZXRocm93V29ya2Zsb3dUYXNrRXJyb3IoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMud29ya2Zsb3dUYXNrRXJyb3IpIHRocm93IHRoaXMud29ya2Zsb3dUYXNrRXJyb3I7XG4gIH1cblxuICBwcml2YXRlIGNvbXBsZXRlUXVlcnkocXVlcnlJZDogc3RyaW5nLCByZXN1bHQ6IHVua25vd24pOiB2b2lkIHtcbiAgICB0aGlzLnB1c2hDb21tYW5kKHtcbiAgICAgIHJlc3BvbmRUb1F1ZXJ5OiB7IHF1ZXJ5SWQsIHN1Y2NlZWRlZDogeyByZXNwb25zZTogdGhpcy5wYXlsb2FkQ29udmVydGVyLnRvUGF5bG9hZChyZXN1bHQpIH0gfSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgZmFpbFF1ZXJ5KHF1ZXJ5SWQ6IHN0cmluZywgZXJyb3I6IHVua25vd24pOiB2b2lkIHtcbiAgICB0aGlzLnB1c2hDb21tYW5kKHtcbiAgICAgIHJlc3BvbmRUb1F1ZXJ5OiB7XG4gICAgICAgIHF1ZXJ5SWQsXG4gICAgICAgIGZhaWxlZDogdGhpcy5lcnJvclRvRmFpbHVyZShlbnN1cmVUZW1wb3JhbEZhaWx1cmUoZXJyb3IpKSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGFjY2VwdFVwZGF0ZShwcm90b2NvbEluc3RhbmNlSWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMucHVzaENvbW1hbmQoeyB1cGRhdGVSZXNwb25zZTogeyBwcm90b2NvbEluc3RhbmNlSWQsIGFjY2VwdGVkOiB7fSB9IH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBjb21wbGV0ZVVwZGF0ZShwcm90b2NvbEluc3RhbmNlSWQ6IHN0cmluZywgcmVzdWx0OiB1bmtub3duKTogdm9pZCB7XG4gICAgdGhpcy5wdXNoQ29tbWFuZCh7XG4gICAgICB1cGRhdGVSZXNwb25zZTogeyBwcm90b2NvbEluc3RhbmNlSWQsIGNvbXBsZXRlZDogdGhpcy5wYXlsb2FkQ29udmVydGVyLnRvUGF5bG9hZChyZXN1bHQpIH0sXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHJlamVjdFVwZGF0ZShwcm90b2NvbEluc3RhbmNlSWQ6IHN0cmluZywgZXJyb3I6IHVua25vd24pOiB2b2lkIHtcbiAgICB0aGlzLnB1c2hDb21tYW5kKHtcbiAgICAgIHVwZGF0ZVJlc3BvbnNlOiB7XG4gICAgICAgIHByb3RvY29sSW5zdGFuY2VJZCxcbiAgICAgICAgcmVqZWN0ZWQ6IHRoaXMuZXJyb3JUb0ZhaWx1cmUoZW5zdXJlVGVtcG9yYWxGYWlsdXJlKGVycm9yKSksXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqIENvbnN1bWUgYSBjb21wbGV0aW9uIGlmIGl0IGV4aXN0cyBpbiBXb3JrZmxvdyBzdGF0ZSAqL1xuICBwcml2YXRlIG1heWJlQ29uc3VtZUNvbXBsZXRpb248SyBleHRlbmRzIGtleW9mIEFjdGl2YXRvclsnY29tcGxldGlvbnMnXT4oXG4gICAgdHlwZTogSyxcbiAgICB0YXNrU2VxOiBudW1iZXJcbiAgKTogSW5mZXJNYXBWYWx1ZTxBY3RpdmF0b3JbJ2NvbXBsZXRpb25zJ11bS10+IHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBjb21wbGV0aW9uID0gdGhpcy5jb21wbGV0aW9uc1t0eXBlXS5nZXQodGFza1NlcSk7XG4gICAgaWYgKGNvbXBsZXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5jb21wbGV0aW9uc1t0eXBlXS5kZWxldGUodGFza1NlcSk7XG4gICAgfVxuICAgIHJldHVybiBjb21wbGV0aW9uIGFzIEluZmVyTWFwVmFsdWU8QWN0aXZhdG9yWydjb21wbGV0aW9ucyddW0tdPiB8IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKiBDb25zdW1lIGEgY29tcGxldGlvbiBpZiBpdCBleGlzdHMgaW4gV29ya2Zsb3cgc3RhdGUsIHRocm93cyBpZiBpdCBkb2Vzbid0ICovXG4gIHByaXZhdGUgY29uc3VtZUNvbXBsZXRpb248SyBleHRlbmRzIGtleW9mIEFjdGl2YXRvclsnY29tcGxldGlvbnMnXT4oXG4gICAgdHlwZTogSyxcbiAgICB0YXNrU2VxOiBudW1iZXJcbiAgKTogSW5mZXJNYXBWYWx1ZTxBY3RpdmF0b3JbJ2NvbXBsZXRpb25zJ11bS10+IHtcbiAgICBjb25zdCBjb21wbGV0aW9uID0gdGhpcy5tYXliZUNvbnN1bWVDb21wbGV0aW9uKHR5cGUsIHRhc2tTZXEpO1xuICAgIGlmIChjb21wbGV0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFcnJvcihgTm8gY29tcGxldGlvbiBmb3IgdGFza1NlcSAke3Rhc2tTZXF9YCk7XG4gICAgfVxuICAgIHJldHVybiBjb21wbGV0aW9uO1xuICB9XG5cbiAgcHJpdmF0ZSBjb21wbGV0ZVdvcmtmbG93KHJlc3VsdDogdW5rbm93bik6IHZvaWQge1xuICAgIHRoaXMucHVzaENvbW1hbmQoXG4gICAgICB7XG4gICAgICAgIGNvbXBsZXRlV29ya2Zsb3dFeGVjdXRpb246IHtcbiAgICAgICAgICByZXN1bHQ6IHRoaXMucGF5bG9hZENvbnZlcnRlci50b1BheWxvYWQocmVzdWx0KSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB0cnVlXG4gICAgKTtcbiAgfVxuXG4gIGVycm9yVG9GYWlsdXJlKGVycjogdW5rbm93bik6IFByb3RvRmFpbHVyZSB7XG4gICAgcmV0dXJuIHRoaXMuZmFpbHVyZUNvbnZlcnRlci5lcnJvclRvRmFpbHVyZShlcnIsIHRoaXMucGF5bG9hZENvbnZlcnRlcik7XG4gIH1cblxuICBmYWlsdXJlVG9FcnJvcihmYWlsdXJlOiBQcm90b0ZhaWx1cmUpOiBFcnJvciB7XG4gICAgcmV0dXJuIHRoaXMuZmFpbHVyZUNvbnZlcnRlci5mYWlsdXJlVG9FcnJvcihmYWlsdXJlLCB0aGlzLnBheWxvYWRDb252ZXJ0ZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNlcTxUIGV4dGVuZHMgeyBzZXE/OiBudW1iZXIgfCBudWxsIH0+KGFjdGl2YXRpb246IFQpOiBudW1iZXIge1xuICBjb25zdCBzZXEgPSBhY3RpdmF0aW9uLnNlcTtcbiAgaWYgKHNlcSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgR290IGFjdGl2YXRpb24gd2l0aCBubyBzZXEgYXR0cmlidXRlYCk7XG4gIH1cbiAgcmV0dXJuIHNlcTtcbn1cblxuZnVuY3Rpb24gbWFrZVVuZmluaXNoZWRVcGRhdGVIYW5kbGVyTWVzc2FnZShoYW5kbGVyRXhlY3V0aW9uczogTWVzc2FnZUhhbmRsZXJFeGVjdXRpb25bXSk6IHN0cmluZyB7XG4gIGNvbnN0IG1lc3NhZ2UgPSBgXG5bVE1QUkwxMTAyXSBXb3JrZmxvdyBmaW5pc2hlZCB3aGlsZSBhbiB1cGRhdGUgaGFuZGxlciB3YXMgc3RpbGwgcnVubmluZy4gVGhpcyBtYXkgaGF2ZSBpbnRlcnJ1cHRlZCB3b3JrIHRoYXQgdGhlXG51cGRhdGUgaGFuZGxlciB3YXMgZG9pbmcsIGFuZCB0aGUgY2xpZW50IHRoYXQgc2VudCB0aGUgdXBkYXRlIHdpbGwgcmVjZWl2ZSBhICd3b3JrZmxvdyBleGVjdXRpb25cbmFscmVhZHkgY29tcGxldGVkJyBSUENFcnJvciBpbnN0ZWFkIG9mIHRoZSB1cGRhdGUgcmVzdWx0LiBZb3UgY2FuIHdhaXQgZm9yIGFsbCB1cGRhdGUgYW5kIHNpZ25hbFxuaGFuZGxlcnMgdG8gY29tcGxldGUgYnkgdXNpbmcgXFxgYXdhaXQgd29ya2Zsb3cuY29uZGl0aW9uKHdvcmtmbG93LmFsbEhhbmRsZXJzRmluaXNoZWQpXFxgLlxuQWx0ZXJuYXRpdmVseSwgaWYgYm90aCB5b3UgYW5kIHRoZSBjbGllbnRzIHNlbmRpbmcgdGhlIHVwZGF0ZSBhcmUgb2theSB3aXRoIGludGVycnVwdGluZyBydW5uaW5nIGhhbmRsZXJzXG53aGVuIHRoZSB3b3JrZmxvdyBmaW5pc2hlcywgYW5kIGNhdXNpbmcgY2xpZW50cyB0byByZWNlaXZlIGVycm9ycywgdGhlbiB5b3UgY2FuIGRpc2FibGUgdGhpcyB3YXJuaW5nIGJ5XG5wYXNzaW5nIGFuIG9wdGlvbiB3aGVuIHNldHRpbmcgdGhlIGhhbmRsZXI6XG5cXGB3b3JrZmxvdy5zZXRIYW5kbGVyKG15VXBkYXRlLCBteVVwZGF0ZUhhbmRsZXIsIHt1bmZpbmlzaGVkUG9saWN5OiBIYW5kbGVyVW5maW5pc2hlZFBvbGljeS5BQkFORE9OfSk7XFxgLmBcbiAgICAucmVwbGFjZSgvXFxuL2csICcgJylcbiAgICAudHJpbSgpO1xuXG4gIHJldHVybiBgJHttZXNzYWdlfSBUaGUgZm9sbG93aW5nIHVwZGF0ZXMgd2VyZSB1bmZpbmlzaGVkIChhbmQgd2FybmluZ3Mgd2VyZSBub3QgZGlzYWJsZWQgZm9yIHRoZWlyIGhhbmRsZXIpOiAke0pTT04uc3RyaW5naWZ5KFxuICAgIGhhbmRsZXJFeGVjdXRpb25zLm1hcCgoZXgpID0+ICh7IG5hbWU6IGV4Lm5hbWUsIGlkOiBleC5pZCB9KSlcbiAgKX1gO1xufVxuXG5mdW5jdGlvbiBtYWtlVW5maW5pc2hlZFNpZ25hbEhhbmRsZXJNZXNzYWdlKGhhbmRsZXJFeGVjdXRpb25zOiBNZXNzYWdlSGFuZGxlckV4ZWN1dGlvbltdKTogc3RyaW5nIHtcbiAgY29uc3QgbWVzc2FnZSA9IGBcbltUTVBSTDExMDJdIFdvcmtmbG93IGZpbmlzaGVkIHdoaWxlIGEgc2lnbmFsIGhhbmRsZXIgd2FzIHN0aWxsIHJ1bm5pbmcuIFRoaXMgbWF5IGhhdmUgaW50ZXJydXB0ZWQgd29yayB0aGF0IHRoZVxuc2lnbmFsIGhhbmRsZXIgd2FzIGRvaW5nLiBZb3UgY2FuIHdhaXQgZm9yIGFsbCB1cGRhdGUgYW5kIHNpZ25hbCBoYW5kbGVycyB0byBjb21wbGV0ZSBieSB1c2luZ1xuXFxgYXdhaXQgd29ya2Zsb3cuY29uZGl0aW9uKHdvcmtmbG93LmFsbEhhbmRsZXJzRmluaXNoZWQpXFxgLiBBbHRlcm5hdGl2ZWx5LCBpZiBib3RoIHlvdSBhbmQgdGhlXG5jbGllbnRzIHNlbmRpbmcgdGhlIHVwZGF0ZSBhcmUgb2theSB3aXRoIGludGVycnVwdGluZyBydW5uaW5nIGhhbmRsZXJzIHdoZW4gdGhlIHdvcmtmbG93IGZpbmlzaGVzLFxudGhlbiB5b3UgY2FuIGRpc2FibGUgdGhpcyB3YXJuaW5nIGJ5IHBhc3NpbmcgYW4gb3B0aW9uIHdoZW4gc2V0dGluZyB0aGUgaGFuZGxlcjpcblxcYHdvcmtmbG93LnNldEhhbmRsZXIobXlTaWduYWwsIG15U2lnbmFsSGFuZGxlciwge3VuZmluaXNoZWRQb2xpY3k6IEhhbmRsZXJVbmZpbmlzaGVkUG9saWN5LkFCQU5ET059KTtcXGAuYFxuXG4gICAgLnJlcGxhY2UoL1xcbi9nLCAnICcpXG4gICAgLnRyaW0oKTtcblxuICBjb25zdCBuYW1lcyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG4gIGZvciAoY29uc3QgZXggb2YgaGFuZGxlckV4ZWN1dGlvbnMpIHtcbiAgICBjb25zdCBjb3VudCA9IG5hbWVzLmdldChleC5uYW1lKSB8fCAwO1xuICAgIG5hbWVzLnNldChleC5uYW1lLCBjb3VudCArIDEpO1xuICB9XG5cbiAgcmV0dXJuIGAke21lc3NhZ2V9IFRoZSBmb2xsb3dpbmcgc2lnbmFscyB3ZXJlIHVuZmluaXNoZWQgKGFuZCB3YXJuaW5ncyB3ZXJlIG5vdCBkaXNhYmxlZCBmb3IgdGhlaXIgaGFuZGxlcik6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgQXJyYXkuZnJvbShuYW1lcy5lbnRyaWVzKCkpLm1hcCgoW25hbWUsIGNvdW50XSkgPT4gKHsgbmFtZSwgY291bnQgfSkpXG4gICl9YDtcbn1cbiIsImltcG9ydCB7IGNvbXBvc2VJbnRlcmNlcHRvcnMgfSBmcm9tICdAdGVtcG9yYWxpby9jb21tb24vbGliL2ludGVyY2VwdG9ycyc7XG5pbXBvcnQgeyBTZGtDb21wb25lbnQgfSBmcm9tICdAdGVtcG9yYWxpby9jb21tb24nO1xuaW1wb3J0IHsgdW50cmFja1Byb21pc2UgfSBmcm9tICcuL3N0YWNrLWhlbHBlcnMnO1xuaW1wb3J0IHsgdHlwZSBTaW5rLCB0eXBlIFNpbmtzLCBwcm94eVNpbmtzIH0gZnJvbSAnLi9zaW5rcyc7XG5pbXBvcnQgeyBpc0NhbmNlbGxhdGlvbiB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IFdvcmtmbG93SW5mbywgQ29udGludWVBc05ldyB9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBhc3NlcnRJbldvcmtmbG93Q29udGV4dCB9IGZyb20gJy4vZ2xvYmFsLWF0dHJpYnV0ZXMnO1xuaW1wb3J0IHsgY3VycmVudFVwZGF0ZUluZm8sIGluV29ya2Zsb3dDb250ZXh0IH0gZnJvbSAnLi93b3JrZmxvdyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgV29ya2Zsb3dMb2dnZXIgZXh0ZW5kcyBTaW5rIHtcbiAgdHJhY2UobWVzc2FnZTogc3RyaW5nLCBhdHRycz86IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdm9pZDtcbiAgZGVidWcobWVzc2FnZTogc3RyaW5nLCBhdHRycz86IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdm9pZDtcbiAgaW5mbyhtZXNzYWdlOiBzdHJpbmcsIGF0dHJzPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiB2b2lkO1xuICB3YXJuKG1lc3NhZ2U6IHN0cmluZywgYXR0cnM/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHZvaWQ7XG4gIGVycm9yKG1lc3NhZ2U6IHN0cmluZywgYXR0cnM/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IHZvaWQ7XG59XG5cbi8qKlxuICogU2luayBpbnRlcmZhY2UgZm9yIGZvcndhcmRpbmcgbG9ncyBmcm9tIHRoZSBXb3JrZmxvdyBzYW5kYm94IHRvIHRoZSBXb3JrZXJcbiAqXG4gKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIExvZ2dlclNpbmtzIGRpcmVjdGx5LiBUbyBsb2cgZnJvbSBXb3JrZmxvdyBjb2RlLCB1c2UgdGhlIGBsb2dgIG9iamVjdFxuICogICAgICAgICAgICAgZXhwb3J0ZWQgYnkgdGhlIGBAdGVtcG9yYWxpby93b3JrZmxvd2AgcGFja2FnZS4gVG8gY2FwdHVyZSBsb2cgbWVzc2FnZXMgZW1pdHRlZFxuICogICAgICAgICAgICAgYnkgV29ya2Zsb3cgY29kZSwgc2V0IHRoZSB7QGxpbmsgUnVudGltZS5sb2dnZXJ9IHByb3BlcnR5LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIExvZ2dlclNpbmtzRGVwcmVjYXRlZCBleHRlbmRzIFNpbmtzIHtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgTG9nZ2VyU2lua3MgZGlyZWN0bHkuIFRvIGxvZyBmcm9tIFdvcmtmbG93IGNvZGUsIHVzZSB0aGUgYGxvZ2Agb2JqZWN0XG4gICAqICAgICAgICAgICAgIGV4cG9ydGVkIGJ5IHRoZSBgQHRlbXBvcmFsaW8vd29ya2Zsb3dgIHBhY2thZ2UuIFRvIGNhcHR1cmUgbG9nIG1lc3NhZ2VzIGVtaXR0ZWRcbiAgICogICAgICAgICAgICAgYnkgV29ya2Zsb3cgY29kZSwgc2V0IHRoZSB7QGxpbmsgUnVudGltZS5sb2dnZXJ9IHByb3BlcnR5LlxuICAgKi9cbiAgZGVmYXVsdFdvcmtlckxvZ2dlcjogV29ya2Zsb3dMb2dnZXI7XG59XG5cbi8qKlxuICogU2luayBpbnRlcmZhY2UgZm9yIGZvcndhcmRpbmcgbG9ncyBmcm9tIHRoZSBXb3JrZmxvdyBzYW5kYm94IHRvIHRoZSBXb3JrZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMb2dnZXJTaW5rc0ludGVybmFsIGV4dGVuZHMgU2lua3Mge1xuICBfX3RlbXBvcmFsX2xvZ2dlcjogV29ya2Zsb3dMb2dnZXI7XG59XG5cbmNvbnN0IGxvZ2dlclNpbmsgPSBwcm94eVNpbmtzPExvZ2dlclNpbmtzSW50ZXJuYWw+KCkuX190ZW1wb3JhbF9sb2dnZXI7XG5cbi8qKlxuICogU3ltYm9sIHVzZWQgYnkgdGhlIFNESyBsb2dnZXIgdG8gZXh0cmFjdCBhIHRpbWVzdGFtcCBmcm9tIGxvZyBhdHRyaWJ1dGVzLlxuICogQWxzbyBkZWZpbmVkIGluIGB3b3JrZXIvbG9nZ2VyLnRzYCAtIGludGVudGlvbmFsbHkgbm90IHNoYXJlZC5cbiAqL1xuY29uc3QgTG9nVGltZXN0YW1wID0gU3ltYm9sLmZvcignbG9nX3RpbWVzdGFtcCcpO1xuXG4vKipcbiAqIERlZmF1bHQgd29ya2Zsb3cgbG9nZ2VyLlxuICpcbiAqIFRoaXMgbG9nZ2VyIGlzIHJlcGxheS1hd2FyZSBhbmQgd2lsbCBvbWl0IGxvZyBtZXNzYWdlcyBvbiB3b3JrZmxvdyByZXBsYXkuIE1lc3NhZ2VzIGVtaXR0ZWQgYnkgdGhpcyBsb2dnZXIgYXJlXG4gKiBmdW5uZWxsZWQgdGhyb3VnaCBhIHNpbmsgdGhhdCBmb3J3YXJkcyB0aGVtIHRvIHRoZSBsb2dnZXIgcmVnaXN0ZXJlZCBvbiB7QGxpbmsgUnVudGltZS5sb2dnZXJ9LlxuICpcbiAqIEF0dHJpYnV0ZXMgZnJvbSB0aGUgY3VycmVudCBXb3JrZmxvdyBFeGVjdXRpb24gY29udGV4dCBhcmUgYXV0b21hdGljYWxseSBpbmNsdWRlZCBhcyBtZXRhZGF0YSBvbiBldmVyeSBsb2dcbiAqIGVudHJpZXMuIEFuIGV4dHJhIGBzZGtDb21wb25lbnRgIG1ldGFkYXRhIGF0dHJpYnV0ZSBpcyBhbHNvIGFkZGVkLCB3aXRoIHZhbHVlIGB3b3JrZmxvd2A7IHRoaXMgY2FuIGJlIHVzZWQgZm9yXG4gKiBmaW5lLWdyYWluZWQgZmlsdGVyaW5nIG9mIGxvZyBlbnRyaWVzIGZ1cnRoZXIgZG93bnN0cmVhbS5cbiAqXG4gKiBUbyBjdXN0b21pemUgbG9nIGF0dHJpYnV0ZXMsIHJlZ2lzdGVyIGEge0BsaW5rIFdvcmtmbG93T3V0Ym91bmRDYWxsc0ludGVyY2VwdG9yfSB0aGF0IGludGVyY2VwdHMgdGhlXG4gKiBgZ2V0TG9nQXR0cmlidXRlcygpYCBtZXRob2QuXG4gKlxuICogTm90aWNlIHRoYXQgc2luY2Ugc2lua3MgYXJlIHVzZWQgdG8gcG93ZXIgdGhpcyBsb2dnZXIsIGFueSBsb2cgYXR0cmlidXRlcyBtdXN0IGJlIHRyYW5zZmVyYWJsZSB2aWEgdGhlXG4gKiB7QGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS93b3JrZXJfdGhyZWFkcy5odG1sI3dvcmtlcl90aHJlYWRzX3BvcnRfcG9zdG1lc3NhZ2VfdmFsdWVfdHJhbnNmZXJsaXN0IHwgcG9zdE1lc3NhZ2V9XG4gKiBBUEkuXG4gKlxuICogTk9URTogU3BlY2lmeWluZyBhIGN1c3RvbSBsb2dnZXIgdGhyb3VnaCB7QGxpbmsgZGVmYXVsdFNpbmt9IG9yIGJ5IG1hbnVhbGx5IHJlZ2lzdGVyaW5nIGEgc2luayBuYW1lZFxuICogYGRlZmF1bHRXb3JrZXJMb2dnZXJgIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2Uge0BsaW5rIFJ1bnRpbWUubG9nZ2VyfSBpbnN0ZWFkLlxuICovXG5leHBvcnQgY29uc3QgbG9nOiBXb3JrZmxvd0xvZ2dlciA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgKFsndHJhY2UnLCAnZGVidWcnLCAnaW5mbycsICd3YXJuJywgJ2Vycm9yJ10gYXMgQXJyYXk8a2V5b2YgV29ya2Zsb3dMb2dnZXI+KS5tYXAoKGxldmVsKSA9PiB7XG4gICAgcmV0dXJuIFtcbiAgICAgIGxldmVsLFxuICAgICAgKG1lc3NhZ2U6IHN0cmluZywgYXR0cnM/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikgPT4ge1xuICAgICAgICBjb25zdCBhY3RpdmF0b3IgPSBhc3NlcnRJbldvcmtmbG93Q29udGV4dCgnV29ya2Zsb3cubG9nKC4uLikgbWF5IG9ubHkgYmUgdXNlZCBmcm9tIHdvcmtmbG93IGNvbnRleHQuJyk7XG4gICAgICAgIGNvbnN0IGdldExvZ0F0dHJpYnV0ZXMgPSBjb21wb3NlSW50ZXJjZXB0b3JzKGFjdGl2YXRvci5pbnRlcmNlcHRvcnMub3V0Ym91bmQsICdnZXRMb2dBdHRyaWJ1dGVzJywgKGEpID0+IGEpO1xuICAgICAgICByZXR1cm4gbG9nZ2VyU2lua1tsZXZlbF0obWVzc2FnZSwge1xuICAgICAgICAgIC8vIEluamVjdCB0aGUgY2FsbCB0aW1lIGluIG5hbm9zZWNvbmQgcmVzb2x1dGlvbiBhcyBleHBlY3RlZCBieSB0aGUgd29ya2VyIGxvZ2dlci5cbiAgICAgICAgICBbTG9nVGltZXN0YW1wXTogYWN0aXZhdG9yLmdldFRpbWVPZkRheSgpLFxuICAgICAgICAgIHNka0NvbXBvbmVudDogU2RrQ29tcG9uZW50LndvcmtmbG93LFxuICAgICAgICAgIC4uLmdldExvZ0F0dHJpYnV0ZXMod29ya2Zsb3dMb2dBdHRyaWJ1dGVzKGFjdGl2YXRvci5pbmZvKSksXG4gICAgICAgICAgLi4uYXR0cnMsXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICBdO1xuICB9KVxuKSBhcyBhbnk7XG5cbmV4cG9ydCBmdW5jdGlvbiBleGVjdXRlV2l0aExpZmVjeWNsZUxvZ2dpbmcoZm46ICgpID0+IFByb21pc2U8dW5rbm93bj4pOiBQcm9taXNlPHVua25vd24+IHtcbiAgbG9nLmRlYnVnKCdXb3JrZmxvdyBzdGFydGVkJywgeyBzZGtDb21wb25lbnQ6IFNka0NvbXBvbmVudC53b3JrZXIgfSk7XG4gIGNvbnN0IHAgPSBmbigpLnRoZW4oXG4gICAgKHJlcykgPT4ge1xuICAgICAgbG9nLmRlYnVnKCdXb3JrZmxvdyBjb21wbGV0ZWQnLCB7IHNka0NvbXBvbmVudDogU2RrQ29tcG9uZW50LndvcmtlciB9KTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICAoZXJyb3IpID0+IHtcbiAgICAgIC8vIEF2b2lkIHVzaW5nIGluc3RhbmNlb2YgY2hlY2tzIGluIGNhc2UgdGhlIG1vZHVsZXMgdGhleSdyZSBkZWZpbmVkIGluIGxvYWRlZCBtb3JlIHRoYW4gb25jZSxcbiAgICAgIC8vIGUuZy4gYnkgamVzdCBvciB3aGVuIG11bHRpcGxlIHZlcnNpb25zIGFyZSBpbnN0YWxsZWQuXG4gICAgICBpZiAodHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPSBudWxsKSB7XG4gICAgICAgIGlmIChpc0NhbmNlbGxhdGlvbihlcnJvcikpIHtcbiAgICAgICAgICBsb2cuZGVidWcoJ1dvcmtmbG93IGNvbXBsZXRlZCBhcyBjYW5jZWxsZWQnLCB7IHNka0NvbXBvbmVudDogU2RrQ29tcG9uZW50LndvcmtlciB9KTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIENvbnRpbnVlQXNOZXcpIHtcbiAgICAgICAgICBsb2cuZGVidWcoJ1dvcmtmbG93IGNvbnRpbnVlZCBhcyBuZXcnLCB7IHNka0NvbXBvbmVudDogU2RrQ29tcG9uZW50LndvcmtlciB9KTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbG9nLndhcm4oJ1dvcmtmbG93IGZhaWxlZCcsIHsgZXJyb3IsIHNka0NvbXBvbmVudDogU2RrQ29tcG9uZW50LndvcmtlciB9KTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgKTtcbiAgLy8gQXZvaWQgc2hvd2luZyB0aGlzIGludGVyY2VwdG9yIGluIHN0YWNrIHRyYWNlIHF1ZXJ5XG4gIHVudHJhY2tQcm9taXNlKHApO1xuICByZXR1cm4gcDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbWFwIG9mIGF0dHJpYnV0ZXMgdG8gYmUgc2V0IF9ieSBkZWZhdWx0XyBvbiBsb2cgbWVzc2FnZXMgZm9yIGEgZ2l2ZW4gV29ya2Zsb3cuXG4gKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGZyb20gb3V0c2lkZSBvZiB0aGUgV29ya2Zsb3cgY29udGV4dCAoZWcuIGJ5IHRoZSB3b3JrZXIgaXRzZWxmKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdvcmtmbG93TG9nQXR0cmlidXRlcyhpbmZvOiBXb3JrZmxvd0luZm8pOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB7XG4gIGNvbnN0IGF0dHJpYnV0ZXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gICAgbmFtZXNwYWNlOiBpbmZvLm5hbWVzcGFjZSxcbiAgICB0YXNrUXVldWU6IGluZm8udGFza1F1ZXVlLFxuICAgIHdvcmtmbG93SWQ6IGluZm8ud29ya2Zsb3dJZCxcbiAgICBydW5JZDogaW5mby5ydW5JZCxcbiAgICB3b3JrZmxvd1R5cGU6IGluZm8ud29ya2Zsb3dUeXBlLFxuICB9O1xuICBpZiAoaW5Xb3JrZmxvd0NvbnRleHQoKSkge1xuICAgIGNvbnN0IHVwZGF0ZUluZm8gPSBjdXJyZW50VXBkYXRlSW5mbygpO1xuICAgIGlmICh1cGRhdGVJbmZvKSB7XG4gICAgICAvLyBBZGQgdXBkYXRlIGluZm8gaWYgaXQgZXhpc3RzXG4gICAgICBhdHRyaWJ1dGVzWyd1cGRhdGVJZCddID0gdXBkYXRlSW5mby5pZDtcbiAgICAgIGF0dHJpYnV0ZXNbJ3VwZGF0ZU5hbWUnXSA9IHVwZGF0ZUluZm8ubmFtZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGF0dHJpYnV0ZXM7XG59XG4iLCJpbXBvcnQge1xuICBNZXRyaWNDb3VudGVyLFxuICBNZXRyaWNHYXVnZSxcbiAgTWV0cmljSGlzdG9ncmFtLFxuICBNZXRyaWNNZXRlcixcbiAgTWV0cmljTWV0ZXJXaXRoQ29tcG9zZWRUYWdzLFxuICBNZXRyaWNUYWdzLFxuICBOdW1lcmljTWV0cmljVmFsdWVUeXBlLFxufSBmcm9tICdAdGVtcG9yYWxpby9jb21tb24nO1xuaW1wb3J0IHsgY29tcG9zZUludGVyY2VwdG9ycyB9IGZyb20gJ0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvaW50ZXJjZXB0b3JzJztcbmltcG9ydCB7IHByb3h5U2lua3MsIFNpbmssIFNpbmtzIH0gZnJvbSAnLi9zaW5rcyc7XG5pbXBvcnQgeyB3b3JrZmxvd0luZm8gfSBmcm9tICcuL3dvcmtmbG93JztcbmltcG9ydCB7IGFzc2VydEluV29ya2Zsb3dDb250ZXh0IH0gZnJvbSAnLi9nbG9iYWwtYXR0cmlidXRlcyc7XG5cbmNsYXNzIFdvcmtmbG93TWV0cmljTWV0ZXJJbXBsIGltcGxlbWVudHMgTWV0cmljTWV0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgY3JlYXRlQ291bnRlcihuYW1lOiBzdHJpbmcsIHVuaXQ/OiBzdHJpbmcsIGRlc2NyaXB0aW9uPzogc3RyaW5nKTogTWV0cmljQ291bnRlciB7XG4gICAgYXNzZXJ0SW5Xb3JrZmxvd0NvbnRleHQoXCJXb3JrZmxvdydzIGBtZXRyaWNNZXRlcmAgY2FuIG9ubHkgYmUgdXNlZCB3aGlsZSBpbiBXb3JrZmxvdyBDb250ZXh0XCIpO1xuICAgIHJldHVybiBuZXcgV29ya2Zsb3dNZXRyaWNDb3VudGVyKG5hbWUsIHVuaXQsIGRlc2NyaXB0aW9uKTtcbiAgfVxuXG4gIGNyZWF0ZUhpc3RvZ3JhbShcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgdmFsdWVUeXBlOiBOdW1lcmljTWV0cmljVmFsdWVUeXBlID0gJ2ludCcsXG4gICAgdW5pdD86IHN0cmluZyxcbiAgICBkZXNjcmlwdGlvbj86IHN0cmluZ1xuICApOiBNZXRyaWNIaXN0b2dyYW0ge1xuICAgIGFzc2VydEluV29ya2Zsb3dDb250ZXh0KFwiV29ya2Zsb3cncyBgbWV0cmljTWV0ZXJgIGNhbiBvbmx5IGJlIHVzZWQgd2hpbGUgaW4gV29ya2Zsb3cgQ29udGV4dFwiKTtcbiAgICByZXR1cm4gbmV3IFdvcmtmbG93TWV0cmljSGlzdG9ncmFtKG5hbWUsIHZhbHVlVHlwZSwgdW5pdCwgZGVzY3JpcHRpb24pO1xuICB9XG5cbiAgY3JlYXRlR2F1Z2UoXG4gICAgbmFtZTogc3RyaW5nLFxuICAgIHZhbHVlVHlwZTogTnVtZXJpY01ldHJpY1ZhbHVlVHlwZSA9ICdpbnQnLFxuICAgIHVuaXQ/OiBzdHJpbmcsXG4gICAgZGVzY3JpcHRpb24/OiBzdHJpbmdcbiAgKTogTWV0cmljR2F1Z2Uge1xuICAgIGFzc2VydEluV29ya2Zsb3dDb250ZXh0KFwiV29ya2Zsb3cncyBgbWV0cmljTWV0ZXJgIGNhbiBvbmx5IGJlIHVzZWQgd2hpbGUgaW4gV29ya2Zsb3cgQ29udGV4dFwiKTtcbiAgICByZXR1cm4gbmV3IFdvcmtmbG93TWV0cmljR2F1Z2UobmFtZSwgdmFsdWVUeXBlLCB1bml0LCBkZXNjcmlwdGlvbik7XG4gIH1cblxuICB3aXRoVGFncyhfdGFnczogTWV0cmljVGFncyk6IE1ldHJpY01ldGVyIHtcbiAgICBhc3NlcnRJbldvcmtmbG93Q29udGV4dChcIldvcmtmbG93J3MgYG1ldHJpY01ldGVyYCBjYW4gb25seSBiZSB1c2VkIHdoaWxlIGluIFdvcmtmbG93IENvbnRleHRcIik7XG4gICAgLy8gVGFncyBjb21wb3NpdGlvbiBpcyBoYW5kbGVkIGJ5IGEgTWV0cmljTWV0ZXJXaXRoQ29tcG9zZWRUYWdzIHdyYXBwZXIgb3ZlciB0aGlzIG9uZVxuICAgIHRocm93IG5ldyBFcnJvcihgd2l0aFRhZ3MgaXMgbm90IHN1cHBvcnRlZCBkaXJlY3RseSBvbiBXb3JrZmxvd01ldHJpY01ldGVyYCk7XG4gIH1cbn1cblxuY2xhc3MgV29ya2Zsb3dNZXRyaWNDb3VudGVyIGltcGxlbWVudHMgTWV0cmljQ291bnRlciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyByZWFkb25seSBuYW1lOiBzdHJpbmcsXG4gICAgcHVibGljIHJlYWRvbmx5IHVuaXQ6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBwdWJsaWMgcmVhZG9ubHkgZGVzY3JpcHRpb246IHN0cmluZyB8IHVuZGVmaW5lZFxuICApIHt9XG5cbiAgYWRkKHZhbHVlOiBudW1iZXIsIGV4dHJhVGFnczogTWV0cmljVGFncyA9IHt9KTogdm9pZCB7XG4gICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZXRyaWNDb3VudGVyIHZhbHVlIG11c3QgYmUgbm9uLW5lZ2F0aXZlIChnb3QgJHt2YWx1ZX0pYCk7XG4gICAgfVxuICAgIGlmICghd29ya2Zsb3dJbmZvKCkudW5zYWZlLmlzUmVwbGF5aW5nKSB7XG4gICAgICBtZXRyaWNTaW5rLmFkZE1ldHJpY0NvdW50ZXJWYWx1ZSh0aGlzLm5hbWUsIHRoaXMudW5pdCwgdGhpcy5kZXNjcmlwdGlvbiwgdmFsdWUsIGV4dHJhVGFncyk7XG4gICAgfVxuICB9XG5cbiAgd2l0aFRhZ3MoX3RhZ3M6IE1ldHJpY1RhZ3MpOiBNZXRyaWNDb3VudGVyIHtcbiAgICAvLyBUYWdzIGNvbXBvc2l0aW9uIGlzIGhhbmRsZWQgYnkgYSBNZXRyaWNNZXRlcldpdGhDb21wb3NlZFRhZ3Mgd3JhcHBlciBvdmVyIHRoaXMgb25lXG4gICAgdGhyb3cgbmV3IEVycm9yKGB3aXRoVGFncyBpcyBub3Qgc3VwcG9ydGVkIGRpcmVjdGx5IG9uIFdvcmtmbG93TWV0cmljQ291bnRlcmApO1xuICB9XG59XG5cbmNsYXNzIFdvcmtmbG93TWV0cmljSGlzdG9ncmFtIGltcGxlbWVudHMgTWV0cmljSGlzdG9ncmFtIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHJlYWRvbmx5IG5hbWU6IHN0cmluZyxcbiAgICBwdWJsaWMgcmVhZG9ubHkgdmFsdWVUeXBlOiBOdW1lcmljTWV0cmljVmFsdWVUeXBlLFxuICAgIHB1YmxpYyByZWFkb25seSB1bml0OiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgcHVibGljIHJlYWRvbmx5IGRlc2NyaXB0aW9uOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgKSB7fVxuXG4gIHJlY29yZCh2YWx1ZTogbnVtYmVyLCBleHRyYVRhZ3M6IE1ldHJpY1RhZ3MgPSB7fSk6IHZvaWQge1xuICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWV0cmljSGlzdG9ncmFtIHZhbHVlIG11c3QgYmUgbm9uLW5lZ2F0aXZlIChnb3QgJHt2YWx1ZX0pYCk7XG4gICAgfVxuICAgIGlmICghd29ya2Zsb3dJbmZvKCkudW5zYWZlLmlzUmVwbGF5aW5nKSB7XG4gICAgICBtZXRyaWNTaW5rLnJlY29yZE1ldHJpY0hpc3RvZ3JhbVZhbHVlKHRoaXMubmFtZSwgdGhpcy52YWx1ZVR5cGUsIHRoaXMudW5pdCwgdGhpcy5kZXNjcmlwdGlvbiwgdmFsdWUsIGV4dHJhVGFncyk7XG4gICAgfVxuICB9XG5cbiAgd2l0aFRhZ3MoX3RhZ3M6IE1ldHJpY1RhZ3MpOiBNZXRyaWNIaXN0b2dyYW0ge1xuICAgIC8vIFRhZ3MgY29tcG9zaXRpb24gaXMgaGFuZGxlZCBieSBhIE1ldHJpY01ldGVyV2l0aENvbXBvc2VkVGFncyB3cmFwcGVyIG92ZXIgdGhpcyBvbmVcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHdpdGhUYWdzIGlzIG5vdCBzdXBwb3J0ZWQgZGlyZWN0bHkgb24gV29ya2Zsb3dNZXRyaWNIaXN0b2dyYW1gKTtcbiAgfVxufVxuXG5jbGFzcyBXb3JrZmxvd01ldHJpY0dhdWdlIGltcGxlbWVudHMgTWV0cmljR2F1Z2Uge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgcmVhZG9ubHkgbmFtZTogc3RyaW5nLFxuICAgIHB1YmxpYyByZWFkb25seSB2YWx1ZVR5cGU6IE51bWVyaWNNZXRyaWNWYWx1ZVR5cGUsXG4gICAgcHVibGljIHJlYWRvbmx5IHVuaXQ6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBwdWJsaWMgcmVhZG9ubHkgZGVzY3JpcHRpb246IHN0cmluZyB8IHVuZGVmaW5lZFxuICApIHt9XG5cbiAgc2V0KHZhbHVlOiBudW1iZXIsIHRhZ3M/OiBNZXRyaWNUYWdzKTogdm9pZCB7XG4gICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZXRyaWNHYXVnZSB2YWx1ZSBtdXN0IGJlIG5vbi1uZWdhdGl2ZSAoZ290ICR7dmFsdWV9KWApO1xuICAgIH1cbiAgICBpZiAoIXdvcmtmbG93SW5mbygpLnVuc2FmZS5pc1JlcGxheWluZykge1xuICAgICAgbWV0cmljU2luay5zZXRNZXRyaWNHYXVnZVZhbHVlKHRoaXMubmFtZSwgdGhpcy52YWx1ZVR5cGUsIHRoaXMudW5pdCwgdGhpcy5kZXNjcmlwdGlvbiwgdmFsdWUsIHRhZ3MgPz8ge30pO1xuICAgIH1cbiAgfVxuXG4gIHdpdGhUYWdzKF90YWdzOiBNZXRyaWNUYWdzKTogTWV0cmljR2F1Z2Uge1xuICAgIC8vIFRhZ3MgY29tcG9zaXRpb24gaXMgaGFuZGxlZCBieSBhIE1ldHJpY01ldGVyV2l0aENvbXBvc2VkVGFncyB3cmFwcGVyIG92ZXIgdGhpcyBvbmVcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHdpdGhUYWdzIGlzIG5vdCBzdXBwb3J0ZWQgZGlyZWN0bHkgb24gV29ya2Zsb3dNZXRyaWNHYXVnZWApO1xuICB9XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8gTm90ZTogZ2l2ZW4gdGhhdCBmb3J3YXJkaW5nIG1ldHJpY3Mgb3V0c2lkZSBvZiB0aGUgc2FuYm94IGNhbiBiZSBxdWl0ZSBjaGF0dHkgYW5kIGFkZCBub25cbi8vIG5lZ2xpZ2VhYmxlIG92ZXJoZWFkLCB3ZSBlYWdlcmx5IGNoZWNrIGZvciBgaXNSZXBsYXlpbmdgIGFuZCBjb21wbGV0ZWx5IHNraXAgZG9pbmcgc2lua1xuLy8gY2FsbHMgaWYgd2UgYXJlIHJlcGxheWluZy5cbmNvbnN0IG1ldHJpY1NpbmsgPSBwcm94eVNpbmtzPE1ldHJpY1NpbmtzPigpLl9fdGVtcG9yYWxfbWV0cmljcztcblxuLyoqXG4gKiBTaW5rIGludGVyZmFjZSBmb3IgZm9yd2FyZGluZyBtZXRyaWNzIGZyb20gdGhlIFdvcmtmbG93IHNhbmRib3ggdG8gdGhlIFdvcmtlci5cbiAqXG4gKiBUaGVzZSBzaW5rIGZ1bmN0aW9ucyBhcmUgbm90IGludGVuZGVkIHRvIGJlIGNhbGxlZCBkaXJlY3RseSBmcm9tIHdvcmtmbG93IGNvZGU7IGluc3RlYWQsXG4gKiBkZXZlbG9wZXJzIHNob3VsZCB1c2UgdGhlIGBtZXRyaWNNZXRlcmAgb2JqZWN0IGV4cG9zZWQgdG8gd29ya2Zsb3cgY29kZSBieSB0aGUgU0RLLCB3aGljaFxuICogcHJvdmlkZXMgYW4gQVBJIHRoYXQgaXMgZWFzaWVyIHRvIHdvcmsgd2l0aC5cbiAqXG4gKiBUaGlzIHNpbmsgaW50ZXJmYWNlIGlzIGFsc28gbm90IG1lYW50IHRvIGJlIGltcGxlbWVudGVkIGJ5IHVzZXIuXG4gKlxuICogQGhpZGRlblxuICogQGludGVybmFsIFVzZXJzIHNob3VsZCBub3QgaW1wbGVtZW50IHRoaXMgaW50ZXJmYWNlLCBub3IgdXNlIGl0IGRpcmVjdGx5LiBVc2UgYG1ldHJpY01ldGVyYCBpbnN0ZWFkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1ldHJpY1NpbmtzIGV4dGVuZHMgU2lua3Mge1xuICBfX3RlbXBvcmFsX21ldHJpY3M6IFdvcmtmbG93TWV0cmljTWV0ZXI7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICogQGludGVybmFsIFVzZXJzIHNob3VsZCBub3QgaW1wbGVtZW50IHRoaXMgaW50ZXJmYWNlLCBub3IgdXNlIGl0IGRpcmVjdGx5LiBVc2UgYG1ldHJpY01ldGVyYCBpbnN0ZWFkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtmbG93TWV0cmljTWV0ZXIgZXh0ZW5kcyBTaW5rIHtcbiAgYWRkTWV0cmljQ291bnRlclZhbHVlKFxuICAgIG1ldHJpY05hbWU6IHN0cmluZyxcbiAgICB1bml0OiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgZGVzY3JpcHRpb246IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICB2YWx1ZTogbnVtYmVyLFxuICAgIGF0dHJzOiBNZXRyaWNUYWdzXG4gICk6IHZvaWQ7XG5cbiAgcmVjb3JkTWV0cmljSGlzdG9ncmFtVmFsdWUoXG4gICAgbWV0cmljTmFtZTogc3RyaW5nLFxuICAgIHZhbHVlVHlwZTogTnVtZXJpY01ldHJpY1ZhbHVlVHlwZSxcbiAgICB1bml0OiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgZGVzY3JpcHRpb246IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICB2YWx1ZTogbnVtYmVyLFxuICAgIGF0dHJzOiBNZXRyaWNUYWdzXG4gICk6IHZvaWQ7XG5cbiAgc2V0TWV0cmljR2F1Z2VWYWx1ZShcbiAgICBtZXRyaWNOYW1lOiBzdHJpbmcsXG4gICAgdmFsdWVUeXBlOiBOdW1lcmljTWV0cmljVmFsdWVUeXBlLFxuICAgIHVuaXQ6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIHZhbHVlOiBudW1iZXIsXG4gICAgYXR0cnM6IE1ldHJpY1RhZ3NcbiAgKTogdm9pZDtcbn1cblxuLyoqXG4gKiBBIE1ldHJpY01ldGVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gZW1pdCBtZXRyaWNzIGZyb20gd2l0aGluIGEgV29ya2Zsb3cuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGUgTWV0cmljIEFQSSBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSBhbmQgbWF5IGJlIHN1YmplY3QgdG8gY2hhbmdlLlxuICovXG5leHBvcnQgY29uc3QgbWV0cmljTWV0ZXI6IE1ldHJpY01ldGVyID0gTWV0cmljTWV0ZXJXaXRoQ29tcG9zZWRUYWdzLmNvbXBvc2UoXG4gIG5ldyBXb3JrZmxvd01ldHJpY01ldGVySW1wbCgpLFxuICAoKSA9PiB7XG4gICAgY29uc3QgYWN0aXZhdG9yID0gYXNzZXJ0SW5Xb3JrZmxvd0NvbnRleHQoJ1dvcmtmbG93Lm1ldHJpY01ldGVyIG1heSBvbmx5IGJlIHVzZWQgZnJvbSB3b3JrZmxvdyBjb250ZXh0LicpO1xuICAgIGNvbnN0IGdldE1ldHJpY1RhZ3MgPSBjb21wb3NlSW50ZXJjZXB0b3JzKGFjdGl2YXRvci5pbnRlcmNlcHRvcnMub3V0Ym91bmQsICdnZXRNZXRyaWNUYWdzJywgKGEpID0+IGEpO1xuXG4gICAgY29uc3QgaW5mbyA9IGFjdGl2YXRvci5pbmZvO1xuICAgIHJldHVybiBnZXRNZXRyaWNUYWdzKHtcbiAgICAgIC8vIG5hbWVzcGFjZSBhbmQgdGFza1F1ZXVlIHdpbGwgYmUgYWRkZWQgYnkgdGhlIFdvcmtlclxuICAgICAgd29ya2Zsb3dUeXBlOiBpbmZvLndvcmtmbG93VHlwZSxcbiAgICB9KTtcbiAgfSxcbiAgdHJ1ZVxuKTtcbiIsImltcG9ydCAqIGFzIG5leHVzIGZyb20gJ25leHVzLXJwYyc7XG5pbXBvcnQgeyBtc09wdGlvbmFsVG9UcyB9IGZyb20gJ0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvdGltZSc7XG5pbXBvcnQgeyB1c2VyTWV0YWRhdGFUb1BheWxvYWQgfSBmcm9tICdAdGVtcG9yYWxpby9jb21tb24vbGliL3VzZXItbWV0YWRhdGEnO1xuaW1wb3J0IHsgY29tcG9zZUludGVyY2VwdG9ycyB9IGZyb20gJ0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvaW50ZXJjZXB0b3JzJztcbmltcG9ydCB7IENhbmNlbGxhdGlvblNjb3BlIH0gZnJvbSAnLi9jYW5jZWxsYXRpb24tc2NvcGUnO1xuaW1wb3J0IHsgZ2V0QWN0aXZhdG9yIH0gZnJvbSAnLi9nbG9iYWwtYXR0cmlidXRlcyc7XG5pbXBvcnQgeyB1bnRyYWNrUHJvbWlzZSB9IGZyb20gJy4vc3RhY2staGVscGVycyc7XG5pbXBvcnQgeyBTdGFydE5leHVzT3BlcmF0aW9uSW5wdXQsIFN0YXJ0TmV4dXNPcGVyYXRpb25PdXRwdXQsIFN0YXJ0TmV4dXNPcGVyYXRpb25PcHRpb25zIH0gZnJvbSAnLi9pbnRlcmNlcHRvcnMnO1xuXG4vKipcbiAqIEEgTmV4dXMgY2xpZW50IGZvciBpbnZva2luZyBOZXh1cyBPcGVyYXRpb25zIGZvciBhIHNwZWNpZmljIHNlcnZpY2UgZnJvbSBhIFdvcmtmbG93LlxuICpcbiAqIEBleHBlcmltZW50YWwgTmV4dXMgc3VwcG9ydCBpbiBUZW1wb3JhbCBTREsgaXMgZXhwZXJpbWVudGFsLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5leHVzQ2xpZW50PFQgZXh0ZW5kcyBuZXh1cy5TZXJ2aWNlRGVmaW5pdGlvbj4ge1xuICAvKipcbiAgICogU3RhcnQgYSBOZXh1cyBPcGVyYXRpb24gYW5kIHdhaXQgZm9yIGl0cyBjb21wbGV0aW9uIHRha2luZyBhIHtAbGluayBuZXh1cy5vcGVyYXRpb259LlxuICAgKiBSZXR1cm5zIHRoZSBvcGVyYXRpb24ncyByZXN1bHQuXG4gICAqXG4gICAqIEBleHBlcmltZW50YWwgTmV4dXMgc3VwcG9ydCBpbiBUZW1wb3JhbCBTREsgaXMgZXhwZXJpbWVudGFsLlxuICAgKi9cbiAgZXhlY3V0ZU9wZXJhdGlvbjxPIGV4dGVuZHMgVFsnb3BlcmF0aW9ucyddW2tleW9mIFRbJ29wZXJhdGlvbnMnXV0+KFxuICAgIG9wOiBPLFxuICAgIGlucHV0OiBuZXh1cy5PcGVyYXRpb25JbnB1dDxPPixcbiAgICBvcHRpb25zPzogUGFydGlhbDxTdGFydE5leHVzT3BlcmF0aW9uT3B0aW9ucz5cbiAgKTogUHJvbWlzZTxuZXh1cy5PcGVyYXRpb25PdXRwdXQ8Tz4+O1xuXG4gIC8vIFRPRE8obmV4dXMvcG9zdC1pbml0aWFsLXJlbGVhc2UpOiBSZXZpc2l0IHRoZSBcIk9wZXJhdGlvbiBQcm9wZXJ0eSBOYW1lXCIgdGVybWlub2xvZ3ksXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmQgcmVmbGVjdCBpbiB0aGUgTmV4dXMgUlBDIFNESy5cblxuICAvKipcbiAgICogU3RhcnQgYSBOZXh1cyBPcGVyYXRpb24gYW5kIHdhaXQgZm9yIGl0cyBjb21wbGV0aW9uLCB0YWtpbmcgYW4gT3BlcmF0aW9uJ3MgX3Byb3BlcnR5IG5hbWVfLlxuICAgKiBSZXR1cm5zIHRoZSBvcGVyYXRpb24ncyByZXN1bHQuXG4gICAqXG4gICAqIEFuIE9wZXJhdGlvbidzIF9wcm9wZXJ0eSBuYW1lXyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdXNlZCB0byBkZWZpbmUgdGhhdCBPcGVyYXRpb24gaW5cbiAgICogdGhlIHtAbGluayBuZXh1cy5TZXJ2aWNlRGVmaW5pdGlvbn0gb2JqZWN0OyBpdCBtYXkgZGlmZmVyIGZyb20gdGhlIHZhbHVlIG9mIHRoZSBgbmFtZWAgcHJvcGVydHlcbiAgICogaWYgb25lIHdhcyBleHBsaWNpdGx5IHNwZWNpZmllZCBvbiB0aGUge0BsaW5rIG5leHVzLk9wZXJhdGlvbkRlZmluaXRpb259IG9iamVjdC5cbiAgICpcbiAgICogQGV4cGVyaW1lbnRhbCBOZXh1cyBzdXBwb3J0IGluIFRlbXBvcmFsIFNESyBpcyBleHBlcmltZW50YWwuXG4gICAqL1xuICBleGVjdXRlT3BlcmF0aW9uPEsgZXh0ZW5kcyBuZXh1cy5PcGVyYXRpb25LZXk8VFsnb3BlcmF0aW9ucyddPj4oXG4gICAgb3A6IEssXG4gICAgaW5wdXQ6IG5leHVzLk9wZXJhdGlvbklucHV0PFRbJ29wZXJhdGlvbnMnXVtLXT4sXG4gICAgb3B0aW9ucz86IFBhcnRpYWw8U3RhcnROZXh1c09wZXJhdGlvbk9wdGlvbnM+XG4gICk6IFByb21pc2U8bmV4dXMuT3BlcmF0aW9uT3V0cHV0PFRbJ29wZXJhdGlvbnMnXVtLXT4+O1xuXG4gIC8qKlxuICAgKiBTdGFydCBhIE5leHVzIE9wZXJhdGlvbiB0YWtpbmcgYSB7QGxpbmsgbmV4dXMub3BlcmF0aW9ufS5cbiAgICpcbiAgICogUmV0dXJucyBhIGhhbmRsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHdhaXQgZm9yIHRoZSBPcGVyYXRpb24ncyByZXN1bHQuXG4gICAqXG4gICAqIEBleHBlcmltZW50YWwgTmV4dXMgc3VwcG9ydCBpbiBUZW1wb3JhbCBTREsgaXMgZXhwZXJpbWVudGFsLlxuICAgKi9cbiAgc3RhcnRPcGVyYXRpb248TyBleHRlbmRzIFRbJ29wZXJhdGlvbnMnXVtrZXlvZiBUWydvcGVyYXRpb25zJ11dPihcbiAgICBvcDogTyxcbiAgICBpbnB1dDogbmV4dXMuT3BlcmF0aW9uSW5wdXQ8Tz4sXG4gICAgb3B0aW9ucz86IFBhcnRpYWw8U3RhcnROZXh1c09wZXJhdGlvbk9wdGlvbnM+XG4gICk6IFByb21pc2U8TmV4dXNPcGVyYXRpb25IYW5kbGU8bmV4dXMuT3BlcmF0aW9uT3V0cHV0PE8+Pj47XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGEgTmV4dXMgT3BlcmF0aW9uLCB0YWtpbmcgYW4gT3BlcmF0aW9uJ3MgX3Byb3BlcnR5IG5hbWVfLlxuICAgKiBSZXR1cm5zIGEgaGFuZGxlIHRoYXQgY2FuIGJlIHVzZWQgdG8gd2FpdCBmb3IgdGhlIE9wZXJhdGlvbidzIHJlc3VsdC5cbiAgICpcbiAgICogQW4gT3BlcmF0aW9uJ3MgX3Byb3BlcnR5IG5hbWVfIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB1c2VkIHRvIGRlZmluZSB0aGF0IE9wZXJhdGlvbiBpblxuICAgKiB0aGUge0BsaW5rIG5leHVzLlNlcnZpY2VEZWZpbml0aW9ufSBvYmplY3Q7IGl0IG1heSBkaWZmZXIgZnJvbSB0aGUgdmFsdWUgb2YgdGhlIGBuYW1lYCBwcm9wZXJ0eVxuICAgKiBpZiBvbmUgd2FzIGV4cGxpY2l0bHkgc3BlY2lmaWVkIG9uIHRoZSB7QGxpbmsgbmV4dXMuT3BlcmF0aW9uRGVmaW5pdGlvbn0gb2JqZWN0LlxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsIE5leHVzIHN1cHBvcnQgaW4gVGVtcG9yYWwgU0RLIGlzIGV4cGVyaW1lbnRhbC5cbiAgICovXG4gIHN0YXJ0T3BlcmF0aW9uPEsgZXh0ZW5kcyBuZXh1cy5PcGVyYXRpb25LZXk8VFsnb3BlcmF0aW9ucyddPj4oXG4gICAgb3A6IEssXG4gICAgaW5wdXQ6IG5leHVzLk9wZXJhdGlvbklucHV0PFRbJ29wZXJhdGlvbnMnXVtLXT4sXG4gICAgb3B0aW9ucz86IFBhcnRpYWw8U3RhcnROZXh1c09wZXJhdGlvbk9wdGlvbnM+XG4gICk6IFByb21pc2U8TmV4dXNPcGVyYXRpb25IYW5kbGU8bmV4dXMuT3BlcmF0aW9uT3V0cHV0PFRbJ29wZXJhdGlvbnMnXVtLXT4+Pjtcbn1cblxuLyoqXG4gKiBBIGhhbmRsZSB0byBhIE5leHVzIE9wZXJhdGlvbi5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIE5leHVzIHN1cHBvcnQgaW4gVGVtcG9yYWwgU0RLIGlzIGV4cGVyaW1lbnRhbC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXh1c09wZXJhdGlvbkhhbmRsZTxUPiB7XG4gIC8qKlxuICAgKiBUaGUgT3BlcmF0aW9uJ3Mgc2VydmljZSBuYW1lLlxuICAgKi9cbiAgcmVhZG9ubHkgc2VydmljZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgT3BlcmF0aW9uLlxuICAgKi9cbiAgcmVhZG9ubHkgb3BlcmF0aW9uOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE9wZXJhdGlvbiB0b2tlbiBhcyBzZXQgYnkgdGhlIE9wZXJhdGlvbidzIGhhbmRsZXIuIE1heSBiZSBlbXB0eSBpZiB0aGUgT3BlcmF0aW9uIGNvbXBsZXRlZCBzeW5jaHJvbm91c2x5LlxuICAgKi9cbiAgcmVhZG9ubHkgdG9rZW4/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdhaXQgZm9yIE9wZXJhdGlvbiBjb21wbGV0aW9uIGFuZCBnZXQgaXRzIHJlc3VsdC5cbiAgICovXG4gIHJlc3VsdCgpOiBQcm9taXNlPFQ+O1xufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHtAbGluayBjcmVhdGVOZXh1c0NsaWVudH0uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV4dXNDbGllbnRPcHRpb25zPFQ+IHtcbiAgZW5kcG9pbnQ6IHN0cmluZztcbiAgc2VydmljZTogVDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBOZXh1cyBjbGllbnQgZm9yIGludm9raW5nIE5leHVzIE9wZXJhdGlvbnMgZnJvbSBhIFdvcmtmbG93LlxuICpcbiAqIEBleHBlcmltZW50YWwgTmV4dXMgc3VwcG9ydCBpbiBUZW1wb3JhbCBTREsgaXMgZXhwZXJpbWVudGFsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTmV4dXNDbGllbnQ8VCBleHRlbmRzIG5leHVzLlNlcnZpY2VEZWZpbml0aW9uPihvcHRpb25zOiBOZXh1c0NsaWVudE9wdGlvbnM8VD4pOiBOZXh1c0NsaWVudDxUPiB7XG4gIGNsYXNzIE5leHVzQ2xpZW50SW1wbDxUIGV4dGVuZHMgbmV4dXMuU2VydmljZURlZmluaXRpb24+IGltcGxlbWVudHMgTmV4dXNDbGllbnQ8VD4ge1xuICAgIGFzeW5jIGV4ZWN1dGVPcGVyYXRpb248TyBleHRlbmRzIFRbJ29wZXJhdGlvbnMnXVtrZXlvZiBUWydvcGVyYXRpb25zJ11dPihcbiAgICAgIG9wZXJhdGlvbjogc3RyaW5nIHwgVFsnb3BlcmF0aW9ucyddW25leHVzLk9wZXJhdGlvbktleTxUWydvcGVyYXRpb25zJ10+XSxcbiAgICAgIGlucHV0OiBuZXh1cy5PcGVyYXRpb25JbnB1dDxUWydvcGVyYXRpb25zJ11bbmV4dXMuT3BlcmF0aW9uS2V5PFRbJ29wZXJhdGlvbnMnXT5dPixcbiAgICAgIG9wZXJhdGlvbk9wdGlvbnM/OiBQYXJ0aWFsPFN0YXJ0TmV4dXNPcGVyYXRpb25PcHRpb25zPlxuICAgICk6IFByb21pc2U8bmV4dXMuT3BlcmF0aW9uT3V0cHV0PE8+PiB7XG4gICAgICBjb25zdCBoYW5kbGUgPSBhd2FpdCB0aGlzLnN0YXJ0T3BlcmF0aW9uKG9wZXJhdGlvbiwgaW5wdXQsIG9wZXJhdGlvbk9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGF3YWl0IGhhbmRsZS5yZXN1bHQoKTtcbiAgICB9XG5cbiAgICBhc3luYyBzdGFydE9wZXJhdGlvbjxPIGV4dGVuZHMgVFsnb3BlcmF0aW9ucyddW2tleW9mIFRbJ29wZXJhdGlvbnMnXV0+KFxuICAgICAgb3BlcmF0aW9uOiBzdHJpbmcgfCBUWydvcGVyYXRpb25zJ11bbmV4dXMuT3BlcmF0aW9uS2V5PFRbJ29wZXJhdGlvbnMnXT5dLFxuICAgICAgaW5wdXQ6IG5leHVzLk9wZXJhdGlvbklucHV0PFRbJ29wZXJhdGlvbnMnXVtuZXh1cy5PcGVyYXRpb25LZXk8VFsnb3BlcmF0aW9ucyddPl0+LFxuICAgICAgb3BlcmF0aW9uT3B0aW9ucz86IFN0YXJ0TmV4dXNPcGVyYXRpb25PcHRpb25zXG4gICAgKSB7XG4gICAgICBjb25zdCBvcE5hbWUgPSB0eXBlb2Ygb3BlcmF0aW9uID09PSAnc3RyaW5nJyA/IG9wdGlvbnMuc2VydmljZS5vcGVyYXRpb25zW29wZXJhdGlvbl0/Lm5hbWUgOiBvcGVyYXRpb24ubmFtZTtcblxuICAgICAgY29uc3QgYWN0aXZhdG9yID0gZ2V0QWN0aXZhdG9yKCk7XG4gICAgICBjb25zdCBzZXEgPSBhY3RpdmF0b3IubmV4dFNlcXMubmV4dXNPcGVyYXRpb24rKztcblxuICAgICAgY29uc3QgZXhlY3V0ZSA9IGNvbXBvc2VJbnRlcmNlcHRvcnMoXG4gICAgICAgIGFjdGl2YXRvci5pbnRlcmNlcHRvcnMub3V0Ym91bmQsXG4gICAgICAgICdzdGFydE5leHVzT3BlcmF0aW9uJyxcbiAgICAgICAgc3RhcnROZXh1c09wZXJhdGlvbk5leHRIYW5kbGVyXG4gICAgICApO1xuXG4gICAgICAvLyBUT0RPOiBEbyB3ZSB3YW50IHRvIG1ha2UgdGhlIGludGVyY2VwdG9yIGFzeW5jIGxpa2Ugd2UgZG8gZm9yIGNoaWxkIHdvcmtmbG93PyBUaGF0IHNlZW1zIHJlZHVuZGFudC5cbiAgICAgIC8vIFJFVklFVzogSSBlbmRlZCB1cCBjaGFuZ2luZyB0aGlzIHNvIHRoYXQgdGhlIGludGVyY2VwdG9yIHJldHVybnMgYSBQcm9taXNlPFN0YXJ0TmV4dXNPcGVyYXRpb25PdXRwdXQ+LFxuICAgICAgLy8gICAgICAgICBhbmQgdGhlIHJlc3VsdCBwcm9taXNlIGlzIGNvbnRhaW5lZCBpbiB0aGF0IE91dHB1dCBvYmplY3QuIEFzIGEgY29uc2VxdWVuY2Ugb2YgdGhpcyxcbiAgICAgIC8vICAgICAgICAgdGhlIHJlc3VsdCBwcm9taXNlL2NvbXBsZXRpb24gZG9lcyBub3QgZXhpc3QgdW50aWwgdGhlIFN0YXJ0TmV4dXNPcGVyYXRpb24gZXZlbnQgaXMgcmVjZWl2ZWQuXG4gICAgICAvLyAgICAgICAgIFRoYXQncyB0b3RhbGx5IGRpZmZlcmVudCBmcm9tIHdoYXQgd2UgZGlkIGluIENoaWxkV29ya2Zsb3csIGJ1dCBJIHRoaW5rIHRoYXQncyBjbGVhbmVyIGZyb21cbiAgICAgIC8vICAgICAgICAgaW50ZXJjZXB0b3JzIHBvaW50IG9mIHZpZXcsIGFuZCB3aWxsIG1ha2UgaXQgZWFzaWVyIHRvIGV4dGVuZCB0aGUgQVBJIGluIHRoZSBmdXR1cmUuXG4gICAgICBjb25zdCB7IHRva2VuLCByZXN1bHQ6IHJlc3VsdFByb21pc2UgfSA9IGF3YWl0IGV4ZWN1dGUoe1xuICAgICAgICBlbmRwb2ludDogb3B0aW9ucy5lbmRwb2ludCxcbiAgICAgICAgc2VydmljZTogb3B0aW9ucy5zZXJ2aWNlLm5hbWUsXG4gICAgICAgIG9wZXJhdGlvbjogb3BOYW1lLFxuICAgICAgICBvcHRpb25zOiBvcGVyYXRpb25PcHRpb25zID8/IHt9LFxuICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgc2VxLFxuICAgICAgICBpbnB1dCxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZXJ2aWNlOiBvcHRpb25zLnNlcnZpY2UubmFtZSxcbiAgICAgICAgb3BlcmF0aW9uOiBvcE5hbWUsXG4gICAgICAgIHRva2VuLFxuICAgICAgICBhc3luYyByZXN1bHQoKTogUHJvbWlzZTxuZXh1cy5PcGVyYXRpb25PdXRwdXQ8Tz4+IHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0UHJvbWlzZSBhcyBuZXh1cy5PcGVyYXRpb25PdXRwdXQ8Tz47XG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgTmV4dXNDbGllbnRJbXBsPFQ+KCk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0TmV4dXNPcGVyYXRpb25OZXh0SGFuZGxlcih7XG4gIGlucHV0LFxuICBlbmRwb2ludCxcbiAgc2VydmljZSxcbiAgb3B0aW9ucyxcbiAgb3BlcmF0aW9uLFxuICBzZXEsXG4gIGhlYWRlcnMsXG59OiBTdGFydE5leHVzT3BlcmF0aW9uSW5wdXQpOiBQcm9taXNlPFN0YXJ0TmV4dXNPcGVyYXRpb25PdXRwdXQ+IHtcbiAgY29uc3QgYWN0aXZhdG9yID0gZ2V0QWN0aXZhdG9yKCk7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlPFN0YXJ0TmV4dXNPcGVyYXRpb25PdXRwdXQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBzY29wZSA9IENhbmNlbGxhdGlvblNjb3BlLmN1cnJlbnQoKTtcbiAgICBpZiAoc2NvcGUuY29uc2lkZXJlZENhbmNlbGxlZCkge1xuICAgICAgdW50cmFja1Byb21pc2Uoc2NvcGUuY2FuY2VsUmVxdWVzdGVkLmNhdGNoKHJlamVjdCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2NvcGUuY2FuY2VsbGFibGUpIHtcbiAgICAgIHVudHJhY2tQcm9taXNlKFxuICAgICAgICBzY29wZS5jYW5jZWxSZXF1ZXN0ZWQuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbXBsZXRlZCA9XG4gICAgICAgICAgICAhYWN0aXZhdG9yLmNvbXBsZXRpb25zLm5leHVzT3BlcmF0aW9uU3RhcnQuaGFzKHNlcSkgJiZcbiAgICAgICAgICAgICFhY3RpdmF0b3IuY29tcGxldGlvbnMubmV4dXNPcGVyYXRpb25Db21wbGV0ZS5oYXMoc2VxKTtcblxuICAgICAgICAgIGlmICghY29tcGxldGVkKSB7XG4gICAgICAgICAgICBhY3RpdmF0b3IucHVzaENvbW1hbmQoe1xuICAgICAgICAgICAgICByZXF1ZXN0Q2FuY2VsTmV4dXNPcGVyYXRpb246IHsgc2VxIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBOb3RoaW5nIHRvIGNhbmNlbCBvdGhlcndpc2VcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgYWN0aXZhdG9yLnB1c2hDb21tYW5kKHtcbiAgICAgIHNjaGVkdWxlTmV4dXNPcGVyYXRpb246IHtcbiAgICAgICAgc2VxLFxuICAgICAgICBlbmRwb2ludCxcbiAgICAgICAgc2VydmljZSxcbiAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICBuZXh1c0hlYWRlcjogaGVhZGVycyxcbiAgICAgICAgaW5wdXQ6IGFjdGl2YXRvci5wYXlsb2FkQ29udmVydGVyLnRvUGF5bG9hZChpbnB1dCksXG4gICAgICAgIHNjaGVkdWxlVG9DbG9zZVRpbWVvdXQ6IG1zT3B0aW9uYWxUb1RzKG9wdGlvbnM/LnNjaGVkdWxlVG9DbG9zZVRpbWVvdXQpLFxuICAgICAgICAvLyBGSVhNRShuZXh1cy1wb3N0LWluaXRpYWwtcmVsZWFzZSk6IGNhbmNlbGxhdGlvblR5cGUgaXMgbm90IHN1cHBvcnRlZCB5ZXRcbiAgICAgIH0sXG4gICAgICB1c2VyTWV0YWRhdGE6IHVzZXJNZXRhZGF0YVRvUGF5bG9hZChhY3RpdmF0b3IucGF5bG9hZENvbnZlcnRlciwgb3B0aW9ucz8uc3VtbWFyeSwgdW5kZWZpbmVkKSxcbiAgICB9KTtcblxuICAgIGFjdGl2YXRvci5jb21wbGV0aW9ucy5uZXh1c09wZXJhdGlvblN0YXJ0LnNldChzZXEsIHtcbiAgICAgIHJlc29sdmUsXG4gICAgICByZWplY3QsXG4gICAgfSk7XG4gIH0pO1xufVxuIiwiLy8gLi4vcGFja2FnZS5qc29uIGlzIG91dHNpZGUgb2YgdGhlIFRTIHByb2plY3Qgcm9vdERpciB3aGljaCBjYXVzZXMgVFMgdG8gY29tcGxhaW4gYWJvdXQgdGhpcyBpbXBvcnQuXG4vLyBXZSBkbyBub3Qgd2FudCB0byBjaGFuZ2UgdGhlIHJvb3REaXIgYmVjYXVzZSBpdCBtZXNzZXMgdXAgdGhlIG91dHB1dCBzdHJ1Y3R1cmUuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4vLyBAdHMtaWdub3JlXG5pbXBvcnQgcGtnIGZyb20gJy4uL3BhY2thZ2UuanNvbic7XG5cbmV4cG9ydCBkZWZhdWx0IHBrZyBhcyB7IG5hbWU6IHN0cmluZzsgdmVyc2lvbjogc3RyaW5nIH07XG4iLCIvKipcbiAqIFR5cGUgZGVmaW5pdGlvbnMgZm9yIHRoZSBXb3JrZmxvdyBlbmQgb2YgdGhlIHNpbmtzIG1lY2hhbmlzbS5cbiAqXG4gKiBTaW5rcyBhcmUgYSBtZWNoYW5pc20gZm9yIGV4cG9ydGluZyBkYXRhIGZyb20gdGhlIFdvcmtmbG93IGlzb2xhdGUgdG8gdGhlXG4gKiBOb2RlLmpzIGVudmlyb25tZW50LCB0aGV5IGFyZSBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgV29ya2Zsb3cgaGFzIG5vIHdheSB0b1xuICogY29tbXVuaWNhdGUgd2l0aCB0aGUgb3V0c2lkZSBXb3JsZC5cbiAqXG4gKiBTaW5rcyBhcmUgdHlwaWNhbGx5IHVzZWQgZm9yIGV4cG9ydGluZyBsb2dzLCBtZXRyaWNzIGFuZCB0cmFjZXMgb3V0IGZyb20gdGhlXG4gKiBXb3JrZmxvdy5cbiAqXG4gKiBTaW5rIGZ1bmN0aW9ucyBtYXkgbm90IHJldHVybiB2YWx1ZXMgdG8gdGhlIFdvcmtmbG93IGluIG9yZGVyIHRvIHByZXZlbnRcbiAqIGJyZWFraW5nIGRldGVybWluaXNtLlxuICpcbiAqIEBtb2R1bGVcbiAqL1xuXG5pbXBvcnQgeyBXb3JrZmxvd0luZm8gfSBmcm9tICcuL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgYXNzZXJ0SW5Xb3JrZmxvd0NvbnRleHQgfSBmcm9tICcuL2dsb2JhbC1hdHRyaWJ1dGVzJztcblxuLyoqXG4gKiBBbnkgZnVuY3Rpb24gc2lnbmF0dXJlIGNhbiBiZSB1c2VkIGZvciBTaW5rIGZ1bmN0aW9ucyBhcyBsb25nIGFzIHRoZSByZXR1cm4gdHlwZSBpcyBgdm9pZGAuXG4gKlxuICogV2hlbiBjYWxsaW5nIGEgU2luayBmdW5jdGlvbiwgYXJndW1lbnRzIGFyZSBjb3BpZWQgZnJvbSB0aGUgV29ya2Zsb3cgaXNvbGF0ZSB0byB0aGUgTm9kZS5qcyBlbnZpcm9ubWVudCB1c2luZ1xuICoge0BsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvd29ya2VyX3RocmVhZHMuaHRtbCN3b3JrZXJfdGhyZWFkc19wb3J0X3Bvc3RtZXNzYWdlX3ZhbHVlX3RyYW5zZmVybGlzdCB8IHBvc3RNZXNzYWdlfS5cblxuICogVGhpcyBjb25zdHJhaW5zIHRoZSBhcmd1bWVudCB0eXBlcyB0byBwcmltaXRpdmVzIChleGNsdWRpbmcgU3ltYm9scykuXG4gKi9cbmV4cG9ydCB0eXBlIFNpbmtGdW5jdGlvbiA9ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZDtcblxuLyoqIEEgbWFwcGluZyBvZiBuYW1lIHRvIGZ1bmN0aW9uLCBkZWZpbmVzIGEgc2luZ2xlIHNpbmsgKGUuZy4gbG9nZ2VyKSAqL1xuZXhwb3J0IHR5cGUgU2luayA9IFJlY29yZDxzdHJpbmcsIFNpbmtGdW5jdGlvbj47XG4vKipcbiAqIFdvcmtmbG93IFNpbmsgYXJlIGEgbWFwcGluZyBvZiBuYW1lIHRvIHtAbGluayBTaW5rfVxuICovXG5leHBvcnQgdHlwZSBTaW5rcyA9IFJlY29yZDxzdHJpbmcsIFNpbms+O1xuXG4vKipcbiAqIENhbGwgaW5mb3JtYXRpb24gZm9yIGEgU2lua1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFNpbmtDYWxsIHtcbiAgaWZhY2VOYW1lOiBzdHJpbmc7XG4gIGZuTmFtZTogc3RyaW5nO1xuICBhcmdzOiBhbnlbXTtcbiAgd29ya2Zsb3dJbmZvOiBXb3JrZmxvd0luZm87XG59XG5cbi8qKlxuICogR2V0IGEgcmVmZXJlbmNlIHRvIFNpbmtzIGZvciBleHBvcnRpbmcgZGF0YSBvdXQgb2YgdGhlIFdvcmtmbG93LlxuICpcbiAqIFRoZXNlIFNpbmtzICoqbXVzdCoqIGJlIHJlZ2lzdGVyZWQgd2l0aCB0aGUgV29ya2VyIGluIG9yZGVyIGZvciB0aGlzXG4gKiBtZWNoYW5pc20gdG8gd29yay5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IHByb3h5U2lua3MsIFNpbmtzIH0gZnJvbSAnQHRlbXBvcmFsaW8vd29ya2Zsb3cnO1xuICpcbiAqIGludGVyZmFjZSBNeVNpbmtzIGV4dGVuZHMgU2lua3Mge1xuICogICBsb2dnZXI6IHtcbiAqICAgICBpbmZvKG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQ7XG4gKiAgICAgZXJyb3IobWVzc2FnZTogc3RyaW5nKTogdm9pZDtcbiAqICAgfTtcbiAqIH1cbiAqXG4gKiBjb25zdCB7IGxvZ2dlciB9ID0gcHJveHlTaW5rczxNeURlcGVuZGVuY2llcz4oKTtcbiAqIGxvZ2dlci5pbmZvKCdzZXR0aW5nIHVwJyk7XG4gKlxuICogZXhwb3J0IGZ1bmN0aW9uIG15V29ya2Zsb3coKSB7XG4gKiAgIHJldHVybiB7XG4gKiAgICAgYXN5bmMgZXhlY3V0ZSgpIHtcbiAqICAgICAgIGxvZ2dlci5pbmZvKFwiaGV5IGhvXCIpO1xuICogICAgICAgbG9nZ2VyLmVycm9yKFwibGV0cyBnb1wiKTtcbiAqICAgICB9XG4gKiAgIH07XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb3h5U2lua3M8VCBleHRlbmRzIFNpbmtzPigpOiBUIHtcbiAgcmV0dXJuIG5ldyBQcm94eShcbiAgICB7fSxcbiAgICB7XG4gICAgICBnZXQoXywgaWZhY2VOYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkoXG4gICAgICAgICAge30sXG4gICAgICAgICAge1xuICAgICAgICAgICAgZ2V0KF8sIGZuTmFtZSkge1xuICAgICAgICAgICAgICByZXR1cm4gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWN0aXZhdG9yID0gYXNzZXJ0SW5Xb3JrZmxvd0NvbnRleHQoXG4gICAgICAgICAgICAgICAgICAnUHJveGllZCBzaW5rcyBmdW5jdGlvbnMgbWF5IG9ubHkgYmUgdXNlZCBmcm9tIGEgV29ya2Zsb3cgRXhlY3V0aW9uLidcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGFjdGl2YXRvci5zaW5rQ2FsbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICBpZmFjZU5hbWU6IGlmYWNlTmFtZSBhcyBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICBmbk5hbWU6IGZuTmFtZSBhcyBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAvLyBTaW5rIGZ1bmN0aW9uIGRvZXNuJ3QgZ2V0IGNhbGxlZCBpbW1lZGlhdGVseS4gTWFrZSBhIGNsb25lIG9mIHRoZSBzaW5rJ3MgYXJncywgc28gdGhhdCBmdXJ0aGVyIG11dGF0aW9uc1xuICAgICAgICAgICAgICAgICAgLy8gdG8gdGhlc2Ugb2JqZWN0cyBkb24ndCBjb3JydXB0IHRoZSBhcmdzIHRoYXQgdGhlIHNpbmsgZnVuY3Rpb24gd2lsbCByZWNlaXZlLiBPbmx5IGF2YWlsYWJsZSBmcm9tIG5vZGUgMTcuXG4gICAgICAgICAgICAgICAgICBhcmdzOiAoZ2xvYmFsVGhpcyBhcyBhbnkpLnN0cnVjdHVyZWRDbG9uZSA/IChnbG9iYWxUaGlzIGFzIGFueSkuc3RydWN0dXJlZENsb25lKGFyZ3MpIDogYXJncyxcbiAgICAgICAgICAgICAgICAgIC8vIGFjdGl2YXRvci5pbmZvIGlzIGludGVybmFsbHkgY29weS1vbi13cml0ZS4gVGhpcyBlbnN1cmUgdGhhdCBhbnkgZnVydGhlciBtdXRhdGlvbnNcbiAgICAgICAgICAgICAgICAgIC8vIHRvIHRoZSB3b3JrZmxvdyBzdGF0ZSBpbiB0aGUgY29udGV4dCBvZiB0aGUgcHJlc2VudCBhY3RpdmF0aW9uIHdpbGwgbm90IGNvcnJ1cHQgdGhlXG4gICAgICAgICAgICAgICAgICAvLyB3b3JrZmxvd0luZm8gc3RhdGUgdGhhdCBnZXRzIHBhc3NlZCB3aGVuIHRoZSBzaW5rIGZ1bmN0aW9uIGFjdHVhbGx5IGdldHMgY2FsbGVkLlxuICAgICAgICAgICAgICAgICAgd29ya2Zsb3dJbmZvOiBhY3RpdmF0b3IuaW5mbyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICB9XG4gICkgYXMgYW55O1xufVxuIiwiaW1wb3J0IHsgbWF5YmVHZXRBY3RpdmF0b3JVbnR5cGVkIH0gZnJvbSAnLi9nbG9iYWwtYXR0cmlidXRlcyc7XG5pbXBvcnQgdHlwZSB7IFByb21pc2VTdGFja1N0b3JlIH0gZnJvbSAnLi9pbnRlcm5hbHMnO1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byByZW1vdmUgYSBwcm9taXNlIGZyb20gYmVpbmcgdHJhY2tlZCBmb3Igc3RhY2sgdHJhY2UgcXVlcnkgcHVycG9zZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVudHJhY2tQcm9taXNlKHByb21pc2U6IFByb21pc2U8dW5rbm93bj4pOiB2b2lkIHtcbiAgY29uc3Qgc3RvcmUgPSAobWF5YmVHZXRBY3RpdmF0b3JVbnR5cGVkKCkgYXMgYW55KT8ucHJvbWlzZVN0YWNrU3RvcmUgYXMgUHJvbWlzZVN0YWNrU3RvcmUgfCB1bmRlZmluZWQ7XG4gIGlmICghc3RvcmUpIHJldHVybjtcbiAgc3RvcmUuY2hpbGRUb1BhcmVudC5kZWxldGUocHJvbWlzZSk7XG4gIHN0b3JlLnByb21pc2VUb1N0YWNrLmRlbGV0ZShwcm9taXNlKTtcbn1cbiIsImltcG9ydCB7IENhbmNlbGxhdGlvblNjb3BlIH0gZnJvbSAnLi9jYW5jZWxsYXRpb24tc2NvcGUnO1xuaW1wb3J0IHsgdW50cmFja1Byb21pc2UgfSBmcm9tICcuL3N0YWNrLWhlbHBlcnMnO1xuXG4vKipcbiAqIEEgYFByb21pc2VMaWtlYCBoZWxwZXIgd2hpY2ggZXhwb3NlcyBpdHMgYHJlc29sdmVgIGFuZCBgcmVqZWN0YCBtZXRob2RzLlxuICpcbiAqIFRyaWdnZXIgaXMgQ2FuY2VsbGF0aW9uU2NvcGUtYXdhcmU6IGl0IGlzIGxpbmtlZCB0byB0aGUgY3VycmVudCBzY29wZSBvblxuICogY29uc3RydWN0aW9uIGFuZCB0aHJvd3Mgd2hlbiB0aGF0IHNjb3BlIGlzIGNhbmNlbGxlZC5cbiAqXG4gKiBVc2VmdWwgZm9yIGUuZy4gd2FpdGluZyBmb3IgdW5ibG9ja2luZyBhIFdvcmtmbG93IGZyb20gYSBTaWduYWwuXG4gKlxuICogQGV4YW1wbGVcbiAqIDwhLS1TTklQU1RBUlQgdHlwZXNjcmlwdC10cmlnZ2VyLXdvcmtmbG93LS0+XG4gKiA8IS0tU05JUEVORC0tPlxuICovXG5leHBvcnQgY2xhc3MgVHJpZ2dlcjxUPiBpbXBsZW1lbnRzIFByb21pc2VMaWtlPFQ+IHtcbiAgLy8gVHlwZXNjcmlwdCBkb2VzIG5vdCByZWFsaXplIHRoYXQgdGhlIHByb21pc2UgZXhlY3V0b3IgaXMgcnVuIHN5bmNocm9ub3VzbHkgaW4gdGhlIGNvbnN0cnVjdG9yXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgLy8gQHRzLWlnbm9yZVxuICBwdWJsaWMgcmVhZG9ubHkgcmVzb2x2ZTogKHZhbHVlOiBUIHwgUHJvbWlzZUxpa2U8VD4pID0+IHZvaWQ7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgLy8gQHRzLWlnbm9yZVxuICBwdWJsaWMgcmVhZG9ubHkgcmVqZWN0OiAocmVhc29uPzogYW55KSA9PiB2b2lkO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgcHJvbWlzZTogUHJvbWlzZTxUPjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZTxUPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBzY29wZSA9IENhbmNlbGxhdGlvblNjb3BlLmN1cnJlbnQoKTtcbiAgICAgIGlmIChzY29wZS5jYW5jZWxsYWJsZSkge1xuICAgICAgICB1bnRyYWNrUHJvbWlzZShzY29wZS5jYW5jZWxSZXF1ZXN0ZWQuY2F0Y2gocmVqZWN0KSk7XG4gICAgICB9XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG4gICAgLy8gQXZvaWQgdW5oYW5kbGVkIHJlamVjdGlvbnNcbiAgICB1bnRyYWNrUHJvbWlzZSh0aGlzLnByb21pc2UuY2F0Y2goKCkgPT4gdW5kZWZpbmVkKSk7XG4gIH1cblxuICB0aGVuPFRSZXN1bHQxID0gVCwgVFJlc3VsdDIgPSBuZXZlcj4oXG4gICAgb25mdWxmaWxsZWQ/OiAoKHZhbHVlOiBUKSA9PiBUUmVzdWx0MSB8IFByb21pc2VMaWtlPFRSZXN1bHQxPikgfCB1bmRlZmluZWQgfCBudWxsLFxuICAgIG9ucmVqZWN0ZWQ/OiAoKHJlYXNvbjogYW55KSA9PiBUUmVzdWx0MiB8IFByb21pc2VMaWtlPFRSZXN1bHQyPikgfCB1bmRlZmluZWQgfCBudWxsXG4gICk6IFByb21pc2VMaWtlPFRSZXN1bHQxIHwgVFJlc3VsdDI+IHtcbiAgICByZXR1cm4gdGhpcy5wcm9taXNlLnRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpO1xuICB9XG59XG4iLCJpbXBvcnQgdHlwZSB7IEFzeW5jTG9jYWxTdG9yYWdlIGFzIEFMUyB9IGZyb20gJ25vZGU6YXN5bmNfaG9va3MnO1xuXG4vKipcbiAqIE9wdGlvbiBmb3IgY29uc3RydWN0aW5nIGEgVXBkYXRlU2NvcGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVcGRhdGVTY29wZU9wdGlvbnMge1xuICAvKipcbiAgICogIEEgd29ya2Zsb3ctdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgdXBkYXRlLlxuICAgKi9cbiAgaWQ6IHN0cmluZztcblxuICAvKipcbiAgICogIFRoZSB1cGRhdGUgdHlwZSBuYW1lLlxuICAgKi9cbiAgbmFtZTogc3RyaW5nO1xufVxuXG4vLyBBc3luY0xvY2FsU3RvcmFnZSBpcyBpbmplY3RlZCB2aWEgdm0gbW9kdWxlIGludG8gZ2xvYmFsIHNjb3BlLlxuLy8gSW4gY2FzZSBXb3JrZmxvdyBjb2RlIGlzIGltcG9ydGVkIGluIE5vZGUuanMgY29udGV4dCwgcmVwbGFjZSB3aXRoIGFuIGVtcHR5IGNsYXNzLlxuZXhwb3J0IGNvbnN0IEFzeW5jTG9jYWxTdG9yYWdlOiBuZXcgPFQ+KCkgPT4gQUxTPFQ+ID0gKGdsb2JhbFRoaXMgYXMgYW55KS5Bc3luY0xvY2FsU3RvcmFnZSA/PyBjbGFzcyB7fTtcblxuZXhwb3J0IGNsYXNzIFVwZGF0ZVNjb3BlIHtcbiAgLyoqXG4gICAqICBBIHdvcmtmbG93LXVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIHVwZGF0ZS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiAgVGhlIHVwZGF0ZSB0eXBlIG5hbWUuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IFVwZGF0ZVNjb3BlT3B0aW9ucykge1xuICAgIHRoaXMuaWQgPSBvcHRpb25zLmlkO1xuICAgIHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZSB0aGUgc2NvcGUgYXMgY3VycmVudCBhbmQgcnVuIHRoZSB1cGRhdGUgaGFuZGxlciBgZm5gLlxuICAgKlxuICAgKiBAcmV0dXJuIHRoZSByZXN1bHQgb2YgYGZuYFxuICAgKi9cbiAgcnVuPFQ+KGZuOiAoKSA9PiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XG4gICAgcmV0dXJuIHN0b3JhZ2UucnVuKHRoaXMsIGZuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgXCJhY3RpdmVcIiB1cGRhdGUgc2NvcGUuXG4gICAqL1xuICBzdGF0aWMgY3VycmVudCgpOiBVcGRhdGVTY29wZSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHN0b3JhZ2UuZ2V0U3RvcmUoKTtcbiAgfVxuXG4gIC8qKiBBbGlhcyB0byBgbmV3IFVwZGF0ZVNjb3BlKHsgaWQsIG5hbWUgfSkucnVuKGZuKWAgKi9cbiAgc3RhdGljIHVwZGF0ZVdpdGhJbmZvPFQ+KGlkOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgZm46ICgpID0+IFByb21pc2U8VD4pOiBQcm9taXNlPFQ+IHtcbiAgICByZXR1cm4gbmV3IHRoaXMoeyBpZCwgbmFtZSB9KS5ydW4oZm4pO1xuICB9XG59XG5cbmNvbnN0IHN0b3JhZ2UgPSBuZXcgQXN5bmNMb2NhbFN0b3JhZ2U8VXBkYXRlU2NvcGU+KCk7XG5cbi8qKlxuICogRGlzYWJsZSB0aGUgYXN5bmMgbG9jYWwgc3RvcmFnZSBmb3IgdXBkYXRlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc2FibGVVcGRhdGVTdG9yYWdlKCk6IHZvaWQge1xuICBzdG9yYWdlLmRpc2FibGUoKTtcbn1cbiIsIi8qKlxuICogRXhwb3J0ZWQgZnVuY3Rpb25zIGZvciB0aGUgV29ya2VyIHRvIGludGVyYWN0IHdpdGggdGhlIFdvcmtmbG93IGlzb2xhdGVcbiAqXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IGVuY29kZVZlcnNpb25pbmdCZWhhdmlvciwgSWxsZWdhbFN0YXRlRXJyb3IsIFdvcmtmbG93RnVuY3Rpb25XaXRoT3B0aW9ucyB9IGZyb20gJ0B0ZW1wb3JhbGlvL2NvbW1vbic7XG5pbXBvcnQgeyBjb21wb3NlSW50ZXJjZXB0b3JzIH0gZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uL2xpYi9pbnRlcmNlcHRvcnMnO1xuaW1wb3J0IHsgY29yZXNkayB9IGZyb20gJ0B0ZW1wb3JhbGlvL3Byb3RvJztcbmltcG9ydCB7IGRpc2FibGVTdG9yYWdlIH0gZnJvbSAnLi9jYW5jZWxsYXRpb24tc2NvcGUnO1xuaW1wb3J0IHsgZGlzYWJsZVVwZGF0ZVN0b3JhZ2UgfSBmcm9tICcuL3VwZGF0ZS1zY29wZSc7XG5pbXBvcnQgeyBXb3JrZmxvd0ludGVyY2VwdG9yc0ZhY3RvcnkgfSBmcm9tICcuL2ludGVyY2VwdG9ycyc7XG5pbXBvcnQgeyBXb3JrZmxvd0NyZWF0ZU9wdGlvbnNJbnRlcm5hbCB9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBBY3RpdmF0b3IgfSBmcm9tICcuL2ludGVybmFscyc7XG5pbXBvcnQgeyBzZXRBY3RpdmF0b3JVbnR5cGVkLCBnZXRBY3RpdmF0b3IgfSBmcm9tICcuL2dsb2JhbC1hdHRyaWJ1dGVzJztcblxuLy8gRXhwb3J0IHRoZSB0eXBlIGZvciB1c2Ugb24gdGhlIFwid29ya2VyXCIgc2lkZVxuZXhwb3J0IHsgUHJvbWlzZVN0YWNrU3RvcmUgfSBmcm9tICcuL2ludGVybmFscyc7XG5cbmNvbnN0IGdsb2JhbCA9IGdsb2JhbFRoaXMgYXMgYW55O1xuY29uc3QgT3JpZ2luYWxEYXRlID0gZ2xvYmFsVGhpcy5EYXRlO1xuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIGlzb2xhdGUgcnVudGltZS5cbiAqXG4gKiBTZXRzIHJlcXVpcmVkIGludGVybmFsIHN0YXRlIGFuZCBpbnN0YW50aWF0ZXMgdGhlIHdvcmtmbG93IGFuZCBpbnRlcmNlcHRvcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0UnVudGltZShvcHRpb25zOiBXb3JrZmxvd0NyZWF0ZU9wdGlvbnNJbnRlcm5hbCk6IHZvaWQge1xuICBjb25zdCBhY3RpdmF0b3IgPSBuZXcgQWN0aXZhdG9yKHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGluZm86IGZpeFByb3RvdHlwZXMoe1xuICAgICAgLi4ub3B0aW9ucy5pbmZvLFxuICAgICAgdW5zYWZlOiB7IC4uLm9wdGlvbnMuaW5mby51bnNhZmUsIG5vdzogT3JpZ2luYWxEYXRlLm5vdyB9LFxuICAgIH0pLFxuICB9KTtcbiAgLy8gVGhlcmUncyBvbmUgYWN0aXZhdG9yIHBlciB3b3JrZmxvdyBpbnN0YW5jZSwgc2V0IGl0IGdsb2JhbGx5IG9uIHRoZSBjb250ZXh0LlxuICAvLyBXZSBkbyB0aGlzIGJlZm9yZSBpbXBvcnRpbmcgYW55IHVzZXIgY29kZSBzbyB1c2VyIGNvZGUgY2FuIHN0YXRpY2FsbHkgcmVmZXJlbmNlIEB0ZW1wb3JhbGlvL3dvcmtmbG93IGZ1bmN0aW9uc1xuICAvLyBhcyB3ZWxsIGFzIERhdGUgYW5kIE1hdGgucmFuZG9tLlxuICBzZXRBY3RpdmF0b3JVbnR5cGVkKGFjdGl2YXRvcik7XG5cbiAgYWN0aXZhdG9yLnJldGhyb3dTeW5jaHJvbm91c2x5ID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICAvLyB3ZWJwYWNrIGFsaWFzIHRvIHBheWxvYWRDb252ZXJ0ZXJQYXRoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgICBjb25zdCBjdXN0b21QYXlsb2FkQ29udmVydGVyID0gcmVxdWlyZSgnX190ZW1wb3JhbF9jdXN0b21fcGF5bG9hZF9jb252ZXJ0ZXInKS5wYXlsb2FkQ29udmVydGVyO1xuICAgIC8vIFRoZSBgcGF5bG9hZENvbnZlcnRlcmAgZXhwb3J0IGlzIHZhbGlkYXRlZCBpbiB0aGUgV29ya2VyXG4gICAgaWYgKGN1c3RvbVBheWxvYWRDb252ZXJ0ZXIgIT0gbnVsbCkge1xuICAgICAgYWN0aXZhdG9yLnBheWxvYWRDb252ZXJ0ZXIgPSBjdXN0b21QYXlsb2FkQ29udmVydGVyO1xuICAgIH1cbiAgICAvLyB3ZWJwYWNrIGFsaWFzIHRvIGZhaWx1cmVDb252ZXJ0ZXJQYXRoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgICBjb25zdCBjdXN0b21GYWlsdXJlQ29udmVydGVyID0gcmVxdWlyZSgnX190ZW1wb3JhbF9jdXN0b21fZmFpbHVyZV9jb252ZXJ0ZXInKS5mYWlsdXJlQ29udmVydGVyO1xuICAgIC8vIFRoZSBgZmFpbHVyZUNvbnZlcnRlcmAgZXhwb3J0IGlzIHZhbGlkYXRlZCBpbiB0aGUgV29ya2VyXG4gICAgaWYgKGN1c3RvbUZhaWx1cmVDb252ZXJ0ZXIgIT0gbnVsbCkge1xuICAgICAgYWN0aXZhdG9yLmZhaWx1cmVDb252ZXJ0ZXIgPSBjdXN0b21GYWlsdXJlQ29udmVydGVyO1xuICAgIH1cblxuICAgIGNvbnN0IHsgaW1wb3J0V29ya2Zsb3dzLCBpbXBvcnRJbnRlcmNlcHRvcnMgfSA9IGdsb2JhbC5fX1RFTVBPUkFMX187XG4gICAgaWYgKGltcG9ydFdvcmtmbG93cyA9PT0gdW5kZWZpbmVkIHx8IGltcG9ydEludGVyY2VwdG9ycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXJyb3IoJ1dvcmtmbG93IGJ1bmRsZSBkaWQgbm90IHJlZ2lzdGVyIGltcG9ydCBob29rcycpO1xuICAgIH1cblxuICAgIGNvbnN0IGludGVyY2VwdG9ycyA9IGltcG9ydEludGVyY2VwdG9ycygpO1xuICAgIGZvciAoY29uc3QgbW9kIG9mIGludGVyY2VwdG9ycykge1xuICAgICAgY29uc3QgZmFjdG9yeTogV29ya2Zsb3dJbnRlcmNlcHRvcnNGYWN0b3J5ID0gbW9kLmludGVyY2VwdG9ycztcbiAgICAgIGlmIChmYWN0b3J5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmYWN0b3J5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gaW5pdGlhbGl6ZSB3b3JrZmxvd3MgaW50ZXJjZXB0b3JzOiBleHBlY3RlZCBhIGZ1bmN0aW9uLCBidXQgZ290OiAnJHtmYWN0b3J5fSdgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnRlcmNlcHRvcnMgPSBmYWN0b3J5KCk7XG4gICAgICAgIGFjdGl2YXRvci5pbnRlcmNlcHRvcnMuaW5ib3VuZC5wdXNoKC4uLihpbnRlcmNlcHRvcnMuaW5ib3VuZCA/PyBbXSkpO1xuICAgICAgICBhY3RpdmF0b3IuaW50ZXJjZXB0b3JzLm91dGJvdW5kLnB1c2goLi4uKGludGVyY2VwdG9ycy5vdXRib3VuZCA/PyBbXSkpO1xuICAgICAgICBhY3RpdmF0b3IuaW50ZXJjZXB0b3JzLmludGVybmFscy5wdXNoKC4uLihpbnRlcmNlcHRvcnMuaW50ZXJuYWxzID8/IFtdKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbW9kID0gaW1wb3J0V29ya2Zsb3dzKCk7XG4gICAgY29uc3Qgd29ya2Zsb3dGbiA9IG1vZFthY3RpdmF0b3IuaW5mby53b3JrZmxvd1R5cGVdO1xuICAgIGNvbnN0IGRlZmF1bHRXb3JrZmxvd0ZuID0gbW9kWydkZWZhdWx0J107XG5cbiAgICBpZiAodHlwZW9mIHdvcmtmbG93Rm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFjdGl2YXRvci53b3JrZmxvdyA9IHdvcmtmbG93Rm47XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmYXVsdFdvcmtmbG93Rm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFjdGl2YXRvci53b3JrZmxvdyA9IGRlZmF1bHRXb3JrZmxvd0ZuO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkZXRhaWxzID1cbiAgICAgICAgd29ya2Zsb3dGbiA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAnbm8gc3VjaCBmdW5jdGlvbiBpcyBleHBvcnRlZCBieSB0aGUgd29ya2Zsb3cgYnVuZGxlJ1xuICAgICAgICAgIDogYGV4cGVjdGVkIGEgZnVuY3Rpb24sIGJ1dCBnb3Q6ICcke3R5cGVvZiB3b3JrZmxvd0ZufSdgO1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRmFpbGVkIHRvIGluaXRpYWxpemUgd29ya2Zsb3cgb2YgdHlwZSAnJHthY3RpdmF0b3IuaW5mby53b3JrZmxvd1R5cGV9JzogJHtkZXRhaWxzfWApO1xuICAgIH1cbiAgICBpZiAoaXNXb3JrZmxvd0Z1bmN0aW9uV2l0aE9wdGlvbnMoYWN0aXZhdG9yLndvcmtmbG93KSkge1xuICAgICAgaWYgKHR5cGVvZiBhY3RpdmF0b3Iud29ya2Zsb3cud29ya2Zsb3dEZWZpbml0aW9uT3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYWN0aXZhdG9yLnZlcnNpb25pbmdCZWhhdmlvciA9IGFjdGl2YXRvci53b3JrZmxvdy53b3JrZmxvd0RlZmluaXRpb25PcHRpb25zLnZlcnNpb25pbmdCZWhhdmlvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2YXRvci53b3JrZmxvd0RlZmluaXRpb25PcHRpb25zR2V0dGVyID0gYWN0aXZhdG9yLndvcmtmbG93LndvcmtmbG93RGVmaW5pdGlvbk9wdGlvbnM7XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGFjdGl2YXRvci5yZXRocm93U3luY2hyb25vdXNseSA9IGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogT2JqZWN0cyB0cmFuc2ZlcmVkIHRvIHRoZSBWTSBmcm9tIG91dHNpZGUgaGF2ZSBwcm90b3R5cGVzIGJlbG9uZ2luZyB0byB0aGVcbiAqIG91dGVyIGNvbnRleHQsIHdoaWNoIG1lYW5zIHRoYXQgaW5zdGFuY2VvZiB3b24ndCB3b3JrIGluc2lkZSB0aGUgVk0uIFRoaXNcbiAqIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5IHdhbGtzIG92ZXIgdGhlIGNvbnRlbnQgb2YgYW4gb2JqZWN0LCBhbmQgcmVjcmVhdGUgc29tZVxuICogb2YgdGhlc2Ugb2JqZWN0cyAobm90YWJseSBBcnJheSwgRGF0ZSBhbmQgT2JqZWN0cykuXG4gKi9cbmZ1bmN0aW9uIGZpeFByb3RvdHlwZXM8WD4ob2JqOiBYKTogWCB7XG4gIGlmIChvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik/LmNvbnN0cnVjdG9yPy5uYW1lKSB7XG4gICAgICBjYXNlICdBcnJheSc6XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKChvYmogYXMgQXJyYXk8dW5rbm93bj4pLm1hcChmaXhQcm90b3R5cGVzKSkgYXMgWDtcbiAgICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgICByZXR1cm4gbmV3IERhdGUob2JqIGFzIHVua25vd24gYXMgRGF0ZSkgYXMgWDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMob2JqKS5tYXAoKFtrLCB2XSk6IFtzdHJpbmcsIGFueV0gPT4gW2ssIGZpeFByb3RvdHlwZXModildKSkgYXMgWDtcbiAgICB9XG4gIH0gZWxzZSByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemUgdGhlIHdvcmtmbG93LiBPciB0byBiZSBleGFjdCwgX2NvbXBsZXRlXyBpbml0aWFsaXphdGlvbiwgYXMgbW9zdCBwYXJ0IGhhcyBiZWVuIGRvbmUgaW4gY29uc3RydWN0b3IpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZShpbml0aWFsaXplV29ya2Zsb3dKb2I6IGNvcmVzZGsud29ya2Zsb3dfYWN0aXZhdGlvbi5JSW5pdGlhbGl6ZVdvcmtmbG93KTogdm9pZCB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGdldEFjdGl2YXRvcigpO1xuICBhY3RpdmF0b3IucmV0aHJvd1N5bmNocm9ub3VzbHkgPSB0cnVlO1xuICB0cnkge1xuICAgIGFjdGl2YXRvci5pbml0aWFsaXplV29ya2Zsb3coaW5pdGlhbGl6ZVdvcmtmbG93Sm9iKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhY3RpdmF0b3IucmV0aHJvd1N5bmNocm9ub3VzbHkgPSBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFJ1biBhIGNodW5rIG9mIGFjdGl2YXRpb24gam9icy5cbiAqXG4gKiBOb3RpY2UgdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIG5vdCBhc3luYyBhbmQgcnVucyBfaW5zaWRlXyB0aGUgVk0gY29udGV4dC4gVGhlcmVmb3JlLCBubyBtaWNyb3Rhc2tcbiAqIHdpbGwgZ2V0IGV4ZWN1dGVkIF93aGlsZV8gdGhpcyBmdW5jdGlvbiBpcyBhY3RpdmU7IHRoZXkgd2lsbCBob3dldmVyIGdldCBleGVjdXRlZCBfYWZ0ZXJfIHRoaXNcbiAqIGZ1bmN0aW9uIHJldHVybnMgKGkuZS4gYWxsIG91dHN0YW5kaW5nIG1pY3JvdGFza3MgaW4gdGhlIFZNIHdpbGwgZ2V0IGV4ZWN1dGVkIGJlZm9yZSBleGVjdXRpb25cbiAqIHJlc3VtZXMgb3V0IG9mIHRoZSBWTSwgaW4gYHZtLXNoYXJlZC50czphY3RpdmF0ZSgpYCkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhY3RpdmF0ZShhY3RpdmF0aW9uOiBjb3Jlc2RrLndvcmtmbG93X2FjdGl2YXRpb24uSVdvcmtmbG93QWN0aXZhdGlvbiwgYmF0Y2hJbmRleCA9IDApOiB2b2lkIHtcbiAgY29uc3QgYWN0aXZhdG9yID0gZ2V0QWN0aXZhdG9yKCk7XG4gIGFjdGl2YXRvci5yZXRocm93U3luY2hyb25vdXNseSA9IHRydWU7XG4gIHRyeSB7XG4gICAgY29uc3QgaW50ZXJjZXB0ID0gY29tcG9zZUludGVyY2VwdG9ycyhhY3RpdmF0b3IuaW50ZXJjZXB0b3JzLmludGVybmFscywgJ2FjdGl2YXRlJywgKHsgYWN0aXZhdGlvbiB9KSA9PiB7XG4gICAgICAvLyBDYXN0IGZyb20gdGhlIGludGVyZmFjZSB0byB0aGUgY2xhc3Mgd2hpY2ggaGFzIHRoZSBgdmFyaWFudGAgYXR0cmlidXRlLlxuICAgICAgLy8gVGhpcyBpcyBzYWZlIGJlY2F1c2Ugd2Uga25vdyB0aGF0IGFjdGl2YXRpb24gaXMgYSBwcm90byBjbGFzcy5cbiAgICAgIGNvbnN0IGpvYnMgPSBhY3RpdmF0aW9uLmpvYnMgYXMgY29yZXNkay53b3JrZmxvd19hY3RpdmF0aW9uLldvcmtmbG93QWN0aXZhdGlvbkpvYltdO1xuXG4gICAgICAvLyBJbml0aWFsaXphdGlvbiB3aWxsIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHksIGJ1dCB3ZSBtaWdodCBzdGlsbCBuZWVkIHRvIHN0YXJ0IHRoZSB3b3JrZmxvdyBmdW5jdGlvblxuICAgICAgY29uc3Qgc3RhcnRXb3JrZmxvd0pvYiA9IGpvYnNbMF0udmFyaWFudCA9PT0gJ2luaXRpYWxpemVXb3JrZmxvdycgPyBqb2JzLnNoaWZ0KCk/LmluaXRpYWxpemVXb3JrZmxvdyA6IHVuZGVmaW5lZDtcblxuICAgICAgZm9yIChjb25zdCBqb2Igb2Ygam9icykge1xuICAgICAgICBpZiAoam9iLnZhcmlhbnQgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgam9iLnZhcmlhbnQgdG8gYmUgZGVmaW5lZCcpO1xuXG4gICAgICAgIGNvbnN0IHZhcmlhbnQgPSBqb2Jbam9iLnZhcmlhbnRdO1xuICAgICAgICBpZiAoIXZhcmlhbnQpIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGpvYi4ke2pvYi52YXJpYW50fSB0byBiZSBzZXRgKTtcblxuICAgICAgICBhY3RpdmF0b3Jbam9iLnZhcmlhbnRdKHZhcmlhbnQgYXMgYW55IC8qIFRTIGNhbid0IGluZmVyIHRoaXMgdHlwZSAqLyk7XG5cbiAgICAgICAgaWYgKGpvYi52YXJpYW50ICE9PSAncXVlcnlXb3JrZmxvdycpIHRyeVVuYmxvY2tDb25kaXRpb25zKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydFdvcmtmbG93Sm9iKSB7XG4gICAgICAgIGNvbnN0IHNhZmVKb2JUeXBlczogY29yZXNkay53b3JrZmxvd19hY3RpdmF0aW9uLldvcmtmbG93QWN0aXZhdGlvbkpvYlsndmFyaWFudCddW10gPSBbXG4gICAgICAgICAgJ2luaXRpYWxpemVXb3JrZmxvdycsXG4gICAgICAgICAgJ3NpZ25hbFdvcmtmbG93JyxcbiAgICAgICAgICAnZG9VcGRhdGUnLFxuICAgICAgICAgICdjYW5jZWxXb3JrZmxvdycsXG4gICAgICAgICAgJ3VwZGF0ZVJhbmRvbVNlZWQnLFxuICAgICAgICBdO1xuICAgICAgICBpZiAoam9icy5zb21lKChqb2IpID0+ICFzYWZlSm9iVHlwZXMuaW5jbHVkZXMoam9iLnZhcmlhbnQpKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAnUmVjZWl2ZWQgYm90aCBpbml0aWFsaXplV29ya2Zsb3cgYW5kIG5vbi1zaWduYWwvbm9uLXVwZGF0ZSBqb2JzIGluIHRoZSBzYW1lIGFjdGl2YXRpb246ICcgK1xuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShqb2JzLm1hcCgoam9iKSA9PiBqb2IudmFyaWFudCkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFjdGl2YXRvci5zdGFydFdvcmtmbG93KHN0YXJ0V29ya2Zsb3dKb2IpO1xuXG4gICAgICAgIHRyeVVuYmxvY2tDb25kaXRpb25zKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaW50ZXJjZXB0KHsgYWN0aXZhdGlvbiwgYmF0Y2hJbmRleCB9KTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhY3RpdmF0b3IucmV0aHJvd1N5bmNocm9ub3VzbHkgPSBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIENvbmNsdWRlIGEgc2luZ2xlIGFjdGl2YXRpb24uXG4gKiBTaG91bGQgYmUgY2FsbGVkIGFmdGVyIHByb2Nlc3NpbmcgYWxsIGFjdGl2YXRpb24gam9icyBhbmQgcXVldWVkIG1pY3JvdGFza3MuXG4gKlxuICogQWN0aXZhdGlvbiBmYWlsdXJlcyBhcmUgaGFuZGxlZCBpbiB0aGUgbWFpbiBOb2RlLmpzIGlzb2xhdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jbHVkZUFjdGl2YXRpb24oKTogY29yZXNkay53b3JrZmxvd19jb21wbGV0aW9uLklXb3JrZmxvd0FjdGl2YXRpb25Db21wbGV0aW9uIHtcbiAgY29uc3QgYWN0aXZhdG9yID0gZ2V0QWN0aXZhdG9yKCk7XG4gIGFjdGl2YXRvci5yZXRocm93U3luY2hyb25vdXNseSA9IHRydWU7XG4gIHRyeSB7XG4gICAgYWN0aXZhdG9yLnJlamVjdEJ1ZmZlcmVkVXBkYXRlcygpO1xuICAgIGNvbnN0IGludGVyY2VwdCA9IGNvbXBvc2VJbnRlcmNlcHRvcnMoYWN0aXZhdG9yLmludGVyY2VwdG9ycy5pbnRlcm5hbHMsICdjb25jbHVkZUFjdGl2YXRpb24nLCAoaW5wdXQpID0+IGlucHV0KTtcbiAgICBjb25zdCBhY3RpdmF0aW9uQ29tcGxldGlvbiA9IGFjdGl2YXRvci5jb25jbHVkZUFjdGl2YXRpb24oKTtcbiAgICBjb25zdCB7IGNvbW1hbmRzIH0gPSBpbnRlcmNlcHQoeyBjb21tYW5kczogYWN0aXZhdGlvbkNvbXBsZXRpb24uY29tbWFuZHMgfSk7XG4gICAgaWYgKGFjdGl2YXRvci5jb21wbGV0ZWQpIHtcbiAgICAgIGFjdGl2YXRvci53YXJuSWZVbmZpbmlzaGVkSGFuZGxlcnMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJ1bklkOiBhY3RpdmF0b3IuaW5mby5ydW5JZCxcbiAgICAgIHN1Y2Nlc3NmdWw6IHtcbiAgICAgICAgLi4uYWN0aXZhdGlvbkNvbXBsZXRpb24sXG4gICAgICAgIGNvbW1hbmRzLFxuICAgICAgICB2ZXJzaW9uaW5nQmVoYXZpb3I6IGVuY29kZVZlcnNpb25pbmdCZWhhdmlvcihhY3RpdmF0aW9uQ29tcGxldGlvbi52ZXJzaW9uaW5nQmVoYXZpb3IpLFxuICAgICAgfSxcbiAgICB9O1xuICB9IGZpbmFsbHkge1xuICAgIGFjdGl2YXRvci5yZXRocm93U3luY2hyb25vdXNseSA9IGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogTG9vcCB0aHJvdWdoIGFsbCBibG9ja2VkIGNvbmRpdGlvbnMsIGV2YWx1YXRlIGFuZCB1bmJsb2NrIGlmIHBvc3NpYmxlLlxuICpcbiAqIEByZXR1cm5zIG51bWJlciBvZiB1bmJsb2NrZWQgY29uZGl0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyeVVuYmxvY2tDb25kaXRpb25zKCk6IG51bWJlciB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGdldEFjdGl2YXRvcigpO1xuICBhY3RpdmF0b3IucmV0aHJvd1N5bmNocm9ub3VzbHkgPSB0cnVlO1xuICB0cnkge1xuICAgIGxldCBudW1VbmJsb2NrZWQgPSAwO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGFjdGl2YXRvci5tYXliZVJldGhyb3dXb3JrZmxvd1Rhc2tFcnJvcigpO1xuICAgICAgY29uc3QgcHJldlVuYmxvY2tlZCA9IG51bVVuYmxvY2tlZDtcbiAgICAgIGZvciAoY29uc3QgW3NlcSwgY29uZF0gb2YgYWN0aXZhdG9yLmJsb2NrZWRDb25kaXRpb25zLmVudHJpZXMoKSkge1xuICAgICAgICBpZiAoY29uZC5mbigpKSB7XG4gICAgICAgICAgY29uZC5yZXNvbHZlKCk7XG4gICAgICAgICAgbnVtVW5ibG9ja2VkKys7XG4gICAgICAgICAgLy8gSXQgaXMgc2FmZSB0byBkZWxldGUgZWxlbWVudHMgZHVyaW5nIG1hcCBpdGVyYXRpb25cbiAgICAgICAgICBhY3RpdmF0b3IuYmxvY2tlZENvbmRpdGlvbnMuZGVsZXRlKHNlcSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcmV2VW5ibG9ja2VkID09PSBudW1VbmJsb2NrZWQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudW1VbmJsb2NrZWQ7XG4gIH0gZmluYWxseSB7XG4gICAgYWN0aXZhdG9yLnJldGhyb3dTeW5jaHJvbm91c2x5ID0gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3Bvc2UoKTogdm9pZCB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGdldEFjdGl2YXRvcigpO1xuICBhY3RpdmF0b3IucmV0aHJvd1N5bmNocm9ub3VzbHkgPSB0cnVlO1xuICB0cnkge1xuICAgIGNvbnN0IGRpc3Bvc2UgPSBjb21wb3NlSW50ZXJjZXB0b3JzKGFjdGl2YXRvci5pbnRlcmNlcHRvcnMuaW50ZXJuYWxzLCAnZGlzcG9zZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGRpc2FibGVTdG9yYWdlKCk7XG4gICAgICBkaXNhYmxlVXBkYXRlU3RvcmFnZSgpO1xuICAgIH0pO1xuICAgIGRpc3Bvc2Uoe30pO1xuICB9IGZpbmFsbHkge1xuICAgIGFjdGl2YXRvci5yZXRocm93U3luY2hyb25vdXNseSA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzV29ya2Zsb3dGdW5jdGlvbldpdGhPcHRpb25zKG9iajogYW55KTogb2JqIGlzIFdvcmtmbG93RnVuY3Rpb25XaXRoT3B0aW9uczxhbnlbXSwgYW55PiB7XG4gIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gT2JqZWN0Lmhhc093bihvYmosICd3b3JrZmxvd0RlZmluaXRpb25PcHRpb25zJyk7XG59XG4iLCJpbXBvcnQge1xuICBBY3Rpdml0eUZ1bmN0aW9uLFxuICBBY3Rpdml0eU9wdGlvbnMsXG4gIGNvbXBpbGVSZXRyeVBvbGljeSxcbiAgY29tcGlsZVByaW9yaXR5LFxuICBlbmNvZGVBY3Rpdml0eUNhbmNlbGxhdGlvblR5cGUsXG4gIGVuY29kZVdvcmtmbG93SWRSZXVzZVBvbGljeSxcbiAgZXh0cmFjdFdvcmtmbG93VHlwZSxcbiAgSGFuZGxlclVuZmluaXNoZWRQb2xpY3ksXG4gIExvY2FsQWN0aXZpdHlPcHRpb25zLFxuICBtYXBUb1BheWxvYWRzLFxuICBRdWVyeURlZmluaXRpb24sXG4gIFNlYXJjaEF0dHJpYnV0ZXMsXG4gIFNlYXJjaEF0dHJpYnV0ZVZhbHVlLFxuICBTaWduYWxEZWZpbml0aW9uLFxuICB0b1BheWxvYWRzLFxuICBUeXBlZFNlYXJjaEF0dHJpYnV0ZXMsXG4gIFVudHlwZWRBY3Rpdml0aWVzLFxuICBVcGRhdGVEZWZpbml0aW9uLFxuICBXaXRoV29ya2Zsb3dBcmdzLFxuICBXb3JrZmxvdyxcbiAgV29ya2Zsb3dSZXN1bHRUeXBlLFxuICBXb3JrZmxvd1JldHVyblR5cGUsXG4gIFdvcmtmbG93VXBkYXRlVmFsaWRhdG9yVHlwZSxcbiAgU2VhcmNoQXR0cmlidXRlVXBkYXRlUGFpcixcbiAgV29ya2Zsb3dEZWZpbml0aW9uT3B0aW9uc09yR2V0dGVyLFxufSBmcm9tICdAdGVtcG9yYWxpby9jb21tb24nO1xuaW1wb3J0IHsgdXNlck1ldGFkYXRhVG9QYXlsb2FkIH0gZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uL2xpYi91c2VyLW1ldGFkYXRhJztcbmltcG9ydCB7XG4gIGVuY29kZVVuaWZpZWRTZWFyY2hBdHRyaWJ1dGVzLFxuICBzZWFyY2hBdHRyaWJ1dGVQYXlsb2FkQ29udmVydGVyLFxufSBmcm9tICdAdGVtcG9yYWxpby9jb21tb24vbGliL2NvbnZlcnRlci9wYXlsb2FkLXNlYXJjaC1hdHRyaWJ1dGVzJztcbmltcG9ydCB7IHZlcnNpb25pbmdJbnRlbnRUb1Byb3RvIH0gZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uL2xpYi92ZXJzaW9uaW5nLWludGVudC1lbnVtJztcbmltcG9ydCB7IER1cmF0aW9uLCBtc09wdGlvbmFsVG9UcywgbXNUb051bWJlciwgbXNUb1RzLCByZXF1aXJlZFRzVG9NcyB9IGZyb20gJ0B0ZW1wb3JhbGlvL2NvbW1vbi9saWIvdGltZSc7XG5pbXBvcnQgeyBjb21wb3NlSW50ZXJjZXB0b3JzIH0gZnJvbSAnQHRlbXBvcmFsaW8vY29tbW9uL2xpYi9pbnRlcmNlcHRvcnMnO1xuaW1wb3J0IHsgdGVtcG9yYWwgfSBmcm9tICdAdGVtcG9yYWxpby9wcm90byc7XG5pbXBvcnQgeyBkZWVwTWVyZ2UgfSBmcm9tICdAdGVtcG9yYWxpby9jb21tb24vbGliL2ludGVybmFsLXdvcmtmbG93JztcbmltcG9ydCB7IHRocm93SWZSZXNlcnZlZE5hbWUgfSBmcm9tICdAdGVtcG9yYWxpby9jb21tb24vbGliL3Jlc2VydmVkJztcbmltcG9ydCB7IENhbmNlbGxhdGlvblNjb3BlLCByZWdpc3RlclNsZWVwSW1wbGVtZW50YXRpb24gfSBmcm9tICcuL2NhbmNlbGxhdGlvbi1zY29wZSc7XG5pbXBvcnQgeyBVcGRhdGVTY29wZSB9IGZyb20gJy4vdXBkYXRlLXNjb3BlJztcbmltcG9ydCB7XG4gIEFjdGl2aXR5SW5wdXQsXG4gIExvY2FsQWN0aXZpdHlJbnB1dCxcbiAgU2lnbmFsV29ya2Zsb3dJbnB1dCxcbiAgU3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uSW5wdXQsXG4gIFRpbWVySW5wdXQsXG4gIFRpbWVyT3B0aW9ucyxcbn0gZnJvbSAnLi9pbnRlcmNlcHRvcnMnO1xuaW1wb3J0IHtcbiAgQ2hpbGRXb3JrZmxvd0NhbmNlbGxhdGlvblR5cGUsXG4gIENoaWxkV29ya2Zsb3dPcHRpb25zLFxuICBDaGlsZFdvcmtmbG93T3B0aW9uc1dpdGhEZWZhdWx0cyxcbiAgQ29udGludWVBc05ldyxcbiAgQ29udGludWVBc05ld09wdGlvbnMsXG4gIERlZmF1bHRTaWduYWxIYW5kbGVyLFxuICBFbmhhbmNlZFN0YWNrVHJhY2UsXG4gIEhhbmRsZXIsXG4gIFF1ZXJ5SGFuZGxlck9wdGlvbnMsXG4gIFNpZ25hbEhhbmRsZXJPcHRpb25zLFxuICBVcGRhdGVIYW5kbGVyT3B0aW9ucyxcbiAgV29ya2Zsb3dJbmZvLFxuICBVcGRhdGVJbmZvLFxuICBlbmNvZGVDaGlsZFdvcmtmbG93Q2FuY2VsbGF0aW9uVHlwZSxcbiAgZW5jb2RlUGFyZW50Q2xvc2VQb2xpY3ksXG4gIERlZmF1bHRVcGRhdGVIYW5kbGVyLFxuICBEZWZhdWx0UXVlcnlIYW5kbGVyLFxufSBmcm9tICcuL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgTG9jYWxBY3Rpdml0eURvQmFja29mZiB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IGFzc2VydEluV29ya2Zsb3dDb250ZXh0LCBnZXRBY3RpdmF0b3IsIG1heWJlR2V0QWN0aXZhdG9yIH0gZnJvbSAnLi9nbG9iYWwtYXR0cmlidXRlcyc7XG5pbXBvcnQgeyB1bnRyYWNrUHJvbWlzZSB9IGZyb20gJy4vc3RhY2staGVscGVycyc7XG5pbXBvcnQgeyBDaGlsZFdvcmtmbG93SGFuZGxlLCBFeHRlcm5hbFdvcmtmbG93SGFuZGxlIH0gZnJvbSAnLi93b3JrZmxvdy1oYW5kbGUnO1xuXG4vLyBBdm9pZCBhIGNpcmN1bGFyIGRlcGVuZGVuY3lcbnJlZ2lzdGVyU2xlZXBJbXBsZW1lbnRhdGlvbihzbGVlcCk7XG5cbi8qKlxuICogQWRkcyBkZWZhdWx0IHZhbHVlcyBvZiBgd29ya2Zsb3dJZGAgYW5kIGBjYW5jZWxsYXRpb25UeXBlYCB0byBnaXZlbiB3b3JrZmxvdyBvcHRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkRGVmYXVsdFdvcmtmbG93T3B0aW9uczxUIGV4dGVuZHMgV29ya2Zsb3c+KFxuICBvcHRzOiBXaXRoV29ya2Zsb3dBcmdzPFQsIENoaWxkV29ya2Zsb3dPcHRpb25zPlxuKTogQ2hpbGRXb3JrZmxvd09wdGlvbnNXaXRoRGVmYXVsdHMge1xuICBjb25zdCB7IGFyZ3MsIHdvcmtmbG93SWQsIC4uLnJlc3QgfSA9IG9wdHM7XG4gIHJldHVybiB7XG4gICAgd29ya2Zsb3dJZDogd29ya2Zsb3dJZCA/PyB1dWlkNCgpLFxuICAgIGFyZ3M6IChhcmdzID8/IFtdKSBhcyB1bmtub3duW10sXG4gICAgY2FuY2VsbGF0aW9uVHlwZTogQ2hpbGRXb3JrZmxvd0NhbmNlbGxhdGlvblR5cGUuV0FJVF9DQU5DRUxMQVRJT05fQ09NUExFVEVELFxuICAgIC4uLnJlc3QsXG4gIH07XG59XG5cbi8qKlxuICogUHVzaCBhIHN0YXJ0VGltZXIgY29tbWFuZCBpbnRvIHN0YXRlIGFjY3VtdWxhdG9yIGFuZCByZWdpc3RlciBjb21wbGV0aW9uXG4gKi9cbmZ1bmN0aW9uIHRpbWVyTmV4dEhhbmRsZXIoeyBzZXEsIGR1cmF0aW9uTXMsIG9wdGlvbnMgfTogVGltZXJJbnB1dCkge1xuICBjb25zdCBhY3RpdmF0b3IgPSBnZXRBY3RpdmF0b3IoKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBzY29wZSA9IENhbmNlbGxhdGlvblNjb3BlLmN1cnJlbnQoKTtcbiAgICBpZiAoc2NvcGUuY29uc2lkZXJlZENhbmNlbGxlZCkge1xuICAgICAgdW50cmFja1Byb21pc2Uoc2NvcGUuY2FuY2VsUmVxdWVzdGVkLmNhdGNoKHJlamVjdCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2NvcGUuY2FuY2VsbGFibGUpIHtcbiAgICAgIHVudHJhY2tQcm9taXNlKFxuICAgICAgICBzY29wZS5jYW5jZWxSZXF1ZXN0ZWQuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGlmICghYWN0aXZhdG9yLmNvbXBsZXRpb25zLnRpbWVyLmRlbGV0ZShzZXEpKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIEFscmVhZHkgcmVzb2x2ZWQgb3IgbmV2ZXIgc2NoZWR1bGVkXG4gICAgICAgICAgfVxuICAgICAgICAgIGFjdGl2YXRvci5wdXNoQ29tbWFuZCh7XG4gICAgICAgICAgICBjYW5jZWxUaW1lcjoge1xuICAgICAgICAgICAgICBzZXEsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgYWN0aXZhdG9yLnB1c2hDb21tYW5kKHtcbiAgICAgIHN0YXJ0VGltZXI6IHtcbiAgICAgICAgc2VxLFxuICAgICAgICBzdGFydFRvRmlyZVRpbWVvdXQ6IG1zVG9UcyhkdXJhdGlvbk1zKSxcbiAgICAgIH0sXG4gICAgICB1c2VyTWV0YWRhdGE6IHVzZXJNZXRhZGF0YVRvUGF5bG9hZChhY3RpdmF0b3IucGF5bG9hZENvbnZlcnRlciwgb3B0aW9ucz8uc3VtbWFyeSwgdW5kZWZpbmVkKSxcbiAgICB9KTtcbiAgICBhY3RpdmF0b3IuY29tcGxldGlvbnMudGltZXIuc2V0KHNlcSwge1xuICAgICAgcmVzb2x2ZSxcbiAgICAgIHJlamVjdCxcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQXN5bmNocm9ub3VzIHNsZWVwLlxuICpcbiAqIFNjaGVkdWxlcyBhIHRpbWVyIG9uIHRoZSBUZW1wb3JhbCBzZXJ2aWNlLlxuICpcbiAqIEBwYXJhbSBtcyBzbGVlcCBkdXJhdGlvbiAtIG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3Ige0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ30uXG4gKiBJZiBnaXZlbiBhIG5lZ2F0aXZlIG51bWJlciBvciAwLCB2YWx1ZSB3aWxsIGJlIHNldCB0byAxLlxuICogQHBhcmFtIG9wdGlvbnMgb3B0aW9uYWwgdGltZXIgb3B0aW9ucyBmb3IgYWRkaXRpb25hbCBjb25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbGVlcChtczogRHVyYXRpb24sIG9wdGlvbnM/OiBUaW1lck9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgYWN0aXZhdG9yID0gYXNzZXJ0SW5Xb3JrZmxvd0NvbnRleHQoJ1dvcmtmbG93LnNsZWVwKC4uLikgbWF5IG9ubHkgYmUgdXNlZCBmcm9tIGEgV29ya2Zsb3cgRXhlY3V0aW9uJyk7XG4gIGNvbnN0IHNlcSA9IGFjdGl2YXRvci5uZXh0U2Vxcy50aW1lcisrO1xuXG4gIGNvbnN0IGR1cmF0aW9uTXMgPSBNYXRoLm1heCgxLCBtc1RvTnVtYmVyKG1zKSk7XG5cbiAgY29uc3QgZXhlY3V0ZSA9IGNvbXBvc2VJbnRlcmNlcHRvcnMoYWN0aXZhdG9yLmludGVyY2VwdG9ycy5vdXRib3VuZCwgJ3N0YXJ0VGltZXInLCB0aW1lck5leHRIYW5kbGVyKTtcblxuICByZXR1cm4gZXhlY3V0ZSh7XG4gICAgZHVyYXRpb25NcyxcbiAgICBzZXEsXG4gICAgb3B0aW9ucyxcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQWN0aXZpdHlPcHRpb25zKG9wdGlvbnM6IEFjdGl2aXR5T3B0aW9ucyk6IHZvaWQge1xuICBpZiAob3B0aW9ucy5zY2hlZHVsZVRvQ2xvc2VUaW1lb3V0ID09PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5zdGFydFRvQ2xvc2VUaW1lb3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZXF1aXJlZCBlaXRoZXIgc2NoZWR1bGVUb0Nsb3NlVGltZW91dCBvciBzdGFydFRvQ2xvc2VUaW1lb3V0Jyk7XG4gIH1cbn1cblxuLy8gVXNlIHNhbWUgdmFsaWRhdGlvbiB3ZSB1c2UgZm9yIG5vcm1hbCBhY3Rpdml0aWVzXG5jb25zdCB2YWxpZGF0ZUxvY2FsQWN0aXZpdHlPcHRpb25zID0gdmFsaWRhdGVBY3Rpdml0eU9wdGlvbnM7XG5cbi8qKlxuICogUHVzaCBhIHNjaGVkdWxlQWN0aXZpdHkgY29tbWFuZCBpbnRvIGFjdGl2YXRvciBhY2N1bXVsYXRvciBhbmQgcmVnaXN0ZXIgY29tcGxldGlvblxuICovXG5mdW5jdGlvbiBzY2hlZHVsZUFjdGl2aXR5TmV4dEhhbmRsZXIoeyBvcHRpb25zLCBhcmdzLCBoZWFkZXJzLCBzZXEsIGFjdGl2aXR5VHlwZSB9OiBBY3Rpdml0eUlucHV0KTogUHJvbWlzZTx1bmtub3duPiB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGdldEFjdGl2YXRvcigpO1xuICB2YWxpZGF0ZUFjdGl2aXR5T3B0aW9ucyhvcHRpb25zKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBzY29wZSA9IENhbmNlbGxhdGlvblNjb3BlLmN1cnJlbnQoKTtcbiAgICBpZiAoc2NvcGUuY29uc2lkZXJlZENhbmNlbGxlZCkge1xuICAgICAgdW50cmFja1Byb21pc2Uoc2NvcGUuY2FuY2VsUmVxdWVzdGVkLmNhdGNoKHJlamVjdCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2NvcGUuY2FuY2VsbGFibGUpIHtcbiAgICAgIHVudHJhY2tQcm9taXNlKFxuICAgICAgICBzY29wZS5jYW5jZWxSZXF1ZXN0ZWQuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIGlmICghYWN0aXZhdG9yLmNvbXBsZXRpb25zLmFjdGl2aXR5LmhhcyhzZXEpKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIEFscmVhZHkgcmVzb2x2ZWQgb3IgbmV2ZXIgc2NoZWR1bGVkXG4gICAgICAgICAgfVxuICAgICAgICAgIGFjdGl2YXRvci5wdXNoQ29tbWFuZCh7XG4gICAgICAgICAgICByZXF1ZXN0Q2FuY2VsQWN0aXZpdHk6IHtcbiAgICAgICAgICAgICAgc2VxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGFjdGl2YXRvci5wdXNoQ29tbWFuZCh7XG4gICAgICBzY2hlZHVsZUFjdGl2aXR5OiB7XG4gICAgICAgIHNlcSxcbiAgICAgICAgYWN0aXZpdHlJZDogb3B0aW9ucy5hY3Rpdml0eUlkID8/IGAke3NlcX1gLFxuICAgICAgICBhY3Rpdml0eVR5cGUsXG4gICAgICAgIGFyZ3VtZW50czogdG9QYXlsb2FkcyhhY3RpdmF0b3IucGF5bG9hZENvbnZlcnRlciwgLi4uYXJncyksXG4gICAgICAgIHJldHJ5UG9saWN5OiBvcHRpb25zLnJldHJ5ID8gY29tcGlsZVJldHJ5UG9saWN5KG9wdGlvbnMucmV0cnkpIDogdW5kZWZpbmVkLFxuICAgICAgICB0YXNrUXVldWU6IG9wdGlvbnMudGFza1F1ZXVlIHx8IGFjdGl2YXRvci5pbmZvLnRhc2tRdWV1ZSxcbiAgICAgICAgaGVhcnRiZWF0VGltZW91dDogbXNPcHRpb25hbFRvVHMob3B0aW9ucy5oZWFydGJlYXRUaW1lb3V0KSxcbiAgICAgICAgc2NoZWR1bGVUb0Nsb3NlVGltZW91dDogbXNPcHRpb25hbFRvVHMob3B0aW9ucy5zY2hlZHVsZVRvQ2xvc2VUaW1lb3V0KSxcbiAgICAgICAgc3RhcnRUb0Nsb3NlVGltZW91dDogbXNPcHRpb25hbFRvVHMob3B0aW9ucy5zdGFydFRvQ2xvc2VUaW1lb3V0KSxcbiAgICAgICAgc2NoZWR1bGVUb1N0YXJ0VGltZW91dDogbXNPcHRpb25hbFRvVHMob3B0aW9ucy5zY2hlZHVsZVRvU3RhcnRUaW1lb3V0KSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgY2FuY2VsbGF0aW9uVHlwZTogZW5jb2RlQWN0aXZpdHlDYW5jZWxsYXRpb25UeXBlKG9wdGlvbnMuY2FuY2VsbGF0aW9uVHlwZSksXG4gICAgICAgIGRvTm90RWFnZXJseUV4ZWN1dGU6ICEob3B0aW9ucy5hbGxvd0VhZ2VyRGlzcGF0Y2ggPz8gdHJ1ZSksXG4gICAgICAgIHZlcnNpb25pbmdJbnRlbnQ6IHZlcnNpb25pbmdJbnRlbnRUb1Byb3RvKG9wdGlvbnMudmVyc2lvbmluZ0ludGVudCksIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICAgICAgcHJpb3JpdHk6IG9wdGlvbnMucHJpb3JpdHkgPyBjb21waWxlUHJpb3JpdHkob3B0aW9ucy5wcmlvcml0eSkgOiB1bmRlZmluZWQsXG4gICAgICB9LFxuICAgICAgdXNlck1ldGFkYXRhOiB1c2VyTWV0YWRhdGFUb1BheWxvYWQoYWN0aXZhdG9yLnBheWxvYWRDb252ZXJ0ZXIsIG9wdGlvbnMuc3VtbWFyeSwgdW5kZWZpbmVkKSxcbiAgICB9KTtcbiAgICBhY3RpdmF0b3IuY29tcGxldGlvbnMuYWN0aXZpdHkuc2V0KHNlcSwge1xuICAgICAgcmVzb2x2ZSxcbiAgICAgIHJlamVjdCxcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogUHVzaCBhIHNjaGVkdWxlQWN0aXZpdHkgY29tbWFuZCBpbnRvIHN0YXRlIGFjY3VtdWxhdG9yIGFuZCByZWdpc3RlciBjb21wbGV0aW9uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNjaGVkdWxlTG9jYWxBY3Rpdml0eU5leHRIYW5kbGVyKHtcbiAgb3B0aW9ucyxcbiAgYXJncyxcbiAgaGVhZGVycyxcbiAgc2VxLFxuICBhY3Rpdml0eVR5cGUsXG4gIGF0dGVtcHQsXG4gIG9yaWdpbmFsU2NoZWR1bGVUaW1lLFxufTogTG9jYWxBY3Rpdml0eUlucHV0KTogUHJvbWlzZTx1bmtub3duPiB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGdldEFjdGl2YXRvcigpO1xuICAvLyBFYWdlcmx5IGZhaWwgdGhlIGxvY2FsIGFjdGl2aXR5ICh3aGljaCB3aWxsIGluIHR1cm4gZmFpbCB0aGUgd29ya2Zsb3cgdGFzay5cbiAgLy8gRG8gbm90IGZhaWwgb24gcmVwbGF5IHdoZXJlIHRoZSBsb2NhbCBhY3Rpdml0aWVzIG1heSBub3QgYmUgcmVnaXN0ZXJlZCBvbiB0aGUgcmVwbGF5IHdvcmtlci5cbiAgaWYgKCFhY3RpdmF0b3IuaW5mby51bnNhZmUuaXNSZXBsYXlpbmcgJiYgIWFjdGl2YXRvci5yZWdpc3RlcmVkQWN0aXZpdHlOYW1lcy5oYXMoYWN0aXZpdHlUeXBlKSkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihgTG9jYWwgYWN0aXZpdHkgb2YgdHlwZSAnJHthY3Rpdml0eVR5cGV9JyBub3QgcmVnaXN0ZXJlZCBvbiB3b3JrZXJgKTtcbiAgfVxuICB2YWxpZGF0ZUxvY2FsQWN0aXZpdHlPcHRpb25zKG9wdGlvbnMpO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgc2NvcGUgPSBDYW5jZWxsYXRpb25TY29wZS5jdXJyZW50KCk7XG4gICAgaWYgKHNjb3BlLmNvbnNpZGVyZWRDYW5jZWxsZWQpIHtcbiAgICAgIHVudHJhY2tQcm9taXNlKHNjb3BlLmNhbmNlbFJlcXVlc3RlZC5jYXRjaChyZWplY3QpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNjb3BlLmNhbmNlbGxhYmxlKSB7XG4gICAgICB1bnRyYWNrUHJvbWlzZShcbiAgICAgICAgc2NvcGUuY2FuY2VsUmVxdWVzdGVkLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICBpZiAoIWFjdGl2YXRvci5jb21wbGV0aW9ucy5hY3Rpdml0eS5oYXMoc2VxKSkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBBbHJlYWR5IHJlc29sdmVkIG9yIG5ldmVyIHNjaGVkdWxlZFxuICAgICAgICAgIH1cbiAgICAgICAgICBhY3RpdmF0b3IucHVzaENvbW1hbmQoe1xuICAgICAgICAgICAgcmVxdWVzdENhbmNlbExvY2FsQWN0aXZpdHk6IHtcbiAgICAgICAgICAgICAgc2VxLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGFjdGl2YXRvci5wdXNoQ29tbWFuZCh7XG4gICAgICBzY2hlZHVsZUxvY2FsQWN0aXZpdHk6IHtcbiAgICAgICAgc2VxLFxuICAgICAgICBhdHRlbXB0LFxuICAgICAgICBvcmlnaW5hbFNjaGVkdWxlVGltZSxcbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBub3QgZXhwb3NpbmcgYWN0aXZpdHlJZCBhcyBhbiBvcHRpb25cbiAgICAgICAgYWN0aXZpdHlJZDogYCR7c2VxfWAsXG4gICAgICAgIGFjdGl2aXR5VHlwZSxcbiAgICAgICAgYXJndW1lbnRzOiB0b1BheWxvYWRzKGFjdGl2YXRvci5wYXlsb2FkQ29udmVydGVyLCAuLi5hcmdzKSxcbiAgICAgICAgcmV0cnlQb2xpY3k6IG9wdGlvbnMucmV0cnkgPyBjb21waWxlUmV0cnlQb2xpY3kob3B0aW9ucy5yZXRyeSkgOiB1bmRlZmluZWQsXG4gICAgICAgIHNjaGVkdWxlVG9DbG9zZVRpbWVvdXQ6IG1zT3B0aW9uYWxUb1RzKG9wdGlvbnMuc2NoZWR1bGVUb0Nsb3NlVGltZW91dCksXG4gICAgICAgIHN0YXJ0VG9DbG9zZVRpbWVvdXQ6IG1zT3B0aW9uYWxUb1RzKG9wdGlvbnMuc3RhcnRUb0Nsb3NlVGltZW91dCksXG4gICAgICAgIHNjaGVkdWxlVG9TdGFydFRpbWVvdXQ6IG1zT3B0aW9uYWxUb1RzKG9wdGlvbnMuc2NoZWR1bGVUb1N0YXJ0VGltZW91dCksXG4gICAgICAgIGxvY2FsUmV0cnlUaHJlc2hvbGQ6IG1zT3B0aW9uYWxUb1RzKG9wdGlvbnMubG9jYWxSZXRyeVRocmVzaG9sZCksXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGNhbmNlbGxhdGlvblR5cGU6IGVuY29kZUFjdGl2aXR5Q2FuY2VsbGF0aW9uVHlwZShvcHRpb25zLmNhbmNlbGxhdGlvblR5cGUpLFxuICAgICAgfSxcbiAgICAgIHVzZXJNZXRhZGF0YTogdXNlck1ldGFkYXRhVG9QYXlsb2FkKGFjdGl2YXRvci5wYXlsb2FkQ29udmVydGVyLCBvcHRpb25zLnN1bW1hcnksIHVuZGVmaW5lZCksXG4gICAgfSk7XG4gICAgYWN0aXZhdG9yLmNvbXBsZXRpb25zLmFjdGl2aXR5LnNldChzZXEsIHtcbiAgICAgIHJlc29sdmUsXG4gICAgICByZWplY3QsXG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNjaGVkdWxlIGFuIGFjdGl2aXR5IGFuZCBydW4gb3V0Ym91bmQgaW50ZXJjZXB0b3JzXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2hlZHVsZUFjdGl2aXR5PFI+KGFjdGl2aXR5VHlwZTogc3RyaW5nLCBhcmdzOiBhbnlbXSwgb3B0aW9uczogQWN0aXZpdHlPcHRpb25zKTogUHJvbWlzZTxSPiB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGFzc2VydEluV29ya2Zsb3dDb250ZXh0KFxuICAgICdXb3JrZmxvdy5zY2hlZHVsZUFjdGl2aXR5KC4uLikgbWF5IG9ubHkgYmUgdXNlZCBmcm9tIGEgV29ya2Zsb3cgRXhlY3V0aW9uJ1xuICApO1xuICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignR290IGVtcHR5IGFjdGl2aXR5IG9wdGlvbnMnKTtcbiAgfVxuICBjb25zdCBzZXEgPSBhY3RpdmF0b3IubmV4dFNlcXMuYWN0aXZpdHkrKztcbiAgY29uc3QgZXhlY3V0ZSA9IGNvbXBvc2VJbnRlcmNlcHRvcnMoYWN0aXZhdG9yLmludGVyY2VwdG9ycy5vdXRib3VuZCwgJ3NjaGVkdWxlQWN0aXZpdHknLCBzY2hlZHVsZUFjdGl2aXR5TmV4dEhhbmRsZXIpO1xuXG4gIHJldHVybiBleGVjdXRlKHtcbiAgICBhY3Rpdml0eVR5cGUsXG4gICAgaGVhZGVyczoge30sXG4gICAgb3B0aW9ucyxcbiAgICBhcmdzLFxuICAgIHNlcSxcbiAgfSkgYXMgUHJvbWlzZTxSPjtcbn1cblxuLyoqXG4gKiBTY2hlZHVsZSBhbiBhY3Rpdml0eSBhbmQgcnVuIG91dGJvdW5kIGludGVyY2VwdG9yc1xuICogQGhpZGRlblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2NoZWR1bGVMb2NhbEFjdGl2aXR5PFI+KFxuICBhY3Rpdml0eVR5cGU6IHN0cmluZyxcbiAgYXJnczogYW55W10sXG4gIG9wdGlvbnM6IExvY2FsQWN0aXZpdHlPcHRpb25zXG4pOiBQcm9taXNlPFI+IHtcbiAgY29uc3QgYWN0aXZhdG9yID0gYXNzZXJ0SW5Xb3JrZmxvd0NvbnRleHQoXG4gICAgJ1dvcmtmbG93LnNjaGVkdWxlTG9jYWxBY3Rpdml0eSguLi4pIG1heSBvbmx5IGJlIHVzZWQgZnJvbSBhIFdvcmtmbG93IEV4ZWN1dGlvbidcbiAgKTtcbiAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0dvdCBlbXB0eSBhY3Rpdml0eSBvcHRpb25zJyk7XG4gIH1cblxuICBsZXQgYXR0ZW1wdCA9IDE7XG4gIGxldCBvcmlnaW5hbFNjaGVkdWxlVGltZSA9IHVuZGVmaW5lZDtcblxuICBmb3IgKDs7KSB7XG4gICAgY29uc3Qgc2VxID0gYWN0aXZhdG9yLm5leHRTZXFzLmFjdGl2aXR5Kys7XG4gICAgY29uc3QgZXhlY3V0ZSA9IGNvbXBvc2VJbnRlcmNlcHRvcnMoXG4gICAgICBhY3RpdmF0b3IuaW50ZXJjZXB0b3JzLm91dGJvdW5kLFxuICAgICAgJ3NjaGVkdWxlTG9jYWxBY3Rpdml0eScsXG4gICAgICBzY2hlZHVsZUxvY2FsQWN0aXZpdHlOZXh0SGFuZGxlclxuICAgICk7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChhd2FpdCBleGVjdXRlKHtcbiAgICAgICAgYWN0aXZpdHlUeXBlLFxuICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgYXJncyxcbiAgICAgICAgc2VxLFxuICAgICAgICBhdHRlbXB0LFxuICAgICAgICBvcmlnaW5hbFNjaGVkdWxlVGltZSxcbiAgICAgIH0pKSBhcyBQcm9taXNlPFI+O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIExvY2FsQWN0aXZpdHlEb0JhY2tvZmYpIHtcbiAgICAgICAgYXdhaXQgc2xlZXAocmVxdWlyZWRUc1RvTXMoZXJyLmJhY2tvZmYuYmFja29mZkR1cmF0aW9uLCAnYmFja29mZkR1cmF0aW9uJykpO1xuICAgICAgICBpZiAodHlwZW9mIGVyci5iYWNrb2ZmLmF0dGVtcHQgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBiYWNrb2ZmIGF0dGVtcHQgdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIGF0dGVtcHQgPSBlcnIuYmFja29mZi5hdHRlbXB0O1xuICAgICAgICBvcmlnaW5hbFNjaGVkdWxlVGltZSA9IGVyci5iYWNrb2ZmLm9yaWdpbmFsU2NoZWR1bGVUaW1lID8/IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uTmV4dEhhbmRsZXIoe1xuICBvcHRpb25zLFxuICBoZWFkZXJzLFxuICB3b3JrZmxvd1R5cGUsXG4gIHNlcSxcbn06IFN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbklucHV0KTogUHJvbWlzZTxbUHJvbWlzZTxzdHJpbmc+LCBQcm9taXNlPHVua25vd24+XT4ge1xuICBjb25zdCBhY3RpdmF0b3IgPSBnZXRBY3RpdmF0b3IoKTtcbiAgY29uc3Qgd29ya2Zsb3dJZCA9IG9wdGlvbnMud29ya2Zsb3dJZCA/PyB1dWlkNCgpO1xuICBjb25zdCBzdGFydFByb21pc2UgPSBuZXcgUHJvbWlzZTxzdHJpbmc+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBzY29wZSA9IENhbmNlbGxhdGlvblNjb3BlLmN1cnJlbnQoKTtcbiAgICBpZiAoc2NvcGUuY29uc2lkZXJlZENhbmNlbGxlZCkge1xuICAgICAgdW50cmFja1Byb21pc2Uoc2NvcGUuY2FuY2VsUmVxdWVzdGVkLmNhdGNoKHJlamVjdCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc2NvcGUuY2FuY2VsbGFibGUpIHtcbiAgICAgIHVudHJhY2tQcm9taXNlKFxuICAgICAgICBzY29wZS5jYW5jZWxSZXF1ZXN0ZWQuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbXBsZXRlID0gIWFjdGl2YXRvci5jb21wbGV0aW9ucy5jaGlsZFdvcmtmbG93Q29tcGxldGUuaGFzKHNlcSk7XG5cbiAgICAgICAgICBpZiAoIWNvbXBsZXRlKSB7XG4gICAgICAgICAgICBhY3RpdmF0b3IucHVzaENvbW1hbmQoe1xuICAgICAgICAgICAgICBjYW5jZWxDaGlsZFdvcmtmbG93RXhlY3V0aW9uOiB7IGNoaWxkV29ya2Zsb3dTZXE6IHNlcSB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE5vdGhpbmcgdG8gY2FuY2VsIG90aGVyd2lzZVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgYWN0aXZhdG9yLnB1c2hDb21tYW5kKHtcbiAgICAgIHN0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbjoge1xuICAgICAgICBzZXEsXG4gICAgICAgIHdvcmtmbG93SWQsXG4gICAgICAgIHdvcmtmbG93VHlwZSxcbiAgICAgICAgaW5wdXQ6IHRvUGF5bG9hZHMoYWN0aXZhdG9yLnBheWxvYWRDb252ZXJ0ZXIsIC4uLm9wdGlvbnMuYXJncyksXG4gICAgICAgIHJldHJ5UG9saWN5OiBvcHRpb25zLnJldHJ5ID8gY29tcGlsZVJldHJ5UG9saWN5KG9wdGlvbnMucmV0cnkpIDogdW5kZWZpbmVkLFxuICAgICAgICB0YXNrUXVldWU6IG9wdGlvbnMudGFza1F1ZXVlIHx8IGFjdGl2YXRvci5pbmZvLnRhc2tRdWV1ZSxcbiAgICAgICAgd29ya2Zsb3dFeGVjdXRpb25UaW1lb3V0OiBtc09wdGlvbmFsVG9UcyhvcHRpb25zLndvcmtmbG93RXhlY3V0aW9uVGltZW91dCksXG4gICAgICAgIHdvcmtmbG93UnVuVGltZW91dDogbXNPcHRpb25hbFRvVHMob3B0aW9ucy53b3JrZmxvd1J1blRpbWVvdXQpLFxuICAgICAgICB3b3JrZmxvd1Rhc2tUaW1lb3V0OiBtc09wdGlvbmFsVG9UcyhvcHRpb25zLndvcmtmbG93VGFza1RpbWVvdXQpLFxuICAgICAgICBuYW1lc3BhY2U6IGFjdGl2YXRvci5pbmZvLm5hbWVzcGFjZSwgLy8gTm90IGNvbmZpZ3VyYWJsZVxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBjYW5jZWxsYXRpb25UeXBlOiBlbmNvZGVDaGlsZFdvcmtmbG93Q2FuY2VsbGF0aW9uVHlwZShvcHRpb25zLmNhbmNlbGxhdGlvblR5cGUpLFxuICAgICAgICB3b3JrZmxvd0lkUmV1c2VQb2xpY3k6IGVuY29kZVdvcmtmbG93SWRSZXVzZVBvbGljeShvcHRpb25zLndvcmtmbG93SWRSZXVzZVBvbGljeSksXG4gICAgICAgIHBhcmVudENsb3NlUG9saWN5OiBlbmNvZGVQYXJlbnRDbG9zZVBvbGljeShvcHRpb25zLnBhcmVudENsb3NlUG9saWN5KSxcbiAgICAgICAgY3JvblNjaGVkdWxlOiBvcHRpb25zLmNyb25TY2hlZHVsZSxcbiAgICAgICAgc2VhcmNoQXR0cmlidXRlczpcbiAgICAgICAgICBvcHRpb25zLnNlYXJjaEF0dHJpYnV0ZXMgfHwgb3B0aW9ucy50eXBlZFNlYXJjaEF0dHJpYnV0ZXMgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgICAgICAgICAgPyBlbmNvZGVVbmlmaWVkU2VhcmNoQXR0cmlidXRlcyhvcHRpb25zLnNlYXJjaEF0dHJpYnV0ZXMsIG9wdGlvbnMudHlwZWRTZWFyY2hBdHRyaWJ1dGVzKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgbWVtbzogb3B0aW9ucy5tZW1vICYmIG1hcFRvUGF5bG9hZHMoYWN0aXZhdG9yLnBheWxvYWRDb252ZXJ0ZXIsIG9wdGlvbnMubWVtbyksXG4gICAgICAgIHZlcnNpb25pbmdJbnRlbnQ6IHZlcnNpb25pbmdJbnRlbnRUb1Byb3RvKG9wdGlvbnMudmVyc2lvbmluZ0ludGVudCksIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICAgICAgcHJpb3JpdHk6IG9wdGlvbnMucHJpb3JpdHkgPyBjb21waWxlUHJpb3JpdHkob3B0aW9ucy5wcmlvcml0eSkgOiB1bmRlZmluZWQsXG4gICAgICB9LFxuICAgICAgdXNlck1ldGFkYXRhOiB1c2VyTWV0YWRhdGFUb1BheWxvYWQoYWN0aXZhdG9yLnBheWxvYWRDb252ZXJ0ZXIsIG9wdGlvbnM/LnN0YXRpY1N1bW1hcnksIG9wdGlvbnM/LnN0YXRpY0RldGFpbHMpLFxuICAgIH0pO1xuICAgIGFjdGl2YXRvci5jb21wbGV0aW9ucy5jaGlsZFdvcmtmbG93U3RhcnQuc2V0KHNlcSwge1xuICAgICAgcmVzb2x2ZSxcbiAgICAgIHJlamVjdCxcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gV2UgY29uc3RydWN0IGEgUHJvbWlzZSBmb3IgdGhlIGNvbXBsZXRpb24gb2YgdGhlIGNoaWxkIFdvcmtmbG93IGJlZm9yZSB3ZSBrbm93XG4gIC8vIGlmIHRoZSBXb3JrZmxvdyBjb2RlIHdpbGwgYXdhaXQgaXQgdG8gY2FwdHVyZSB0aGUgcmVzdWx0IGluIGNhc2UgaXQgZG9lcy5cbiAgY29uc3QgY29tcGxldGVQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIC8vIENoYWluIHN0YXJ0IFByb21pc2UgcmVqZWN0aW9uIHRvIHRoZSBjb21wbGV0ZSBQcm9taXNlLlxuICAgIHVudHJhY2tQcm9taXNlKHN0YXJ0UHJvbWlzZS5jYXRjaChyZWplY3QpKTtcbiAgICBhY3RpdmF0b3IuY29tcGxldGlvbnMuY2hpbGRXb3JrZmxvd0NvbXBsZXRlLnNldChzZXEsIHtcbiAgICAgIHJlc29sdmUsXG4gICAgICByZWplY3QsXG4gICAgfSk7XG4gIH0pO1xuICB1bnRyYWNrUHJvbWlzZShzdGFydFByb21pc2UpO1xuICB1bnRyYWNrUHJvbWlzZShjb21wbGV0ZVByb21pc2UpO1xuICAvLyBQcmV2ZW50IHVuaGFuZGxlZCByZWplY3Rpb24gYmVjYXVzZSB0aGUgY29tcGxldGlvbiBtaWdodCBub3QgYmUgYXdhaXRlZFxuICB1bnRyYWNrUHJvbWlzZShjb21wbGV0ZVByb21pc2UuY2F0Y2goKCkgPT4gdW5kZWZpbmVkKSk7XG4gIGNvbnN0IHJldCA9IG5ldyBQcm9taXNlPFtQcm9taXNlPHN0cmluZz4sIFByb21pc2U8dW5rbm93bj5dPigocmVzb2x2ZSkgPT4gcmVzb2x2ZShbc3RhcnRQcm9taXNlLCBjb21wbGV0ZVByb21pc2VdKSk7XG4gIHVudHJhY2tQcm9taXNlKHJldCk7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHNpZ25hbFdvcmtmbG93TmV4dEhhbmRsZXIoeyBzZXEsIHNpZ25hbE5hbWUsIGFyZ3MsIHRhcmdldCwgaGVhZGVycyB9OiBTaWduYWxXb3JrZmxvd0lucHV0KSB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGdldEFjdGl2YXRvcigpO1xuICByZXR1cm4gbmV3IFByb21pc2U8YW55PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3Qgc2NvcGUgPSBDYW5jZWxsYXRpb25TY29wZS5jdXJyZW50KCk7XG4gICAgaWYgKHNjb3BlLmNvbnNpZGVyZWRDYW5jZWxsZWQpIHtcbiAgICAgIHVudHJhY2tQcm9taXNlKHNjb3BlLmNhbmNlbFJlcXVlc3RlZC5jYXRjaChyZWplY3QpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2NvcGUuY2FuY2VsbGFibGUpIHtcbiAgICAgIHVudHJhY2tQcm9taXNlKFxuICAgICAgICBzY29wZS5jYW5jZWxSZXF1ZXN0ZWQuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIGlmICghYWN0aXZhdG9yLmNvbXBsZXRpb25zLnNpZ25hbFdvcmtmbG93LmhhcyhzZXEpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGFjdGl2YXRvci5wdXNoQ29tbWFuZCh7IGNhbmNlbFNpZ25hbFdvcmtmbG93OiB7IHNlcSB9IH0pO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgYWN0aXZhdG9yLnB1c2hDb21tYW5kKHtcbiAgICAgIHNpZ25hbEV4dGVybmFsV29ya2Zsb3dFeGVjdXRpb246IHtcbiAgICAgICAgc2VxLFxuICAgICAgICBhcmdzOiB0b1BheWxvYWRzKGFjdGl2YXRvci5wYXlsb2FkQ29udmVydGVyLCAuLi5hcmdzKSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgc2lnbmFsTmFtZSxcbiAgICAgICAgLi4uKHRhcmdldC50eXBlID09PSAnZXh0ZXJuYWwnXG4gICAgICAgICAgPyB7XG4gICAgICAgICAgICAgIHdvcmtmbG93RXhlY3V0aW9uOiB7XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBhY3RpdmF0b3IuaW5mby5uYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgLi4udGFyZ2V0LndvcmtmbG93RXhlY3V0aW9uLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfVxuICAgICAgICAgIDoge1xuICAgICAgICAgICAgICBjaGlsZFdvcmtmbG93SWQ6IHRhcmdldC5jaGlsZFdvcmtmbG93SWQsXG4gICAgICAgICAgICB9KSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBhY3RpdmF0b3IuY29tcGxldGlvbnMuc2lnbmFsV29ya2Zsb3cuc2V0KHNlcSwgeyByZXNvbHZlLCByZWplY3QgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFN5bWJvbCB1c2VkIGluIHRoZSByZXR1cm4gdHlwZSBvZiBwcm94eSBtZXRob2RzIHRvIG1hcmsgdGhhdCBhbiBhdHRyaWJ1dGUgb24gdGhlIHNvdXJjZSB0eXBlIGlzIG5vdCBhIG1ldGhvZC5cbiAqXG4gKiBAc2VlIHtAbGluayBBY3Rpdml0eUludGVyZmFjZUZvcn1cbiAqIEBzZWUge0BsaW5rIHByb3h5QWN0aXZpdGllc31cbiAqIEBzZWUge0BsaW5rIHByb3h5TG9jYWxBY3Rpdml0aWVzfVxuICovXG5leHBvcnQgY29uc3QgTm90QW5BY3Rpdml0eU1ldGhvZCA9IFN5bWJvbC5mb3IoJ19fVEVNUE9SQUxfTk9UX0FOX0FDVElWSVRZX01FVEhPRCcpO1xuXG4vKipcbiAqIFR5cGUgaGVscGVyIHRoYXQgdGFrZXMgYSB0eXBlIGBUYCBhbmQgdHJhbnNmb3JtcyBhdHRyaWJ1dGVzIHRoYXQgYXJlIG5vdCB7QGxpbmsgQWN0aXZpdHlGdW5jdGlvbn0gdG9cbiAqIHtAbGluayBOb3RBbkFjdGl2aXR5TWV0aG9kfS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIFVzZWQgYnkge0BsaW5rIHByb3h5QWN0aXZpdGllc30gdG8gZ2V0IHRoaXMgY29tcGlsZS10aW1lIGVycm9yOlxuICpcbiAqIGBgYHRzXG4gKiBpbnRlcmZhY2UgTXlBY3Rpdml0aWVzIHtcbiAqICAgdmFsaWQoaW5wdXQ6IG51bWJlcik6IFByb21pc2U8bnVtYmVyPjtcbiAqICAgaW52YWxpZChpbnB1dDogbnVtYmVyKTogbnVtYmVyO1xuICogfVxuICpcbiAqIGNvbnN0IGFjdCA9IHByb3h5QWN0aXZpdGllczxNeUFjdGl2aXRpZXM+KHsgc3RhcnRUb0Nsb3NlVGltZW91dDogJzVtJyB9KTtcbiAqXG4gKiBhd2FpdCBhY3QudmFsaWQodHJ1ZSk7XG4gKiBhd2FpdCBhY3QuaW52YWxpZCgpO1xuICogLy8gXiBUUyBjb21wbGFpbnMgd2l0aDpcbiAqIC8vIChwcm9wZXJ0eSkgaW52YWxpZERlZmluaXRpb246IHR5cGVvZiBOb3RBbkFjdGl2aXR5TWV0aG9kXG4gKiAvLyBUaGlzIGV4cHJlc3Npb24gaXMgbm90IGNhbGxhYmxlLlxuICogLy8gVHlwZSAnU3ltYm9sJyBoYXMgbm8gY2FsbCBzaWduYXR1cmVzLigyMzQ5KVxuICogYGBgXG4gKi9cbmV4cG9ydCB0eXBlIEFjdGl2aXR5SW50ZXJmYWNlRm9yPFQ+ID0ge1xuICBbSyBpbiBrZXlvZiBUXTogVFtLXSBleHRlbmRzIEFjdGl2aXR5RnVuY3Rpb24gPyBBY3Rpdml0eUZ1bmN0aW9uV2l0aE9wdGlvbnM8VFtLXT4gOiB0eXBlb2YgTm90QW5BY3Rpdml0eU1ldGhvZDtcbn07XG5cbmV4cG9ydCB0eXBlIEFjdGl2aXR5RnVuY3Rpb25XaXRoT3B0aW9uczxUIGV4dGVuZHMgQWN0aXZpdHlGdW5jdGlvbj4gPSBUICYge1xuICAvKipcbiAgICogRXhlY3V0ZSB0aGUgYWN0aXZpdHksIG92ZXJyaWRpbmcgaXRzIGV4aXN0aW5nIG9wdGlvbnMgd2l0aCB0aGVcbiAgICogcHJvdmlkZWQgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgQWN0aXZpdHlPcHRpb25zXG4gICAqIEBwYXJhbSBhcmdzOiBsaXN0IG9mIGFyZ3VtZW50c1xuICAgKiBAcmV0dXJucyByZXR1cm4gdmFsdWUgb2YgdGhlIGFjdGl2aXR5XG4gICAqXG4gICAqIEBleHBlcmltZW50YWwgZXhlY3V0ZVdpdGhPcHRpb25zIGlzIGEgbmV3IG1ldGhvZCB0byBwcm92aWRlIGNhbGwtc2l0ZSBvcHRpb25zIGFuZCBpcyBzdWJqZWN0IHRvIGNoYW5nZVxuICAgKi9cbiAgZXhlY3V0ZVdpdGhPcHRpb25zKG9wdGlvbnM6IEFjdGl2aXR5T3B0aW9ucywgYXJnczogUGFyYW1ldGVyczxUPik6IFByb21pc2U8QXdhaXRlZDxSZXR1cm5UeXBlPFQ+Pj47XG59O1xuXG4vKipcbiAqIFRoZSBsb2NhbCBhY3Rpdml0eSBjb3VudGVycGFydCB0byB7QGxpbmsgQWN0aXZpdHlJbnRlcmZhY2VGb3J9XG4gKi9cbmV4cG9ydCB0eXBlIExvY2FsQWN0aXZpdHlJbnRlcmZhY2VGb3I8VD4gPSB7XG4gIFtLIGluIGtleW9mIFRdOiBUW0tdIGV4dGVuZHMgQWN0aXZpdHlGdW5jdGlvbiA/IExvY2FsQWN0aXZpdHlGdW5jdGlvbldpdGhPcHRpb25zPFRbS10+IDogdHlwZW9mIE5vdEFuQWN0aXZpdHlNZXRob2Q7XG59O1xuXG5leHBvcnQgdHlwZSBMb2NhbEFjdGl2aXR5RnVuY3Rpb25XaXRoT3B0aW9uczxUIGV4dGVuZHMgQWN0aXZpdHlGdW5jdGlvbj4gPSBUICYge1xuICAvKipcbiAgICogUnVuIHRoZSBsb2NhbCBhY3Rpdml0eSwgb3ZlcnJpZGluZyBpdHMgZXhpc3Rpbmcgb3B0aW9ucyB3aXRoIHRoZVxuICAgKiBwcm92aWRlZCBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBMb2NhbEFjdGl2aXR5T3B0aW9uc1xuICAgKiBAcGFyYW0gYXJnczogbGlzdCBvZiBhcmd1bWVudHNcbiAgICogQHJldHVybnMgcmV0dXJuIHZhbHVlIG9mIHRoZSBhY3Rpdml0eVxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsIGV4ZWN1dGVXaXRoT3B0aW9ucyBpcyBhIG5ldyBtZXRob2QgdG8gcHJvdmlkZSBjYWxsLXNpdGUgb3B0aW9ucyBhbmQgaXMgc3ViamVjdCB0byBjaGFuZ2VcbiAgICovXG4gIGV4ZWN1dGVXaXRoT3B0aW9ucyhvcHRpb25zOiBMb2NhbEFjdGl2aXR5T3B0aW9ucywgYXJnczogUGFyYW1ldGVyczxUPik6IFByb21pc2U8QXdhaXRlZDxSZXR1cm5UeXBlPFQ+Pj47XG59O1xuXG4vKipcbiAqIENvbmZpZ3VyZSBBY3Rpdml0eSBmdW5jdGlvbnMgd2l0aCBnaXZlbiB7QGxpbmsgQWN0aXZpdHlPcHRpb25zfS5cbiAqXG4gKiBUaGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHRvIHNldHVwIEFjdGl2aXRpZXMgd2l0aCBkaWZmZXJlbnQgb3B0aW9ucy5cbiAqXG4gKiBAcmV0dXJuIGEge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb3h5IHwgUHJveHl9IGZvclxuICogICAgICAgICB3aGljaCBlYWNoIGF0dHJpYnV0ZSBpcyBhIGNhbGxhYmxlIEFjdGl2aXR5IGZ1bmN0aW9uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBwcm94eUFjdGl2aXRpZXMgfSBmcm9tICdAdGVtcG9yYWxpby93b3JrZmxvdyc7XG4gKiBpbXBvcnQgKiBhcyBhY3Rpdml0aWVzIGZyb20gJy4uL2FjdGl2aXRpZXMnO1xuICpcbiAqIC8vIFNldHVwIEFjdGl2aXRpZXMgZnJvbSBtb2R1bGUgZXhwb3J0c1xuICogY29uc3QgeyBodHRwR2V0LCBvdGhlckFjdGl2aXR5IH0gPSBwcm94eUFjdGl2aXRpZXM8dHlwZW9mIGFjdGl2aXRpZXM+KHtcbiAqICAgc3RhcnRUb0Nsb3NlVGltZW91dDogJzMwIG1pbnV0ZXMnLFxuICogfSk7XG4gKlxuICogLy8gVXNlIGFjdGl2aXRpZXMgd2l0aCBkZWZhdWx0IG9wdGlvbnNcbiAqIGNvbnN0IHJlc3VsdDEgPSBhd2FpdCBodHRwR2V0KCdodHRwOi8vZXhhbXBsZS5jb20nKTtcbiAqXG4gKiAvLyBPdmVycmlkZSBvcHRpb25zIGZvciBzcGVjaWZpYyBhY3Rpdml0eSBjYWxsc1xuICogY29uc3QgcmVzdWx0MiA9IGF3YWl0IGh0dHBHZXQuZXhlY3V0ZVdpdGhPcHRpb25zKHtcbiAqICAgc3RhdGljU3VtbWFyeTogJ0ZldGNoZXMgZGF0YSBmcm9tIGV4dGVybmFsIEFQSScsXG4gKiAgIHNjaGVkdWxlVG9DbG9zZVRpbWVvdXQ6ICc1bSdcbiAqIH0sIFsnaHR0cDovL2FwaS5leGFtcGxlLmNvbSddKTtcbiAqXG4gKiBjb25zdCByZXN1bHQzID0gYXdhaXQgb3RoZXJBY3Rpdml0eS5leGVjdXRlV2l0aE9wdGlvbnMoe1xuICogICBzdGF0aWNTdW1tYXJ5OiAnUHJvY2Vzc2VzIHRoZSBmZXRjaGVkIGRhdGEnLFxuICogICB0YXNrUXVldWU6ICdzcGVjaWFsLXRhc2stcXVldWUnXG4gKiB9LCBbZGF0YV0pO1xuICpcbiAqIC8vIFNldHVwIEFjdGl2aXRpZXMgZnJvbSBhbiBleHBsaWNpdCBpbnRlcmZhY2UgKGUuZy4gd2hlbiBkZWZpbmVkIGJ5IGFub3RoZXIgU0RLKVxuICogaW50ZXJmYWNlIEphdmFBY3Rpdml0aWVzIHtcbiAqICAgaHR0cEdldEZyb21KYXZhKHVybDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+XG4gKiAgIHNvbWVPdGhlckphdmFBY3Rpdml0eShhcmcxOiBudW1iZXIsIGFyZzI6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPjtcbiAqIH1cbiAqXG4gKiBjb25zdCB7XG4gKiAgIGh0dHBHZXRGcm9tSmF2YSxcbiAqICAgc29tZU90aGVySmF2YUFjdGl2aXR5XG4gKiB9ID0gcHJveHlBY3Rpdml0aWVzPEphdmFBY3Rpdml0aWVzPih7XG4gKiAgIHRhc2tRdWV1ZTogJ2phdmEtd29ya2VyLXRhc2tRdWV1ZScsXG4gKiAgIHN0YXJ0VG9DbG9zZVRpbWVvdXQ6ICc1bScsXG4gKiB9KTtcbiAqXG4gKiBleHBvcnQgZnVuY3Rpb24gZXhlY3V0ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAqICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBodHRwR2V0KFwiaHR0cDovL2V4YW1wbGUuY29tXCIpO1xuICogICAvLyBPciB3aXRoIGN1c3RvbSBvcHRpb25zOlxuICogICBjb25zdCByZXNwb25zZTIgPSBhd2FpdCBodHRwR2V0RnJvbUphdmEuZXhlY3V0ZVdpdGhPcHRpb25zKHtcbiAqICAgICBzdGF0aWNTdW1tYXJ5OiAnSmF2YSBIVFRQIGNhbGwgd2l0aCB0aW1lb3V0IG92ZXJyaWRlJyxcbiAqICAgICBzdGFydFRvQ2xvc2VUaW1lb3V0OiAnMm0nXG4gKiAgIH0sIFtcImh0dHA6Ly9mYXN0LWFwaS5leGFtcGxlLmNvbVwiXSk7XG4gKiAgIC8vIC4uLlxuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm94eUFjdGl2aXRpZXM8QSA9IFVudHlwZWRBY3Rpdml0aWVzPihvcHRpb25zOiBBY3Rpdml0eU9wdGlvbnMpOiBBY3Rpdml0eUludGVyZmFjZUZvcjxBPiB7XG4gIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIG11c3QgYmUgZGVmaW5lZCcpO1xuICB9XG4gIC8vIFZhbGlkYXRlIGFzIGVhcmx5IGFzIHBvc3NpYmxlIGZvciBpbW1lZGlhdGUgdXNlciBmZWVkYmFja1xuICB2YWxpZGF0ZUFjdGl2aXR5T3B0aW9ucyhvcHRpb25zKTtcblxuICByZXR1cm4gbmV3IFByb3h5KHt9IGFzIEFjdGl2aXR5SW50ZXJmYWNlRm9yPEE+LCB7XG4gICAgZ2V0KF8sIGFjdGl2aXR5VHlwZSkge1xuICAgICAgaWYgKHR5cGVvZiBhY3Rpdml0eVR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE9ubHkgc3RyaW5ncyBhcmUgc3VwcG9ydGVkIGZvciBBY3Rpdml0eSB0eXBlcywgZ290OiAke1N0cmluZyhhY3Rpdml0eVR5cGUpfWApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhY3Rpdml0eVByb3h5RnVuY3Rpb24oLi4uYXJnczogdW5rbm93bltdKTogUHJvbWlzZTx1bmtub3duPiB7XG4gICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGl2aXR5KGFjdGl2aXR5VHlwZSBhcyBzdHJpbmcsIGFyZ3MsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBhY3Rpdml0eVByb3h5RnVuY3Rpb24uZXhlY3V0ZVdpdGhPcHRpb25zID0gZnVuY3Rpb24gKFxuICAgICAgICBvdmVycmlkZU9wdGlvbnM6IEFjdGl2aXR5T3B0aW9ucyxcbiAgICAgICAgYXJnczogYW55W11cbiAgICAgICk6IFByb21pc2U8dW5rbm93bj4ge1xuICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpdml0eShhY3Rpdml0eVR5cGUsIGFyZ3MsIGRlZXBNZXJnZShvcHRpb25zLCBvdmVycmlkZU9wdGlvbnMpKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBhY3Rpdml0eVByb3h5RnVuY3Rpb247XG4gICAgfSxcbiAgfSk7XG59XG5cbi8qKlxuICogQ29uZmlndXJlIExvY2FsIEFjdGl2aXR5IGZ1bmN0aW9ucyB3aXRoIGdpdmVuIHtAbGluayBMb2NhbEFjdGl2aXR5T3B0aW9uc30uXG4gKlxuICogVGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB0byBzZXR1cCBBY3Rpdml0aWVzIHdpdGggZGlmZmVyZW50IG9wdGlvbnMuXG4gKlxuICogQHJldHVybiBhIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9Qcm94eSB8IFByb3h5fVxuICogICAgICAgICBmb3Igd2hpY2ggZWFjaCBhdHRyaWJ1dGUgaXMgYSBjYWxsYWJsZSBBY3Rpdml0eSBmdW5jdGlvblxuICpcbiAqIEBzZWUge0BsaW5rIHByb3h5QWN0aXZpdGllc30gZm9yIGV4YW1wbGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm94eUxvY2FsQWN0aXZpdGllczxBID0gVW50eXBlZEFjdGl2aXRpZXM+KFxuICBvcHRpb25zOiBMb2NhbEFjdGl2aXR5T3B0aW9uc1xuKTogTG9jYWxBY3Rpdml0eUludGVyZmFjZUZvcjxBPiB7XG4gIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIG11c3QgYmUgZGVmaW5lZCcpO1xuICB9XG4gIC8vIFZhbGlkYXRlIGFzIGVhcmx5IGFzIHBvc3NpYmxlIGZvciBpbW1lZGlhdGUgdXNlciBmZWVkYmFja1xuICB2YWxpZGF0ZUxvY2FsQWN0aXZpdHlPcHRpb25zKG9wdGlvbnMpO1xuXG4gIHJldHVybiBuZXcgUHJveHkoe30gYXMgTG9jYWxBY3Rpdml0eUludGVyZmFjZUZvcjxBPiwge1xuICAgIGdldChfLCBhY3Rpdml0eVR5cGUpIHtcbiAgICAgIGlmICh0eXBlb2YgYWN0aXZpdHlUeXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBPbmx5IHN0cmluZ3MgYXJlIHN1cHBvcnRlZCBmb3IgQWN0aXZpdHkgdHlwZXMsIGdvdDogJHtTdHJpbmcoYWN0aXZpdHlUeXBlKX1gKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbG9jYWxBY3Rpdml0eVByb3h5RnVuY3Rpb24oLi4uYXJnczogdW5rbm93bltdKTogUHJvbWlzZTx1bmtub3duPiB7XG4gICAgICAgIHJldHVybiBzY2hlZHVsZUxvY2FsQWN0aXZpdHkoYWN0aXZpdHlUeXBlIGFzIHN0cmluZywgYXJncywgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGxvY2FsQWN0aXZpdHlQcm94eUZ1bmN0aW9uLmV4ZWN1dGVXaXRoT3B0aW9ucyA9IGZ1bmN0aW9uIChcbiAgICAgICAgb3ZlcnJpZGVPcHRpb25zOiBMb2NhbEFjdGl2aXR5T3B0aW9ucyxcbiAgICAgICAgYXJnczogYW55W11cbiAgICAgICk6IFByb21pc2U8dW5rbm93bj4ge1xuICAgICAgICByZXR1cm4gc2NoZWR1bGVMb2NhbEFjdGl2aXR5KGFjdGl2aXR5VHlwZSwgYXJncywgZGVlcE1lcmdlKG9wdGlvbnMsIG92ZXJyaWRlT3B0aW9ucykpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGxvY2FsQWN0aXZpdHlQcm94eUZ1bmN0aW9uO1xuICAgIH0sXG4gIH0pO1xufVxuXG4vLyBUT0RPOiBkZXByZWNhdGUgdGhpcyBwYXRjaCBhZnRlciBcImVub3VnaFwiIHRpbWUgaGFzIHBhc3NlZFxuY29uc3QgRVhURVJOQUxfV0ZfQ0FOQ0VMX1BBVENIID0gJ19fdGVtcG9yYWxfaW50ZXJuYWxfY29ubmVjdF9leHRlcm5hbF9oYW5kbGVfY2FuY2VsX3RvX3Njb3BlJztcbi8vIFRoZSBuYW1lIG9mIHRoaXMgcGF0Y2ggY29tZXMgZnJvbSBhbiBhdHRlbXB0IHRvIGJ1aWxkIGEgZ2VuZXJpYyBpbnRlcm5hbCBwYXRjaGluZyBtZWNoYW5pc20uXG4vLyBUaGF0IGVmZm9ydCBoYXMgYmVlbiBhYmFuZG9uZWQgaW4gZmF2b3Igb2YgYSBuZXdlciBXb3JrZmxvd1Rhc2tDb21wbGV0ZWRNZXRhZGF0YSBiYXNlZCBtZWNoYW5pc20uXG5jb25zdCBDT05ESVRJT05fMF9QQVRDSCA9ICdfX3Nka19pbnRlcm5hbF9wYXRjaF9udW1iZXI6MSc7XG5cbi8qKlxuICogUmV0dXJucyBhIGNsaWVudC1zaWRlIGhhbmRsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHNpZ25hbCBhbmQgY2FuY2VsIGFuIGV4aXN0aW5nIFdvcmtmbG93IGV4ZWN1dGlvbi5cbiAqIEl0IHRha2VzIGEgV29ya2Zsb3cgSUQgYW5kIG9wdGlvbmFsIHJ1biBJRC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEV4dGVybmFsV29ya2Zsb3dIYW5kbGUod29ya2Zsb3dJZDogc3RyaW5nLCBydW5JZD86IHN0cmluZyk6IEV4dGVybmFsV29ya2Zsb3dIYW5kbGUge1xuICBjb25zdCBhY3RpdmF0b3IgPSBhc3NlcnRJbldvcmtmbG93Q29udGV4dChcbiAgICAnV29ya2Zsb3cuZ2V0RXh0ZXJuYWxXb3JrZmxvd0hhbmRsZSguLi4pIG1heSBvbmx5IGJlIHVzZWQgZnJvbSBhIFdvcmtmbG93IEV4ZWN1dGlvbi4gQ29uc2lkZXIgdXNpbmcgQ2xpZW50LndvcmtmbG93LmdldEhhbmRsZSguLi4pIGluc3RlYWQuKSdcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICB3b3JrZmxvd0lkLFxuICAgIHJ1bklkLFxuICAgIGNhbmNlbCgpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIC8vIENvbm5lY3QgdGhpcyBjYW5jZWwgb3BlcmF0aW9uIHRvIHRoZSBjdXJyZW50IGNhbmNlbGxhdGlvbiBzY29wZS5cbiAgICAgICAgLy8gVGhpcyBpcyBiZWhhdmlvciB3YXMgaW50cm9kdWNlZCBhZnRlciB2MC4yMi4wIGFuZCBpcyBpbmNvbXBhdGlibGVcbiAgICAgICAgLy8gd2l0aCBoaXN0b3JpZXMgZ2VuZXJhdGVkIHdpdGggcHJldmlvdXMgU0RLIHZlcnNpb25zIGFuZCB0aHVzIHJlcXVpcmVzXG4gICAgICAgIC8vIHBhdGNoaW5nLlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSB0cnkgdG8gZGVsYXkgcGF0Y2hpbmcgYXMgbXVjaCBhcyBwb3NzaWJsZSB0byBhdm9pZCBwb2xsdXRpbmdcbiAgICAgICAgLy8gaGlzdG9yaWVzIHVubGVzcyBzdHJpY3RseSByZXF1aXJlZC5cbiAgICAgICAgY29uc3Qgc2NvcGUgPSBDYW5jZWxsYXRpb25TY29wZS5jdXJyZW50KCk7XG4gICAgICAgIGlmIChzY29wZS5jYW5jZWxsYWJsZSkge1xuICAgICAgICAgIHVudHJhY2tQcm9taXNlKFxuICAgICAgICAgICAgc2NvcGUuY2FuY2VsUmVxdWVzdGVkLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHBhdGNoZWQoRVhURVJOQUxfV0ZfQ0FOQ0VMX1BBVENIKSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjb3BlLmNvbnNpZGVyZWRDYW5jZWxsZWQpIHtcbiAgICAgICAgICBpZiAocGF0Y2hlZChFWFRFUk5BTF9XRl9DQU5DRUxfUEFUQ0gpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2VxID0gYWN0aXZhdG9yLm5leHRTZXFzLmNhbmNlbFdvcmtmbG93Kys7XG4gICAgICAgIGFjdGl2YXRvci5wdXNoQ29tbWFuZCh7XG4gICAgICAgICAgcmVxdWVzdENhbmNlbEV4dGVybmFsV29ya2Zsb3dFeGVjdXRpb246IHtcbiAgICAgICAgICAgIHNlcSxcbiAgICAgICAgICAgIHdvcmtmbG93RXhlY3V0aW9uOiB7XG4gICAgICAgICAgICAgIG5hbWVzcGFjZTogYWN0aXZhdG9yLmluZm8ubmFtZXNwYWNlLFxuICAgICAgICAgICAgICB3b3JrZmxvd0lkLFxuICAgICAgICAgICAgICBydW5JZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGFjdGl2YXRvci5jb21wbGV0aW9ucy5jYW5jZWxXb3JrZmxvdy5zZXQoc2VxLCB7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc2lnbmFsPEFyZ3MgZXh0ZW5kcyBhbnlbXT4oZGVmOiBTaWduYWxEZWZpbml0aW9uPEFyZ3M+IHwgc3RyaW5nLCAuLi5hcmdzOiBBcmdzKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICByZXR1cm4gY29tcG9zZUludGVyY2VwdG9ycyhcbiAgICAgICAgYWN0aXZhdG9yLmludGVyY2VwdG9ycy5vdXRib3VuZCxcbiAgICAgICAgJ3NpZ25hbFdvcmtmbG93JyxcbiAgICAgICAgc2lnbmFsV29ya2Zsb3dOZXh0SGFuZGxlclxuICAgICAgKSh7XG4gICAgICAgIHNlcTogYWN0aXZhdG9yLm5leHRTZXFzLnNpZ25hbFdvcmtmbG93KyssXG4gICAgICAgIHNpZ25hbE5hbWU6IHR5cGVvZiBkZWYgPT09ICdzdHJpbmcnID8gZGVmIDogZGVmLm5hbWUsXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIHRhcmdldDoge1xuICAgICAgICAgIHR5cGU6ICdleHRlcm5hbCcsXG4gICAgICAgICAgd29ya2Zsb3dFeGVjdXRpb246IHsgd29ya2Zsb3dJZCwgcnVuSWQgfSxcbiAgICAgICAgfSxcbiAgICAgICAgaGVhZGVyczoge30sXG4gICAgICB9KTtcbiAgICB9LFxuICB9O1xufVxuXG4vKipcbiAqIFN0YXJ0IGEgY2hpbGQgV29ya2Zsb3cgZXhlY3V0aW9uXG4gKlxuICogLSBSZXR1cm5zIGEgY2xpZW50LXNpZGUgaGFuZGxlIHRoYXQgaW1wbGVtZW50cyBhIGNoaWxkIFdvcmtmbG93IGludGVyZmFjZS5cbiAqIC0gQnkgZGVmYXVsdCwgYSBjaGlsZCB3aWxsIGJlIHNjaGVkdWxlZCBvbiB0aGUgc2FtZSB0YXNrIHF1ZXVlIGFzIGl0cyBwYXJlbnQuXG4gKlxuICogQSBjaGlsZCBXb3JrZmxvdyBoYW5kbGUgc3VwcG9ydHMgYXdhaXRpbmcgY29tcGxldGlvbiwgc2lnbmFsaW5nIGFuZCBjYW5jZWxsYXRpb24gdmlhIHtAbGluayBDYW5jZWxsYXRpb25TY29wZX1zLlxuICogSW4gb3JkZXIgdG8gcXVlcnkgdGhlIGNoaWxkLCB1c2UgYSB7QGxpbmsgV29ya2Zsb3dDbGllbnR9IGZyb20gYW4gQWN0aXZpdHkuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdGFydENoaWxkPFQgZXh0ZW5kcyBXb3JrZmxvdz4oXG4gIHdvcmtmbG93VHlwZTogc3RyaW5nLFxuICBvcHRpb25zOiBXaXRoV29ya2Zsb3dBcmdzPFQsIENoaWxkV29ya2Zsb3dPcHRpb25zPlxuKTogUHJvbWlzZTxDaGlsZFdvcmtmbG93SGFuZGxlPFQ+PjtcblxuLyoqXG4gKiBTdGFydCBhIGNoaWxkIFdvcmtmbG93IGV4ZWN1dGlvblxuICpcbiAqIC0gUmV0dXJucyBhIGNsaWVudC1zaWRlIGhhbmRsZSB0aGF0IGltcGxlbWVudHMgYSBjaGlsZCBXb3JrZmxvdyBpbnRlcmZhY2UuXG4gKiAtIERlZHVjZXMgdGhlIFdvcmtmbG93IHR5cGUgYW5kIHNpZ25hdHVyZSBmcm9tIHByb3ZpZGVkIFdvcmtmbG93IGZ1bmN0aW9uLlxuICogLSBCeSBkZWZhdWx0LCBhIGNoaWxkIHdpbGwgYmUgc2NoZWR1bGVkIG9uIHRoZSBzYW1lIHRhc2sgcXVldWUgYXMgaXRzIHBhcmVudC5cbiAqXG4gKiBBIGNoaWxkIFdvcmtmbG93IGhhbmRsZSBzdXBwb3J0cyBhd2FpdGluZyBjb21wbGV0aW9uLCBzaWduYWxpbmcgYW5kIGNhbmNlbGxhdGlvbiB2aWEge0BsaW5rIENhbmNlbGxhdGlvblNjb3BlfXMuXG4gKiBJbiBvcmRlciB0byBxdWVyeSB0aGUgY2hpbGQsIHVzZSBhIHtAbGluayBXb3JrZmxvd0NsaWVudH0gZnJvbSBhbiBBY3Rpdml0eS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0YXJ0Q2hpbGQ8VCBleHRlbmRzIFdvcmtmbG93PihcbiAgd29ya2Zsb3dGdW5jOiBULFxuICBvcHRpb25zOiBXaXRoV29ya2Zsb3dBcmdzPFQsIENoaWxkV29ya2Zsb3dPcHRpb25zPlxuKTogUHJvbWlzZTxDaGlsZFdvcmtmbG93SGFuZGxlPFQ+PjtcblxuLyoqXG4gKiBTdGFydCBhIGNoaWxkIFdvcmtmbG93IGV4ZWN1dGlvblxuICpcbiAqICoqT3ZlcnJpZGUgZm9yIFdvcmtmbG93cyB0aGF0IGFjY2VwdCBubyBhcmd1bWVudHMqKi5cbiAqXG4gKiAtIFJldHVybnMgYSBjbGllbnQtc2lkZSBoYW5kbGUgdGhhdCBpbXBsZW1lbnRzIGEgY2hpbGQgV29ya2Zsb3cgaW50ZXJmYWNlLlxuICogLSBUaGUgY2hpbGQgd2lsbCBiZSBzY2hlZHVsZWQgb24gdGhlIHNhbWUgdGFzayBxdWV1ZSBhcyBpdHMgcGFyZW50LlxuICpcbiAqIEEgY2hpbGQgV29ya2Zsb3cgaGFuZGxlIHN1cHBvcnRzIGF3YWl0aW5nIGNvbXBsZXRpb24sIHNpZ25hbGluZyBhbmQgY2FuY2VsbGF0aW9uIHZpYSB7QGxpbmsgQ2FuY2VsbGF0aW9uU2NvcGV9cy5cbiAqIEluIG9yZGVyIHRvIHF1ZXJ5IHRoZSBjaGlsZCwgdXNlIGEge0BsaW5rIFdvcmtmbG93Q2xpZW50fSBmcm9tIGFuIEFjdGl2aXR5LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RhcnRDaGlsZDxUIGV4dGVuZHMgKCkgPT4gUHJvbWlzZTxhbnk+Pih3b3JrZmxvd1R5cGU6IHN0cmluZyk6IFByb21pc2U8Q2hpbGRXb3JrZmxvd0hhbmRsZTxUPj47XG5cbi8qKlxuICogU3RhcnQgYSBjaGlsZCBXb3JrZmxvdyBleGVjdXRpb25cbiAqXG4gKiAqKk92ZXJyaWRlIGZvciBXb3JrZmxvd3MgdGhhdCBhY2NlcHQgbm8gYXJndW1lbnRzKiouXG4gKlxuICogLSBSZXR1cm5zIGEgY2xpZW50LXNpZGUgaGFuZGxlIHRoYXQgaW1wbGVtZW50cyBhIGNoaWxkIFdvcmtmbG93IGludGVyZmFjZS5cbiAqIC0gRGVkdWNlcyB0aGUgV29ya2Zsb3cgdHlwZSBhbmQgc2lnbmF0dXJlIGZyb20gcHJvdmlkZWQgV29ya2Zsb3cgZnVuY3Rpb24uXG4gKiAtIFRoZSBjaGlsZCB3aWxsIGJlIHNjaGVkdWxlZCBvbiB0aGUgc2FtZSB0YXNrIHF1ZXVlIGFzIGl0cyBwYXJlbnQuXG4gKlxuICogQSBjaGlsZCBXb3JrZmxvdyBoYW5kbGUgc3VwcG9ydHMgYXdhaXRpbmcgY29tcGxldGlvbiwgc2lnbmFsaW5nIGFuZCBjYW5jZWxsYXRpb24gdmlhIHtAbGluayBDYW5jZWxsYXRpb25TY29wZX1zLlxuICogSW4gb3JkZXIgdG8gcXVlcnkgdGhlIGNoaWxkLCB1c2UgYSB7QGxpbmsgV29ya2Zsb3dDbGllbnR9IGZyb20gYW4gQWN0aXZpdHkuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdGFydENoaWxkPFQgZXh0ZW5kcyAoKSA9PiBQcm9taXNlPGFueT4+KHdvcmtmbG93RnVuYzogVCk6IFByb21pc2U8Q2hpbGRXb3JrZmxvd0hhbmRsZTxUPj47XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdGFydENoaWxkPFQgZXh0ZW5kcyBXb3JrZmxvdz4oXG4gIHdvcmtmbG93VHlwZU9yRnVuYzogc3RyaW5nIHwgVCxcbiAgb3B0aW9ucz86IFdpdGhXb3JrZmxvd0FyZ3M8VCwgQ2hpbGRXb3JrZmxvd09wdGlvbnM+XG4pOiBQcm9taXNlPENoaWxkV29ya2Zsb3dIYW5kbGU8VD4+IHtcbiAgY29uc3QgYWN0aXZhdG9yID0gYXNzZXJ0SW5Xb3JrZmxvd0NvbnRleHQoXG4gICAgJ1dvcmtmbG93LnN0YXJ0Q2hpbGQoLi4uKSBtYXkgb25seSBiZSB1c2VkIGZyb20gYSBXb3JrZmxvdyBFeGVjdXRpb24uIENvbnNpZGVyIHVzaW5nIENsaWVudC53b3JrZmxvdy5zdGFydCguLi4pIGluc3RlYWQuKSdcbiAgKTtcbiAgY29uc3Qgb3B0aW9uc1dpdGhEZWZhdWx0cyA9IGFkZERlZmF1bHRXb3JrZmxvd09wdGlvbnMob3B0aW9ucyA/PyAoe30gYXMgYW55KSk7XG4gIGNvbnN0IHdvcmtmbG93VHlwZSA9IGV4dHJhY3RXb3JrZmxvd1R5cGUod29ya2Zsb3dUeXBlT3JGdW5jKTtcbiAgY29uc3QgZXhlY3V0ZSA9IGNvbXBvc2VJbnRlcmNlcHRvcnMoXG4gICAgYWN0aXZhdG9yLmludGVyY2VwdG9ycy5vdXRib3VuZCxcbiAgICAnc3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uJyxcbiAgICBzdGFydENoaWxkV29ya2Zsb3dFeGVjdXRpb25OZXh0SGFuZGxlclxuICApO1xuICBjb25zdCBbc3RhcnRlZCwgY29tcGxldGVkXSA9IGF3YWl0IGV4ZWN1dGUoe1xuICAgIHNlcTogYWN0aXZhdG9yLm5leHRTZXFzLmNoaWxkV29ya2Zsb3crKyxcbiAgICBvcHRpb25zOiBvcHRpb25zV2l0aERlZmF1bHRzLFxuICAgIGhlYWRlcnM6IHt9LFxuICAgIHdvcmtmbG93VHlwZSxcbiAgfSk7XG4gIGNvbnN0IGZpcnN0RXhlY3V0aW9uUnVuSWQgPSBhd2FpdCBzdGFydGVkO1xuXG4gIHJldHVybiB7XG4gICAgd29ya2Zsb3dJZDogb3B0aW9uc1dpdGhEZWZhdWx0cy53b3JrZmxvd0lkLFxuICAgIGZpcnN0RXhlY3V0aW9uUnVuSWQsXG4gICAgYXN5bmMgcmVzdWx0KCk6IFByb21pc2U8V29ya2Zsb3dSZXN1bHRUeXBlPFQ+PiB7XG4gICAgICByZXR1cm4gKGF3YWl0IGNvbXBsZXRlZCkgYXMgYW55O1xuICAgIH0sXG4gICAgYXN5bmMgc2lnbmFsPEFyZ3MgZXh0ZW5kcyBhbnlbXT4oZGVmOiBTaWduYWxEZWZpbml0aW9uPEFyZ3M+IHwgc3RyaW5nLCAuLi5hcmdzOiBBcmdzKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICByZXR1cm4gY29tcG9zZUludGVyY2VwdG9ycyhcbiAgICAgICAgYWN0aXZhdG9yLmludGVyY2VwdG9ycy5vdXRib3VuZCxcbiAgICAgICAgJ3NpZ25hbFdvcmtmbG93JyxcbiAgICAgICAgc2lnbmFsV29ya2Zsb3dOZXh0SGFuZGxlclxuICAgICAgKSh7XG4gICAgICAgIHNlcTogYWN0aXZhdG9yLm5leHRTZXFzLnNpZ25hbFdvcmtmbG93KyssXG4gICAgICAgIHNpZ25hbE5hbWU6IHR5cGVvZiBkZWYgPT09ICdzdHJpbmcnID8gZGVmIDogZGVmLm5hbWUsXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIHRhcmdldDoge1xuICAgICAgICAgIHR5cGU6ICdjaGlsZCcsXG4gICAgICAgICAgY2hpbGRXb3JrZmxvd0lkOiBvcHRpb25zV2l0aERlZmF1bHRzLndvcmtmbG93SWQsXG4gICAgICAgIH0sXG4gICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgfSk7XG4gICAgfSxcbiAgfTtcbn1cblxuLyoqXG4gKiBTdGFydCBhIGNoaWxkIFdvcmtmbG93IGV4ZWN1dGlvbiBhbmQgYXdhaXQgaXRzIGNvbXBsZXRpb24uXG4gKlxuICogLSBCeSBkZWZhdWx0LCBhIGNoaWxkIHdpbGwgYmUgc2NoZWR1bGVkIG9uIHRoZSBzYW1lIHRhc2sgcXVldWUgYXMgaXRzIHBhcmVudC5cbiAqIC0gVGhpcyBvcGVyYXRpb24gaXMgY2FuY2VsbGFibGUgdXNpbmcge0BsaW5rIENhbmNlbGxhdGlvblNjb3BlfXMuXG4gKlxuICogQHJldHVybiBUaGUgcmVzdWx0IG9mIHRoZSBjaGlsZCBXb3JrZmxvdy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVDaGlsZDxUIGV4dGVuZHMgV29ya2Zsb3c+KFxuICB3b3JrZmxvd1R5cGU6IHN0cmluZyxcbiAgb3B0aW9uczogV2l0aFdvcmtmbG93QXJnczxULCBDaGlsZFdvcmtmbG93T3B0aW9ucz5cbik6IFByb21pc2U8V29ya2Zsb3dSZXN1bHRUeXBlPFQ+PjtcblxuLyoqXG4gKiBTdGFydCBhIGNoaWxkIFdvcmtmbG93IGV4ZWN1dGlvbiBhbmQgYXdhaXQgaXRzIGNvbXBsZXRpb24uXG4gKlxuICogLSBCeSBkZWZhdWx0LCBhIGNoaWxkIHdpbGwgYmUgc2NoZWR1bGVkIG9uIHRoZSBzYW1lIHRhc2sgcXVldWUgYXMgaXRzIHBhcmVudC5cbiAqIC0gRGVkdWNlcyB0aGUgV29ya2Zsb3cgdHlwZSBhbmQgc2lnbmF0dXJlIGZyb20gcHJvdmlkZWQgV29ya2Zsb3cgZnVuY3Rpb24uXG4gKiAtIFRoaXMgb3BlcmF0aW9uIGlzIGNhbmNlbGxhYmxlIHVzaW5nIHtAbGluayBDYW5jZWxsYXRpb25TY29wZX1zLlxuICpcbiAqIEByZXR1cm4gVGhlIHJlc3VsdCBvZiB0aGUgY2hpbGQgV29ya2Zsb3cuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleGVjdXRlQ2hpbGQ8VCBleHRlbmRzIFdvcmtmbG93PihcbiAgd29ya2Zsb3dGdW5jOiBULFxuICBvcHRpb25zOiBXaXRoV29ya2Zsb3dBcmdzPFQsIENoaWxkV29ya2Zsb3dPcHRpb25zPlxuKTogUHJvbWlzZTxXb3JrZmxvd1Jlc3VsdFR5cGU8VD4+O1xuXG4vKipcbiAqIFN0YXJ0IGEgY2hpbGQgV29ya2Zsb3cgZXhlY3V0aW9uIGFuZCBhd2FpdCBpdHMgY29tcGxldGlvbi5cbiAqXG4gKiAqKk92ZXJyaWRlIGZvciBXb3JrZmxvd3MgdGhhdCBhY2NlcHQgbm8gYXJndW1lbnRzKiouXG4gKlxuICogLSBUaGUgY2hpbGQgd2lsbCBiZSBzY2hlZHVsZWQgb24gdGhlIHNhbWUgdGFzayBxdWV1ZSBhcyBpdHMgcGFyZW50LlxuICogLSBUaGlzIG9wZXJhdGlvbiBpcyBjYW5jZWxsYWJsZSB1c2luZyB7QGxpbmsgQ2FuY2VsbGF0aW9uU2NvcGV9cy5cbiAqXG4gKiBAcmV0dXJuIFRoZSByZXN1bHQgb2YgdGhlIGNoaWxkIFdvcmtmbG93LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZUNoaWxkPFQgZXh0ZW5kcyAoKSA9PiBXb3JrZmxvd1JldHVyblR5cGU+KFxuICB3b3JrZmxvd1R5cGU6IHN0cmluZ1xuKTogUHJvbWlzZTxXb3JrZmxvd1Jlc3VsdFR5cGU8VD4+O1xuXG4vKipcbiAqIFN0YXJ0IGEgY2hpbGQgV29ya2Zsb3cgZXhlY3V0aW9uIGFuZCBhd2FpdCBpdHMgY29tcGxldGlvbi5cbiAqXG4gKiAqKk92ZXJyaWRlIGZvciBXb3JrZmxvd3MgdGhhdCBhY2NlcHQgbm8gYXJndW1lbnRzKiouXG4gKlxuICogLSBUaGUgY2hpbGQgd2lsbCBiZSBzY2hlZHVsZWQgb24gdGhlIHNhbWUgdGFzayBxdWV1ZSBhcyBpdHMgcGFyZW50LlxuICogLSBEZWR1Y2VzIHRoZSBXb3JrZmxvdyB0eXBlIGFuZCBzaWduYXR1cmUgZnJvbSBwcm92aWRlZCBXb3JrZmxvdyBmdW5jdGlvbi5cbiAqIC0gVGhpcyBvcGVyYXRpb24gaXMgY2FuY2VsbGFibGUgdXNpbmcge0BsaW5rIENhbmNlbGxhdGlvblNjb3BlfXMuXG4gKlxuICogQHJldHVybiBUaGUgcmVzdWx0IG9mIHRoZSBjaGlsZCBXb3JrZmxvdy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVDaGlsZDxUIGV4dGVuZHMgKCkgPT4gV29ya2Zsb3dSZXR1cm5UeXBlPih3b3JrZmxvd0Z1bmM6IFQpOiBQcm9taXNlPFdvcmtmbG93UmVzdWx0VHlwZTxUPj47XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleGVjdXRlQ2hpbGQ8VCBleHRlbmRzIFdvcmtmbG93PihcbiAgd29ya2Zsb3dUeXBlT3JGdW5jOiBzdHJpbmcgfCBULFxuICBvcHRpb25zPzogV2l0aFdvcmtmbG93QXJnczxULCBDaGlsZFdvcmtmbG93T3B0aW9ucz5cbik6IFByb21pc2U8V29ya2Zsb3dSZXN1bHRUeXBlPFQ+PiB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGFzc2VydEluV29ya2Zsb3dDb250ZXh0KFxuICAgICdXb3JrZmxvdy5leGVjdXRlQ2hpbGQoLi4uKSBtYXkgb25seSBiZSB1c2VkIGZyb20gYSBXb3JrZmxvdyBFeGVjdXRpb24uIENvbnNpZGVyIHVzaW5nIENsaWVudC53b3JrZmxvdy5leGVjdXRlKC4uLikgaW5zdGVhZC4nXG4gICk7XG4gIGNvbnN0IG9wdGlvbnNXaXRoRGVmYXVsdHMgPSBhZGREZWZhdWx0V29ya2Zsb3dPcHRpb25zKG9wdGlvbnMgPz8gKHt9IGFzIGFueSkpO1xuICBjb25zdCB3b3JrZmxvd1R5cGUgPSBleHRyYWN0V29ya2Zsb3dUeXBlKHdvcmtmbG93VHlwZU9yRnVuYyk7XG4gIGNvbnN0IGV4ZWN1dGUgPSBjb21wb3NlSW50ZXJjZXB0b3JzKFxuICAgIGFjdGl2YXRvci5pbnRlcmNlcHRvcnMub3V0Ym91bmQsXG4gICAgJ3N0YXJ0Q2hpbGRXb3JrZmxvd0V4ZWN1dGlvbicsXG4gICAgc3RhcnRDaGlsZFdvcmtmbG93RXhlY3V0aW9uTmV4dEhhbmRsZXJcbiAgKTtcbiAgY29uc3QgZXhlY1Byb21pc2UgPSBleGVjdXRlKHtcbiAgICBzZXE6IGFjdGl2YXRvci5uZXh0U2Vxcy5jaGlsZFdvcmtmbG93KyssXG4gICAgb3B0aW9uczogb3B0aW9uc1dpdGhEZWZhdWx0cyxcbiAgICBoZWFkZXJzOiB7fSxcbiAgICB3b3JrZmxvd1R5cGUsXG4gIH0pO1xuICB1bnRyYWNrUHJvbWlzZShleGVjUHJvbWlzZSk7XG4gIGNvbnN0IGNvbXBsZXRlZFByb21pc2UgPSBleGVjUHJvbWlzZS50aGVuKChbX3N0YXJ0ZWQsIGNvbXBsZXRlZF0pID0+IGNvbXBsZXRlZCk7XG4gIHVudHJhY2tQcm9taXNlKGNvbXBsZXRlZFByb21pc2UpO1xuICByZXR1cm4gY29tcGxldGVkUHJvbWlzZSBhcyBQcm9taXNlPGFueT47XG59XG5cbi8qKlxuICogR2V0IGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IFdvcmtmbG93LlxuICpcbiAqIFdBUk5JTkc6IFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIGZyb3plbiBjb3B5IG9mIFdvcmtmbG93SW5mbywgYXQgdGhlIHBvaW50IHdoZXJlIHRoaXMgbWV0aG9kIGhhcyBiZWVuIGNhbGxlZC5cbiAqIENoYW5nZXMgaGFwcGVuaW5nIGF0IGxhdGVyIHBvaW50IGluIHdvcmtmbG93IGV4ZWN1dGlvbiB3aWxsIG5vdCBiZSByZWZsZWN0ZWQgaW4gdGhlIHJldHVybmVkIG9iamVjdC5cbiAqXG4gKiBGb3IgdGhpcyByZWFzb24sIHdlIHJlY29tbWVuZCBjYWxsaW5nIGB3b3JrZmxvd0luZm8oKWAgb24gZXZlcnkgYWNjZXNzIHRvIHtAbGluayBXb3JrZmxvd0luZm99J3MgZmllbGRzLFxuICogcmF0aGVyIHRoYW4gY2FjaGluZyB0aGUgYFdvcmtmbG93SW5mb2Agb2JqZWN0IChvciBwYXJ0IG9mIGl0KSBpbiBhIGxvY2FsIHZhcmlhYmxlLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGB0c1xuICogLy8gR09PRFxuICogZnVuY3Rpb24gbXlXb3JrZmxvdygpIHtcbiAqICAgZG9Tb21ldGhpbmcod29ya2Zsb3dJbmZvKCkuc2VhcmNoQXR0cmlidXRlcylcbiAqICAgLi4uXG4gKiAgIGRvU29tZXRoaW5nRWxzZSh3b3JrZmxvd0luZm8oKS5zZWFyY2hBdHRyaWJ1dGVzKVxuICogfVxuICogYGBgXG4gKlxuICogdnNcbiAqXG4gKiBgYGB0c1xuICogLy8gQkFEXG4gKiBmdW5jdGlvbiBteVdvcmtmbG93KCkge1xuICogICBjb25zdCBhdHRyaWJ1dGVzID0gd29ya2Zsb3dJbmZvKCkuc2VhcmNoQXR0cmlidXRlc1xuICogICBkb1NvbWV0aGluZyhhdHRyaWJ1dGVzKVxuICogICAuLi5cbiAqICAgZG9Tb21ldGhpbmdFbHNlKGF0dHJpYnV0ZXMpXG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdvcmtmbG93SW5mbygpOiBXb3JrZmxvd0luZm8ge1xuICBjb25zdCBhY3RpdmF0b3IgPSBhc3NlcnRJbldvcmtmbG93Q29udGV4dCgnV29ya2Zsb3cud29ya2Zsb3dJbmZvKC4uLikgbWF5IG9ubHkgYmUgdXNlZCBmcm9tIGEgV29ya2Zsb3cgRXhlY3V0aW9uLicpO1xuICByZXR1cm4gYWN0aXZhdG9yLmluZm87XG59XG5cbi8qKlxuICogR2V0IGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IHVwZGF0ZSBpZiBhbnkuXG4gKlxuICogQHJldHVybiBJbmZvIGZvciB0aGUgY3VycmVudCB1cGRhdGUgaGFuZGxlciB0aGUgY29kZSBjYWxsaW5nIHRoaXMgaXMgZXhlY3V0aW5nXG4gKiB3aXRoaW4gaWYgYW55LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3VycmVudFVwZGF0ZUluZm8oKTogVXBkYXRlSW5mbyB8IHVuZGVmaW5lZCB7XG4gIGFzc2VydEluV29ya2Zsb3dDb250ZXh0KCdXb3JrZmxvdy5jdXJyZW50VXBkYXRlSW5mbyguLi4pIG1heSBvbmx5IGJlIHVzZWQgZnJvbSBhIFdvcmtmbG93IEV4ZWN1dGlvbi4nKTtcbiAgcmV0dXJuIFVwZGF0ZVNjb3BlLmN1cnJlbnQoKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGNvZGUgaXMgZXhlY3V0aW5nIGluIHdvcmtmbG93IGNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluV29ya2Zsb3dDb250ZXh0KCk6IGJvb2xlYW4ge1xuICByZXR1cm4gbWF5YmVHZXRBY3RpdmF0b3IoKSAhPT0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiBgZmAgdGhhdCB3aWxsIGNhdXNlIHRoZSBjdXJyZW50IFdvcmtmbG93IHRvIENvbnRpbnVlQXNOZXcgd2hlbiBjYWxsZWQuXG4gKlxuICogYGZgIHRha2VzIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyB0aGUgV29ya2Zsb3cgZnVuY3Rpb24gc3VwcGxpZWQgdG8gdHlwZXBhcmFtIGBGYC5cbiAqXG4gKiBPbmNlIGBmYCBpcyBjYWxsZWQsIFdvcmtmbG93IEV4ZWN1dGlvbiBpbW1lZGlhdGVseSBjb21wbGV0ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQ29udGludWVBc05ld0Z1bmM8RiBleHRlbmRzIFdvcmtmbG93PihcbiAgb3B0aW9ucz86IENvbnRpbnVlQXNOZXdPcHRpb25zXG4pOiAoLi4uYXJnczogUGFyYW1ldGVyczxGPikgPT4gUHJvbWlzZTxuZXZlcj4ge1xuICBjb25zdCBhY3RpdmF0b3IgPSBhc3NlcnRJbldvcmtmbG93Q29udGV4dChcbiAgICAnV29ya2Zsb3cuY29udGludWVBc05ldyguLi4pIGFuZCBXb3JrZmxvdy5tYWtlQ29udGludWVBc05ld0Z1bmMoLi4uKSBtYXkgb25seSBiZSB1c2VkIGZyb20gYSBXb3JrZmxvdyBFeGVjdXRpb24uJ1xuICApO1xuICBjb25zdCBpbmZvID0gYWN0aXZhdG9yLmluZm87XG4gIGNvbnN0IHsgd29ya2Zsb3dUeXBlLCB0YXNrUXVldWUsIC4uLnJlc3QgfSA9IG9wdGlvbnMgPz8ge307XG4gIGNvbnN0IHJlcXVpcmVkT3B0aW9ucyA9IHtcbiAgICB3b3JrZmxvd1R5cGU6IHdvcmtmbG93VHlwZSA/PyBpbmZvLndvcmtmbG93VHlwZSxcbiAgICB0YXNrUXVldWU6IHRhc2tRdWV1ZSA/PyBpbmZvLnRhc2tRdWV1ZSxcbiAgICAuLi5yZXN0LFxuICB9O1xuXG4gIHJldHVybiAoLi4uYXJnczogUGFyYW1ldGVyczxGPik6IFByb21pc2U8bmV2ZXI+ID0+IHtcbiAgICBjb25zdCBmbiA9IGNvbXBvc2VJbnRlcmNlcHRvcnMoYWN0aXZhdG9yLmludGVyY2VwdG9ycy5vdXRib3VuZCwgJ2NvbnRpbnVlQXNOZXcnLCBhc3luYyAoaW5wdXQpID0+IHtcbiAgICAgIGNvbnN0IHsgaGVhZGVycywgYXJncywgb3B0aW9ucyB9ID0gaW5wdXQ7XG4gICAgICB0aHJvdyBuZXcgQ29udGludWVBc05ldyh7XG4gICAgICAgIHdvcmtmbG93VHlwZTogb3B0aW9ucy53b3JrZmxvd1R5cGUsXG4gICAgICAgIGFyZ3VtZW50czogdG9QYXlsb2FkcyhhY3RpdmF0b3IucGF5bG9hZENvbnZlcnRlciwgLi4uYXJncyksXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHRhc2tRdWV1ZTogb3B0aW9ucy50YXNrUXVldWUsXG4gICAgICAgIG1lbW86IG9wdGlvbnMubWVtbyAmJiBtYXBUb1BheWxvYWRzKGFjdGl2YXRvci5wYXlsb2FkQ29udmVydGVyLCBvcHRpb25zLm1lbW8pLFxuICAgICAgICBzZWFyY2hBdHRyaWJ1dGVzOlxuICAgICAgICAgIG9wdGlvbnMuc2VhcmNoQXR0cmlidXRlcyB8fCBvcHRpb25zLnR5cGVkU2VhcmNoQXR0cmlidXRlcyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgICAgICAgICA/IGVuY29kZVVuaWZpZWRTZWFyY2hBdHRyaWJ1dGVzKG9wdGlvbnMuc2VhcmNoQXR0cmlidXRlcywgb3B0aW9ucy50eXBlZFNlYXJjaEF0dHJpYnV0ZXMpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZGVwcmVjYXRpb24vZGVwcmVjYXRpb25cbiAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB3b3JrZmxvd1J1blRpbWVvdXQ6IG1zT3B0aW9uYWxUb1RzKG9wdGlvbnMud29ya2Zsb3dSdW5UaW1lb3V0KSxcbiAgICAgICAgd29ya2Zsb3dUYXNrVGltZW91dDogbXNPcHRpb25hbFRvVHMob3B0aW9ucy53b3JrZmxvd1Rhc2tUaW1lb3V0KSxcbiAgICAgICAgdmVyc2lvbmluZ0ludGVudDogdmVyc2lvbmluZ0ludGVudFRvUHJvdG8ob3B0aW9ucy52ZXJzaW9uaW5nSW50ZW50KSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZuKHtcbiAgICAgIGFyZ3MsXG4gICAgICBoZWFkZXJzOiB7fSxcbiAgICAgIG9wdGlvbnM6IHJlcXVpcmVkT3B0aW9ucyxcbiAgICB9KTtcbiAgfTtcbn1cblxuLyoqXG4gKiB7QGxpbmsgaHR0cHM6Ly9kb2NzLnRlbXBvcmFsLmlvL2NvbmNlcHRzL3doYXQtaXMtY29udGludWUtYXMtbmV3LyB8IENvbnRpbnVlcy1Bcy1OZXd9IHRoZSBjdXJyZW50IFdvcmtmbG93IEV4ZWN1dGlvblxuICogd2l0aCBkZWZhdWx0IG9wdGlvbnMuXG4gKlxuICogU2hvcnRoYW5kIGZvciBgbWFrZUNvbnRpbnVlQXNOZXdGdW5jPEY+KCkoLi4uYXJncylgLiAoU2VlOiB7QGxpbmsgbWFrZUNvbnRpbnVlQXNOZXdGdW5jfS4pXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgY29udGludWVBc05ldyB9IGZyb20gJ0B0ZW1wb3JhbGlvL3dvcmtmbG93JztcbiAqIGltcG9ydCB7IFNlYXJjaEF0dHJpYnV0ZVR5cGUgfSBmcm9tICdAdGVtcG9yYWxpby9jb21tb24nO1xuICpcbiAqIGV4cG9ydCBhc3luYyBmdW5jdGlvbiBteVdvcmtmbG93KG46IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICogICAvLyAuLi4gV29ya2Zsb3cgbG9naWNcbiAqICAgYXdhaXQgY29udGludWVBc05ldzx0eXBlb2YgbXlXb3JrZmxvdz4obiArIDEpO1xuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb250aW51ZUFzTmV3PEYgZXh0ZW5kcyBXb3JrZmxvdz4oLi4uYXJnczogUGFyYW1ldGVyczxGPik6IFByb21pc2U8bmV2ZXI+IHtcbiAgcmV0dXJuIG1ha2VDb250aW51ZUFzTmV3RnVuYygpKC4uLmFyZ3MpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGFuIFJGQyBjb21wbGlhbnQgVjQgdXVpZC5cbiAqIFVzZXMgdGhlIHdvcmtmbG93J3MgZGV0ZXJtaW5pc3RpYyBQUk5HIG1ha2luZyBpdCBzYWZlIGZvciB1c2Ugd2l0aGluIGEgd29ya2Zsb3cuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGNyeXB0b2dyYXBoaWNhbGx5IGluc2VjdXJlLlxuICogU2VlIHRoZSB7QGxpbmsgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1MDM0L2hvdy10by1jcmVhdGUtYS1ndWlkLXV1aWQgfCBzdGFja292ZXJmbG93IGRpc2N1c3Npb259LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXVpZDQoKTogc3RyaW5nIHtcbiAgLy8gUmV0dXJuIHRoZSBoZXhhZGVjaW1hbCB0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIG51bWJlciBgbmAsIHBhZGRlZCB3aXRoIHplcm9lcyB0byBiZSBvZiBsZW5ndGggYHBgXG4gIGNvbnN0IGhvID0gKG46IG51bWJlciwgcDogbnVtYmVyKSA9PiBuLnRvU3RyaW5nKDE2KS5wYWRTdGFydChwLCAnMCcpO1xuICAvLyBDcmVhdGUgYSB2aWV3IGJhY2tlZCBieSBhIDE2LWJ5dGUgYnVmZmVyXG4gIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDE2KSk7XG4gIC8vIEZpbGwgYnVmZmVyIHdpdGggcmFuZG9tIHZhbHVlc1xuICB2aWV3LnNldFVpbnQzMigwLCAoTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwKSA+Pj4gMCk7XG4gIHZpZXcuc2V0VWludDMyKDQsIChNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDApID4+PiAwKTtcbiAgdmlldy5zZXRVaW50MzIoOCwgKE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMCkgPj4+IDApO1xuICB2aWV3LnNldFVpbnQzMigxMiwgKE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMCkgPj4+IDApO1xuICAvLyBQYXRjaCB0aGUgNnRoIGJ5dGUgdG8gcmVmbGVjdCBhIHZlcnNpb24gNCBVVUlEXG4gIHZpZXcuc2V0VWludDgoNiwgKHZpZXcuZ2V0VWludDgoNikgJiAweGYpIHwgMHg0MCk7XG4gIC8vIFBhdGNoIHRoZSA4dGggYnl0ZSB0byByZWZsZWN0IGEgdmFyaWFudCAxIFVVSUQgKHZlcnNpb24gNCBVVUlEcyBhcmUpXG4gIHZpZXcuc2V0VWludDgoOCwgKHZpZXcuZ2V0VWludDgoOCkgJiAweDNmKSB8IDB4ODApO1xuICAvLyBDb21waWxlIHRoZSBjYW5vbmljYWwgdGV4dHVhbCBmb3JtIGZyb20gdGhlIGFycmF5IGRhdGFcbiAgcmV0dXJuIGAke2hvKHZpZXcuZ2V0VWludDMyKDApLCA4KX0tJHtobyh2aWV3LmdldFVpbnQxNig0KSwgNCl9LSR7aG8odmlldy5nZXRVaW50MTYoNiksIDQpfS0ke2hvKFxuICAgIHZpZXcuZ2V0VWludDE2KDgpLFxuICAgIDRcbiAgKX0tJHtobyh2aWV3LmdldFVpbnQzMigxMCksIDgpfSR7aG8odmlldy5nZXRVaW50MTYoMTQpLCA0KX1gO1xufVxuXG4vKipcbiAqIFBhdGNoIG9yIHVwZ3JhZGUgd29ya2Zsb3cgY29kZSBieSBjaGVja2luZyBvciBzdGF0aW5nIHRoYXQgdGhpcyB3b3JrZmxvdyBoYXMgYSBjZXJ0YWluIHBhdGNoLlxuICpcbiAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9kb2NzLnRlbXBvcmFsLmlvL3R5cGVzY3JpcHQvdmVyc2lvbmluZyB8IGRvY3MgcGFnZX0gZm9yIGluZm8uXG4gKlxuICogSWYgdGhlIHdvcmtmbG93IGlzIHJlcGxheWluZyBhbiBleGlzdGluZyBoaXN0b3J5LCB0aGVuIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0cnVlIGlmIHRoYXRcbiAqIGhpc3Rvcnkgd2FzIHByb2R1Y2VkIGJ5IGEgd29ya2VyIHdoaWNoIGFsc28gaGFkIGEgYHBhdGNoZWRgIGNhbGwgd2l0aCB0aGUgc2FtZSBgcGF0Y2hJZGAuXG4gKiBJZiB0aGUgaGlzdG9yeSB3YXMgcHJvZHVjZWQgYnkgYSB3b3JrZXIgKndpdGhvdXQqIHN1Y2ggYSBjYWxsLCB0aGVuIGl0IHdpbGwgcmV0dXJuIGZhbHNlLlxuICpcbiAqIElmIHRoZSB3b3JrZmxvdyBpcyBub3QgY3VycmVudGx5IHJlcGxheWluZywgdGhlbiB0aGlzIGNhbGwgKmFsd2F5cyogcmV0dXJucyB0cnVlLlxuICpcbiAqIFlvdXIgd29ya2Zsb3cgY29kZSBzaG91bGQgcnVuIHRoZSBcIm5ld1wiIGNvZGUgaWYgdGhpcyByZXR1cm5zIHRydWUsIGlmIGl0IHJldHVybnMgZmFsc2UsIHlvdVxuICogc2hvdWxkIHJ1biB0aGUgXCJvbGRcIiBjb2RlLiBCeSBkb2luZyB0aGlzLCB5b3UgY2FuIG1haW50YWluIGRldGVybWluaXNtLlxuICpcbiAqIEBwYXJhbSBwYXRjaElkIEFuIGlkZW50aWZpZXIgdGhhdCBzaG91bGQgYmUgdW5pcXVlIHRvIHRoaXMgcGF0Y2guIEl0IGlzIE9LIHRvIHVzZSBtdWx0aXBsZVxuICogY2FsbHMgd2l0aCB0aGUgc2FtZSBJRCwgd2hpY2ggbWVhbnMgYWxsIHN1Y2ggY2FsbHMgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSBzYW1lIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGF0Y2hlZChwYXRjaElkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgYWN0aXZhdG9yID0gYXNzZXJ0SW5Xb3JrZmxvd0NvbnRleHQoXG4gICAgJ1dvcmtmbG93LnBhdGNoKC4uLikgYW5kIFdvcmtmbG93LmRlcHJlY2F0ZVBhdGNoIG1heSBvbmx5IGJlIHVzZWQgZnJvbSBhIFdvcmtmbG93IEV4ZWN1dGlvbi4nXG4gICk7XG4gIHJldHVybiBhY3RpdmF0b3IucGF0Y2hJbnRlcm5hbChwYXRjaElkLCBmYWxzZSk7XG59XG5cbi8qKlxuICogSW5kaWNhdGUgdGhhdCBhIHBhdGNoIGlzIGJlaW5nIHBoYXNlZCBvdXQuXG4gKlxuICogU2VlIHtAbGluayBodHRwczovL2RvY3MudGVtcG9yYWwuaW8vdHlwZXNjcmlwdC92ZXJzaW9uaW5nIHwgZG9jcyBwYWdlfSBmb3IgaW5mby5cbiAqXG4gKiBXb3JrZmxvd3Mgd2l0aCB0aGlzIGNhbGwgbWF5IGJlIGRlcGxveWVkIGFsb25nc2lkZSB3b3JrZmxvd3Mgd2l0aCBhIHtAbGluayBwYXRjaGVkfSBjYWxsLCBidXRcbiAqIHRoZXkgbXVzdCAqbm90KiBiZSBkZXBsb3llZCB3aGlsZSBhbnkgd29ya2VycyBzdGlsbCBleGlzdCBydW5uaW5nIG9sZCBjb2RlIHdpdGhvdXQgYVxuICoge0BsaW5rIHBhdGNoZWR9IGNhbGwsIG9yIGFueSBydW5zIHdpdGggaGlzdG9yaWVzIHByb2R1Y2VkIGJ5IHN1Y2ggd29ya2VycyBleGlzdC4gSWYgZWl0aGVyIGtpbmRcbiAqIG9mIHdvcmtlciBlbmNvdW50ZXJzIGEgaGlzdG9yeSBwcm9kdWNlZCBieSB0aGUgb3RoZXIsIHRoZWlyIGJlaGF2aW9yIGlzIHVuZGVmaW5lZC5cbiAqXG4gKiBPbmNlIGFsbCBsaXZlIHdvcmtmbG93IHJ1bnMgaGF2ZSBiZWVuIHByb2R1Y2VkIGJ5IHdvcmtlcnMgd2l0aCB0aGlzIGNhbGwsIHlvdSBjYW4gZGVwbG95IHdvcmtlcnNcbiAqIHdoaWNoIGFyZSBmcmVlIG9mIGVpdGhlciBraW5kIG9mIHBhdGNoIGNhbGwgZm9yIHRoaXMgSUQuIFdvcmtlcnMgd2l0aCBhbmQgd2l0aG91dCB0aGlzIGNhbGxcbiAqIG1heSBjb2V4aXN0LCBhcyBsb25nIGFzIHRoZXkgYXJlIGJvdGggcnVubmluZyB0aGUgXCJuZXdcIiBjb2RlLlxuICpcbiAqIEBwYXJhbSBwYXRjaElkIEFuIGlkZW50aWZpZXIgdGhhdCBzaG91bGQgYmUgdW5pcXVlIHRvIHRoaXMgcGF0Y2guIEl0IGlzIE9LIHRvIHVzZSBtdWx0aXBsZVxuICogY2FsbHMgd2l0aCB0aGUgc2FtZSBJRCwgd2hpY2ggbWVhbnMgYWxsIHN1Y2ggY2FsbHMgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSBzYW1lIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVwcmVjYXRlUGF0Y2gocGF0Y2hJZDogc3RyaW5nKTogdm9pZCB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGFzc2VydEluV29ya2Zsb3dDb250ZXh0KFxuICAgICdXb3JrZmxvdy5wYXRjaCguLi4pIGFuZCBXb3JrZmxvdy5kZXByZWNhdGVQYXRjaCBtYXkgb25seSBiZSB1c2VkIGZyb20gYSBXb3JrZmxvdyBFeGVjdXRpb24uJ1xuICApO1xuICBhY3RpdmF0b3IucGF0Y2hJbnRlcm5hbChwYXRjaElkLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYGZuYCBldmFsdWF0ZXMgdG8gYHRydWVgIG9yIGB0aW1lb3V0YCBleHBpcmVzLCBwcm92aWRpbmdcbiAqIG9wdGlvbnMgdG8gY29uZmlndXJlIHRoZSB0aW1lciAoaS5lLiBwcm92aWRlIG1ldGFkYXRhKVxuICpcbiAqIEBwYXJhbSB0aW1lb3V0IG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3Ige0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL21zIHwgbXMtZm9ybWF0dGVkIHN0cmluZ31cbiAqXG4gKiBAcmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjb25kaXRpb24gd2FzIHRydWUgYmVmb3JlIHRoZSB0aW1lb3V0IGV4cGlyZXNcbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRpbWVyT3B0aW9ucyBpcyBhIG5ldyBhZGRpdGlvbiBhbmQgc3ViamVjdCB0byBjaGFuZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmRpdGlvbihmbjogKCkgPT4gYm9vbGVhbiwgdGltZW91dDogRHVyYXRpb24sIG9wdGlvbnM6IFRpbWVyT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj47XG5cbi8qKlxuICogUmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGBmbmAgZXZhbHVhdGVzIHRvIGB0cnVlYCBvciBgdGltZW91dGAgZXhwaXJlcy5cbiAqXG4gKiBAcGFyYW0gdGltZW91dCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9yIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tcyB8IG1zLWZvcm1hdHRlZCBzdHJpbmd9XG4gKlxuICogQHJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY29uZGl0aW9uIHdhcyB0cnVlIGJlZm9yZSB0aGUgdGltZW91dCBleHBpcmVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25kaXRpb24oZm46ICgpID0+IGJvb2xlYW4sIHRpbWVvdXQ6IER1cmF0aW9uKTogUHJvbWlzZTxib29sZWFuPjtcblxuLyoqXG4gKiBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYGZuYCBldmFsdWF0ZXMgdG8gYHRydWVgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uZGl0aW9uKGZuOiAoKSA9PiBib29sZWFuKTogUHJvbWlzZTx2b2lkPjtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbmRpdGlvbihmbjogKCkgPT4gYm9vbGVhbiwgdGltZW91dD86IER1cmF0aW9uLCBvcHRzPzogVGltZXJPcHRpb25zKTogUHJvbWlzZTx2b2lkIHwgYm9vbGVhbj4ge1xuICBhc3NlcnRJbldvcmtmbG93Q29udGV4dCgnV29ya2Zsb3cuY29uZGl0aW9uKC4uLikgbWF5IG9ubHkgYmUgdXNlZCBmcm9tIGEgV29ya2Zsb3cgRXhlY3V0aW9uLicpO1xuICAvLyBQcmlvciB0byAxLjUuMCwgYGNvbmRpdGlvbihmbiwgMClgIHdhcyB0cmVhdGVkIGFzIGVxdWl2YWxlbnQgdG8gYGNvbmRpdGlvbihmbiwgdW5kZWZpbmVkKWBcbiAgaWYgKHRpbWVvdXQgPT09IDAgJiYgIXBhdGNoZWQoQ09ORElUSU9OXzBfUEFUQ0gpKSB7XG4gICAgcmV0dXJuIGNvbmRpdGlvbklubmVyKGZuKTtcbiAgfVxuICBpZiAodHlwZW9mIHRpbWVvdXQgPT09ICdudW1iZXInIHx8IHR5cGVvZiB0aW1lb3V0ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBDYW5jZWxsYXRpb25TY29wZS5jYW5jZWxsYWJsZShhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5yYWNlKFtzbGVlcCh0aW1lb3V0LCBvcHRzKS50aGVuKCgpID0+IGZhbHNlKSwgY29uZGl0aW9uSW5uZXIoZm4pLnRoZW4oKCkgPT4gdHJ1ZSldKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIENhbmNlbGxhdGlvblNjb3BlLmN1cnJlbnQoKS5jYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY29uZGl0aW9uSW5uZXIoZm4pO1xufVxuXG5mdW5jdGlvbiBjb25kaXRpb25Jbm5lcihmbjogKCkgPT4gYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBhY3RpdmF0b3IgPSBnZXRBY3RpdmF0b3IoKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBzY29wZSA9IENhbmNlbGxhdGlvblNjb3BlLmN1cnJlbnQoKTtcbiAgICBpZiAoc2NvcGUuY29uc2lkZXJlZENhbmNlbGxlZCkge1xuICAgICAgdW50cmFja1Byb21pc2Uoc2NvcGUuY2FuY2VsUmVxdWVzdGVkLmNhdGNoKHJlamVjdCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNlcSA9IGFjdGl2YXRvci5uZXh0U2Vxcy5jb25kaXRpb24rKztcbiAgICBpZiAoc2NvcGUuY2FuY2VsbGFibGUpIHtcbiAgICAgIHVudHJhY2tQcm9taXNlKFxuICAgICAgICBzY29wZS5jYW5jZWxSZXF1ZXN0ZWQuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIGFjdGl2YXRvci5ibG9ja2VkQ29uZGl0aW9ucy5kZWxldGUoc2VxKTtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRWFnZXIgZXZhbHVhdGlvblxuICAgIGlmIChmbigpKSB7XG4gICAgICByZXNvbHZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYWN0aXZhdG9yLmJsb2NrZWRDb25kaXRpb25zLnNldChzZXEsIHsgZm4sIHJlc29sdmUgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIERlZmluZSBhbiB1cGRhdGUgbWV0aG9kIGZvciBhIFdvcmtmbG93LlxuICpcbiAqIEEgZGVmaW5pdGlvbiBpcyB1c2VkIHRvIHJlZ2lzdGVyIGEgaGFuZGxlciBpbiB0aGUgV29ya2Zsb3cgdmlhIHtAbGluayBzZXRIYW5kbGVyfSBhbmQgdG8gdXBkYXRlIGEgV29ya2Zsb3cgdXNpbmcgYSB7QGxpbmsgV29ya2Zsb3dIYW5kbGV9LCB7QGxpbmsgQ2hpbGRXb3JrZmxvd0hhbmRsZX0gb3Ige0BsaW5rIEV4dGVybmFsV29ya2Zsb3dIYW5kbGV9LlxuICogQSBkZWZpbml0aW9uIGNhbiBiZSByZXVzZWQgaW4gbXVsdGlwbGUgV29ya2Zsb3dzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lVXBkYXRlPFJldCwgQXJncyBleHRlbmRzIGFueVtdID0gW10sIE5hbWUgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+KFxuICBuYW1lOiBOYW1lXG4pOiBVcGRhdGVEZWZpbml0aW9uPFJldCwgQXJncywgTmFtZT4ge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICd1cGRhdGUnLFxuICAgIG5hbWUsXG4gIH0gYXMgVXBkYXRlRGVmaW5pdGlvbjxSZXQsIEFyZ3MsIE5hbWU+O1xufVxuXG4vKipcbiAqIERlZmluZSBhIHNpZ25hbCBtZXRob2QgZm9yIGEgV29ya2Zsb3cuXG4gKlxuICogQSBkZWZpbml0aW9uIGlzIHVzZWQgdG8gcmVnaXN0ZXIgYSBoYW5kbGVyIGluIHRoZSBXb3JrZmxvdyB2aWEge0BsaW5rIHNldEhhbmRsZXJ9IGFuZCB0byBzaWduYWwgYSBXb3JrZmxvdyB1c2luZyBhIHtAbGluayBXb3JrZmxvd0hhbmRsZX0sIHtAbGluayBDaGlsZFdvcmtmbG93SGFuZGxlfSBvciB7QGxpbmsgRXh0ZXJuYWxXb3JrZmxvd0hhbmRsZX0uXG4gKiBBIGRlZmluaXRpb24gY2FuIGJlIHJldXNlZCBpbiBtdWx0aXBsZSBXb3JrZmxvd3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVTaWduYWw8QXJncyBleHRlbmRzIGFueVtdID0gW10sIE5hbWUgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+KFxuICBuYW1lOiBOYW1lXG4pOiBTaWduYWxEZWZpbml0aW9uPEFyZ3MsIE5hbWU+IHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnc2lnbmFsJyxcbiAgICBuYW1lLFxuICB9IGFzIFNpZ25hbERlZmluaXRpb248QXJncywgTmFtZT47XG59XG5cbi8qKlxuICogRGVmaW5lIGEgcXVlcnkgbWV0aG9kIGZvciBhIFdvcmtmbG93LlxuICpcbiAqIEEgZGVmaW5pdGlvbiBpcyB1c2VkIHRvIHJlZ2lzdGVyIGEgaGFuZGxlciBpbiB0aGUgV29ya2Zsb3cgdmlhIHtAbGluayBzZXRIYW5kbGVyfSBhbmQgdG8gcXVlcnkgYSBXb3JrZmxvdyB1c2luZyBhIHtAbGluayBXb3JrZmxvd0hhbmRsZX0uXG4gKiBBIGRlZmluaXRpb24gY2FuIGJlIHJldXNlZCBpbiBtdWx0aXBsZSBXb3JrZmxvd3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVRdWVyeTxSZXQsIEFyZ3MgZXh0ZW5kcyBhbnlbXSA9IFtdLCBOYW1lIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPihcbiAgbmFtZTogTmFtZVxuKTogUXVlcnlEZWZpbml0aW9uPFJldCwgQXJncywgTmFtZT4ge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdxdWVyeScsXG4gICAgbmFtZSxcbiAgfSBhcyBRdWVyeURlZmluaXRpb248UmV0LCBBcmdzLCBOYW1lPjtcbn1cblxuLyoqXG4gKiBTZXQgYSBoYW5kbGVyIGZ1bmN0aW9uIGZvciBhIFdvcmtmbG93IHVwZGF0ZSwgc2lnbmFsLCBvciBxdWVyeS5cbiAqXG4gKiBJZiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBmb3IgYSBnaXZlbiB1cGRhdGUsIHNpZ25hbCwgb3IgcXVlcnkgbmFtZSB0aGUgbGFzdCBoYW5kbGVyIHdpbGwgb3ZlcndyaXRlIGFueSBwcmV2aW91cyBjYWxscy5cbiAqXG4gKiBAcGFyYW0gZGVmIGFuIHtAbGluayBVcGRhdGVEZWZpbml0aW9ufSwge0BsaW5rIFNpZ25hbERlZmluaXRpb259LCBvciB7QGxpbmsgUXVlcnlEZWZpbml0aW9ufSBhcyByZXR1cm5lZCBieSB7QGxpbmsgZGVmaW5lVXBkYXRlfSwge0BsaW5rIGRlZmluZVNpZ25hbH0sIG9yIHtAbGluayBkZWZpbmVRdWVyeX0gcmVzcGVjdGl2ZWx5LlxuICogQHBhcmFtIGhhbmRsZXIgYSBjb21wYXRpYmxlIGhhbmRsZXIgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBkZWZpbml0aW9uIG9yIGB1bmRlZmluZWRgIHRvIHVuc2V0IHRoZSBoYW5kbGVyLlxuICogQHBhcmFtIG9wdGlvbnMgYW4gb3B0aW9uYWwgYGRlc2NyaXB0aW9uYCBvZiB0aGUgaGFuZGxlciBhbmQgYW4gb3B0aW9uYWwgdXBkYXRlIGB2YWxpZGF0b3JgIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0SGFuZGxlcjxSZXQsIEFyZ3MgZXh0ZW5kcyBhbnlbXSwgVCBleHRlbmRzIFF1ZXJ5RGVmaW5pdGlvbjxSZXQsIEFyZ3M+PihcbiAgZGVmOiBULFxuICBoYW5kbGVyOiBIYW5kbGVyPFJldCwgQXJncywgVD4gfCB1bmRlZmluZWQsXG4gIG9wdGlvbnM/OiBRdWVyeUhhbmRsZXJPcHRpb25zXG4pOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIHNldEhhbmRsZXI8UmV0LCBBcmdzIGV4dGVuZHMgYW55W10sIFQgZXh0ZW5kcyBTaWduYWxEZWZpbml0aW9uPEFyZ3M+PihcbiAgZGVmOiBULFxuICBoYW5kbGVyOiBIYW5kbGVyPFJldCwgQXJncywgVD4gfCB1bmRlZmluZWQsXG4gIG9wdGlvbnM/OiBTaWduYWxIYW5kbGVyT3B0aW9uc1xuKTogdm9pZDtcbmV4cG9ydCBmdW5jdGlvbiBzZXRIYW5kbGVyPFJldCwgQXJncyBleHRlbmRzIGFueVtdLCBUIGV4dGVuZHMgVXBkYXRlRGVmaW5pdGlvbjxSZXQsIEFyZ3M+PihcbiAgZGVmOiBULFxuICBoYW5kbGVyOiBIYW5kbGVyPFJldCwgQXJncywgVD4gfCB1bmRlZmluZWQsXG4gIG9wdGlvbnM/OiBVcGRhdGVIYW5kbGVyT3B0aW9uczxBcmdzPlxuKTogdm9pZDtcblxuLy8gRm9yIFVwZGF0ZXMgYW5kIFNpZ25hbHMgd2Ugd2FudCB0byBtYWtlIGEgcHVibGljIGd1YXJhbnRlZSBzb21ldGhpbmcgbGlrZSB0aGVcbi8vIGZvbGxvd2luZzpcbi8vXG4vLyAgIFwiSWYgYSBXRlQgY29udGFpbnMgYSBTaWduYWwvVXBkYXRlLCBhbmQgaWYgYSBoYW5kbGVyIGlzIGF2YWlsYWJsZSBmb3IgdGhhdFxuLy8gICBTaWduYWwvVXBkYXRlLCB0aGVuIHRoZSBoYW5kbGVyIHdpbGwgYmUgZXhlY3V0ZWQuXCJcIlxuLy9cbi8vIEhvd2V2ZXIsIHRoYXQgc3RhdGVtZW50IGlzIG5vdCB3ZWxsLWRlZmluZWQsIGxlYXZpbmcgc2V2ZXJhbCBxdWVzdGlvbnMgb3Blbjpcbi8vXG4vLyAxLiBXaGF0IGRvZXMgaXQgbWVhbiBmb3IgYSBoYW5kbGVyIHRvIGJlIFwiYXZhaWxhYmxlXCI/IFdoYXQgaGFwcGVucyBpZiB0aGVcbi8vICAgIGhhbmRsZXIgaXMgbm90IHByZXNlbnQgaW5pdGlhbGx5IGJ1dCBpcyBzZXQgYXQgc29tZSBwb2ludCBkdXJpbmcgdGhlXG4vLyAgICBXb3JrZmxvdyBjb2RlIHRoYXQgaXMgZXhlY3V0ZWQgaW4gdGhhdCBXRlQ/IFdoYXQgaGFwcGVucyBpZiB0aGUgaGFuZGxlciBpc1xuLy8gICAgc2V0IGFuZCB0aGVuIGRlbGV0ZWQsIG9yIHJlcGxhY2VkIHdpdGggYSBkaWZmZXJlbnQgaGFuZGxlcj9cbi8vXG4vLyAyLiBXaGVuIGlzIHRoZSBoYW5kbGVyIGV4ZWN1dGVkPyAoV2hlbiBpdCBmaXJzdCBiZWNvbWVzIGF2YWlsYWJsZT8gQXQgdGhlIGVuZFxuLy8gICAgb2YgdGhlIGFjdGl2YXRpb24/KSBXaGF0IGFyZSB0aGUgZXhlY3V0aW9uIHNlbWFudGljcyBvZiBXb3JrZmxvdyBhbmRcbi8vICAgIFNpZ25hbC9VcGRhdGUgaGFuZGxlciBjb2RlIGdpdmVuIHRoYXQgdGhleSBhcmUgY29uY3VycmVudD8gQ2FuIHRoZSB1c2VyXG4vLyAgICByZWx5IG9uIFNpZ25hbC9VcGRhdGUgc2lkZSBlZmZlY3RzIGJlaW5nIHJlZmxlY3RlZCBpbiB0aGUgV29ya2Zsb3cgcmV0dXJuXG4vLyAgICB2YWx1ZSwgb3IgaW4gdGhlIHZhbHVlIHBhc3NlZCB0byBDb250aW51ZS1Bcy1OZXc/IElmIHRoZSBoYW5kbGVyIGlzIGFuXG4vLyAgICBhc3luYyBmdW5jdGlvbiAvIGNvcm91dGluZSwgaG93IG11Y2ggb2YgaXQgaXMgZXhlY3V0ZWQgYW5kIHdoZW4gaXMgdGhlXG4vLyAgICByZXN0IGV4ZWN1dGVkP1xuLy9cbi8vIDMuIFdoYXQgaGFwcGVucyBpZiB0aGUgaGFuZGxlciBpcyBub3QgZXhlY3V0ZWQ/IChpLmUuIGJlY2F1c2UgaXQgd2Fzbid0XG4vLyAgICBhdmFpbGFibGUgaW4gdGhlIHNlbnNlIGRlZmluZWQgYnkgKDEpKVxuLy9cbi8vIDQuIEluIHRoZSBjYXNlIG9mIFVwZGF0ZSwgd2hlbiBpcyB0aGUgdmFsaWRhdGlvbiBmdW5jdGlvbiBleGVjdXRlZD9cbi8vXG4vLyBUaGUgaW1wbGVtZW50YXRpb24gZm9yIFR5cGVzY3JpcHQgaXMgYXMgZm9sbG93czpcbi8vXG4vLyAxLiBzZGstY29yZSBzb3J0cyBTaWduYWwgYW5kIFVwZGF0ZSBqb2JzIChhbmQgUGF0Y2hlcykgYWhlYWQgb2YgYWxsIG90aGVyXG4vLyAgICBqb2JzLiBUaHVzIGlmIHRoZSBoYW5kbGVyIGlzIGF2YWlsYWJsZSBhdCB0aGUgc3RhcnQgb2YgdGhlIEFjdGl2YXRpb24gdGhlblxuLy8gICAgdGhlIFNpZ25hbC9VcGRhdGUgd2lsbCBiZSBleGVjdXRlZCBiZWZvcmUgV29ya2Zsb3cgY29kZSBpcyBleGVjdXRlZC4gSWYgaXRcbi8vICAgIGlzIG5vdCwgdGhlbiB0aGUgU2lnbmFsL1VwZGF0ZSBjYWxscyBhcmUgcHVzaGVkIHRvIGEgYnVmZmVyLlxuLy9cbi8vIDIuIE9uIGVhY2ggY2FsbCB0byBzZXRIYW5kbGVyIGZvciBhIGdpdmVuIFNpZ25hbC9VcGRhdGUsIHdlIG1ha2UgYSBwYXNzXG4vLyAgICB0aHJvdWdoIHRoZSBidWZmZXIgbGlzdC4gSWYgYSBidWZmZXJlZCBqb2IgaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBqdXN0LXNldFxuLy8gICAgaGFuZGxlciwgdGhlbiB0aGUgam9iIGlzIHJlbW92ZWQgZnJvbSB0aGUgYnVmZmVyIGFuZCB0aGUgaW5pdGlhbFxuLy8gICAgc3luY2hyb25vdXMgcG9ydGlvbiBvZiB0aGUgaGFuZGxlciBpcyBpbnZva2VkIG9uIHRoYXQgaW5wdXQgKGkuZS5cbi8vICAgIHByZWVtcHRpbmcgd29ya2Zsb3cgY29kZSkuXG4vL1xuLy8gVGh1cyBpbiB0aGUgY2FzZSBvZiBUeXBlc2NyaXB0IHRoZSBxdWVzdGlvbnMgYWJvdmUgYXJlIGFuc3dlcmVkIGFzIGZvbGxvd3M6XG4vL1xuLy8gMS4gQSBoYW5kbGVyIGlzIFwiYXZhaWxhYmxlXCIgaWYgaXQgaXMgc2V0IGF0IHRoZSBzdGFydCBvZiB0aGUgQWN0aXZhdGlvbiBvclxuLy8gICAgYmVjb21lcyBzZXQgYXQgYW55IHBvaW50IGR1cmluZyB0aGUgQWN0aXZhdGlvbi4gSWYgdGhlIGhhbmRsZXIgaXMgbm90IHNldFxuLy8gICAgaW5pdGlhbGx5IHRoZW4gaXQgaXMgZXhlY3V0ZWQgYXMgc29vbiBhcyBpdCBpcyBzZXQuIFN1YnNlcXVlbnQgZGVsZXRpb24gb3Jcbi8vICAgIHJlcGxhY2VtZW50IGJ5IGEgZGlmZmVyZW50IGhhbmRsZXIgaGFzIG5vIGltcGFjdCBiZWNhdXNlIHRoZSBqb2JzIGl0IHdhc1xuLy8gICAgaGFuZGxpbmcgaGF2ZSBhbHJlYWR5IGJlZW4gaGFuZGxlZCBhbmQgYXJlIG5vIGxvbmdlciBpbiB0aGUgYnVmZmVyLlxuLy9cbi8vIDIuIFRoZSBoYW5kbGVyIGlzIGV4ZWN1dGVkIGFzIHNvb24gYXMgaXQgYmVjb21lcyBhdmFpbGFibGUuIEkuZS4gaWYgdGhlXG4vLyAgICBoYW5kbGVyIGlzIHNldCBhdCB0aGUgc3RhcnQgb2YgdGhlIEFjdGl2YXRpb24gdGhlbiBpdCBpcyBleGVjdXRlZCB3aGVuXG4vLyAgICBmaXJzdCBhdHRlbXB0aW5nIHRvIHByb2Nlc3MgdGhlIFNpZ25hbC9VcGRhdGUgam9iOyBhbHRlcm5hdGl2ZWx5LCBpZiBpdCBpc1xuLy8gICAgc2V0IGJ5IGEgc2V0SGFuZGxlciBjYWxsIG1hZGUgYnkgV29ya2Zsb3cgY29kZSwgdGhlbiBpdCBpcyBleGVjdXRlZCBhc1xuLy8gICAgcGFydCBvZiB0aGF0IGNhbGwgKHByZWVtcHRpbmcgV29ya2Zsb3cgY29kZSkuIFRoZXJlZm9yZSwgYSB1c2VyIGNhbiByZWx5XG4vLyAgICBvbiBTaWduYWwvVXBkYXRlIHNpZGUgZWZmZWN0cyBiZWluZyByZWZsZWN0ZWQgaW4gZS5nLiB0aGUgV29ya2Zsb3cgcmV0dXJuXG4vLyAgICB2YWx1ZSwgYW5kIGluIHRoZSB2YWx1ZSBwYXNzZWQgdG8gQ29udGludWUtQXMtTmV3LiBBY3RpdmF0aW9uIGpvYnMgYXJlXG4vLyAgICBwcm9jZXNzZWQgaW4gdGhlIG9yZGVyIHN1cHBsaWVkIGJ5IHNkay1jb3JlLCBpLmUuIFNpZ25hbHMsIHRoZW4gVXBkYXRlcyxcbi8vICAgIHRoZW4gb3RoZXIgam9icy4gV2l0aGluIGVhY2ggZ3JvdXAsIHRoZSBvcmRlciBzZW50IGJ5IHRoZSBzZXJ2ZXIgaXNcbi8vICAgIHByZXNlcnZlZC4gSWYgdGhlIGhhbmRsZXIgaXMgYXN5bmMsIGl0IGlzIGV4ZWN1dGVkIHVwIHRvIGl0cyBmaXJzdCB5aWVsZFxuLy8gICAgcG9pbnQuXG4vL1xuLy8gMy4gU2lnbmFsIGNhc2U6IElmIGEgaGFuZGxlciBkb2VzIG5vdCBiZWNvbWUgYXZhaWxhYmxlIGZvciBhIFNpZ25hbCBqb2IgdGhlblxuLy8gICAgdGhlIGpvYiByZW1haW5zIGluIHRoZSBidWZmZXIuIElmIGEgaGFuZGxlciBmb3IgdGhlIFNpZ25hbCBiZWNvbWVzXG4vLyAgICBhdmFpbGFibGUgaW4gYSBzdWJzZXF1ZW50IEFjdGl2YXRpb24gKG9mIHRoZSBzYW1lIG9yIGEgc3Vic2VxdWVudCBXRlQpXG4vLyAgICB0aGVuIHRoZSBoYW5kbGVyIHdpbGwgYmUgZXhlY3V0ZWQuIElmIG5vdCwgdGhlbiB0aGUgU2lnbmFsIHdpbGwgbmV2ZXIgYmVcbi8vICAgIHJlc3BvbmRlZCB0byBhbmQgdGhpcyBjYXVzZXMgbm8gZXJyb3IuXG4vL1xuLy8gICAgVXBkYXRlIGNhc2U6IElmIGEgaGFuZGxlciBkb2VzIG5vdCBiZWNvbWUgYXZhaWxhYmxlIGZvciBhbiBVcGRhdGUgam9iIHRoZW5cbi8vICAgIHRoZSBVcGRhdGUgaXMgcmVqZWN0ZWQgYXQgdGhlIGVuZCBvZiB0aGUgQWN0aXZhdGlvbi4gVGh1cywgaWYgYSB1c2VyIGRvZXNcbi8vICAgIG5vdCB3YW50IGFuIFVwZGF0ZSB0byBiZSByZWplY3RlZCBmb3IgdGhpcyByZWFzb24sIHRoZW4gaXQgaXMgdGhlaXJcbi8vICAgIHJlc3BvbnNpYmlsaXR5IHRvIGVuc3VyZSB0aGF0IHRoZWlyIGFwcGxpY2F0aW9uIGFuZCB3b3JrZmxvdyBjb2RlIGludGVyYWN0XG4vLyAgICBzdWNoIHRoYXQgYSBoYW5kbGVyIGlzIGF2YWlsYWJsZSBmb3IgdGhlIFVwZGF0ZSBkdXJpbmcgYW55IEFjdGl2YXRpb25cbi8vICAgIHdoaWNoIG1pZ2h0IGNvbnRhaW4gdGhlaXIgVXBkYXRlIGpvYi4gKE5vdGUgdGhhdCB0aGUgdXNlciBvZnRlbiBoYXNcbi8vICAgIHVuY2VydGFpbnR5IGFib3V0IHdoaWNoIFdGVCB0aGVpciBTaWduYWwvVXBkYXRlIHdpbGwgYXBwZWFyIGluLiBGb3Jcbi8vICAgIGV4YW1wbGUsIGlmIHRoZXkgY2FsbCBzdGFydFdvcmtmbG93KCkgZm9sbG93ZWQgYnkgc3RhcnRVcGRhdGUoKSwgdGhlbiB0aGV5XG4vLyAgICB3aWxsIHR5cGljYWxseSBub3Qga25vdyB3aGV0aGVyIHRoZXNlIHdpbGwgYmUgZGVsaXZlcmVkIGluIG9uZSBvciB0d29cbi8vICAgIFdGVHMuIE9uIHRoZSBvdGhlciBoYW5kIHRoZXJlIGFyZSBzaXR1YXRpb25zIHdoZXJlIHRoZXkgd291bGQgaGF2ZSByZWFzb25cbi8vICAgIHRvIGJlbGlldmUgdGhleSBhcmUgaW4gdGhlIHNhbWUgV0ZULCBmb3IgZXhhbXBsZSBpZiB0aGV5IGRvIG5vdCBzdGFydFxuLy8gICAgV29ya2VyIHBvbGxpbmcgdW50aWwgYWZ0ZXIgdGhleSBoYXZlIHZlcmlmaWVkIHRoYXQgYm90aCByZXF1ZXN0cyBoYXZlXG4vLyAgICBzdWNjZWVkZWQuKVxuLy9cbi8vIDQuIElmIGFuIFVwZGF0ZSBoYXMgYSB2YWxpZGF0aW9uIGZ1bmN0aW9uIHRoZW4gaXQgaXMgZXhlY3V0ZWQgaW1tZWRpYXRlbHlcbi8vICAgIHByaW9yIHRvIHRoZSBoYW5kbGVyLiAoTm90ZSB0aGF0IHRoZSB2YWxpZGF0aW9uIGZ1bmN0aW9uIGlzIHJlcXVpcmVkIHRvIGJlXG4vLyAgICBzeW5jaHJvbm91cykuXG5leHBvcnQgZnVuY3Rpb24gc2V0SGFuZGxlcjxcbiAgUmV0LFxuICBBcmdzIGV4dGVuZHMgYW55W10sXG4gIFQgZXh0ZW5kcyBVcGRhdGVEZWZpbml0aW9uPFJldCwgQXJncz4gfCBTaWduYWxEZWZpbml0aW9uPEFyZ3M+IHwgUXVlcnlEZWZpbml0aW9uPFJldCwgQXJncz4sXG4+KFxuICBkZWY6IFQsXG4gIGhhbmRsZXI6IEhhbmRsZXI8UmV0LCBBcmdzLCBUPiB8IHVuZGVmaW5lZCxcbiAgb3B0aW9ucz86IFF1ZXJ5SGFuZGxlck9wdGlvbnMgfCBTaWduYWxIYW5kbGVyT3B0aW9ucyB8IFVwZGF0ZUhhbmRsZXJPcHRpb25zPEFyZ3M+XG4pOiB2b2lkIHtcbiAgY29uc3QgYWN0aXZhdG9yID0gYXNzZXJ0SW5Xb3JrZmxvd0NvbnRleHQoJ1dvcmtmbG93LnNldEhhbmRsZXIoLi4uKSBtYXkgb25seSBiZSB1c2VkIGZyb20gYSBXb3JrZmxvdyBFeGVjdXRpb24uJyk7XG4gIC8vIENhbm5vdCByZWdpc3RlciBoYW5kbGVyIGZvciByZXNlcnZlZCBuYW1lc1xuICB0aHJvd0lmUmVzZXJ2ZWROYW1lKGRlZi50eXBlLCBkZWYubmFtZSk7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gb3B0aW9ucz8uZGVzY3JpcHRpb247XG4gIGlmIChkZWYudHlwZSA9PT0gJ3VwZGF0ZScpIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZU9wdGlvbnMgPSBvcHRpb25zIGFzIFVwZGF0ZUhhbmRsZXJPcHRpb25zPEFyZ3M+IHwgdW5kZWZpbmVkO1xuXG4gICAgICBjb25zdCB2YWxpZGF0b3IgPSB1cGRhdGVPcHRpb25zPy52YWxpZGF0b3IgYXMgV29ya2Zsb3dVcGRhdGVWYWxpZGF0b3JUeXBlIHwgdW5kZWZpbmVkO1xuICAgICAgY29uc3QgdW5maW5pc2hlZFBvbGljeSA9IHVwZGF0ZU9wdGlvbnM/LnVuZmluaXNoZWRQb2xpY3kgPz8gSGFuZGxlclVuZmluaXNoZWRQb2xpY3kuV0FSTl9BTkRfQUJBTkRPTjtcbiAgICAgIGFjdGl2YXRvci51cGRhdGVIYW5kbGVycy5zZXQoZGVmLm5hbWUsIHsgaGFuZGxlciwgdmFsaWRhdG9yLCBkZXNjcmlwdGlvbiwgdW5maW5pc2hlZFBvbGljeSB9KTtcbiAgICAgIGFjdGl2YXRvci5kaXNwYXRjaEJ1ZmZlcmVkVXBkYXRlcygpO1xuICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9PSBudWxsKSB7XG4gICAgICBhY3RpdmF0b3IudXBkYXRlSGFuZGxlcnMuZGVsZXRlKGRlZi5uYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgaGFuZGxlciB0byBiZSBlaXRoZXIgYSBmdW5jdGlvbiBvciAndW5kZWZpbmVkJy4gR290OiAnJHt0eXBlb2YgaGFuZGxlcn0nYCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRlZi50eXBlID09PSAnc2lnbmFsJykge1xuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3Qgc2lnbmFsT3B0aW9ucyA9IG9wdGlvbnMgYXMgU2lnbmFsSGFuZGxlck9wdGlvbnMgfCB1bmRlZmluZWQ7XG4gICAgICBjb25zdCB1bmZpbmlzaGVkUG9saWN5ID0gc2lnbmFsT3B0aW9ucz8udW5maW5pc2hlZFBvbGljeSA/PyBIYW5kbGVyVW5maW5pc2hlZFBvbGljeS5XQVJOX0FORF9BQkFORE9OO1xuICAgICAgYWN0aXZhdG9yLnNpZ25hbEhhbmRsZXJzLnNldChkZWYubmFtZSwgeyBoYW5kbGVyOiBoYW5kbGVyIGFzIGFueSwgZGVzY3JpcHRpb24sIHVuZmluaXNoZWRQb2xpY3kgfSk7XG4gICAgICBhY3RpdmF0b3IuZGlzcGF0Y2hCdWZmZXJlZFNpZ25hbHMoKTtcbiAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPT0gbnVsbCkge1xuICAgICAgYWN0aXZhdG9yLnNpZ25hbEhhbmRsZXJzLmRlbGV0ZShkZWYubmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGhhbmRsZXIgdG8gYmUgZWl0aGVyIGEgZnVuY3Rpb24gb3IgJ3VuZGVmaW5lZCcuIEdvdDogJyR7dHlwZW9mIGhhbmRsZXJ9J2ApO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkZWYudHlwZSA9PT0gJ3F1ZXJ5Jykge1xuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYWN0aXZhdG9yLnF1ZXJ5SGFuZGxlcnMuc2V0KGRlZi5uYW1lLCB7IGhhbmRsZXI6IGhhbmRsZXIgYXMgYW55LCBkZXNjcmlwdGlvbiB9KTtcbiAgICB9IGVsc2UgaWYgKGhhbmRsZXIgPT0gbnVsbCkge1xuICAgICAgYWN0aXZhdG9yLnF1ZXJ5SGFuZGxlcnMuZGVsZXRlKGRlZi5uYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgaGFuZGxlciB0byBiZSBlaXRoZXIgYSBmdW5jdGlvbiBvciAndW5kZWZpbmVkJy4gR290OiAnJHt0eXBlb2YgaGFuZGxlcn0nYCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgZGVmaW5pdGlvbiB0eXBlOiAkeyhkZWYgYXMgYW55KS50eXBlfWApO1xuICB9XG59XG5cbi8qKlxuICogU2V0IGEgc2lnbmFsIGhhbmRsZXIgZnVuY3Rpb24gdGhhdCB3aWxsIGhhbmRsZSBzaWduYWxzIGNhbGxzIGZvciBub24tcmVnaXN0ZXJlZCBzaWduYWwgbmFtZXMuXG4gKlxuICogU2lnbmFscyBhcmUgZGlzcGF0Y2hlZCB0byB0aGUgZGVmYXVsdCBzaWduYWwgaGFuZGxlciBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IHdlcmUgYWNjZXB0ZWQgYnkgdGhlIHNlcnZlci5cbiAqXG4gKiBJZiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBmb3IgYSBnaXZlbiBzaWduYWwgbmFtZSB0aGUgbGFzdCBoYW5kbGVyIHdpbGwgb3ZlcndyaXRlIGFueSBwcmV2aW91cyBjYWxscy5cbiAqXG4gKiBAcGFyYW0gaGFuZGxlciBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBoYW5kbGUgc2lnbmFscyBmb3Igbm9uLXJlZ2lzdGVyZWQgc2lnbmFsIG5hbWVzLCBvciBgdW5kZWZpbmVkYCB0byB1bnNldCB0aGUgaGFuZGxlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldERlZmF1bHRTaWduYWxIYW5kbGVyKGhhbmRsZXI6IERlZmF1bHRTaWduYWxIYW5kbGVyIHwgdW5kZWZpbmVkKTogdm9pZCB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGFzc2VydEluV29ya2Zsb3dDb250ZXh0KFxuICAgICdXb3JrZmxvdy5zZXREZWZhdWx0U2lnbmFsSGFuZGxlciguLi4pIG1heSBvbmx5IGJlIHVzZWQgZnJvbSBhIFdvcmtmbG93IEV4ZWN1dGlvbi4nXG4gICk7XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFjdGl2YXRvci5kZWZhdWx0U2lnbmFsSGFuZGxlciA9IGhhbmRsZXI7XG4gICAgYWN0aXZhdG9yLmRpc3BhdGNoQnVmZmVyZWRTaWduYWxzKCk7XG4gIH0gZWxzZSBpZiAoaGFuZGxlciA9PSBudWxsKSB7XG4gICAgYWN0aXZhdG9yLmRlZmF1bHRTaWduYWxIYW5kbGVyID0gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGhhbmRsZXIgdG8gYmUgZWl0aGVyIGEgZnVuY3Rpb24gb3IgJ3VuZGVmaW5lZCcuIEdvdDogJyR7dHlwZW9mIGhhbmRsZXJ9J2ApO1xuICB9XG59XG5cbi8qKlxuICogU2V0IGEgdXBkYXRlIGhhbmRsZXIgZnVuY3Rpb24gdGhhdCB3aWxsIGhhbmRsZSB1cGRhdGVzIGNhbGxzIGZvciBub24tcmVnaXN0ZXJlZCB1cGRhdGUgbmFtZXMuXG4gKlxuICogVXBkYXRlcyBhcmUgZGlzcGF0Y2hlZCB0byB0aGUgZGVmYXVsdCB1cGRhdGUgaGFuZGxlciBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IHdlcmUgYWNjZXB0ZWQgYnkgdGhlIHNlcnZlci5cbiAqXG4gKiBJZiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBmb3IgYSBnaXZlbiB1cGRhdGUgbmFtZSB0aGUgbGFzdCBoYW5kbGVyIHdpbGwgb3ZlcndyaXRlIGFueSBwcmV2aW91cyBjYWxscy5cbiAqXG4gKiBAcGFyYW0gaGFuZGxlciBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBoYW5kbGUgdXBkYXRlcyBmb3Igbm9uLXJlZ2lzdGVyZWQgdXBkYXRlIG5hbWVzLCBvciBgdW5kZWZpbmVkYCB0byB1bnNldCB0aGUgaGFuZGxlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldERlZmF1bHRVcGRhdGVIYW5kbGVyKGhhbmRsZXI6IERlZmF1bHRVcGRhdGVIYW5kbGVyIHwgdW5kZWZpbmVkKTogdm9pZCB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGFzc2VydEluV29ya2Zsb3dDb250ZXh0KFxuICAgICdXb3JrZmxvdy5zZXREZWZhdWx0VXBkYXRlSGFuZGxlciguLi4pIG1heSBvbmx5IGJlIHVzZWQgZnJvbSBhIFdvcmtmbG93IEV4ZWN1dGlvbi4nXG4gICk7XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFjdGl2YXRvci5kZWZhdWx0VXBkYXRlSGFuZGxlciA9IGhhbmRsZXI7XG4gICAgYWN0aXZhdG9yLmRpc3BhdGNoQnVmZmVyZWRVcGRhdGVzKCk7XG4gIH0gZWxzZSBpZiAoaGFuZGxlciA9PSBudWxsKSB7XG4gICAgYWN0aXZhdG9yLmRlZmF1bHRVcGRhdGVIYW5kbGVyID0gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGhhbmRsZXIgdG8gYmUgZWl0aGVyIGEgZnVuY3Rpb24gb3IgJ3VuZGVmaW5lZCcuIEdvdDogJyR7dHlwZW9mIGhhbmRsZXJ9J2ApO1xuICB9XG59XG5cbi8qKlxuICogU2V0IGEgcXVlcnkgaGFuZGxlciBmdW5jdGlvbiB0aGF0IHdpbGwgaGFuZGxlIHF1ZXJ5IGNhbGxzIGZvciBub24tcmVnaXN0ZXJlZCBxdWVyeSBuYW1lcy5cbiAqXG4gKiBRdWVyaWVzIGFyZSBkaXNwYXRjaGVkIHRvIHRoZSBkZWZhdWx0IHF1ZXJ5IGhhbmRsZXIgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSB3ZXJlIGFjY2VwdGVkIGJ5IHRoZSBzZXJ2ZXIuXG4gKlxuICogSWYgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgZm9yIGEgZ2l2ZW4gcXVlcnkgbmFtZSB0aGUgbGFzdCBoYW5kbGVyIHdpbGwgb3ZlcndyaXRlIGFueSBwcmV2aW91cyBjYWxscy5cbiAqXG4gKiBAcGFyYW0gaGFuZGxlciBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBoYW5kbGUgcXVlcmllcyBmb3Igbm9uLXJlZ2lzdGVyZWQgcXVlcnkgbmFtZXMsIG9yIGB1bmRlZmluZWRgIHRvIHVuc2V0IHRoZSBoYW5kbGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RGVmYXVsdFF1ZXJ5SGFuZGxlcihoYW5kbGVyOiBEZWZhdWx0UXVlcnlIYW5kbGVyIHwgdW5kZWZpbmVkKTogdm9pZCB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGFzc2VydEluV29ya2Zsb3dDb250ZXh0KFxuICAgICdXb3JrZmxvdy5zZXREZWZhdWx0UXVlcnlIYW5kbGVyKC4uLikgbWF5IG9ubHkgYmUgdXNlZCBmcm9tIGEgV29ya2Zsb3cgRXhlY3V0aW9uLidcbiAgKTtcbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nIHx8IGhhbmRsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIGFjdGl2YXRvci5kZWZhdWx0UXVlcnlIYW5kbGVyID0gaGFuZGxlcjtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBoYW5kbGVyIHRvIGJlIGVpdGhlciBhIGZ1bmN0aW9uIG9yICd1bmRlZmluZWQnLiBHb3Q6ICcke3R5cGVvZiBoYW5kbGVyfSdgKTtcbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhpcyBXb3JrZmxvdydzIFNlYXJjaCBBdHRyaWJ1dGVzIGJ5IG1lcmdpbmcgdGhlIHByb3ZpZGVkIGBzZWFyY2hBdHRyaWJ1dGVzYCB3aXRoIHRoZSBleGlzdGluZyBTZWFyY2hcbiAqIEF0dHJpYnV0ZXMsIGB3b3JrZmxvd0luZm8oKS5zZWFyY2hBdHRyaWJ1dGVzYC5cbiAqXG4gKiBTZWFyY2ggYXR0cmlidXRlcyBjYW4gYmUgdXBzZXJ0ZWQgdXNpbmcgZWl0aGVyIFNlYXJjaEF0dHJpYnV0ZXMgKGRlcHJlY2F0ZWQpIG9yIFNlYXJjaEF0dHJpYnV0ZVVwZGF0ZVBhaXJbXSAocHJlZmVycmVkKVxuICpcbiAqIFVwc2VydGluZyBhIHdvcmtmbG93J3Mgc2VhcmNoIGF0dHJpYnV0ZXMgdXNpbmcgU2VhcmNoQXR0cmlidXRlVXBkYXRlUGFpcltdOlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBpbnRLZXkgPSBkZWZpbmVTZWFyY2hLZXkoJ0N1c3RvbUludEZpZWxkJywgJ0lOVCcpO1xuICogY29uc3QgYm9vbEtleSA9IGRlZmluZVNlYXJjaEtleSgnQ3VzdG9tQm9vbEZpZWxkJywgJ0JPT0wnKTtcbiAqIGNvbnN0IGtleXdvcmRMaXN0S2V5ID0gZGVmaW5lU2VhcmNoS2V5KCdDdXN0b21LZXl3b3JkRmllbGQnLCAnS0VZV09SRF9MSVNUJyk7XG4gKlxuICogdXBzZXJ0U2VhcmNoQXR0cmlidXRlcyhbXG4gKiAgZGVmaW5lU2VhcmNoQXR0cmlidXRlKGludEtleSwgMSksXG4gKiAgZGVmaW5lU2VhcmNoQXR0cmlidXRlKGJvb2xLZXksIHRydWUpXG4gKiBdKTtcbiAqIHVwc2VydFNlYXJjaEF0dHJpYnV0ZXMoW1xuICogIGRlZmluZVNlYXJjaEF0dHJpYnV0ZShpbnRLZXksIDQyKSxcbiAqICBkZWZpbmVTZWFyY2hBdHRyaWJ1dGUoa2V5d29yZExpc3RLZXksIFsnZHVyYWJsZSBjb2RlJywgJ2lzIGdyZWF0J10pXG4gKiBdKTtcbiAqIGBgYFxuICpcbiAqIFdvdWxkIHJlc3VsdCBpbiB0aGUgV29ya2Zsb3cgaGF2aW5nIHRoZXNlIFNlYXJjaCBBdHRyaWJ1dGVzOlxuICpcbiAqIGBgYHRzXG4gKiB7XG4gKiAgIEN1c3RvbUludEZpZWxkOiBbNDJdLFxuICogICBDdXN0b21Cb29sRmllbGQ6IFt0cnVlXSxcbiAqICAgQ3VzdG9tS2V5d29yZEZpZWxkOiBbJ2R1cmFibGUgY29kZScsICdpcyBncmVhdCddXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2VhcmNoQXR0cmlidXRlcyBUaGUgUmVjb3JkIHRvIG1lcmdlLlxuICogSWYgdXNpbmcgU2VhcmNoQXR0cmlidXRlVXBkYXRlUGFpcltdIChwcmVmZXJyZWQpLCBzZXQgYSB2YWx1ZSB0byBudWxsIHRvIHJlbW92ZSB0aGUgc2VhcmNoIGF0dHJpYnV0ZS5cbiAqIElmIHVzaW5nIFNlYXJjaEF0dHJpYnV0ZXMgKGRlcHJlY2F0ZWQpLCBzZXQgYSB2YWx1ZSB0byB1bmRlZmluZWQgb3IgYW4gZW1wdHkgbGlzdCB0byByZW1vdmUgdGhlIHNlYXJjaCBhdHRyaWJ1dGUuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuZXhwb3J0IGZ1bmN0aW9uIHVwc2VydFNlYXJjaEF0dHJpYnV0ZXMoc2VhcmNoQXR0cmlidXRlczogU2VhcmNoQXR0cmlidXRlcyB8IFNlYXJjaEF0dHJpYnV0ZVVwZGF0ZVBhaXJbXSk6IHZvaWQge1xuICBjb25zdCBhY3RpdmF0b3IgPSBhc3NlcnRJbldvcmtmbG93Q29udGV4dChcbiAgICAnV29ya2Zsb3cudXBzZXJ0U2VhcmNoQXR0cmlidXRlcyguLi4pIG1heSBvbmx5IGJlIHVzZWQgZnJvbSBhIFdvcmtmbG93IEV4ZWN1dGlvbi4nXG4gICk7XG5cbiAgaWYgKHNlYXJjaEF0dHJpYnV0ZXMgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2VhcmNoQXR0cmlidXRlcyBtdXN0IGJlIGEgbm9uLW51bGwgU2VhcmNoQXR0cmlidXRlcycpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoc2VhcmNoQXR0cmlidXRlcykpIHtcbiAgICAvLyBUeXBlZCBzZWFyY2ggYXR0cmlidXRlc1xuICAgIGFjdGl2YXRvci5wdXNoQ29tbWFuZCh7XG4gICAgICB1cHNlcnRXb3JrZmxvd1NlYXJjaEF0dHJpYnV0ZXM6IHtcbiAgICAgICAgc2VhcmNoQXR0cmlidXRlczogZW5jb2RlVW5pZmllZFNlYXJjaEF0dHJpYnV0ZXModW5kZWZpbmVkLCBzZWFyY2hBdHRyaWJ1dGVzKSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBhY3RpdmF0b3IubXV0YXRlV29ya2Zsb3dJbmZvKChpbmZvOiBXb3JrZmxvd0luZm8pOiBXb3JrZmxvd0luZm8gPT4ge1xuICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAgIGNvbnN0IG5ld1NlYXJjaEF0dHJpYnV0ZXM6IFNlYXJjaEF0dHJpYnV0ZXMgPSB7IC4uLmluZm8uc2VhcmNoQXR0cmlidXRlcyB9OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG4gICAgICBmb3IgKGNvbnN0IHBhaXIgb2Ygc2VhcmNoQXR0cmlidXRlcykge1xuICAgICAgICBpZiAocGFpci52YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIG51bGwsIHJlbW92ZSB0aGUgc2VhcmNoIGF0dHJpYnV0ZS5cbiAgICAgICAgICAvLyBXZSBkb24ndCBtdXRhdGUgdGhlIGV4aXN0aW5nIHN0YXRlIChqdXN0IHRoZSBuZXcgbWFwKSBzbyB0aGlzIGlzIHNhZmUuXG4gICAgICAgICAgZGVsZXRlIG5ld1NlYXJjaEF0dHJpYnV0ZXNbcGFpci5rZXkubmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3U2VhcmNoQXR0cmlidXRlc1twYWlyLmtleS5uYW1lXSA9IEFycmF5LmlzQXJyYXkocGFpci52YWx1ZSlcbiAgICAgICAgICAgID8gcGFpci52YWx1ZVxuICAgICAgICAgICAgOiAoW3BhaXIudmFsdWVdIGFzIFNlYXJjaEF0dHJpYnV0ZVZhbHVlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkZXByZWNhdGlvbi9kZXByZWNhdGlvblxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5pbmZvLFxuICAgICAgICBzZWFyY2hBdHRyaWJ1dGVzOiBuZXdTZWFyY2hBdHRyaWJ1dGVzLFxuICAgICAgICAvLyBDcmVhdGUgYW4gZW1wdHkgY29weSBhbmQgYXBwbHkgZXhpc3RpbmcgYW5kIG5ldyB1cGRhdGVzLiBLZWVwIGluIG1pbmQgdGhlIG9yZGVyIG1hdHRlcnMgaGVyZSAoZXhpc3RpbmcgZmlyc3QsIG5ldyBzZWNvbmQgLSB0byBwb3NzaWJseSBvdmVyd3JpdGUgZXhpc3RpbmcpLlxuICAgICAgICB0eXBlZFNlYXJjaEF0dHJpYnV0ZXM6IGluZm8udHlwZWRTZWFyY2hBdHRyaWJ1dGVzLnVwZGF0ZUNvcHkoWy4uLnNlYXJjaEF0dHJpYnV0ZXNdKSxcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTGVnYWN5IHNlYXJjaCBhdHRyaWJ1dGVzXG4gICAgYWN0aXZhdG9yLnB1c2hDb21tYW5kKHtcbiAgICAgIHVwc2VydFdvcmtmbG93U2VhcmNoQXR0cmlidXRlczoge1xuICAgICAgICBzZWFyY2hBdHRyaWJ1dGVzOiBtYXBUb1BheWxvYWRzKHNlYXJjaEF0dHJpYnV0ZVBheWxvYWRDb252ZXJ0ZXIsIHNlYXJjaEF0dHJpYnV0ZXMpLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGFjdGl2YXRvci5tdXRhdGVXb3JrZmxvd0luZm8oKGluZm86IFdvcmtmbG93SW5mbyk6IFdvcmtmbG93SW5mbyA9PiB7XG4gICAgICAvLyBDcmVhdGUgYSBuZXcgY29weSBvZiB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAgIGxldCB0eXBlZFNlYXJjaEF0dHJpYnV0ZXMgPSBpbmZvLnR5cGVkU2VhcmNoQXR0cmlidXRlcy51cGRhdGVDb3B5KFtdKTtcbiAgICAgIGNvbnN0IG5ld1NlYXJjaEF0dHJpYnV0ZXM6IFNlYXJjaEF0dHJpYnV0ZXMgPSB7IC4uLmluZm8uc2VhcmNoQXR0cmlidXRlcyB9OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRlcHJlY2F0aW9uL2RlcHJlY2F0aW9uXG5cbiAgICAgIC8vIFVwc2VydCBsZWdhY3kgc2VhcmNoIGF0dHJpYnV0ZXMgaW50byB0eXBlZFNlYXJjaEF0dHJpYnV0ZXMuXG4gICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhzZWFyY2hBdHRyaWJ1dGVzKSkge1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkICYmICFBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZWFyY2ggYXR0cmlidXRlIHZhbHVlIG11c3QgYmUgYW4gYXJyYXkgb3IgdW5kZWZpbmVkLCBnb3QgJHt2fWApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHZhbHVlIGlzIHVuZGVmaW5lZCBvciBhbiBlbXB0eSBsaXN0LCB0aGlzIHNpZ25pZmllcyBkZWxldGlvbi5cbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gYm90aCB1bnR5cGVkICYgdHlwZWQgc2VhcmNoIGF0dHJpYnV0ZXMuXG4gICAgICAgIGlmICh2ID09IG51bGwgfHwgKEFycmF5LmlzQXJyYXkodikgJiYgdi5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgLy8gV2UgY2Fubm90IGRpc2Nlcm4gYSB2YWxpZCBrZXkgdHlwaW5nIGZyb20gdGhlc2UgdmFsdWVzLlxuICAgICAgICAgIC8vIEluc3RlYWQsIHdlIGRvIGEgXCJiZXN0IGVmZm9ydFwiIGRlbGV0aW9uIGZyb20gdHlwZWQgc2VhcmNoIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgLy8gLSBjaGVjayBpZiBhIG1hdGNoaW5nIGtleSBuYW1lIGV4aXN0cywgaWYgc28sIHJlbW92ZSBpdC5cbiAgICAgICAgICBjb25zdCBtYXRjaGluZ1BhaXIgPSB0eXBlZFNlYXJjaEF0dHJpYnV0ZXMuZ2V0QWxsKCkuZmluZCgocGFpcikgPT4gcGFpci5rZXkubmFtZSA9PT0gayk7XG4gICAgICAgICAgaWYgKG1hdGNoaW5nUGFpcikge1xuICAgICAgICAgICAgdHlwZWRTZWFyY2hBdHRyaWJ1dGVzID0gdHlwZWRTZWFyY2hBdHRyaWJ1dGVzLnVwZGF0ZUNvcHkoW1xuICAgICAgICAgICAgICB7IGtleTogbWF0Y2hpbmdQYWlyLmtleSwgdmFsdWU6IG51bGwgfSBhcyBTZWFyY2hBdHRyaWJ1dGVVcGRhdGVQYWlyLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSBuZXdTZWFyY2hBdHRyaWJ1dGVzW2tdO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXR0ZW1wdCB0byBkaXNjZXJuIGEgdmFsaWQga2V5IHR5cGluZyBmb3IgdGhlIHVwZGF0ZS5cbiAgICAgICAgY29uc3QgdHlwZWRLZXkgPSBUeXBlZFNlYXJjaEF0dHJpYnV0ZXMuZ2V0S2V5RnJvbVVudHlwZWQoaywgdik7XG5cbiAgICAgICAgLy8gVW5hYmxlIHRvIGRpc2Nlcm4gYSB2YWxpZCBrZXkgdHlwaW5nIChubyB2YWxpZCB0eXBlIGZvciBkZWZpbmVkIHZhbHVlKS5cbiAgICAgICAgLy8gU2tpcCBhcHBseWluZyB0aGlzIHVwZGF0ZSAobm8tb3ApLlxuICAgICAgICBpZiAodHlwZWRLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVEVYVCB0eXBlIGlzIGluZmVycmVkIGZyb20gYSBzdHJpbmcgdmFsdWUsIGJ1dCBpdCBjb3VsZCBhbHNvIGJlIEtFWVdPUkQuXG4gICAgICAgIC8vIElmIGEgbWF0Y2hpbmcgcGFpciBleGlzdHMgd2l0aCBLRVlXT1JEIHR5cGUsIHVzZSB0aGF0IGluc3RlYWQuXG4gICAgICAgIGlmICh0eXBlZEtleS50eXBlID09PSAnVEVYVCcpIHtcbiAgICAgICAgICBjb25zdCBtYXRjaGluZ1BhaXIgPSB0eXBlZFNlYXJjaEF0dHJpYnV0ZXMuZ2V0QWxsKCkuZmluZCgocGFpcikgPT4gcGFpci5rZXkubmFtZSA9PT0gdHlwZWRLZXkubmFtZSk7XG4gICAgICAgICAgaWYgKG1hdGNoaW5nUGFpcikge1xuICAgICAgICAgICAgdHlwZWRLZXkudHlwZSA9IG1hdGNoaW5nUGFpci5rZXkudHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbmV3VmFsdWU6IHVua25vd24gPSB2O1xuICAgICAgICAvLyBVbnBhY2sgdmFsdWUgaWYgaXQgaXMgYSBzaW5nbGUtZWxlbWVudCBhcnJheS5cbiAgICAgICAgaWYgKHYubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSB2WzBdO1xuICAgICAgICAgIC8vIENvbnZlcnQgdmFsdWUgYmFjayB0byBEYXRlLlxuICAgICAgICAgIGlmICh0eXBlZEtleS50eXBlID09PSAnREFURVRJTUUnKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IG5ldyBEYXRlKG5ld1ZhbHVlIGFzIHN0cmluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgaGF2ZSBhIGRlZmluZWQgdmFsdWUgd2l0aCB2YWxpZCB0eXBlLiBBcHBseSB0aGUgdXBkYXRlLlxuICAgICAgICB0eXBlZFNlYXJjaEF0dHJpYnV0ZXMgPSB0eXBlZFNlYXJjaEF0dHJpYnV0ZXMudXBkYXRlQ29weShbXG4gICAgICAgICAgeyBrZXk6IHR5cGVkS2V5LCB2YWx1ZTogbmV3VmFsdWUgfSBhcyBTZWFyY2hBdHRyaWJ1dGVVcGRhdGVQYWlyLFxuICAgICAgICBdKTtcbiAgICAgICAgbmV3U2VhcmNoQXR0cmlidXRlc1trXSA9IHY7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5pbmZvLFxuICAgICAgICBzZWFyY2hBdHRyaWJ1dGVzOiBuZXdTZWFyY2hBdHRyaWJ1dGVzLFxuICAgICAgICB0eXBlZFNlYXJjaEF0dHJpYnV0ZXMsXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGlzIFdvcmtmbG93J3MgTWVtb3MgYnkgbWVyZ2luZyB0aGUgcHJvdmlkZWQgYG1lbW9gIHdpdGggZXhpc3RpbmdcbiAqIE1lbW9zIChhcyByZXR1cm5lZCBieSBgd29ya2Zsb3dJbmZvKCkubWVtb2ApLlxuICpcbiAqIE5ldyBtZW1vIGlzIG1lcmdlZCBieSByZXBsYWNpbmcgcHJvcGVydGllcyBvZiB0aGUgc2FtZSBuYW1lIF9hdCB0aGUgZmlyc3RcbiAqIGxldmVsIG9ubHlfLiBTZXR0aW5nIGEgcHJvcGVydHkgdG8gdmFsdWUgYHVuZGVmaW5lZGAgb3IgYG51bGxgIGNsZWFycyB0aGF0XG4gKiBrZXkgZnJvbSB0aGUgTWVtby5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGB0c1xuICogdXBzZXJ0TWVtbyh7XG4gKiAgIGtleTE6IHZhbHVlLFxuICogICBrZXkzOiB7IHN1YmtleTE6IHZhbHVlIH1cbiAqICAga2V5NDogdmFsdWUsXG4gKiB9KTtcbiAqIHVwc2VydE1lbW8oe1xuICogICBrZXkyOiB2YWx1ZVxuICogICBrZXkzOiB7IHN1YmtleTI6IHZhbHVlIH1cbiAqICAga2V5NDogdW5kZWZpbmVkLFxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiB3b3VsZCByZXN1bHQgaW4gdGhlIFdvcmtmbG93IGhhdmluZyB0aGVzZSBNZW1vOlxuICpcbiAqIGBgYHRzXG4gKiB7XG4gKiAgIGtleTE6IHZhbHVlLFxuICogICBrZXkyOiB2YWx1ZSxcbiAqICAga2V5MzogeyBzdWJrZXkyOiB2YWx1ZSB9ICAvLyBOb3RlIHRoaXMgb2JqZWN0IHdhcyBjb21wbGV0ZWx5IHJlcGxhY2VkXG4gKiAgIC8vIE5vdGUgdGhhdCBrZXk0IHdhcyBjb21wbGV0ZWx5IHJlbW92ZWRcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBtZW1vIFRoZSBSZWNvcmQgdG8gbWVyZ2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cHNlcnRNZW1vKG1lbW86IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogdm9pZCB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGFzc2VydEluV29ya2Zsb3dDb250ZXh0KCdXb3JrZmxvdy51cHNlcnRNZW1vKC4uLikgbWF5IG9ubHkgYmUgdXNlZCBmcm9tIGEgV29ya2Zsb3cgRXhlY3V0aW9uLicpO1xuXG4gIGlmIChtZW1vID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ21lbW8gbXVzdCBiZSBhIG5vbi1udWxsIFJlY29yZCcpO1xuICB9XG5cbiAgYWN0aXZhdG9yLnB1c2hDb21tYW5kKHtcbiAgICBtb2RpZnlXb3JrZmxvd1Byb3BlcnRpZXM6IHtcbiAgICAgIHVwc2VydGVkTWVtbzoge1xuICAgICAgICBmaWVsZHM6IG1hcFRvUGF5bG9hZHMoXG4gICAgICAgICAgYWN0aXZhdG9yLnBheWxvYWRDb252ZXJ0ZXIsXG4gICAgICAgICAgLy8gQ29udmVydCBudWxsIHRvIHVuZGVmaW5lZFxuICAgICAgICAgIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhtZW1vKS5tYXAoKFtrLCB2XSkgPT4gW2ssIHYgPz8gdW5kZWZpbmVkXSkpXG4gICAgICAgICksXG4gICAgICB9LFxuICAgIH0sXG4gIH0pO1xuXG4gIGFjdGl2YXRvci5tdXRhdGVXb3JrZmxvd0luZm8oKGluZm86IFdvcmtmbG93SW5mbyk6IFdvcmtmbG93SW5mbyA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmluZm8sXG4gICAgICBtZW1vOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHtcbiAgICAgICAgICAuLi5pbmZvLm1lbW8sXG4gICAgICAgICAgLi4ubWVtbyxcbiAgICAgICAgfSkuZmlsdGVyKChbXywgdl0pID0+IHYgIT0gbnVsbClcbiAgICAgICksXG4gICAgfTtcbiAgfSk7XG59XG5cbi8qKlxuICogV2hldGhlciB1cGRhdGUgYW5kIHNpZ25hbCBoYW5kbGVycyBoYXZlIGZpbmlzaGVkIGV4ZWN1dGluZy5cbiAqXG4gKiBDb25zaWRlciB3YWl0aW5nIG9uIHRoaXMgY29uZGl0aW9uIGJlZm9yZSB3b3JrZmxvdyByZXR1cm4gb3IgY29udGludWUtYXMtbmV3LCB0byBwcmV2ZW50XG4gKiBpbnRlcnJ1cHRpb24gb2YgaW4tcHJvZ3Jlc3MgaGFuZGxlcnMgYnkgd29ya2Zsb3cgZXhpdDpcbiAqXG4gKiBgYGB0c1xuICogYXdhaXQgd29ya2Zsb3cuY29uZGl0aW9uKHdvcmtmbG93LmFsbEhhbmRsZXJzRmluaXNoZWQpXG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZXJlIGFyZSBubyBpbi1wcm9ncmVzcyB1cGRhdGUgb3Igc2lnbmFsIGhhbmRsZXIgZXhlY3V0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFsbEhhbmRsZXJzRmluaXNoZWQoKTogYm9vbGVhbiB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGFzc2VydEluV29ya2Zsb3dDb250ZXh0KCdhbGxIYW5kbGVyc0ZpbmlzaGVkKCkgbWF5IG9ubHkgYmUgdXNlZCBmcm9tIGEgV29ya2Zsb3cgRXhlY3V0aW9uLicpO1xuICByZXR1cm4gYWN0aXZhdG9yLmluUHJvZ3Jlc3NTaWduYWxzLnNpemUgPT09IDAgJiYgYWN0aXZhdG9yLmluUHJvZ3Jlc3NVcGRhdGVzLnNpemUgPT09IDA7XG59XG5cbi8qKlxuICogQ2FuIGJlIHVzZWQgdG8gYWx0ZXIgd29ya2Zsb3cgZnVuY3Rpb25zIHdpdGggY2VydGFpbiBvcHRpb25zIHNwZWNpZmllZCBhdCBkZWZpbml0aW9uIHRpbWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIEZvciBleGFtcGxlOlxuICogYGBgdHNcbiAqIHNldFdvcmtmbG93T3B0aW9ucyh7IHZlcnNpb25pbmdCZWhhdmlvcjogJ1BJTk5FRCcgfSwgbXlXb3JrZmxvdyk7XG4gKiBleHBvcnQgYXN5bmMgZnVuY3Rpb24gbXlXb3JrZmxvdygpOiBQcm9taXNlPHN0cmluZz4ge1xuICogICAvLyBXb3JrZmxvdyBjb2RlIGhlcmVcbiAqICAgcmV0dXJuIFwiaGlcIjtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBUbyBhbm5vdGF0ZSBhIGRlZmF1bHQgb3IgZHluYW1pYyB3b3JrZmxvdzpcbiAqIGBgYHRzXG4gKiBleHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiAoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAqICAgLy8gV29ya2Zsb3cgY29kZSBoZXJlXG4gKiAgIHJldHVybiBcImhpXCI7XG4gKiB9XG4gKiBzZXRXb3JrZmxvd09wdGlvbnMoeyB2ZXJzaW9uaW5nQmVoYXZpb3I6ICdQSU5ORUQnIH0sIG1vZHVsZS5leHBvcnRzLmRlZmF1bHQpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIHdvcmtmbG93IGRlZmludGlvbiwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgb3B0aW9ucy4gSWYgYVxuICogZnVuY3Rpb24gaXMgcHJvdmlkZWQsIGl0IHdpbGwgYmUgY2FsbGVkIG9uY2UganVzdCBiZWZvcmUgdGhlIHdvcmtmbG93IGZ1bmN0aW9uIGlzIGNhbGxlZCBmb3IgdGhlXG4gKiBmaXJzdCB0aW1lLiBJdCBpcyBzYWZlIHRvIGNhbGwge0BsaW5rIHdvcmtmbG93SW5mb30gaW5zaWRlIHN1Y2ggYSBmdW5jdGlvbi5cbiAqIEBwYXJhbSBmbiBUaGUgd29ya2Zsb3cgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRXb3JrZmxvd09wdGlvbnM8QSBleHRlbmRzIGFueVtdLCBSVD4oXG4gIG9wdGlvbnM6IFdvcmtmbG93RGVmaW5pdGlvbk9wdGlvbnNPckdldHRlcixcbiAgZm46ICguLi5hcmdzOiBBKSA9PiBQcm9taXNlPFJUPlxuKTogdm9pZCB7XG4gIE9iamVjdC5hc3NpZ24oZm4sIHtcbiAgICB3b3JrZmxvd0RlZmluaXRpb25PcHRpb25zOiBvcHRpb25zLFxuICB9KTtcbn1cblxuZXhwb3J0IGNvbnN0IHN0YWNrVHJhY2VRdWVyeSA9IGRlZmluZVF1ZXJ5PHN0cmluZz4oJ19fc3RhY2tfdHJhY2UnKTtcbmV4cG9ydCBjb25zdCBlbmhhbmNlZFN0YWNrVHJhY2VRdWVyeSA9IGRlZmluZVF1ZXJ5PEVuaGFuY2VkU3RhY2tUcmFjZT4oJ19fZW5oYW5jZWRfc3RhY2tfdHJhY2UnKTtcbmV4cG9ydCBjb25zdCB3b3JrZmxvd01ldGFkYXRhUXVlcnkgPSBkZWZpbmVRdWVyeTx0ZW1wb3JhbC5hcGkuc2RrLnYxLklXb3JrZmxvd01ldGFkYXRhPignX190ZW1wb3JhbF93b3JrZmxvd19tZXRhZGF0YScpO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VycmVudERldGFpbHMoKTogc3RyaW5nIHtcbiAgY29uc3QgYWN0aXZhdG9yID0gYXNzZXJ0SW5Xb3JrZmxvd0NvbnRleHQoJ2dldEN1cnJlbnREZXRhaWxzKCkgbWF5IG9ubHkgYmUgdXNlZCBmcm9tIGEgV29ya2Zsb3cgRXhlY3V0aW9uLicpO1xuICByZXR1cm4gYWN0aXZhdG9yLmN1cnJlbnREZXRhaWxzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0Q3VycmVudERldGFpbHMoZGV0YWlsczogc3RyaW5nKTogdm9pZCB7XG4gIGNvbnN0IGFjdGl2YXRvciA9IGFzc2VydEluV29ya2Zsb3dDb250ZXh0KCdnZXRDdXJyZW50RGV0YWlscygpIG1heSBvbmx5IGJlIHVzZWQgZnJvbSBhIFdvcmtmbG93IEV4ZWN1dGlvbi4nKTtcbiAgYWN0aXZhdG9yLmN1cnJlbnREZXRhaWxzID0gZGV0YWlscztcbn1cbiIsIi8vIEdFTkVSQVRFRCBGSUxFLiBETyBOT1QgRURJVC5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIGZ1bmN0aW9uIHByZWZlckRlZmF1bHQoZXhwb3J0cykge1xuICAgIHJldHVybiBleHBvcnRzLmRlZmF1bHQgfHwgZXhwb3J0cztcbiAgfVxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBleHBvcnRzID0ge307XG4gICAgICBmYWN0b3J5KGV4cG9ydHMpO1xuICAgICAgcmV0dXJuIHByZWZlckRlZmF1bHQoZXhwb3J0cyk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBmYWN0b3J5KGV4cG9ydHMpO1xuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiKSBtb2R1bGUuZXhwb3J0cyA9IHByZWZlckRlZmF1bHQoZXhwb3J0cyk7XG4gIH0gZWxzZSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBleHBvcnRzID0ge307XG4gICAgICBmYWN0b3J5KGV4cG9ydHMpO1xuICAgICAgZ2xvYmFsLkxvbmcgPSBwcmVmZXJEZWZhdWx0KGV4cG9ydHMpO1xuICAgIH0pKCk7XG4gIH1cbn0pKFxuICB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIlxuICAgID8gZ2xvYmFsVGhpc1xuICAgIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgID8gc2VsZlxuICAgICAgOiB0aGlzLFxuICBmdW5jdGlvbiAoX2V4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlLFxuICAgIH0pO1xuICAgIF9leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgMjAwOSBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnNcbiAgICAgKiBDb3B5cmlnaHQgMjAyMCBEYW5pZWwgV2lydHogLyBUaGUgbG9uZy5qcyBBdXRob3JzLlxuICAgICAqXG4gICAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICAgKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAgICpcbiAgICAgKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gICAgICpcbiAgICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAgICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICAgKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAgICAgKlxuICAgICAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gICAgICovXG5cbiAgICAvLyBXZWJBc3NlbWJseSBvcHRpbWl6YXRpb25zIHRvIGRvIG5hdGl2ZSBpNjQgbXVsdGlwbGljYXRpb24gYW5kIGRpdmlkZVxuICAgIHZhciB3YXNtID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgd2FzbSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShcbiAgICAgICAgbmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShcbiAgICAgICAgICBuZXcgVWludDhBcnJheShbXG4gICAgICAgICAgICAvLyBcXDBhc21cbiAgICAgICAgICAgIDAsIDk3LCAxMTUsIDEwOSxcbiAgICAgICAgICAgIC8vIHZlcnNpb24gMVxuICAgICAgICAgICAgMSwgMCwgMCwgMCxcbiAgICAgICAgICAgIC8vIHNlY3Rpb24gXCJ0eXBlXCJcbiAgICAgICAgICAgIDEsIDEzLCAyLFxuICAgICAgICAgICAgLy8gMCwgKCkgPT4gaTMyXG4gICAgICAgICAgICA5NiwgMCwgMSwgMTI3LFxuICAgICAgICAgICAgLy8gMSwgKGkzMiwgaTMyLCBpMzIsIGkzMikgPT4gaTMyXG4gICAgICAgICAgICA5NiwgNCwgMTI3LCAxMjcsIDEyNywgMTI3LCAxLCAxMjcsXG4gICAgICAgICAgICAvLyBzZWN0aW9uIFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgMywgNywgNixcbiAgICAgICAgICAgIC8vIDAsIHR5cGUgMFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIC8vIDEsIHR5cGUgMVxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIC8vIDIsIHR5cGUgMVxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIC8vIDMsIHR5cGUgMVxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIC8vIDQsIHR5cGUgMVxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIC8vIDUsIHR5cGUgMVxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIC8vIHNlY3Rpb24gXCJnbG9iYWxcIlxuICAgICAgICAgICAgNiwgNiwgMSxcbiAgICAgICAgICAgIC8vIDAsIFwiaGlnaFwiLCBtdXRhYmxlIGkzMlxuICAgICAgICAgICAgMTI3LCAxLCA2NSwgMCwgMTEsXG4gICAgICAgICAgICAvLyBzZWN0aW9uIFwiZXhwb3J0XCJcbiAgICAgICAgICAgIDcsIDUwLCA2LFxuICAgICAgICAgICAgLy8gMCwgXCJtdWxcIlxuICAgICAgICAgICAgMywgMTA5LCAxMTcsIDEwOCwgMCwgMSxcbiAgICAgICAgICAgIC8vIDEsIFwiZGl2X3NcIlxuICAgICAgICAgICAgNSwgMTAwLCAxMDUsIDExOCwgOTUsIDExNSwgMCwgMixcbiAgICAgICAgICAgIC8vIDIsIFwiZGl2X3VcIlxuICAgICAgICAgICAgNSwgMTAwLCAxMDUsIDExOCwgOTUsIDExNywgMCwgMyxcbiAgICAgICAgICAgIC8vIDMsIFwicmVtX3NcIlxuICAgICAgICAgICAgNSwgMTE0LCAxMDEsIDEwOSwgOTUsIDExNSwgMCwgNCxcbiAgICAgICAgICAgIC8vIDQsIFwicmVtX3VcIlxuICAgICAgICAgICAgNSwgMTE0LCAxMDEsIDEwOSwgOTUsIDExNywgMCwgNSxcbiAgICAgICAgICAgIC8vIDUsIFwiZ2V0X2hpZ2hcIlxuICAgICAgICAgICAgOCwgMTAzLCAxMDEsIDExNiwgOTUsIDEwNCwgMTA1LCAxMDMsIDEwNCwgMCwgMCxcbiAgICAgICAgICAgIC8vIHNlY3Rpb24gXCJjb2RlXCJcbiAgICAgICAgICAgIDEwLCAxOTEsIDEsIDYsXG4gICAgICAgICAgICAvLyAwLCBcImdldF9oaWdoXCJcbiAgICAgICAgICAgIDQsIDAsIDM1LCAwLCAxMSxcbiAgICAgICAgICAgIC8vIDEsIFwibXVsXCJcbiAgICAgICAgICAgIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsXG4gICAgICAgICAgICAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjYsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCxcbiAgICAgICAgICAgIDMyLCA0LCAxNjcsIDExLFxuICAgICAgICAgICAgLy8gMiwgXCJkaXZfc1wiXG4gICAgICAgICAgICAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLFxuICAgICAgICAgICAgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI3LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsXG4gICAgICAgICAgICAzMiwgNCwgMTY3LCAxMSxcbiAgICAgICAgICAgIC8vIDMsIFwiZGl2X3VcIlxuICAgICAgICAgICAgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MyxcbiAgICAgICAgICAgIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyOCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLFxuICAgICAgICAgICAgMzIsIDQsIDE2NywgMTEsXG4gICAgICAgICAgICAvLyA0LCBcInJlbV9zXCJcbiAgICAgICAgICAgIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsXG4gICAgICAgICAgICAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjksIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCxcbiAgICAgICAgICAgIDMyLCA0LCAxNjcsIDExLFxuICAgICAgICAgICAgLy8gNSwgXCJyZW1fdVwiXG4gICAgICAgICAgICAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLFxuICAgICAgICAgICAgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTMwLCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsXG4gICAgICAgICAgICAzMiwgNCwgMTY3LCAxMSxcbiAgICAgICAgICBdKSxcbiAgICAgICAgKSxcbiAgICAgICAge30sXG4gICAgICApLmV4cG9ydHM7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBubyB3YXNtIHN1cHBvcnQgOihcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgNjQgYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciwgZ2l2ZW4gaXRzIGxvdyBhbmQgaGlnaCAzMiBiaXQgdmFsdWVzIGFzICpzaWduZWQqIGludGVnZXJzLlxuICAgICAqICBTZWUgdGhlIGZyb20qIGZ1bmN0aW9ucyBiZWxvdyBmb3IgbW9yZSBjb252ZW5pZW50IHdheXMgb2YgY29uc3RydWN0aW5nIExvbmdzLlxuICAgICAqIEBleHBvcnRzIExvbmdcbiAgICAgKiBAY2xhc3MgQSBMb25nIGNsYXNzIGZvciByZXByZXNlbnRpbmcgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb3cgVGhlIGxvdyAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhpZ2ggVGhlIGhpZ2ggKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb25nKGxvdywgaGlnaCwgdW5zaWduZWQpIHtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxuICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAqL1xuICAgICAgdGhpcy5sb3cgPSBsb3cgfCAwO1xuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICovXG4gICAgICB0aGlzLmhpZ2ggPSBoaWdoIHwgMDtcblxuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdC5cbiAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICovXG4gICAgICB0aGlzLnVuc2lnbmVkID0gISF1bnNpZ25lZDtcbiAgICB9XG5cbiAgICAvLyBUaGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYSBsb25nIGlzIHRoZSB0d28gZ2l2ZW4gc2lnbmVkLCAzMi1iaXQgdmFsdWVzLlxuICAgIC8vIFdlIHVzZSAzMi1iaXQgcGllY2VzIGJlY2F1c2UgdGhlc2UgYXJlIHRoZSBzaXplIG9mIGludGVnZXJzIG9uIHdoaWNoXG4gICAgLy8gSmF2YXNjcmlwdCBwZXJmb3JtcyBiaXQtb3BlcmF0aW9ucy4gIEZvciBvcGVyYXRpb25zIGxpa2UgYWRkaXRpb24gYW5kXG4gICAgLy8gbXVsdGlwbGljYXRpb24sIHdlIHNwbGl0IGVhY2ggbnVtYmVyIGludG8gMTYgYml0IHBpZWNlcywgd2hpY2ggY2FuIGVhc2lseSBiZVxuICAgIC8vIG11bHRpcGxpZWQgd2l0aGluIEphdmFzY3JpcHQncyBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiB3aXRob3V0IG92ZXJmbG93XG4gICAgLy8gb3IgY2hhbmdlIGluIHNpZ24uXG4gICAgLy9cbiAgICAvLyBJbiB0aGUgYWxnb3JpdGhtcyBiZWxvdywgd2UgZnJlcXVlbnRseSByZWR1Y2UgdGhlIG5lZ2F0aXZlIGNhc2UgdG8gdGhlXG4gICAgLy8gcG9zaXRpdmUgY2FzZSBieSBuZWdhdGluZyB0aGUgaW5wdXQocykgYW5kIHRoZW4gcG9zdC1wcm9jZXNzaW5nIHRoZSByZXN1bHQuXG4gICAgLy8gTm90ZSB0aGF0IHdlIG11c3QgQUxXQVlTIGNoZWNrIHNwZWNpYWxseSB3aGV0aGVyIHRob3NlIHZhbHVlcyBhcmUgTUlOX1ZBTFVFXG4gICAgLy8gKC0yXjYzKSBiZWNhdXNlIC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFIChzaW5jZSAyXjYzIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhc1xuICAgIC8vIGEgcG9zaXRpdmUgbnVtYmVyLCBpdCBvdmVyZmxvd3MgYmFjayBpbnRvIGEgbmVnYXRpdmUpLiAgTm90IGhhbmRsaW5nIHRoaXNcbiAgICAvLyBjYXNlIHdvdWxkIG9mdGVuIHJlc3VsdCBpbiBpbmZpbml0ZSByZWN1cnNpb24uXG4gICAgLy9cbiAgICAvLyBDb21tb24gY29uc3RhbnQgdmFsdWVzIFpFUk8sIE9ORSwgTkVHX09ORSwgZXRjLiBhcmUgZGVmaW5lZCBiZWxvdyB0aGUgZnJvbSpcbiAgICAvLyBtZXRob2RzIG9uIHdoaWNoIHRoZXkgZGVwZW5kLlxuXG4gICAgLyoqXG4gICAgICogQW4gaW5kaWNhdG9yIHVzZWQgdG8gcmVsaWFibHkgZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIExvbmcgb3Igbm90LlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBjb25zdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTG9uZy5wcm90b3R5cGUuX19pc0xvbmdfXztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9uZy5wcm90b3R5cGUsIFwiX19pc0xvbmdfX1wiLCB7XG4gICAgICB2YWx1ZTogdHJ1ZSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTG9uZyhvYmopIHtcbiAgICAgIHJldHVybiAob2JqICYmIG9ialtcIl9faXNMb25nX19cIl0pID09PSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgbnVtYmVyXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdHozMih2YWx1ZSkge1xuICAgICAgdmFyIGMgPSBNYXRoLmNsejMyKHZhbHVlICYgLXZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZSA/IDMxIC0gYyA6IGM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgaXMgYSBMb25nLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIExvbmcuaXNMb25nID0gaXNMb25nO1xuXG4gICAgLyoqXG4gICAgICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgaW50ZWdlciB2YWx1ZXMuXG4gICAgICogQHR5cGUgeyFPYmplY3R9XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIElOVF9DQUNIRSA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuXG4gICAgICogQHR5cGUgeyFPYmplY3R9XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIFVJTlRfQ0FDSEUgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXG4gICAgICogQHJldHVybnMgeyFMb25nfVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21JbnQodmFsdWUsIHVuc2lnbmVkKSB7XG4gICAgICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlO1xuICAgICAgaWYgKHVuc2lnbmVkKSB7XG4gICAgICAgIHZhbHVlID4+Pj0gMDtcbiAgICAgICAgaWYgKChjYWNoZSA9IDAgPD0gdmFsdWUgJiYgdmFsdWUgPCAyNTYpKSB7XG4gICAgICAgICAgY2FjaGVkT2JqID0gVUlOVF9DQUNIRVt2YWx1ZV07XG4gICAgICAgICAgaWYgKGNhY2hlZE9iaikgcmV0dXJuIGNhY2hlZE9iajtcbiAgICAgICAgfVxuICAgICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgMCwgdHJ1ZSk7XG4gICAgICAgIGlmIChjYWNoZSkgVUlOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSB8PSAwO1xuICAgICAgICBpZiAoKGNhY2hlID0gLTEyOCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDEyOCkpIHtcbiAgICAgICAgICBjYWNoZWRPYmogPSBJTlRfQ0FDSEVbdmFsdWVdO1xuICAgICAgICAgIGlmIChjYWNoZWRPYmopIHJldHVybiBjYWNoZWRPYmo7XG4gICAgICAgIH1cbiAgICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpO1xuICAgICAgICBpZiAoY2FjaGUpIElOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiAzMiBiaXQgaW50ZWdlciB2YWx1ZS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIDMyIGJpdCBpbnRlZ2VyIGluIHF1ZXN0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICAgICAqL1xuICAgIExvbmcuZnJvbUludCA9IGZyb21JbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlLCB1bnNpZ25lZCkge1xuICAgICAgaWYgKGlzTmFOKHZhbHVlKSkgcmV0dXJuIHVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICAgICAgaWYgKHVuc2lnbmVkKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8IDApIHJldHVybiBVWkVSTztcbiAgICAgICAgaWYgKHZhbHVlID49IFRXT19QV1JfNjRfREJMKSByZXR1cm4gTUFYX1VOU0lHTkVEX1ZBTFVFO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHZhbHVlIDw9IC1UV09fUFdSXzYzX0RCTCkgcmV0dXJuIE1JTl9WQUxVRTtcbiAgICAgICAgaWYgKHZhbHVlICsgMSA+PSBUV09fUFdSXzYzX0RCTCkgcmV0dXJuIE1BWF9WQUxVRTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA8IDApIHJldHVybiBmcm9tTnVtYmVyKC12YWx1ZSwgdW5zaWduZWQpLm5lZygpO1xuICAgICAgcmV0dXJuIGZyb21CaXRzKFxuICAgICAgICB2YWx1ZSAlIFRXT19QV1JfMzJfREJMIHwgMCxcbiAgICAgICAgKHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwpIHwgMCxcbiAgICAgICAgdW5zaWduZWQsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gdmFsdWUsIHByb3ZpZGVkIHRoYXQgaXQgaXMgYSBmaW5pdGUgbnVtYmVyLiBPdGhlcndpc2UsIHplcm8gaXMgcmV0dXJuZWQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgaW4gcXVlc3Rpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAgICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gICAgICovXG4gICAgTG9uZy5mcm9tTnVtYmVyID0gZnJvbU51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbUJpdHMobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKSB7XG4gICAgICByZXR1cm4gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIDY0IGJpdCBpbnRlZ2VyIHRoYXQgY29tZXMgYnkgY29uY2F0ZW5hdGluZyB0aGUgZ2l2ZW4gbG93IGFuZCBoaWdoIGJpdHMuIEVhY2ggaXNcbiAgICAgKiAgYXNzdW1lZCB0byB1c2UgMzIgYml0cy5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG93Qml0cyBUaGUgbG93IDMyIGJpdHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHMgVGhlIGhpZ2ggMzIgYml0c1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAgICAgKi9cbiAgICBMb25nLmZyb21CaXRzID0gZnJvbUJpdHM7XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYmFzZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleHBvbmVudFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIHBvd19kYmwgPSBNYXRoLnBvdzsgLy8gVXNlZCA0IHRpbWVzICg0KjggdG8gMTUrNClcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICAgKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXhcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIsIHVuc2lnbmVkLCByYWRpeCkge1xuICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDApIHRocm93IEVycm9yKFwiZW1wdHkgc3RyaW5nXCIpO1xuICAgICAgaWYgKHR5cGVvZiB1bnNpZ25lZCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAvLyBGb3IgZ29vZy5tYXRoLmxvbmcgY29tcGF0aWJpbGl0eVxuICAgICAgICByYWRpeCA9IHVuc2lnbmVkO1xuICAgICAgICB1bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5zaWduZWQgPSAhIXVuc2lnbmVkO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBzdHIgPT09IFwiTmFOXCIgfHxcbiAgICAgICAgc3RyID09PSBcIkluZmluaXR5XCIgfHxcbiAgICAgICAgc3RyID09PSBcIitJbmZpbml0eVwiIHx8XG4gICAgICAgIHN0ciA9PT0gXCItSW5maW5pdHlcIlxuICAgICAgKVxuICAgICAgICByZXR1cm4gdW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XG4gICAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xuICAgICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KSB0aHJvdyBSYW5nZUVycm9yKFwicmFkaXhcIik7XG4gICAgICB2YXIgcDtcbiAgICAgIGlmICgocCA9IHN0ci5pbmRleE9mKFwiLVwiKSkgPiAwKSB0aHJvdyBFcnJvcihcImludGVyaW9yIGh5cGhlblwiKTtcbiAgICAgIGVsc2UgaWYgKHAgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcoc3RyLnN1YnN0cmluZygxKSwgdW5zaWduZWQsIHJhZGl4KS5uZWcoKTtcbiAgICAgIH1cblxuICAgICAgLy8gRG8gc2V2ZXJhbCAoOCkgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xuICAgICAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXG4gICAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA4KSk7XG4gICAgICB2YXIgcmVzdWx0ID0gWkVSTztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSA4KSB7XG4gICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oOCwgc3RyLmxlbmd0aCAtIGkpLFxuICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTtcbiAgICAgICAgaWYgKHNpemUgPCA4KSB7XG4gICAgICAgICAgdmFyIHBvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCBzaXplKSk7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChwb3dlcikuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHJhZGl4VG9Qb3dlcik7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdC51bnNpZ25lZCA9IHVuc2lnbmVkO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gc3RyaW5nLCB3cml0dGVuIHVzaW5nIHRoZSBzcGVjaWZpZWQgcmFkaXguXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgTG9uZ1xuICAgICAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IHJhZGl4IFRoZSByYWRpeCBpbiB3aGljaCB0aGUgdGV4dCBpcyB3cml0dGVuICgyLTM2KSwgZGVmYXVsdHMgdG8gMTBcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAgICAgKi9cbiAgICBMb25nLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tVmFsdWUodmFsLCB1bnNpZ25lZCkge1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIpIHJldHVybiBmcm9tTnVtYmVyKHZhbCwgdW5zaWduZWQpO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpIHJldHVybiBmcm9tU3RyaW5nKHZhbCwgdW5zaWduZWQpO1xuICAgICAgLy8gVGhyb3dzIGZvciBub24tb2JqZWN0cywgY29udmVydHMgbm9uLWluc3RhbmNlb2YgTG9uZzpcbiAgICAgIHJldHVybiBmcm9tQml0cyhcbiAgICAgICAgdmFsLmxvdyxcbiAgICAgICAgdmFsLmhpZ2gsXG4gICAgICAgIHR5cGVvZiB1bnNpZ25lZCA9PT0gXCJib29sZWFuXCIgPyB1bnNpZ25lZCA6IHZhbC51bnNpZ25lZCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIHNwZWNpZmllZCB2YWx1ZSB0byBhIExvbmcgdXNpbmcgdGhlIGFwcHJvcHJpYXRlIGZyb20qIGZ1bmN0aW9uIGZvciBpdHMgdHlwZS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWwgVmFsdWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAgICogQHJldHVybnMgeyFMb25nfVxuICAgICAqL1xuICAgIExvbmcuZnJvbVZhbHVlID0gZnJvbVZhbHVlO1xuXG4gICAgLy8gTk9URTogdGhlIGNvbXBpbGVyIHNob3VsZCBpbmxpbmUgdGhlc2UgY29uc3RhbnQgdmFsdWVzIGJlbG93IGFuZCB0aGVuIHJlbW92ZSB0aGVzZSB2YXJpYWJsZXMsIHNvIHRoZXJlIHNob3VsZCBiZVxuICAgIC8vIG5vIHJ1bnRpbWUgcGVuYWx0eSBmb3IgdGhlc2UuXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBjb25zdFxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBjb25zdFxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBUV09fUFdSXzI0X0RCTCA9IDEgPDwgMjQ7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBjb25zdFxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBUV09fUFdSXzMyX0RCTCA9IFRXT19QV1JfMTZfREJMICogVFdPX1BXUl8xNl9EQkw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBjb25zdFxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBjb25zdFxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBUV09fUFdSXzYzX0RCTCA9IFRXT19QV1JfNjRfREJMIC8gMjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshTG9uZ31cbiAgICAgKiBAY29uc3RcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgVFdPX1BXUl8yNCA9IGZyb21JbnQoVFdPX1BXUl8yNF9EQkwpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFMb25nfVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBaRVJPID0gZnJvbUludCgwKTtcblxuICAgIC8qKlxuICAgICAqIFNpZ25lZCB6ZXJvLlxuICAgICAqIEB0eXBlIHshTG9uZ31cbiAgICAgKi9cbiAgICBMb25nLlpFUk8gPSBaRVJPO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFMb25nfVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBVWkVSTyA9IGZyb21JbnQoMCwgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBVbnNpZ25lZCB6ZXJvLlxuICAgICAqIEB0eXBlIHshTG9uZ31cbiAgICAgKi9cbiAgICBMb25nLlVaRVJPID0gVVpFUk87XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IUxvbmd9XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIE9ORSA9IGZyb21JbnQoMSk7XG5cbiAgICAvKipcbiAgICAgKiBTaWduZWQgb25lLlxuICAgICAqIEB0eXBlIHshTG9uZ31cbiAgICAgKi9cbiAgICBMb25nLk9ORSA9IE9ORTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshTG9uZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgVU9ORSA9IGZyb21JbnQoMSwgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBVbnNpZ25lZCBvbmUuXG4gICAgICogQHR5cGUgeyFMb25nfVxuICAgICAqL1xuICAgIExvbmcuVU9ORSA9IFVPTkU7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IUxvbmd9XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIE5FR19PTkUgPSBmcm9tSW50KC0xKTtcblxuICAgIC8qKlxuICAgICAqIFNpZ25lZCBuZWdhdGl2ZSBvbmUuXG4gICAgICogQHR5cGUgeyFMb25nfVxuICAgICAqL1xuICAgIExvbmcuTkVHX09ORSA9IE5FR19PTkU7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IUxvbmd9XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIE1BWF9WQUxVRSA9IGZyb21CaXRzKDB4ZmZmZmZmZmYgfCAwLCAweDdmZmZmZmZmIHwgMCwgZmFsc2UpO1xuXG4gICAgLyoqXG4gICAgICogTWF4aW11bSBzaWduZWQgdmFsdWUuXG4gICAgICogQHR5cGUgeyFMb25nfVxuICAgICAqL1xuICAgIExvbmcuTUFYX1ZBTFVFID0gTUFYX1ZBTFVFO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFMb25nfVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBNQVhfVU5TSUdORURfVkFMVUUgPSBmcm9tQml0cygweGZmZmZmZmZmIHwgMCwgMHhmZmZmZmZmZiB8IDAsIHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogTWF4aW11bSB1bnNpZ25lZCB2YWx1ZS5cbiAgICAgKiBAdHlwZSB7IUxvbmd9XG4gICAgICovXG4gICAgTG9uZy5NQVhfVU5TSUdORURfVkFMVUUgPSBNQVhfVU5TSUdORURfVkFMVUU7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IUxvbmd9XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIE1JTl9WQUxVRSA9IGZyb21CaXRzKDAsIDB4ODAwMDAwMDAgfCAwLCBmYWxzZSk7XG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIHNpZ25lZCB2YWx1ZS5cbiAgICAgKiBAdHlwZSB7IUxvbmd9XG4gICAgICovXG4gICAgTG9uZy5NSU5fVkFMVUUgPSBNSU5fVkFMVUU7XG5cbiAgICAvKipcbiAgICAgKiBAYWxpYXMgTG9uZy5wcm90b3R5cGVcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgTG9uZ1Byb3RvdHlwZSA9IExvbmcucHJvdG90eXBlO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIExvbmcgdG8gYSAzMiBiaXQgaW50ZWdlciwgYXNzdW1pbmcgaXQgaXMgYSAzMiBiaXQgaW50ZWdlci5cbiAgICAgKiBAdGhpcyB7IUxvbmd9XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLnRvSW50ID0gZnVuY3Rpb24gdG9JbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IHRoaXMubG93ID4+PiAwIDogdGhpcy5sb3c7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgdGhlIG5lYXJlc3QgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2YWx1ZSAoZG91YmxlLCA1MyBiaXQgbWFudGlzc2EpLlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcigpIHtcbiAgICAgIGlmICh0aGlzLnVuc2lnbmVkKVxuICAgICAgICByZXR1cm4gKHRoaXMuaGlnaCA+Pj4gMCkgKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7XG4gICAgICByZXR1cm4gdGhpcy5oaWdoICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHN0cmluZyB3cml0dGVuIGluIHRoZSBzcGVjaWZpZWQgcmFkaXguXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggUmFkaXggKDItMzYpLCBkZWZhdWx0cyB0byAxMFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYHJhZGl4YCBpcyBvdXQgb2YgcmFuZ2VcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcocmFkaXgpIHtcbiAgICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XG4gICAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpIHRocm93IFJhbmdlRXJyb3IoXCJyYWRpeFwiKTtcbiAgICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gXCIwXCI7XG4gICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXG4gICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNoYW5nZSB0aGUgTG9uZyB2YWx1ZSBiZWZvcmUgaXQgY2FuIGJlIG5lZ2F0ZWQsIHNvIHdlIHJlbW92ZVxuICAgICAgICAgIC8vIHRoZSBib3R0b20tbW9zdCBkaWdpdCBpbiB0aGlzIGJhc2UgYW5kIHRoZW4gcmVjdXJzZSB0byBkbyB0aGUgcmVzdC5cbiAgICAgICAgICB2YXIgcmFkaXhMb25nID0gZnJvbU51bWJlcihyYWRpeCksXG4gICAgICAgICAgICBkaXYgPSB0aGlzLmRpdihyYWRpeExvbmcpLFxuICAgICAgICAgICAgcmVtMSA9IGRpdi5tdWwocmFkaXhMb25nKS5zdWIodGhpcyk7XG4gICAgICAgICAgcmV0dXJuIGRpdi50b1N0cmluZyhyYWRpeCkgKyByZW0xLnRvSW50KCkudG9TdHJpbmcocmFkaXgpO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIFwiLVwiICsgdGhpcy5uZWcoKS50b1N0cmluZyhyYWRpeCk7XG4gICAgICB9XG5cbiAgICAgIC8vIERvIHNldmVyYWwgKDYpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cbiAgICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxuICAgICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgNiksIHRoaXMudW5zaWduZWQpLFxuICAgICAgICByZW0gPSB0aGlzO1xuICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgcmVtRGl2ID0gcmVtLmRpdihyYWRpeFRvUG93ZXIpLFxuICAgICAgICAgIGludHZhbCA9IHJlbS5zdWIocmVtRGl2Lm11bChyYWRpeFRvUG93ZXIpKS50b0ludCgpID4+PiAwLFxuICAgICAgICAgIGRpZ2l0cyA9IGludHZhbC50b1N0cmluZyhyYWRpeCk7XG4gICAgICAgIHJlbSA9IHJlbURpdjtcbiAgICAgICAgaWYgKHJlbS5pc1plcm8oKSkgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCA2KSBkaWdpdHMgPSBcIjBcIiArIGRpZ2l0cztcbiAgICAgICAgICByZXN1bHQgPSBcIlwiICsgZGlnaXRzICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgaGlnaCBiaXRzXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0cyA9IGZ1bmN0aW9uIGdldEhpZ2hCaXRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGlnaDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGhpZ2ggYml0c1xuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldEhpZ2hCaXRzVW5zaWduZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oaWdoID4+PiAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgbG93IGJpdHNcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmdldExvd0JpdHMgPSBmdW5jdGlvbiBnZXRMb3dCaXRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMubG93O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsb3cgMzIgYml0cyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCBsb3cgYml0c1xuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuZ2V0TG93Qml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0TG93Qml0c1Vuc2lnbmVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMubG93ID4+PiAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgYml0cyBuZWVkZWQgdG8gcmVwcmVzZW50IHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIExvbmcuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5nZXROdW1CaXRzQWJzID0gZnVuY3Rpb24gZ2V0TnVtQml0c0FicygpIHtcbiAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSlcbiAgICAgICAgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXG4gICAgICAgIHJldHVybiB0aGlzLmVxKE1JTl9WQUxVRSkgPyA2NCA6IHRoaXMubmVnKCkuZ2V0TnVtQml0c0FicygpO1xuICAgICAgdmFyIHZhbCA9IHRoaXMuaGlnaCAhPSAwID8gdGhpcy5oaWdoIDogdGhpcy5sb3c7XG4gICAgICBmb3IgKHZhciBiaXQgPSAzMTsgYml0ID4gMDsgYml0LS0pIGlmICgodmFsICYgKDEgPDwgYml0KSkgIT0gMCkgYnJlYWs7XG4gICAgICByZXR1cm4gdGhpcy5oaWdoICE9IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZyBjYW4gYmUgc2FmZWx5IHJlcHJlc2VudGVkIGFzIGEgSmF2YVNjcmlwdCBudW1iZXIuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuaXNTYWZlSW50ZWdlciA9IGZ1bmN0aW9uIGlzU2FmZUludGVnZXIoKSB7XG4gICAgICAvLyAyXjUzLTEgaXMgdGhlIG1heGltdW0gc2FmZSB2YWx1ZVxuICAgICAgdmFyIHRvcDExQml0cyA9IHRoaXMuaGlnaCA+PiAyMTtcbiAgICAgIC8vIFswLCAyXjUzLTFdXG4gICAgICBpZiAoIXRvcDExQml0cykgcmV0dXJuIHRydWU7XG4gICAgICAvLyA+IDJeNTMtMVxuICAgICAgaWYgKHRoaXMudW5zaWduZWQpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIFstMl41MywgLTFdIGV4Y2VwdCAtMl41M1xuICAgICAgcmV0dXJuIHRvcDExQml0cyA9PT0gLTEgJiYgISh0aGlzLmxvdyA9PT0gMCAmJiB0aGlzLmhpZ2ggPT09IC0weDIwMDAwMCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB6ZXJvLlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHtcbiAgICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IDAgJiYgdGhpcy5sb3cgPT09IDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB6ZXJvLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2lzWmVyb30uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5lcXogPSBMb25nUHJvdG90eXBlLmlzWmVybztcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG5lZ2F0aXZlLlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiBpc05lZ2F0aXZlKCkge1xuICAgICAgcmV0dXJuICF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA8IDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIHBvc2l0aXZlIG9yIHplcm8uXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uIGlzUG9zaXRpdmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCB8fCB0aGlzLmhpZ2ggPj0gMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgb2RkLlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQoKSB7XG4gICAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGV2ZW4uXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuKCkge1xuICAgICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgICBpZiAoIWlzTG9uZyhvdGhlcikpIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy51bnNpZ25lZCAhPT0gb3RoZXIudW5zaWduZWQgJiZcbiAgICAgICAgdGhpcy5oaWdoID4+PiAzMSA9PT0gMSAmJlxuICAgICAgICBvdGhlci5oaWdoID4+PiAzMSA9PT0gMVxuICAgICAgKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcy5oaWdoID09PSBvdGhlci5oaWdoICYmIHRoaXMubG93ID09PSBvdGhlci5sb3c7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZXF1YWxzfS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuZXEgPSBMb25nUHJvdG90eXBlLmVxdWFscztcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHMgPSBmdW5jdGlvbiBub3RFcXVhbHMob3RoZXIpIHtcbiAgICAgIHJldHVybiAhdGhpcy5lcSgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLm5lcSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNub3RFcXVhbHN9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5uZSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy5cbiAgICAgKiBAdGhpcyB7IUxvbmd9XG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmxlc3NUaGFuID0gZnVuY3Rpb24gbGVzc1RoYW4ob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA8IDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW59LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5sdCA9IExvbmdQcm90b3R5cGUubGVzc1RoYW47XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsID0gZnVuY3Rpb24gbGVzc1RoYW5PckVxdWFsKG90aGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPD0gMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbk9yRXF1YWx9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5sdGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDtcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW5PckVxdWFsfS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUubGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDtcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbiA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuKG90aGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPiAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFufS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuZ3QgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuO1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cbiAgICAgKiBAdGhpcyB7IUxvbmd9XG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuT3JFcXVhbChvdGhlcikge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpID49IDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuZ3RlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmdlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7XG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB0aGlzIExvbmcncyB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQncy5cbiAgICAgKiBAdGhpcyB7IUxvbmd9XG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIgYW5kIC0xXG4gICAgICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUob3RoZXIpIHtcbiAgICAgIGlmICghaXNMb25nKG90aGVyKSkgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICAgICAgaWYgKHRoaXMuZXEob3RoZXIpKSByZXR1cm4gMDtcbiAgICAgIHZhciB0aGlzTmVnID0gdGhpcy5pc05lZ2F0aXZlKCksXG4gICAgICAgIG90aGVyTmVnID0gb3RoZXIuaXNOZWdhdGl2ZSgpO1xuICAgICAgaWYgKHRoaXNOZWcgJiYgIW90aGVyTmVnKSByZXR1cm4gLTE7XG4gICAgICBpZiAoIXRoaXNOZWcgJiYgb3RoZXJOZWcpIHJldHVybiAxO1xuICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgc2lnbiBiaXRzIGFyZSB0aGUgc2FtZVxuICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKSByZXR1cm4gdGhpcy5zdWIob3RoZXIpLmlzTmVnYXRpdmUoKSA/IC0xIDogMTtcbiAgICAgIC8vIEJvdGggYXJlIHBvc2l0aXZlIGlmIGF0IGxlYXN0IG9uZSBpcyB1bnNpZ25lZFxuICAgICAgcmV0dXJuIG90aGVyLmhpZ2ggPj4+IDAgPiB0aGlzLmhpZ2ggPj4+IDAgfHxcbiAgICAgICAgKG90aGVyLmhpZ2ggPT09IHRoaXMuaGlnaCAmJiBvdGhlci5sb3cgPj4+IDAgPiB0aGlzLmxvdyA+Pj4gMClcbiAgICAgICAgPyAtMVxuICAgICAgICA6IDE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2NvbXBhcmV9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyIGFuZCAtMVxuICAgICAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmNvbXAgPSBMb25nUHJvdG90eXBlLmNvbXBhcmU7XG5cbiAgICAvKipcbiAgICAgKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gbmVnYXRlKCkge1xuICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmIHRoaXMuZXEoTUlOX1ZBTFVFKSkgcmV0dXJuIE1JTl9WQUxVRTtcbiAgICAgIHJldHVybiB0aGlzLm5vdCgpLmFkZChPTkUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25lZ2F0ZX0uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMgeyFMb25nfSBOZWdhdGVkIExvbmdcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLm5lZyA9IExvbmdQcm90b3R5cGUubmVnYXRlO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3VtIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cbiAgICAgKiBAdGhpcyB7IUxvbmd9XG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gYWRkZW5kIEFkZGVuZFxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU3VtXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoYWRkZW5kKSB7XG4gICAgICBpZiAoIWlzTG9uZyhhZGRlbmQpKSBhZGRlbmQgPSBmcm9tVmFsdWUoYWRkZW5kKTtcblxuICAgICAgLy8gRGl2aWRlIGVhY2ggbnVtYmVyIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gc3VtIHRoZSBjaHVua3MuXG5cbiAgICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xuICAgICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4ZmZmZjtcbiAgICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XG4gICAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiAweGZmZmY7XG4gICAgICB2YXIgYjQ4ID0gYWRkZW5kLmhpZ2ggPj4+IDE2O1xuICAgICAgdmFyIGIzMiA9IGFkZGVuZC5oaWdoICYgMHhmZmZmO1xuICAgICAgdmFyIGIxNiA9IGFkZGVuZC5sb3cgPj4+IDE2O1xuICAgICAgdmFyIGIwMCA9IGFkZGVuZC5sb3cgJiAweGZmZmY7XG4gICAgICB2YXIgYzQ4ID0gMCxcbiAgICAgICAgYzMyID0gMCxcbiAgICAgICAgYzE2ID0gMCxcbiAgICAgICAgYzAwID0gMDtcbiAgICAgIGMwMCArPSBhMDAgKyBiMDA7XG4gICAgICBjMTYgKz0gYzAwID4+PiAxNjtcbiAgICAgIGMwMCAmPSAweGZmZmY7XG4gICAgICBjMTYgKz0gYTE2ICsgYjE2O1xuICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7XG4gICAgICBjMTYgJj0gMHhmZmZmO1xuICAgICAgYzMyICs9IGEzMiArIGIzMjtcbiAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xuICAgICAgYzMyICY9IDB4ZmZmZjtcbiAgICAgIGM0OCArPSBhNDggKyBiNDg7XG4gICAgICBjNDggJj0gMHhmZmZmO1xuICAgICAgcmV0dXJuIGZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IERpZmZlcmVuY2VcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3Qoc3VidHJhaGVuZCkge1xuICAgICAgaWYgKCFpc0xvbmcoc3VidHJhaGVuZCkpIHN1YnRyYWhlbmQgPSBmcm9tVmFsdWUoc3VidHJhaGVuZCk7XG4gICAgICByZXR1cm4gdGhpcy5hZGQoc3VidHJhaGVuZC5uZWcoKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3N1YnRyYWN0fS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IERpZmZlcmVuY2VcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLnN1YiA9IExvbmdQcm90b3R5cGUuc3VidHJhY3Q7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cbiAgICAgKiBAdGhpcyB7IUxvbmd9XG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBQcm9kdWN0XG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KG11bHRpcGxpZXIpIHtcbiAgICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gdGhpcztcbiAgICAgIGlmICghaXNMb25nKG11bHRpcGxpZXIpKSBtdWx0aXBsaWVyID0gZnJvbVZhbHVlKG11bHRpcGxpZXIpO1xuXG4gICAgICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcbiAgICAgIGlmICh3YXNtKSB7XG4gICAgICAgIHZhciBsb3cgPSB3YXNtW1wibXVsXCJdKFxuICAgICAgICAgIHRoaXMubG93LFxuICAgICAgICAgIHRoaXMuaGlnaCxcbiAgICAgICAgICBtdWx0aXBsaWVyLmxvdyxcbiAgICAgICAgICBtdWx0aXBsaWVyLmhpZ2gsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc21bXCJnZXRfaGlnaFwiXSgpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgIH1cbiAgICAgIGlmIChtdWx0aXBsaWVyLmlzWmVybygpKSByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHJldHVybiBtdWx0aXBsaWVyLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xuICAgICAgaWYgKG11bHRpcGxpZXIuZXEoTUlOX1ZBTFVFKSkgcmV0dXJuIHRoaXMuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87XG4gICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKSByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllci5uZWcoKSk7XG4gICAgICAgIGVsc2UgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIpLm5lZygpO1xuICAgICAgfSBlbHNlIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSlcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsKG11bHRpcGxpZXIubmVnKCkpLm5lZygpO1xuXG4gICAgICAvLyBJZiBib3RoIGxvbmdzIGFyZSBzbWFsbCwgdXNlIGZsb2F0IG11bHRpcGxpY2F0aW9uXG4gICAgICBpZiAodGhpcy5sdChUV09fUFdSXzI0KSAmJiBtdWx0aXBsaWVyLmx0KFRXT19QV1JfMjQpKVxuICAgICAgICByZXR1cm4gZnJvbU51bWJlcihcbiAgICAgICAgICB0aGlzLnRvTnVtYmVyKCkgKiBtdWx0aXBsaWVyLnRvTnVtYmVyKCksXG4gICAgICAgICAgdGhpcy51bnNpZ25lZCxcbiAgICAgICAgKTtcblxuICAgICAgLy8gRGl2aWRlIGVhY2ggbG9uZyBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIGFkZCB1cCA0eDQgcHJvZHVjdHMuXG4gICAgICAvLyBXZSBjYW4gc2tpcCBwcm9kdWN0cyB0aGF0IHdvdWxkIG92ZXJmbG93LlxuXG4gICAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcbiAgICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweGZmZmY7XG4gICAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xuICAgICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhmZmZmO1xuICAgICAgdmFyIGI0OCA9IG11bHRpcGxpZXIuaGlnaCA+Pj4gMTY7XG4gICAgICB2YXIgYjMyID0gbXVsdGlwbGllci5oaWdoICYgMHhmZmZmO1xuICAgICAgdmFyIGIxNiA9IG11bHRpcGxpZXIubG93ID4+PiAxNjtcbiAgICAgIHZhciBiMDAgPSBtdWx0aXBsaWVyLmxvdyAmIDB4ZmZmZjtcbiAgICAgIHZhciBjNDggPSAwLFxuICAgICAgICBjMzIgPSAwLFxuICAgICAgICBjMTYgPSAwLFxuICAgICAgICBjMDAgPSAwO1xuICAgICAgYzAwICs9IGEwMCAqIGIwMDtcbiAgICAgIGMxNiArPSBjMDAgPj4+IDE2O1xuICAgICAgYzAwICY9IDB4ZmZmZjtcbiAgICAgIGMxNiArPSBhMTYgKiBiMDA7XG4gICAgICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgICAgIGMxNiAmPSAweGZmZmY7XG4gICAgICBjMTYgKz0gYTAwICogYjE2O1xuICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7XG4gICAgICBjMTYgJj0gMHhmZmZmO1xuICAgICAgYzMyICs9IGEzMiAqIGIwMDtcbiAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xuICAgICAgYzMyICY9IDB4ZmZmZjtcbiAgICAgIGMzMiArPSBhMTYgKiBiMTY7XG4gICAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICAgIGMzMiAmPSAweGZmZmY7XG4gICAgICBjMzIgKz0gYTAwICogYjMyO1xuICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgICBjMzIgJj0gMHhmZmZmO1xuICAgICAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODtcbiAgICAgIGM0OCAmPSAweGZmZmY7XG4gICAgICByZXR1cm4gZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbXVsdGlwbHl9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IG11bHRpcGxpZXIgTXVsdGlwbGllclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUubXVsID0gTG9uZ1Byb3RvdHlwZS5tdWx0aXBseTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhlIHJlc3VsdCBpcyBzaWduZWQgaWYgdGhpcyBMb25nIGlzIHNpZ25lZCBvclxuICAgICAqICB1bnNpZ25lZCBpZiB0aGlzIExvbmcgaXMgdW5zaWduZWQuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gUXVvdGllbnRcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZShkaXZpc29yKSB7XG4gICAgICBpZiAoIWlzTG9uZyhkaXZpc29yKSkgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTtcbiAgICAgIGlmIChkaXZpc29yLmlzWmVybygpKSB0aHJvdyBFcnJvcihcImRpdmlzaW9uIGJ5IHplcm9cIik7XG5cbiAgICAgIC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxuICAgICAgaWYgKHdhc20pIHtcbiAgICAgICAgLy8gZ3VhcmQgYWdhaW5zdCBzaWduZWQgZGl2aXNpb24gb3ZlcmZsb3c6IHRoZSBsYXJnZXN0XG4gICAgICAgIC8vIG5lZ2F0aXZlIG51bWJlciAvIC0xIHdvdWxkIGJlIDEgbGFyZ2VyIHRoYW4gdGhlIGxhcmdlc3RcbiAgICAgICAgLy8gcG9zaXRpdmUgbnVtYmVyLCBkdWUgdG8gdHdvJ3MgY29tcGxlbWVudC5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICF0aGlzLnVuc2lnbmVkICYmXG4gICAgICAgICAgdGhpcy5oaWdoID09PSAtMHg4MDAwMDAwMCAmJlxuICAgICAgICAgIGRpdmlzb3IubG93ID09PSAtMSAmJlxuICAgICAgICAgIGRpdmlzb3IuaGlnaCA9PT0gLTFcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gYmUgY29uc2lzdGVudCB3aXRoIG5vbi13YXNtIGNvZGUgcGF0aFxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc21bXCJkaXZfdVwiXSA6IHdhc21bXCJkaXZfc1wiXSkoXG4gICAgICAgICAgdGhpcy5sb3csXG4gICAgICAgICAgdGhpcy5oaWdoLFxuICAgICAgICAgIGRpdmlzb3IubG93LFxuICAgICAgICAgIGRpdmlzb3IuaGlnaCxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbVtcImdldF9oaWdoXCJdKCksIHRoaXMudW5zaWduZWQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICAgICAgdmFyIGFwcHJveCwgcmVtLCByZXM7XG4gICAgICBpZiAoIXRoaXMudW5zaWduZWQpIHtcbiAgICAgICAgLy8gVGhpcyBzZWN0aW9uIGlzIG9ubHkgcmVsZXZhbnQgZm9yIHNpZ25lZCBsb25ncyBhbmQgaXMgZGVyaXZlZCBmcm9tIHRoZVxuICAgICAgICAvLyBjbG9zdXJlIGxpYnJhcnkgYXMgYSB3aG9sZS5cbiAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkge1xuICAgICAgICAgIGlmIChkaXZpc29yLmVxKE9ORSkgfHwgZGl2aXNvci5lcShORUdfT05FKSlcbiAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7IC8vIHJlY2FsbCB0aGF0IC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFXG4gICAgICAgICAgZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKSByZXR1cm4gT05FO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSB8b3RoZXJ8ID49IDIsIHNvIHx0aGlzL290aGVyfCA8IHxNSU5fVkFMVUV8LlxuICAgICAgICAgICAgdmFyIGhhbGZUaGlzID0gdGhpcy5zaHIoMSk7XG4gICAgICAgICAgICBhcHByb3ggPSBoYWxmVGhpcy5kaXYoZGl2aXNvcikuc2hsKDEpO1xuICAgICAgICAgICAgaWYgKGFwcHJveC5lcShaRVJPKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZGl2aXNvci5pc05lZ2F0aXZlKCkgPyBPTkUgOiBORUdfT05FO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVtID0gdGhpcy5zdWIoZGl2aXNvci5tdWwoYXBwcm94KSk7XG4gICAgICAgICAgICAgIHJlcyA9IGFwcHJveC5hZGQocmVtLmRpdihkaXZpc29yKSk7XG4gICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSkgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgICAgICAgIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSkgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IubmVnKCkpO1xuICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yKS5uZWcoKTtcbiAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSkgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpO1xuICAgICAgICByZXMgPSBaRVJPO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIGFsZ29yaXRobSBiZWxvdyBoYXMgbm90IGJlZW4gbWFkZSBmb3IgdW5zaWduZWQgbG9uZ3MuIEl0J3MgdGhlcmVmb3JlXG4gICAgICAgIC8vIHJlcXVpcmVkIHRvIHRha2Ugc3BlY2lhbCBjYXJlIG9mIHRoZSBNU0IgcHJpb3IgdG8gcnVubmluZyBpdC5cbiAgICAgICAgaWYgKCFkaXZpc29yLnVuc2lnbmVkKSBkaXZpc29yID0gZGl2aXNvci50b1Vuc2lnbmVkKCk7XG4gICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKSByZXR1cm4gVVpFUk87XG4gICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMuc2hydSgxKSkpXG4gICAgICAgICAgLy8gMTUgPj4+IDEgPSA3IDsgd2l0aCBkaXZpc29yID0gOCA7IHRydWVcbiAgICAgICAgICByZXR1cm4gVU9ORTtcbiAgICAgICAgcmVzID0gVVpFUk87XG4gICAgICB9XG5cbiAgICAgIC8vIFJlcGVhdCB0aGUgZm9sbG93aW5nIHVudGlsIHRoZSByZW1haW5kZXIgaXMgbGVzcyB0aGFuIG90aGVyOiAgZmluZCBhXG4gICAgICAvLyBmbG9hdGluZy1wb2ludCB0aGF0IGFwcHJveGltYXRlcyByZW1haW5kZXIgLyBvdGhlciAqZnJvbSBiZWxvdyosIGFkZCB0aGlzXG4gICAgICAvLyBpbnRvIHRoZSByZXN1bHQsIGFuZCBzdWJ0cmFjdCBpdCBmcm9tIHRoZSByZW1haW5kZXIuICBJdCBpcyBjcml0aWNhbCB0aGF0XG4gICAgICAvLyB0aGUgYXBwcm94aW1hdGUgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSByZWFsIHZhbHVlIHNvIHRoYXQgdGhlXG4gICAgICAvLyByZW1haW5kZXIgbmV2ZXIgYmVjb21lcyBuZWdhdGl2ZS5cbiAgICAgIHJlbSA9IHRoaXM7XG4gICAgICB3aGlsZSAocmVtLmd0ZShkaXZpc29yKSkge1xuICAgICAgICAvLyBBcHByb3hpbWF0ZSB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uLiBUaGlzIG1heSBiZSBhIGxpdHRsZSBncmVhdGVyIG9yXG4gICAgICAgIC8vIHNtYWxsZXIgdGhhbiB0aGUgYWN0dWFsIHZhbHVlLlxuICAgICAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gZGl2aXNvci50b051bWJlcigpKSk7XG5cbiAgICAgICAgLy8gV2Ugd2lsbCB0d2VhayB0aGUgYXBwcm94aW1hdGUgcmVzdWx0IGJ5IGNoYW5naW5nIGl0IGluIHRoZSA0OC10aCBkaWdpdCBvclxuICAgICAgICAvLyB0aGUgc21hbGxlc3Qgbm9uLWZyYWN0aW9uYWwgZGlnaXQsIHdoaWNoZXZlciBpcyBsYXJnZXIuXG4gICAgICAgIHZhciBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMiksXG4gICAgICAgICAgZGVsdGEgPSBsb2cyIDw9IDQ4ID8gMSA6IHBvd19kYmwoMiwgbG9nMiAtIDQ4KSxcbiAgICAgICAgICAvLyBEZWNyZWFzZSB0aGUgYXBwcm94aW1hdGlvbiB1bnRpbCBpdCBpcyBzbWFsbGVyIHRoYW4gdGhlIHJlbWFpbmRlci4gIE5vdGVcbiAgICAgICAgICAvLyB0aGF0IGlmIGl0IGlzIHRvbyBsYXJnZSwgdGhlIHByb2R1Y3Qgb3ZlcmZsb3dzIGFuZCBpcyBuZWdhdGl2ZS5cbiAgICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCksXG4gICAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTtcbiAgICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHtcbiAgICAgICAgICBhcHByb3ggLT0gZGVsdGE7XG4gICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gsIHRoaXMudW5zaWduZWQpO1xuICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBrbm93IHRoZSBhbnN3ZXIgY2FuJ3QgYmUgemVyby4uLiBhbmQgYWN0dWFsbHksIHplcm8gd291bGQgY2F1c2VcbiAgICAgICAgLy8gaW5maW5pdGUgcmVjdXJzaW9uIHNpbmNlIHdlIHdvdWxkIG1ha2Ugbm8gcHJvZ3Jlc3MuXG4gICAgICAgIGlmIChhcHByb3hSZXMuaXNaZXJvKCkpIGFwcHJveFJlcyA9IE9ORTtcbiAgICAgICAgcmVzID0gcmVzLmFkZChhcHByb3hSZXMpO1xuICAgICAgICByZW0gPSByZW0uc3ViKGFwcHJveFJlbSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZGl2aWRlfS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFF1b3RpZW50XG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5kaXYgPSBMb25nUHJvdG90eXBlLmRpdmlkZTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUubW9kdWxvID0gZnVuY3Rpb24gbW9kdWxvKGRpdmlzb3IpIHtcbiAgICAgIGlmICghaXNMb25nKGRpdmlzb3IpKSBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xuXG4gICAgICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcbiAgICAgIGlmICh3YXNtKSB7XG4gICAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc21bXCJyZW1fdVwiXSA6IHdhc21bXCJyZW1fc1wiXSkoXG4gICAgICAgICAgdGhpcy5sb3csXG4gICAgICAgICAgdGhpcy5oaWdoLFxuICAgICAgICAgIGRpdmlzb3IubG93LFxuICAgICAgICAgIGRpdmlzb3IuaGlnaCxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbVtcImdldF9oaWdoXCJdKCksIHRoaXMudW5zaWduZWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuZGl2KGRpdmlzb3IpLm11bChkaXZpc29yKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gICAgICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLm1vZCA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUucmVtID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE5PVCBvZiB0aGlzIExvbmcuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uIG5vdCgpIHtcbiAgICAgIHJldHVybiBmcm9tQml0cyh+dGhpcy5sb3csIH50aGlzLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvdW50IGxlYWRpbmcgemVyb3Mgb2YgdGhpcyBMb25nLlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcmV0dXJucyB7IW51bWJlcn1cbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmNvdW50TGVhZGluZ1plcm9zID0gZnVuY3Rpb24gY291bnRMZWFkaW5nWmVyb3MoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oaWdoID8gTWF0aC5jbHozMih0aGlzLmhpZ2gpIDogTWF0aC5jbHozMih0aGlzLmxvdykgKyAzMjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb3VudCBsZWFkaW5nIHplcm9zLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2NvdW50TGVhZGluZ1plcm9zfS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyFMb25nfVxuICAgICAqIEByZXR1cm5zIHshbnVtYmVyfVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuY2x6ID0gTG9uZ1Byb3RvdHlwZS5jb3VudExlYWRpbmdaZXJvcztcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY291bnQgdHJhaWxpbmcgemVyb3Mgb2YgdGhpcyBMb25nLlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcmV0dXJucyB7IW51bWJlcn1cbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmNvdW50VHJhaWxpbmdaZXJvcyA9IGZ1bmN0aW9uIGNvdW50VHJhaWxpbmdaZXJvcygpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvdyA/IGN0ejMyKHRoaXMubG93KSA6IGN0ejMyKHRoaXMuaGlnaCkgKyAzMjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb3VudCB0cmFpbGluZyB6ZXJvcy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNjb3VudFRyYWlsaW5nWmVyb3N9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7IUxvbmd9XG4gICAgICogQHJldHVybnMgeyFudW1iZXJ9XG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5jdHogPSBMb25nUHJvdG90eXBlLmNvdW50VHJhaWxpbmdaZXJvcztcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJpdHdpc2UgQU5EIG9mIHRoaXMgTG9uZyBhbmQgdGhlIHNwZWNpZmllZC5cbiAgICAgKiBAdGhpcyB7IUxvbmd9XG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xuICAgICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZChvdGhlcikge1xuICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKSBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gICAgICByZXR1cm4gZnJvbUJpdHMoXG4gICAgICAgIHRoaXMubG93ICYgb3RoZXIubG93LFxuICAgICAgICB0aGlzLmhpZ2ggJiBvdGhlci5oaWdoLFxuICAgICAgICB0aGlzLnVuc2lnbmVkLFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYml0d2lzZSBPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKG90aGVyKSB7XG4gICAgICBpZiAoIWlzTG9uZyhvdGhlcikpIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcbiAgICAgIHJldHVybiBmcm9tQml0cyhcbiAgICAgICAgdGhpcy5sb3cgfCBvdGhlci5sb3csXG4gICAgICAgIHRoaXMuaGlnaCB8IG90aGVyLmhpZ2gsXG4gICAgICAgIHRoaXMudW5zaWduZWQsXG4gICAgICApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlIFhPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBnaXZlbiBvbmUuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3Iob3RoZXIpIHtcbiAgICAgIGlmICghaXNMb25nKG90aGVyKSkgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICAgICAgcmV0dXJuIGZyb21CaXRzKFxuICAgICAgICB0aGlzLmxvdyBeIG90aGVyLmxvdyxcbiAgICAgICAgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCxcbiAgICAgICAgdGhpcy51bnNpZ25lZCxcbiAgICAgICk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLnNoaWZ0TGVmdCA9IGZ1bmN0aW9uIHNoaWZ0TGVmdChudW1CaXRzKSB7XG4gICAgICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICAgICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gICAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpXG4gICAgICAgIHJldHVybiBmcm9tQml0cyhcbiAgICAgICAgICB0aGlzLmxvdyA8PCBudW1CaXRzLFxuICAgICAgICAgICh0aGlzLmhpZ2ggPDwgbnVtQml0cykgfCAodGhpcy5sb3cgPj4+ICgzMiAtIG51bUJpdHMpKSxcbiAgICAgICAgICB0aGlzLnVuc2lnbmVkLFxuICAgICAgICApO1xuICAgICAgZWxzZSByZXR1cm4gZnJvbUJpdHMoMCwgdGhpcy5sb3cgPDwgKG51bUJpdHMgLSAzMiksIHRoaXMudW5zaWduZWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0TGVmdH0uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuc2hsID0gTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQ7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiAgICAgKiBAdGhpcyB7IUxvbmd9XG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuc2hpZnRSaWdodCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHQobnVtQml0cykge1xuICAgICAgaWYgKGlzTG9uZyhudW1CaXRzKSkgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApIHJldHVybiB0aGlzO1xuICAgICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKVxuICAgICAgICByZXR1cm4gZnJvbUJpdHMoXG4gICAgICAgICAgKHRoaXMubG93ID4+PiBudW1CaXRzKSB8ICh0aGlzLmhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLFxuICAgICAgICAgIHRoaXMuaGlnaCA+PiBudW1CaXRzLFxuICAgICAgICAgIHRoaXMudW5zaWduZWQsXG4gICAgICAgICk7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBmcm9tQml0cyhcbiAgICAgICAgICB0aGlzLmhpZ2ggPj4gKG51bUJpdHMgLSAzMiksXG4gICAgICAgICAgdGhpcy5oaWdoID49IDAgPyAwIDogLTEsXG4gICAgICAgICAgdGhpcy51bnNpZ25lZCxcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodH0uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuc2hyID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0VW5zaWduZWQobnVtQml0cykge1xuICAgICAgaWYgKGlzTG9uZyhudW1CaXRzKSkgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApIHJldHVybiB0aGlzO1xuICAgICAgaWYgKG51bUJpdHMgPCAzMilcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKFxuICAgICAgICAgICh0aGlzLmxvdyA+Pj4gbnVtQml0cykgfCAodGhpcy5oaWdoIDw8ICgzMiAtIG51bUJpdHMpKSxcbiAgICAgICAgICB0aGlzLmhpZ2ggPj4+IG51bUJpdHMsXG4gICAgICAgICAgdGhpcy51bnNpZ25lZCxcbiAgICAgICAgKTtcbiAgICAgIGlmIChudW1CaXRzID09PSAzMikgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCwgMCwgdGhpcy51bnNpZ25lZCk7XG4gICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoID4+PiAobnVtQml0cyAtIDMyKSwgMCwgdGhpcy51bnNpZ25lZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0VW5zaWduZWR9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLnNocnUgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0VW5zaWduZWR9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLnNocl91ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgICAqIEByZXR1cm5zIHshTG9uZ30gUm90YXRlZCBMb25nXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5yb3RhdGVMZWZ0ID0gZnVuY3Rpb24gcm90YXRlTGVmdChudW1CaXRzKSB7XG4gICAgICB2YXIgYjtcbiAgICAgIGlmIChpc0xvbmcobnVtQml0cykpIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gICAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKSByZXR1cm4gdGhpcztcbiAgICAgIGlmIChudW1CaXRzID09PSAzMikgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCwgdGhpcy5sb3csIHRoaXMudW5zaWduZWQpO1xuICAgICAgaWYgKG51bUJpdHMgPCAzMikge1xuICAgICAgICBiID0gMzIgLSBudW1CaXRzO1xuICAgICAgICByZXR1cm4gZnJvbUJpdHMoXG4gICAgICAgICAgKHRoaXMubG93IDw8IG51bUJpdHMpIHwgKHRoaXMuaGlnaCA+Pj4gYiksXG4gICAgICAgICAgKHRoaXMuaGlnaCA8PCBudW1CaXRzKSB8ICh0aGlzLmxvdyA+Pj4gYiksXG4gICAgICAgICAgdGhpcy51bnNpZ25lZCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG51bUJpdHMgLT0gMzI7XG4gICAgICBiID0gMzIgLSBudW1CaXRzO1xuICAgICAgcmV0dXJuIGZyb21CaXRzKFxuICAgICAgICAodGhpcy5oaWdoIDw8IG51bUJpdHMpIHwgKHRoaXMubG93ID4+PiBiKSxcbiAgICAgICAgKHRoaXMubG93IDw8IG51bUJpdHMpIHwgKHRoaXMuaGlnaCA+Pj4gYiksXG4gICAgICAgIHRoaXMudW5zaWduZWQsXG4gICAgICApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHJvdGF0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNyb3RhdGVMZWZ0fS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgICAqIEByZXR1cm5zIHshTG9uZ30gUm90YXRlZCBMb25nXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5yb3RsID0gTG9uZ1Byb3RvdHlwZS5yb3RhdGVMZWZ0O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHJvdGF0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAgICogQHJldHVybnMgeyFMb25nfSBSb3RhdGVkIExvbmdcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLnJvdGF0ZVJpZ2h0ID0gZnVuY3Rpb24gcm90YXRlUmlnaHQobnVtQml0cykge1xuICAgICAgdmFyIGI7XG4gICAgICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICAgICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gICAgICBpZiAobnVtQml0cyA9PT0gMzIpIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2gsIHRoaXMubG93LCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgIGlmIChudW1CaXRzIDwgMzIpIHtcbiAgICAgICAgYiA9IDMyIC0gbnVtQml0cztcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKFxuICAgICAgICAgICh0aGlzLmhpZ2ggPDwgYikgfCAodGhpcy5sb3cgPj4+IG51bUJpdHMpLFxuICAgICAgICAgICh0aGlzLmxvdyA8PCBiKSB8ICh0aGlzLmhpZ2ggPj4+IG51bUJpdHMpLFxuICAgICAgICAgIHRoaXMudW5zaWduZWQsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBudW1CaXRzIC09IDMyO1xuICAgICAgYiA9IDMyIC0gbnVtQml0cztcbiAgICAgIHJldHVybiBmcm9tQml0cyhcbiAgICAgICAgKHRoaXMubG93IDw8IGIpIHwgKHRoaXMuaGlnaCA+Pj4gbnVtQml0cyksXG4gICAgICAgICh0aGlzLmhpZ2ggPDwgYikgfCAodGhpcy5sb3cgPj4+IG51bUJpdHMpLFxuICAgICAgICB0aGlzLnVuc2lnbmVkLFxuICAgICAgKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyByb3RhdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3JvdGF0ZVJpZ2h0fS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgICAqIEByZXR1cm5zIHshTG9uZ30gUm90YXRlZCBMb25nXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5yb3RyID0gTG9uZ1Byb3RvdHlwZS5yb3RhdGVSaWdodDtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBzaWduZWQuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2lnbmVkIGxvbmdcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLnRvU2lnbmVkID0gZnVuY3Rpb24gdG9TaWduZWQoKSB7XG4gICAgICBpZiAoIXRoaXMudW5zaWduZWQpIHJldHVybiB0aGlzO1xuICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIGZhbHNlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIHVuc2lnbmVkLlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFVuc2lnbmVkIGxvbmdcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLnRvVW5zaWduZWQgPSBmdW5jdGlvbiB0b1Vuc2lnbmVkKCkge1xuICAgICAgaWYgKHRoaXMudW5zaWduZWQpIHJldHVybiB0aGlzO1xuICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIHRydWUpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGJ5dGUgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBCeXRlIHJlcHJlc2VudGF0aW9uXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24gdG9CeXRlcyhsZSkge1xuICAgICAgcmV0dXJuIGxlID8gdGhpcy50b0J5dGVzTEUoKSA6IHRoaXMudG9CeXRlc0JFKCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgbGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBMaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLnRvQnl0ZXNMRSA9IGZ1bmN0aW9uIHRvQnl0ZXNMRSgpIHtcbiAgICAgIHZhciBoaSA9IHRoaXMuaGlnaCxcbiAgICAgICAgbG8gPSB0aGlzLmxvdztcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGxvICYgMHhmZixcbiAgICAgICAgKGxvID4+PiA4KSAmIDB4ZmYsXG4gICAgICAgIChsbyA+Pj4gMTYpICYgMHhmZixcbiAgICAgICAgbG8gPj4+IDI0LFxuICAgICAgICBoaSAmIDB4ZmYsXG4gICAgICAgIChoaSA+Pj4gOCkgJiAweGZmLFxuICAgICAgICAoaGkgPj4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIGhpID4+PiAyNCxcbiAgICAgIF07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgYmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBCaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLnRvQnl0ZXNCRSA9IGZ1bmN0aW9uIHRvQnl0ZXNCRSgpIHtcbiAgICAgIHZhciBoaSA9IHRoaXMuaGlnaCxcbiAgICAgICAgbG8gPSB0aGlzLmxvdztcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGhpID4+PiAyNCxcbiAgICAgICAgKGhpID4+PiAxNikgJiAweGZmLFxuICAgICAgICAoaGkgPj4+IDgpICYgMHhmZixcbiAgICAgICAgaGkgJiAweGZmLFxuICAgICAgICBsbyA+Pj4gMjQsXG4gICAgICAgIChsbyA+Pj4gMTYpICYgMHhmZixcbiAgICAgICAgKGxvID4+PiA4KSAmIDB4ZmYsXG4gICAgICAgIGxvICYgMHhmZixcbiAgICAgIF07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGJ5dGUgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIEJ5dGUgcmVwcmVzZW50YXRpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxuICAgICAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gICAgICovXG4gICAgTG9uZy5mcm9tQnl0ZXMgPSBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMsIHVuc2lnbmVkLCBsZSkge1xuICAgICAgcmV0dXJuIGxlXG4gICAgICAgID8gTG9uZy5mcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpXG4gICAgICAgIDogTG9uZy5mcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTG9uZyBmcm9tIGl0cyBsaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAgICAgKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICAgICAqL1xuICAgIExvbmcuZnJvbUJ5dGVzTEUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIHtcbiAgICAgIHJldHVybiBuZXcgTG9uZyhcbiAgICAgICAgYnl0ZXNbMF0gfCAoYnl0ZXNbMV0gPDwgOCkgfCAoYnl0ZXNbMl0gPDwgMTYpIHwgKGJ5dGVzWzNdIDw8IDI0KSxcbiAgICAgICAgYnl0ZXNbNF0gfCAoYnl0ZXNbNV0gPDwgOCkgfCAoYnl0ZXNbNl0gPDwgMTYpIHwgKGJ5dGVzWzddIDw8IDI0KSxcbiAgICAgICAgdW5zaWduZWQsXG4gICAgICApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTG9uZyBmcm9tIGl0cyBiaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIEJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAgICAgKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICAgICAqL1xuICAgIExvbmcuZnJvbUJ5dGVzQkUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpIHtcbiAgICAgIHJldHVybiBuZXcgTG9uZyhcbiAgICAgICAgKGJ5dGVzWzRdIDw8IDI0KSB8IChieXRlc1s1XSA8PCAxNikgfCAoYnl0ZXNbNl0gPDwgOCkgfCBieXRlc1s3XSxcbiAgICAgICAgKGJ5dGVzWzBdIDw8IDI0KSB8IChieXRlc1sxXSA8PCAxNikgfCAoYnl0ZXNbMl0gPDwgOCkgfCBieXRlc1szXSxcbiAgICAgICAgdW5zaWduZWQsXG4gICAgICApO1xuICAgIH07XG5cbiAgICAvLyBTdXBwb3J0IGNvbnZlcnNpb24gdG8vZnJvbSBCaWdJbnQgd2hlcmUgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiBCaWdJbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIGJpZyBpbnRlZ2VyLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGJpZyBpbnRlZ2VyIHZhbHVlXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAgICAgICAqL1xuICAgICAgTG9uZy5mcm9tQmlnSW50ID0gZnVuY3Rpb24gZnJvbUJpZ0ludCh2YWx1ZSwgdW5zaWduZWQpIHtcbiAgICAgICAgdmFyIGxvd0JpdHMgPSBOdW1iZXIoQmlnSW50LmFzSW50TigzMiwgdmFsdWUpKTtcbiAgICAgICAgdmFyIGhpZ2hCaXRzID0gTnVtYmVyKEJpZ0ludC5hc0ludE4oMzIsIHZhbHVlID4+IEJpZ0ludCgzMikpKTtcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBPdmVycmlkZVxuICAgICAgTG9uZy5mcm9tVmFsdWUgPSBmdW5jdGlvbiBmcm9tVmFsdWVXaXRoQmlnSW50KHZhbHVlLCB1bnNpZ25lZCkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSByZXR1cm4gTG9uZy5mcm9tQmlnSW50KHZhbHVlLCB1bnNpZ25lZCk7XG4gICAgICAgIHJldHVybiBmcm9tVmFsdWUodmFsdWUsIHVuc2lnbmVkKTtcbiAgICAgIH07XG5cbiAgICAgIC8qKlxuICAgICAgICogQ29udmVydHMgdGhlIExvbmcgdG8gaXRzIGJpZyBpbnRlZ2VyIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICogQHRoaXMgeyFMb25nfVxuICAgICAgICogQHJldHVybnMge2JpZ2ludH1cbiAgICAgICAqL1xuICAgICAgTG9uZ1Byb3RvdHlwZS50b0JpZ0ludCA9IGZ1bmN0aW9uIHRvQmlnSW50KCkge1xuICAgICAgICB2YXIgbG93QmlnSW50ID0gQmlnSW50KHRoaXMubG93ID4+PiAwKTtcbiAgICAgICAgdmFyIGhpZ2hCaWdJbnQgPSBCaWdJbnQodGhpcy51bnNpZ25lZCA/IHRoaXMuaGlnaCA+Pj4gMCA6IHRoaXMuaGlnaCk7XG4gICAgICAgIHJldHVybiAoaGlnaEJpZ0ludCA8PCBCaWdJbnQoMzIpKSB8IGxvd0JpZ0ludDtcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciBfZGVmYXVsdCA9IChfZXhwb3J0cy5kZWZhdWx0ID0gTG9uZyk7XG4gIH0sXG4pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBIZWxwZXJzLlxuY29uc3QgcyA9IDEwMDA7XG5jb25zdCBtID0gcyAqIDYwO1xuY29uc3QgaCA9IG0gKiA2MDtcbmNvbnN0IGQgPSBoICogMjQ7XG5jb25zdCB3ID0gZCAqIDc7XG5jb25zdCB5ID0gZCAqIDM2NS4yNTtcbmZ1bmN0aW9uIG1zKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM/LmxvbmcgPyBmbXRMb25nKHZhbHVlKSA6IGZtdFNob3J0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIGlzIG5vdCBhIHN0cmluZyBvciBudW1iZXIuJyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gaXNFcnJvcihlcnJvcilcbiAgICAgICAgICAgID8gYCR7ZXJyb3IubWVzc2FnZX0uIHZhbHVlPSR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWBcbiAgICAgICAgICAgIDogJ0FuIHVua25vd24gZXJyb3IgaGFzIG9jY3VyZWQuJztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbn1cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICovXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIGV4Y2VlZHMgdGhlIG1heGltdW0gbGVuZ3RoIG9mIDEwMCBjaGFyYWN0ZXJzLicpO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhzdHIpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgY29uc3QgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICAgIGNvbnN0IHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAneWVhcnMnOlxuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgY2FzZSAneXJzJzpcbiAgICAgICAgY2FzZSAneXInOlxuICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICAgIHJldHVybiBuICogeTtcbiAgICAgICAgY2FzZSAnd2Vla3MnOlxuICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgY2FzZSAndyc6XG4gICAgICAgICAgICByZXR1cm4gbiAqIHc7XG4gICAgICAgIGNhc2UgJ2RheXMnOlxuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgIHJldHVybiBuICogZDtcbiAgICAgICAgY2FzZSAnaG91cnMnOlxuICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgY2FzZSAnaHJzJzpcbiAgICAgICAgY2FzZSAnaHInOlxuICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgIHJldHVybiBuICogaDtcbiAgICAgICAgY2FzZSAnbWludXRlcyc6XG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgIGNhc2UgJ21pbnMnOlxuICAgICAgICBjYXNlICdtaW4nOlxuICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgIHJldHVybiBuICogbTtcbiAgICAgICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgIGNhc2UgJ3NlY3MnOlxuICAgICAgICBjYXNlICdzZWMnOlxuICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIHJldHVybiBuICogcztcbiAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICBjYXNlICdtc2Vjcyc6XG4gICAgICAgIGNhc2UgJ21zZWMnOlxuICAgICAgICBjYXNlICdtcyc6XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIG9jY3VyLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgdW5pdCAke3R5cGV9IHdhcyBtYXRjaGVkLCBidXQgbm8gbWF0Y2hpbmcgY2FzZSBleGlzdHMuYCk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gbXM7XG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqL1xuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgICBjb25zdCBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgICBpZiAobXNBYnMgPj0gZCkge1xuICAgICAgICByZXR1cm4gYCR7TWF0aC5yb3VuZChtcyAvIGQpfWRgO1xuICAgIH1cbiAgICBpZiAobXNBYnMgPj0gaCkge1xuICAgICAgICByZXR1cm4gYCR7TWF0aC5yb3VuZChtcyAvIGgpfWhgO1xuICAgIH1cbiAgICBpZiAobXNBYnMgPj0gbSkge1xuICAgICAgICByZXR1cm4gYCR7TWF0aC5yb3VuZChtcyAvIG0pfW1gO1xuICAgIH1cbiAgICBpZiAobXNBYnMgPj0gcykge1xuICAgICAgICByZXR1cm4gYCR7TWF0aC5yb3VuZChtcyAvIHMpfXNgO1xuICAgIH1cbiAgICByZXR1cm4gYCR7bXN9bXNgO1xufVxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqL1xuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICAgIGNvbnN0IG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICAgIGlmIChtc0FicyA+PSBkKSB7XG4gICAgICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gICAgfVxuICAgIGlmIChtc0FicyA+PSBoKSB7XG4gICAgICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICAgIH1cbiAgICBpZiAobXNBYnMgPj0gbSkge1xuICAgICAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICAgIH1cbiAgICBpZiAobXNBYnMgPj0gcykge1xuICAgICAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICAgIH1cbiAgICByZXR1cm4gYCR7bXN9IG1zYDtcbn1cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgICBjb25zdCBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gICAgcmV0dXJuIGAke01hdGgucm91bmQobXMgLyBuKX0gJHtuYW1lfSR7aXNQbHVyYWwgPyAncycgOiAnJ31gO1xufVxuLyoqXG4gKiBBIHR5cGUgZ3VhcmQgZm9yIGVycm9ycy5cbiAqL1xuZnVuY3Rpb24gaXNFcnJvcihlcnJvcikge1xuICAgIHJldHVybiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yICE9PSBudWxsICYmICdtZXNzYWdlJyBpbiBlcnJvcjtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdDtcbiIsImltcG9ydCB7IGluamVjdFN5bWJvbEJhc2VkSW5zdGFuY2VPZiB9IGZyb20gXCIuLi9pbnRlcm5hbC9zeW1ib2wtaW5zdGFuY2VvZlwiO1xuXG4vKipcbiAqIEEgTmV4dXMgaGFuZGxlciBlcnJvci5cbiAqXG4gKiBUaGlzIGVycm9yIGNsYXNzIHJlcHJlc2VudHMgYW4gZXJyb3IgdGhhdCBvY2N1cnJlZCBkdXJpbmcgdGhlIGhhbmRsaW5nIG9mIGFcbiAqIE5leHVzIG9wZXJhdGlvbiB0aGF0IHNob3VsZCBiZSByZXBvcnRlZCB0byB0aGUgY2FsbGVyIGFzIGEgaGFuZGxlciBlcnJvci5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYHRzXG4gKiAgICAgaW1wb3J0IHsgSGFuZGxlckVycm9yIH0gZnJvbSBcIm5leHVzLXJwY1wiO1xuICpcbiAqICAgICAvLyBUaHJvdyBhIGJhZCByZXF1ZXN0IGVycm9yXG4gKiAgICAgdGhyb3cgbmV3IEhhbmRsZXJFcnJvcihcIkJBRF9SRVFVRVNUXCIsIFwiSW52YWxpZCBpbnB1dCBwcm92aWRlZFwiKTtcbiAqXG4gKiAgICAgLy8gVGhyb3cgYSBiYWQgcmVxdWVzdCBlcnJvciwgd2l0aCBhIGNhdXNlXG4gKiAgICAgdGhyb3cgbmV3IEhhbmRsZXJFcnJvcihcIkJBRF9SRVFVRVNUXCIsIFwiSW52YWxpZCBpbnB1dCBwcm92aWRlZFwiLCB7IGNhdXNlIH0pO1xuICpcbiAqICAgICAvLyBUaHJvdyBhIHJldHJ5YWJsZSBpbnRlcm5hbCBlcnJvclxuICogICAgIHRocm93IG5ldyBIYW5kbGVyRXJyb3IoXCJJTlRFUk5BTFwiLCBcIkRhdGFiYXNlIHVuYXZhaWxhYmxlXCIsIHsgcmV0cnlhYmxlT3ZlcnJpZGU6IHRydWUgfSk7XG4gKiBgYGBcbiAqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCBjbGFzcyBIYW5kbGVyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBPbmUgb2YgdGhlIHByZWRlZmluZWQgZXJyb3IgdHlwZXMuXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIEhhbmRsZXJFcnJvclR5cGV9XG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgdHlwZTogSGFuZGxlckVycm9yVHlwZTtcblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIGVycm9yIHNob3VsZCBiZSBjb25zaWRlcmVkIHJldHJ5YWJsZS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhlIHJldHJ5IGJlaGF2aW9yIGlzIGRldGVybWluZWQgZnJvbSB0aGUgZXJyb3IgdHlwZS5cbiAgICogRm9yIGV4YW1wbGUsIGJ5IGRlZmF1bHQsIGBJTlRFUk5BTGAgaXMgcmV0cnlhYmxlLCBidXQgYFVOQVZBSUxBQkxFYCBpcyBub24tcmV0cnlhYmxlLlxuICAgKlxuICAgKiBJZiBzcGVjaWZpZWQsIGByZXRyeWFibGVPdmVycmlkZWAgb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IHJldHJ5IGJlaGF2aW9yIGRldGVybWluZWQgYmFzZWQgb25cbiAgICogdGhlIGVycm9yIHR5cGUuIFVzZSB7QGxpbmsgcmV0cnlhYmxlfSB0byBkZXRlcm1pbmUgdGhlIGVmZmVjdGl2ZSByZXRyeSBiZWhhdmlvci5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgcmV0cnlhYmxlfS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSByZXRyeWFibGVPdmVycmlkZTogYm9vbGVhbiB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyB7QGxpbmsgSGFuZGxlckVycm9yfS5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIG1lc3NhZ2Ugb2YgdGhlIGVycm9yLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEV4dHJhIG9wdGlvbnMgZm9yIHRoZSBlcnJvciwgaW5jbHVkaW5nIHRoZSBjYXVzZSBhbmQgcmV0cnlhYmxlIG92ZXJyaWRlLlxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlOiBIYW5kbGVyRXJyb3JUeXBlLCBtZXNzYWdlPzogc3RyaW5nIHwgdW5kZWZpbmVkLCBvcHRpb25zPzogSGFuZGxlckVycm9yT3B0aW9ucykge1xuICAgIGNvbnN0IGFjdHVhbE1lc3NhZ2UgPSBtZXNzYWdlIHx8IGBIYW5kbGVyIGVycm9yOiAke3R5cGV9YDtcblxuICAgIHN1cGVyKGFjdHVhbE1lc3NhZ2UsIHsgY2F1c2U6IG9wdGlvbnM/LmNhdXNlIH0pO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5yZXRyeWFibGVPdmVycmlkZSA9IG9wdGlvbnM/LnJldHJ5YWJsZU92ZXJyaWRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBlcnJvciBpcyByZXRyeWFibGUuXG4gICAqXG4gICAqIFRoaXMgZGlmZmVycyBmcm9tIHRoZSB7QGxpbmsgcmV0cnlhYmxlT3ZlcnJpZGV9IHByb3BlcnR5IGluIHRoYXQgYHJldHJ5YWJsZWAgdGFrZXMgaW50b1xuICAgKiBhY2NvdW50IHRoZSBkZWZhdWx0IGJlaGF2aW9yIHJlc3VsdGluZyBmcm9tIHRoZSBlcnJvciB0eXBlLCBpZiBubyBvdmVycmlkZSBpcyBwcm92aWRlZC5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgcmV0cnlhYmxlT3ZlcnJpZGV9LlxuICAgKi9cbiAgcHVibGljIGdldCByZXRyeWFibGUoKTogYm9vbGVhbiB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnJldHJ5YWJsZU92ZXJyaWRlID09PSBcImJvb2xlYW5cIikgcmV0dXJuIHRoaXMucmV0cnlhYmxlT3ZlcnJpZGU7XG5cbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSBcIkJBRF9SRVFVRVNUXCI6XG4gICAgICBjYXNlIFwiVU5BVVRIRU5USUNBVEVEXCI6XG4gICAgICBjYXNlIFwiVU5BVVRIT1JJWkVEXCI6XG4gICAgICBjYXNlIFwiTk9UX0ZPVU5EXCI6XG4gICAgICBjYXNlIFwiTk9UX0lNUExFTUVOVEVEXCI6XG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgY2FzZSBcIlVOQVZBSUxBQkxFXCI6XG4gICAgICBjYXNlIFwiVVBTVFJFQU1fVElNRU9VVFwiOlxuICAgICAgY2FzZSBcIlJFU09VUkNFX0VYSEFVU1RFRFwiOlxuICAgICAgY2FzZSBcIklOVEVSTkFMXCI6XG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIC8vIEZvcmNlIGEgY29tcGlsZSB0aW1lIGVycm9yIGlmIG1pc3NpbmcgYSBjYXNlXG4gICAgICAgIGNvbnN0IF9ub01pc3NpbmdDYXNlOiBuZXZlciA9IHRoaXMudHlwZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmluamVjdFN5bWJvbEJhc2VkSW5zdGFuY2VPZihIYW5kbGVyRXJyb3IsIFwiSGFuZGxlckVycm9yXCIpO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGNvbnN0cnVjdGluZyBhIHtAbGluayBIYW5kbGVyRXJyb3J9LlxuICpcbiAqIEBleHBlcmltZW50YWxcbiAqIEBpbmxpbmVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBIYW5kbGVyRXJyb3JPcHRpb25zIHtcbiAgLyoqXG4gICAqIFVuZGVybHlpbmcgY2F1c2Ugb2YgdGhlIGVycm9yLlxuICAgKi9cbiAgY2F1c2U/OiB1bmtub3duO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgZXJyb3Igc2hvdWxkIGJlIGNvbnNpZGVyZWQgcmV0cnlhYmxlLlxuICAgKlxuICAgKiBJZiBub3Qgc2V0LCB0aGUgcmV0cnkgYmVoYXZpb3IgaXMgZGV0ZXJtaW5lZCBmcm9tIHRoZSBlcnJvciB0eXBlLlxuICAgKiBGb3IgZXhhbXBsZSwgYnkgZGVmYXVsdCwgYElOVEVSTkFMYCBpcyByZXRyeWFibGUsIGJ1dCBgVU5BVkFJTEFCTEVgIGlzIG5vbi1yZXRyeWFibGUuXG4gICAqL1xuICByZXRyeWFibGVPdmVycmlkZT86IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQW4gZXJyb3IgdHlwZSBhc3NvY2lhdGVkIHdpdGggYSB7QGxpbmsgSGFuZGxlckVycm9yfSwgZGVmaW5lZCBhY2NvcmRpbmcgdG8gdGhlIE5leHVzIHNwZWNpZmljYXRpb24uXG4gKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgdHlwZSBIYW5kbGVyRXJyb3JUeXBlID0gKHR5cGVvZiBIYW5kbGVyRXJyb3JUeXBlKVtrZXlvZiB0eXBlb2YgSGFuZGxlckVycm9yVHlwZV07XG5leHBvcnQgY29uc3QgSGFuZGxlckVycm9yVHlwZSA9IHtcbiAgLyoqXG4gICAqIFRoZSBoYW5kbGVyIGNhbm5vdCBvciB3aWxsIG5vdCBwcm9jZXNzIHRoZSByZXF1ZXN0IGR1ZSB0byBhbiBhcHBhcmVudCBjbGllbnQgZXJyb3IuXG4gICAqXG4gICAqIENsaWVudHMgc2hvdWxkIG5vdCByZXRyeSB0aGlzIHJlcXVlc3QgdW5sZXNzIGFkdmlzZWQgb3RoZXJ3aXNlLlxuICAgKi9cbiAgQkFEX1JFUVVFU1Q6IFwiQkFEX1JFUVVFU1RcIixcblxuICAvKipcbiAgICogVGhlIGNsaWVudCBkaWQgbm90IHN1cHBseSB2YWxpZCBhdXRoZW50aWNhdGlvbiBjcmVkZW50aWFscyBmb3IgdGhpcyByZXF1ZXN0LlxuICAgKlxuICAgKiBDbGllbnRzIHNob3VsZCBub3QgcmV0cnkgdGhpcyByZXF1ZXN0IHVubGVzcyBhZHZpc2VkIG90aGVyd2lzZS5cbiAgICovXG4gIFVOQVVUSEVOVElDQVRFRDogXCJVTkFVVEhFTlRJQ0FURURcIixcblxuICAvKipcbiAgICogVGhlIGNhbGxlciBkb2VzIG5vdCBoYXZlIHBlcm1pc3Npb24gdG8gZXhlY3V0ZSB0aGUgc3BlY2lmaWVkIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQ2xpZW50cyBzaG91bGQgbm90IHJldHJ5IHRoaXMgcmVxdWVzdCB1bmxlc3MgYWR2aXNlZCBvdGhlcndpc2UuXG4gICAqL1xuICBVTkFVVEhPUklaRUQ6IFwiVU5BVVRIT1JJWkVEXCIsXG5cbiAgLyoqXG4gICAqIFRoZSByZXF1ZXN0ZWQgcmVzb3VyY2UgY291bGQgbm90IGJlIGZvdW5kIGJ1dCBtYXkgYmUgYXZhaWxhYmxlIGluIHRoZSBmdXR1cmUuXG4gICAqL1xuICBOT1RfRk9VTkQ6IFwiTk9UX0ZPVU5EXCIsXG5cbiAgLyoqXG4gICAqIFNvbWUgcmVzb3VyY2UgaGFzIGJlZW4gZXhoYXVzdGVkLCBwZXJoYXBzIGEgcGVyLXVzZXIgcXVvdGEsIG9yIHBlcmhhcHMgdGhlIGVudGlyZSBmaWxlIHN5c3RlbVxuICAgKiBpcyBvdXQgb2Ygc3BhY2UuXG4gICAqXG4gICAqIFN1YnNlcXVlbnQgcmVxdWVzdHMgYnkgdGhlIGNsaWVudCBhcmUgcGVybWlzc2libGUuXG4gICAqL1xuICBSRVNPVVJDRV9FWEhBVVNURUQ6IFwiUkVTT1VSQ0VfRVhIQVVTVEVEXCIsXG5cbiAgLyoqXG4gICAqIEFuIGludGVybmFsIGVycm9yIG9jY3VyZWQuXG4gICAqXG4gICAqIFN1YnNlcXVlbnQgcmVxdWVzdHMgYnkgdGhlIGNsaWVudCBhcmUgcGVybWlzc2libGUuXG4gICAqL1xuICBJTlRFUk5BTDogXCJJTlRFUk5BTFwiLFxuXG4gIC8qKlxuICAgKiBUaGUgc2VydmVyIGVpdGhlciBkb2VzIG5vdCByZWNvZ25pemUgdGhlIHJlcXVlc3QgbWV0aG9kLCBvciBpdCBsYWNrcyB0aGUgYWJpbGl0eSB0byBmdWxmaWxsIHRoZVxuICAgKiByZXF1ZXN0LiBDbGllbnRzIHNob3VsZCBub3QgcmV0cnkgdGhpcyByZXF1ZXN0IHVubGVzcyBhZHZpc2VkIG90aGVyd2lzZS5cbiAgICovXG4gIE5PVF9JTVBMRU1FTlRFRDogXCJOT1RfSU1QTEVNRU5URURcIixcblxuICAvKipcbiAgICogVGhlIHNlcnZpY2UgaXMgY3VycmVudGx5IHVuYXZhaWxhYmxlLlxuICAgKlxuICAgKiBTdWJzZXF1ZW50IHJlcXVlc3RzIGJ5IHRoZSBjbGllbnQgYXJlIHBlcm1pc3NpYmxlLlxuICAgKi9cbiAgVU5BVkFJTEFCTEU6IFwiVU5BVkFJTEFCTEVcIixcblxuICAvKipcbiAgICogVXNlZCBieSBnYXRld2F5cyB0byByZXBvcnQgdGhhdCBhIHJlcXVlc3QgdG8gYW4gdXBzdHJlYW0gc2VydmVyIGhhcyB0aW1lZCBvdXQuXG4gICAqXG4gICAqIFN1YnNlcXVlbnQgcmVxdWVzdHMgYnkgdGhlIGNsaWVudCBhcmUgcGVybWlzc2libGUuXG4gICAqL1xuICBVUFNUUkVBTV9USU1FT1VUOiBcIlVQU1RSRUFNX1RJTUVPVVRcIixcbn0gYXMgY29uc3Q7XG4iLCJleHBvcnQgeyBIYW5kbGVyRXJyb3IsIHR5cGUgSGFuZGxlckVycm9yVHlwZSwgdHlwZSBIYW5kbGVyRXJyb3JPcHRpb25zIH0gZnJvbSBcIi4vaGFuZGxlci1lcnJvclwiO1xuZXhwb3J0IHsgdHlwZSBMaW5rIH0gZnJvbSBcIi4vbGlua1wiO1xuZXhwb3J0IHsgT3BlcmF0aW9uRXJyb3IgfSBmcm9tIFwiLi9vcGVyYXRpb24tZXJyb3JcIjtcbmV4cG9ydCB7IHR5cGUgT3BlcmF0aW9uU3RhdGUsIHR5cGUgT3BlcmF0aW9uSW5mbyB9IGZyb20gXCIuL29wZXJhdGlvbi1pbmZvXCI7XG5leHBvcnQgeyBPcGVyYXRpb25TdGlsbFJ1bm5pbmdFcnJvciB9IGZyb20gXCIuL29wZXJhdGlvbi1zdGlsbC1ydW5uaW5nLWVycm9yXCI7XG4iLCJpbXBvcnQgeyBpbmplY3RTeW1ib2xCYXNlZEluc3RhbmNlT2YgfSBmcm9tIFwiLi4vaW50ZXJuYWwvc3ltYm9sLWluc3RhbmNlb2ZcIjtcblxuLyoqXG4gKiBBIE5leHVzIG9wZXJhdGlvbiBlcnJvci5cbiAqXG4gKiBUaGlzIGVycm9yIGNsYXNzIHJlcHJlc2VudHMgdGhlIGFibm9ybWFsIGNvbXBsZXRpb24gb2YgYSBOZXh1cyBvcGVyYXRpb24sXG4gKiB0aGF0IHNob3VsZCBiZSByZXBvcnRlZCB0byB0aGUgY2FsbGVyIGFzIGFuIG9wZXJhdGlvbiBlcnJvci5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYHRzXG4gKiAgICAgaW1wb3J0IHsgT3BlcmF0aW9uRXJyb3IgfSBmcm9tIFwibmV4dXMtcnBjXCI7XG4gKlxuICogICAgIC8vIFRocm93IGEgZmFpbGVkIG9wZXJhdGlvbiBlcnJvclxuICogICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihcImZhaWxlZFwiLCBcIk5vdCBlbm91Z2ggaW52ZW50b3J5XCIpO1xuICpcbiAqICAgICAvLyBUaHJvdyBhIGZhaWxlZCBvcGVyYXRpb24gZXJyb3IsIHdpdGggYSBjYXVzZVxuICogICAgIHRocm93IG5ldyBPcGVyYXRpb25FcnJvcihcImZhaWxlZFwiLCBcIk5vdCBlbm91Z2ggaW52ZW50b3J5XCIsIHsgY2F1c2UgfSk7XG4gKlxuICogICAgIC8vIFRocm93IGEgY2FuY2VsZWQgb3BlcmF0aW9uIGVycm9yXG4gKiAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkVycm9yKFwiY2FuY2VsZWRcIiwgXCJVc2VyIGNhbmNlbGVkIHRoZSBvcGVyYXRpb25cIik7XG4gKiBgYGBcbiAqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCBjbGFzcyBPcGVyYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqIFN0YXRlIG9mIHRoZSBvcGVyYXRpb24uXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgc3RhdGU6IE9wZXJhdGlvbkVycm9yU3RhdGU7XG5cbiAgLyoqXG4gICAqIFRoZSBlcnJvciB0aGF0IHJlc3VsdGVkIGluIHRoaXMgb3BlcmF0aW9uIGVycm9yLlxuICAgKi9cbiAgZGVjbGFyZSBwdWJsaWMgcmVhZG9ubHkgY2F1c2U6IEVycm9yO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHtAbGluayBPcGVyYXRpb25FcnJvcn0uXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZSAtIFRoZSBzdGF0ZSBvZiB0aGUgb3BlcmF0aW9uLlxuICAgKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIG9mIHRoZSBlcnJvci5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBFeHRyYSBvcHRpb25zIGZvciB0aGUgZXJyb3IsIGUuZy4gdGhlIGNhdXNlLlxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBzdGF0ZTogT3BlcmF0aW9uRXJyb3JTdGF0ZSxcbiAgICBtZXNzYWdlPzogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIG9wdGlvbnM/OiBPcGVyYXRpb25FcnJvck9wdGlvbnMsXG4gICkge1xuICAgIGNvbnN0IGRlZmF1bHRNZXNzYWdlID0gc3RhdGUgPT09IFwiY2FuY2VsZWRcIiA/IGBPcGVyYXRpb24gY2FuY2VsZWRgIDogYE9wZXJhdGlvbiBmYWlsZWRgO1xuICAgIGNvbnN0IGFjdHVhbE1lc3NhZ2UgPSBtZXNzYWdlIHx8IGRlZmF1bHRNZXNzYWdlO1xuXG4gICAgc3VwZXIoYWN0dWFsTWVzc2FnZSwgeyBjYXVzZTogb3B0aW9ucz8uY2F1c2UgfSk7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICB9XG59XG5cbmluamVjdFN5bWJvbEJhc2VkSW5zdGFuY2VPZihPcGVyYXRpb25FcnJvciwgXCJPcGVyYXRpb25FcnJvclwiKTtcblxuLyoqXG4gKiBPcHRpb25zIGZvciBjb25zdHJ1Y3RpbmcgYW4ge0BsaW5rIE9wZXJhdGlvbkVycm9yfS5cbiAqXG4gKiBAZXhwZXJpbWVudGFsXG4gKiBAaW5saW5lXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT3BlcmF0aW9uRXJyb3JPcHRpb25zIHtcbiAgLyoqXG4gICAqIFVuZGVybHlpbmcgY2F1c2Ugb2YgdGhlIGVycm9yLlxuICAgKi9cbiAgY2F1c2U/OiBFcnJvciB8IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBEZXNjcmliZXMgc3RhdGUgb2YgYW4gb3BlcmF0aW9uIHRoYXQgZGlkIG5vdCBjb21wbGV0ZSBzdWNjZXNzZnVsbHkuXG4gKlxuICogVGhpcyBpcyBhIHN1YnNldCBvZiB7QGxpbmsgT3BlcmF0aW9uU3RhdGV9LlxuICpcbiAqIEBleHBlcmltZW50YWxcbiAqIEBpbmxpbmVcbiAqL1xuZXhwb3J0IHR5cGUgT3BlcmF0aW9uRXJyb3JTdGF0ZSA9IFwiZmFpbGVkXCIgfCBcImNhbmNlbGVkXCI7XG4iLCJpbXBvcnQgeyBpbmplY3RTeW1ib2xCYXNlZEluc3RhbmNlT2YgfSBmcm9tIFwiLi4vaW50ZXJuYWwvc3ltYm9sLWluc3RhbmNlb2ZcIjtcblxuLyoqXG4gKiBBbiBvcGVyYXRpb24gcmVzdWx0IHdhcyByZXF1ZXN0ZWQsIGJ1dCB0aGUgb3BlcmF0aW9uIGlzIHN0aWxsIHJ1bm5pbmcuXG4gKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgY2xhc3MgT3BlcmF0aW9uU3RpbGxSdW5uaW5nRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcge0BsaW5rIE9wZXJhdGlvblN0aWxsUnVubmluZ0Vycm9yfS5cbiAgICpcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJPcGVyYXRpb24gc3RpbGwgcnVubmluZ1wiKTtcbiAgfVxufVxuXG5pbmplY3RTeW1ib2xCYXNlZEluc3RhbmNlT2YoT3BlcmF0aW9uU3RpbGxSdW5uaW5nRXJyb3IsIFwiT3BlcmF0aW9uU3RpbGxSdW5uaW5nRXJyb3JcIik7XG4iLCJleHBvcnQge1xuICB0eXBlIE9wZXJhdGlvbkNvbnRleHQsXG4gIHR5cGUgU3RhcnRPcGVyYXRpb25Db250ZXh0LFxuICB0eXBlIEdldE9wZXJhdGlvbkluZm9Db250ZXh0LFxuICB0eXBlIEdldE9wZXJhdGlvblJlc3VsdENvbnRleHQsXG4gIHR5cGUgQ2FuY2VsT3BlcmF0aW9uQ29udGV4dCxcbn0gZnJvbSBcIi4vb3BlcmF0aW9uLWNvbnRleHRcIjtcblxuZXhwb3J0IHtcbiAgSGFuZGxlclN0YXJ0T3BlcmF0aW9uUmVzdWx0LFxuICB0eXBlIEhhbmRsZXJTdGFydE9wZXJhdGlvblJlc3VsdFN5bmMsXG4gIHR5cGUgSGFuZGxlclN0YXJ0T3BlcmF0aW9uUmVzdWx0QXN5bmMsXG59IGZyb20gXCIuL3N0YXJ0LW9wZXJhdGlvbi1yZXN1bHRcIjtcblxuZXhwb3J0IHtcbiAgLy9cbiAgdHlwZSBPcGVyYXRpb25IYW5kbGVyLFxuICB0eXBlIFN5bmNPcGVyYXRpb25IYW5kbGVyLFxufSBmcm9tIFwiLi9vcGVyYXRpb24taGFuZGxlclwiO1xuXG5leHBvcnQge1xuICBTZXJ2aWNlSGFuZGxlcixcbiAgc2VydmljZUhhbmRsZXIsXG4gIHR5cGUgT3BlcmF0aW9uSGFuZGxlckZvcixcbiAgdHlwZSBTZXJ2aWNlSGFuZGxlckZvcixcbn0gZnJvbSBcIi4vc2VydmljZS1oYW5kbGVyXCI7XG5cbmV4cG9ydCB7IFNlcnZpY2VSZWdpc3RyeSB9IGZyb20gXCIuL3NlcnZpY2UtcmVnaXN0cnlcIjtcbiIsImltcG9ydCB7IEhhbmRsZXJFcnJvciwgT3BlcmF0aW9uSW5mbyB9IGZyb20gXCIuLi9jb21tb25cIjtcbmltcG9ydCB7IEhhbmRsZXJTdGFydE9wZXJhdGlvblJlc3VsdCB9IGZyb20gXCIuL3N0YXJ0LW9wZXJhdGlvbi1yZXN1bHRcIjtcbmltcG9ydCB7XG4gIENhbmNlbE9wZXJhdGlvbkNvbnRleHQsXG4gIEdldE9wZXJhdGlvbkluZm9Db250ZXh0LFxuICBHZXRPcGVyYXRpb25SZXN1bHRDb250ZXh0LFxuICBTdGFydE9wZXJhdGlvbkNvbnRleHQsXG59IGZyb20gXCIuL29wZXJhdGlvbi1jb250ZXh0XCI7XG5pbXBvcnQge1xuICBPcGVyYXRpb25EZWZpbml0aW9uLFxuICBPcGVyYXRpb25JbnB1dCxcbiAgT3BlcmF0aW9uS2V5LFxuICBPcGVyYXRpb25NYXAsXG4gIE9wZXJhdGlvbk91dHB1dCxcbn0gZnJvbSBcIi4uL3NlcnZpY2VcIjtcblxuLyoqXG4gKiBBIGhhbmRsZXIgZm9yIGEgTmV4dXMgb3BlcmF0aW9uLlxuICpcbiAqIFRoaXMgaW50ZXJmYWNlIGlzIG1lYW50IHRvIGJlIGltcGxlbWVudGVkIGJ5IE5leHVzIHNlcnZpY2UgaW1wbGVtZW50b3JzLlxuICpcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBPcGVyYXRpb25IYW5kbGVyPEksIE8+IHtcbiAgLyoqXG4gICAqIEhhbmRsZSByZXF1ZXN0cyB0byBzdGFydCBhbiBvcGVyYXRpb24uXG4gICAqXG4gICAqIFJldHVybiB7QGxpbmsgSGFuZGxlclN0YXJ0T3BlcmF0aW9uUmVzdWx0U3luY30gdG8gcmVzcG9uZCBzdWNjZXNzZnVsbHkgaW5saW5lLCBvclxuICAgKiB7QGxpbmsgSGFuZGxlclN0YXJ0T3BlcmF0aW9uUmVzdWx0QXN5bmN9IHRvIGluZGljYXRlIHRoYXQgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbiB3YXMgc3RhcnRlZC5cbiAgICogVGhyb3cgYW4ge0BsaW5rIE9wZXJhdGlvbkVycm9yfSB0byBpbmRpY2F0ZSB0aGF0IGFuIG9wZXJhdGlvbiBjb21wbGV0ZWQgYXMgZmFpbGVkIG9yIGNhbmNlbGVkLlxuICAgKi9cbiAgc3RhcnQoY3R4OiBTdGFydE9wZXJhdGlvbkNvbnRleHQsIGlucHV0OiBJKTogUHJvbWlzZTxIYW5kbGVyU3RhcnRPcGVyYXRpb25SZXN1bHQ8Tz4+O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgcmVxdWVzdHMgdG8gZ2V0IGluZm9ybWF0aW9uIGFib3V0IGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uXG4gICAqL1xuICBnZXRJbmZvKGN0eDogR2V0T3BlcmF0aW9uSW5mb0NvbnRleHQsIHRva2VuOiBzdHJpbmcpOiBQcm9taXNlPE9wZXJhdGlvbkluZm8+O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgcmVxdWVzdHMgdG8gZ2V0IHRoZSByZXN1bHQgb2YgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi4gUmV0dXJuIG5vbiBlcnJvciByZXN1bHQgdG9cbiAgICogcmVzcG9uZCBzdWNjZXNzZnVsbHkgaW5saW5lLCBvciB0aHJvdyBhbiB7QGxpbmsgT3BlcmF0aW9uU3RpbGxSdW5uaW5nRXJyb3J9IHRvIGluZGljYXRlIHRoYXQgYW5cbiAgICogYXN5bmNocm9ub3VzIG9wZXJhdGlvbiBpcyBzdGlsbCBydW5uaW5nLlxuICAgKlxuICAgKiBUaHJvdyBhbiB7QGxpbmsgT3BlcmF0aW9uRXJyb3J9IHRvIGluZGljYXRlIHRoYXQgYW4gb3BlcmF0aW9uIGNvbXBsZXRlZCBhcyBmYWlsZWQgb3IgY2FuY2VsZWQuXG4gICAqXG4gICAqIFdoZW4ge0BsaW5rIEdldE9wZXJhdGlvblJlc3VsdENvbnRleHQudGltZW91dE1zIHwgdGltZW91dE1zfSBpcyBncmVhdGVyIHRoYW4gemVybywgdGhpcyByZXF1ZXN0XG4gICAqIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgbG9uZyBwb2xsLiBOb3RlIHRoYXQgdGhlIHNwZWNpZmllZCB3YWl0IGR1cmF0aW9uIG1heSBiZSBsb25nZXIgdGhhbiB0aGVcbiAgICogY29uZmlndXJlZCBjbGllbnQgb3Igc2VydmVyIHNpZGUgcmVxdWVzdCB0aW1lb3V0LCBhbmQgc2hvdWxkIGJlIGhhbmRsZWQgc2VwYXJhdGVseS5cbiAgICpcbiAgICogSXQgaXMgdGhlIGltcGxlbWVudG9yJ3MgcmVzcG9uc2liaWxpdHkgdG8gcmVzcGVjdCB0aGUgY2xpZW50J3MgdGltZW91dCBkdXJhdGlvbiBhbmQgcmV0dXJuIGluIGFcbiAgICogdGltZWx5IGZhc2hpb24sIGxlYXZpbmcgZW5vdWdoIHRpbWUgZm9yIHRoZSByZXF1ZXN0IHRvIGNvbXBsZXRlIGFuZCB0aGUgcmVzcG9uc2UgdG8gYmUgc2VudFxuICAgKiBiYWNrLlxuICAgKi9cbiAgZ2V0UmVzdWx0KGN0eDogR2V0T3BlcmF0aW9uUmVzdWx0Q29udGV4dCwgdG9rZW46IHN0cmluZyk6IFByb21pc2U8Tz47XG5cbiAgLyoqXG4gICAqIEhhbmRsZSByZXF1ZXN0cyB0byBjYW5jZWwgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQ2FuY2VsYXRpb24gb2YgYSBOZXh1cyBvcGVyYXRpb24gaXM6XG4gICAqIDEuIF9hc3luY2hyb25vdXNfIC0gcmV0dXJuaW5nIGZyb20gdGhpcyBtZXRob2Qgb25seSBjb25maXJtcyB0aGF0IGNhbmNlbGF0aW9uIHdhcyBub3RpZmllZDtcbiAgICogICAgdGhlIGltcGxlbWVudGF0aW9uIG1heSBob3dldmVyIGNob29zZSB0byBwcm9jZXNzIHRoZSBjYW5jZWxsYXRpb24gYXQgYSBsYXRlciB0aW1lLCBvciB0b1xuICAgKiAgICBpZ25vcmUgaXQgZW50aXJlbHkuXG4gICAqIDIuIF9pZGVtcG90ZW50XyAtIGltcGxlbWVudGF0aW9ucyBtdXN0IGlnbm9yZSBkdXBsaWNhdGUgY2FuY2VsYXRpb25zIGZvciB0aGUgc2FtZSBvcGVyYXRpb24uXG4gICAqL1xuICBjYW5jZWwoY3R4OiBDYW5jZWxPcGVyYXRpb25Db250ZXh0LCB0b2tlbjogc3RyaW5nKTogUHJvbWlzZTx2b2lkPjtcbn1cblxuLyoqXG4gKiBBIHNob3J0Y3V0IGZvciBkZWZpbmluZyBhbiBvcGVyYXRpb24gaGFuZGxlciB0aGF0IG9ubHkgaW1wbGVtZW50cyB0aGUge0BsaW5rIE9wZXJhdGlvbkhhbmRsZXIuc3RhcnR9XG4gKiBtZXRob2QgYW5kIGFsd2F5cyByZXR1cm5zIGEge0BsaW5rIEhhbmRsZXJTdGFydE9wZXJhdGlvblJlc3VsdFN5bmN9LlxuICpcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IHR5cGUgU3luY09wZXJhdGlvbkhhbmRsZXI8SSwgTz4gPSAoY3R4OiBTdGFydE9wZXJhdGlvbkNvbnRleHQsIGlucHV0OiBJKSA9PiBQcm9taXNlPE8+O1xuXG4vKipcbiAqIENvbXBpbGVzIGFuIG9wZXJhdGlvbiBoYW5kbGVyIGludG8gYSB7QGxpbmsgQ29tcGlsZWRPcGVyYXRpb25IYW5kbGVyfS4gQSBjb21waWxlZCBvcGVyYXRpb25cbiAqIGhhbmRsZXIgaXMgYSBzaW5nbGUgb2JqZWN0IHRoYXQgaXMgYm90aCBhbiBvcGVyYXRpb24gZGVmaW5pdGlvbiBhbmQgYSBmdWxsLWZsZWRnZWQgb3BlcmF0aW9uXG4gKiBoYW5kbGVyIGZvciB0aGF0IG9wZXJhdGlvbi5cbiAqXG4gKiBAaGlkZGVuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGVPcGVyYXRpb25IYW5kbGVyPEksIE8+KFxuICBkZWZpbml0aW9uOiBPcGVyYXRpb25EZWZpbml0aW9uPEksIE8+LFxuICBoYW5kbGVyOiBPcGVyYXRpb25IYW5kbGVyPEksIE8+IHwgU3luY09wZXJhdGlvbkhhbmRsZXI8SSwgTz4gfCB1bmRlZmluZWQsXG4pOiBDb21waWxlZE9wZXJhdGlvbkhhbmRsZXI8SSwgTz4ge1xuICBpZiAoaGFuZGxlciA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIGBObyBoYW5kbGVyIHJlZ2lzdGVyZWQgZm9yIG9wZXJhdGlvbiAnJHtkZWZpbml0aW9uLm5hbWV9JyAoZXhwZWN0ZWQgcHJvcGVydHkgbmFtZSAnJHtkZWZpbml0aW9uLm5hbWV9JylgLFxuICAgICk7XG4gIH1cblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIC8vIE9wZXJhdGlvbiBoYW5kbGVyIGlzIGRlY2xhcmVkIHVzaW5nIHRoZSBzaG9ydGN1dCBzeW50YXguIFdyYXAgaXQgaW50byBhIGZ1bGwtZmxlZGdlZCBoYW5kbGVyLlxuICAgIHJldHVybiB7XG4gICAgICAuLi5kZWZpbml0aW9uLFxuXG4gICAgICBzdGFydDogYXN5bmMgKGN0eCwgaW5wdXQpID0+IHtcbiAgICAgICAgcmV0dXJuIEhhbmRsZXJTdGFydE9wZXJhdGlvblJlc3VsdC5zeW5jKGF3YWl0IGhhbmRsZXIoY3R4LCBpbnB1dCkpO1xuICAgICAgfSxcbiAgICAgIGdldEluZm86IG5vdEltcGxlbWVudGVkLFxuICAgICAgZ2V0UmVzdWx0OiBub3RJbXBsZW1lbnRlZCxcbiAgICAgIGNhbmNlbDogbm90SW1wbGVtZW50ZWQsXG4gICAgfTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaGFuZGxlci5zdGFydCAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSGFuZGxlciBmb3Igb3BlcmF0aW9uICcke2RlZmluaXRpb24ubmFtZX0nIGhhcyBubyBzdGFydCBtZXRob2RgKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4uZGVmaW5pdGlvbixcblxuICAgIC8vIERlZmVuc2l2ZWx5IGVuc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhbGwgdGhlIHJlcXVpcmVkIG1ldGhvZHMsXG4gICAgLy8gZGVmYXVsdGluZyB0byB0aHJvd2luZyBhIG5vdCBpbXBsZW1lbnRlZCBlcnJvciBpZiBzb21lIG1ldGhvZHMgYXJlIG1pc3NpbmcuXG4gICAgc3RhcnQ6IGhhbmRsZXIuc3RhcnQuYmluZChoYW5kbGVyKSxcbiAgICBnZXRJbmZvOiBoYW5kbGVyLmdldEluZm8/LmJpbmQoaGFuZGxlcikgPz8gbm90SW1wbGVtZW50ZWQsXG4gICAgZ2V0UmVzdWx0OiBoYW5kbGVyLmdldFJlc3VsdD8uYmluZChoYW5kbGVyKSA/PyBub3RJbXBsZW1lbnRlZCxcbiAgICBjYW5jZWw6IGhhbmRsZXIuY2FuY2VsPy5iaW5kKGhhbmRsZXIpID8/IG5vdEltcGxlbWVudGVkLFxuICB9O1xufVxuXG4vKipcbiAqIEEgY29tcGlsZWQgb3BlcmF0aW9uIGhhbmRsZXIgaXMgYSBzaW5nbGUgb2JqZWN0IHRoYXQgaXMgYm90aCBhbiBvcGVyYXRpb24gZGVmaW5pdGlvbiBhbmQgYVxuICogZnVsbC1mbGVkZ2VkIG9wZXJhdGlvbiBoYW5kbGVyIGZvciB0aGF0IG9wZXJhdGlvbi5cbiAqXG4gKiBAaGlkZGVuXG4gKiBAaW50ZXJuYWxcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IHR5cGUgQ29tcGlsZWRPcGVyYXRpb25IYW5kbGVyPEksIE8+ID0gT3BlcmF0aW9uRGVmaW5pdGlvbjxJLCBPPiAmIE9wZXJhdGlvbkhhbmRsZXI8SSwgTz47XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCB0eXBlIENvbXBpbGVkT3BlcmF0aW9uSGFuZGxlckZvcjxPcHMgZXh0ZW5kcyBPcGVyYXRpb25NYXA+ID0gQ29tcGlsZWRPcGVyYXRpb25IYW5kbGVyPFxuICBPcGVyYXRpb25JbnB1dDxPcHNbT3BlcmF0aW9uS2V5PE9wcz5dPixcbiAgT3BlcmF0aW9uT3V0cHV0PE9wc1tPcGVyYXRpb25LZXk8T3BzPl0+XG4+O1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5mdW5jdGlvbiBub3RJbXBsZW1lbnRlZCgpOiBuZXZlciB7XG4gIHRocm93IG5ldyBIYW5kbGVyRXJyb3IoXCJOT1RfSU1QTEVNRU5URURcIiwgXCJOb3QgaW1wbGVtZW50ZWRcIik7XG59XG4iLCJpbXBvcnQgeyBIYW5kbGVyRXJyb3IgfSBmcm9tIFwiLi4vY29tbW9uXCI7XG5pbXBvcnQgeyBPcGVyYXRpb25EZWZpbml0aW9uLCBPcGVyYXRpb25LZXksIE9wZXJhdGlvbk1hcCwgU2VydmljZURlZmluaXRpb24gfSBmcm9tIFwiLi4vc2VydmljZVwiO1xuaW1wb3J0IHtcbiAgQ29tcGlsZWRPcGVyYXRpb25IYW5kbGVyRm9yLFxuICBjb21waWxlT3BlcmF0aW9uSGFuZGxlcixcbiAgT3BlcmF0aW9uSGFuZGxlcixcbiAgU3luY09wZXJhdGlvbkhhbmRsZXIsXG59IGZyb20gXCIuL29wZXJhdGlvbi1oYW5kbGVyXCI7XG5cbi8qKlxuICogQSBOZXh1cyBTZXJ2aWNlIGltcGxlbWVudGF0aW9uLCB0aGF0IHByb3ZpZGVzIGhhbmRsZXJzIGZvciBlYWNoIG9mIGl0cyBvcGVyYXRpb25zLlxuICpcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IGNsYXNzIFNlcnZpY2VIYW5kbGVyPE9wcyBleHRlbmRzIE9wZXJhdGlvbk1hcCA9IE9wZXJhdGlvbk1hcD4ge1xuICAvKipcbiAgICogQnVpbGQgYSBgU2VydmljZUhhbmRsZXJgIGZyb20gYSBzZXJ2aWNlIGRlZmluaXRpb24gYW5kIGEgY29sbGVjdGlvbiBvZiBvcGVyYXRpb24gaGFuZGxlcnMuXG4gICAqXG4gICAqIFRoZXJlIG11c3QgYmUgYW4gb3BlcmF0aW9uIGhhbmRsZXIgZm9yIGV2ZXJ5IG9wZXJhdGlvbiBpbiB0aGUgc2VydmljZSBkZWZpbml0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gc2VydmljZSBUaGUgc2VydmljZSBkZWZpbml0aW9uXG4gICAqIEBwYXJhbSBoYW5kbGVycyBUaGUgY29sbGVjdGlvbiBvZiBoYW5kbGVyc1xuICAgKiBAcmV0dXJucyBUaGUgY29tcGlsZWQgc2VydmljZSBoYW5kbGVyXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAaGlkZGVuXG4gICAqL1xuICBzdGF0aWMgYnVpbGQ8T3BzIGV4dGVuZHMgT3BlcmF0aW9uTWFwPihcbiAgICBzZXJ2aWNlOiBTZXJ2aWNlRGVmaW5pdGlvbjxPcHM+LFxuICAgIGhhbmRsZXJzOiBTZXJ2aWNlSGFuZGxlckZvcjxPcHM+LFxuICApOiBTZXJ2aWNlSGFuZGxlcjxPcHM+IHtcbiAgICBjb25zdCBvcGVyYXRpb25zID0gbmV3IE1hcDxPcGVyYXRpb25LZXk8T3BzPiwgQ29tcGlsZWRPcGVyYXRpb25IYW5kbGVyRm9yPE9wcz4+KCk7XG5cbiAgICBmb3IgKGNvbnN0IFtwcm9wTmFtZSwgZGVmaW5pdGlvbl0gb2YgT2JqZWN0LmVudHJpZXMoc2VydmljZS5vcGVyYXRpb25zKSkge1xuICAgICAgY29uc3QgY29tcGlsZWRPcEhhbmRsZXIgPSBjb21waWxlT3BlcmF0aW9uSGFuZGxlcihkZWZpbml0aW9uLCBoYW5kbGVyc1twcm9wTmFtZV0pO1xuICAgICAgY29uc3Qgb3BlcmF0aW9uTmFtZSA9IGNvbXBpbGVkT3BIYW5kbGVyLm5hbWUgYXMgT3BlcmF0aW9uS2V5PE9wcz47XG5cbiAgICAgIGlmIChvcGVyYXRpb25zLmhhcyhvcGVyYXRpb25OYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGBPcGVyYXRpb24gd2l0aCBuYW1lICcke29wZXJhdGlvbk5hbWV9JyBhbHJlYWR5IHJlZ2lzdGVyZWQgZm9yIHNlcnZpY2UgJyR7c2VydmljZS5uYW1lfSdgLFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBvcGVyYXRpb25zLnNldChvcGVyYXRpb25OYW1lLCBjb21waWxlZE9wSGFuZGxlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTZXJ2aWNlSGFuZGxlcihzZXJ2aWNlLCBoYW5kbGVycywgb3BlcmF0aW9ucyk7XG4gIH1cblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyByZWFkb25seSBkZWZpbml0aW9uOiBTZXJ2aWNlRGVmaW5pdGlvbjxPcHM+LFxuICAgIHB1YmxpYyByZWFkb25seSBoYW5kbGVyczogU2VydmljZUhhbmRsZXJGb3I8T3BzPixcbiAgICBwcml2YXRlIHJlYWRvbmx5IG9wZXJhdGlvbnNNYXA6IE1hcDxPcGVyYXRpb25LZXk8T3BzPiwgQ29tcGlsZWRPcGVyYXRpb25IYW5kbGVyRm9yPE9wcz4+LFxuICApIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlZmluaXRpb24gYW5kIGhhbmRsZXIgZm9yIGEgZ2l2ZW4gb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gb3BlcmF0aW9uTmFtZVxuICAgKi9cbiAgcHVibGljIGdldE9wZXJhdGlvbkhhbmRsZXI8SyBleHRlbmRzIE9wZXJhdGlvbktleTxPcHM+PihcbiAgICBvcGVyYXRpb25OYW1lOiBLLFxuICApOiBDb21waWxlZE9wZXJhdGlvbkhhbmRsZXJGb3I8T3BzPiB7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLm9wZXJhdGlvbnNNYXAuZ2V0KG9wZXJhdGlvbk5hbWUpO1xuICAgIGlmIChlbnRyeSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSGFuZGxlckVycm9yKFxuICAgICAgICBcIk5PVF9GT1VORFwiLFxuICAgICAgICBgT3BlcmF0aW9uIGhhbmRsZXIgbm90IHJlZ2lzdGVyZWQgZm9yIG9wZXJhdGlvbiAnJHtvcGVyYXRpb25OYW1lfScgaW4gc2VydmljZSAnJHt0aGlzLmRlZmluaXRpb24ubmFtZX0nYCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBlbnRyeTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBzZXJ2aWNlIGhhbmRsZXIgZm9yIGEgZ2l2ZW4gc2VydmljZSBjb250cmFjdC5cbiAqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJ2aWNlSGFuZGxlcjxPcHMgZXh0ZW5kcyBPcGVyYXRpb25NYXA+KFxuICBzZXJ2aWNlOiBTZXJ2aWNlRGVmaW5pdGlvbjxPcHM+LFxuICBoYW5kbGVyczogU2VydmljZUhhbmRsZXJGb3I8T3BzPixcbik6IFNlcnZpY2VIYW5kbGVyPE9wcz4ge1xuICByZXR1cm4gU2VydmljZUhhbmRsZXIuYnVpbGQoc2VydmljZSwgaGFuZGxlcnMpO1xufVxuXG4vKipcbiAqIEEgdHlwZSB0aGF0IGRlZmluZXMgYSBoYW5kbGVyIGZvciBhIGdpdmVuIG9wZXJhdGlvbi5cbiAqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCB0eXBlIE9wZXJhdGlvbkhhbmRsZXJGb3I8VD4gPVxuICBUIGV4dGVuZHMgT3BlcmF0aW9uRGVmaW5pdGlvbjxpbmZlciBJLCBpbmZlciBPPlxuICAgID8gT3BlcmF0aW9uSGFuZGxlcjxJLCBPPiB8IFN5bmNPcGVyYXRpb25IYW5kbGVyPEksIE8+XG4gICAgOiBuZXZlcjtcblxuLyoqXG4gKiBBIHR5cGUgdGhhdCBkZWZpbmVzIGEgY29sbGVjdGlvbiBvZiBoYW5kbGVycyBmb3IgYSBnaXZlbiBjb2xsZWN0aW9uIG9mIG9wZXJhdGlvbiBpbnRlcmZhY2VzLlxuICpcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IHR5cGUgU2VydmljZUhhbmRsZXJGb3I8VCBleHRlbmRzIE9wZXJhdGlvbk1hcCA9IE9wZXJhdGlvbk1hcD4gPSB7XG4gIFtLIGluIGtleW9mIFQgJiBzdHJpbmddOiBPcGVyYXRpb25IYW5kbGVyRm9yPFRbS10+O1xufTtcbiIsImltcG9ydCB7IEhhbmRsZXJFcnJvciwgT3BlcmF0aW9uSW5mbyB9IGZyb20gXCIuLi9jb21tb25cIjtcbmltcG9ydCB7IExhenlWYWx1ZSB9IGZyb20gXCIuLi9zZXJpYWxpemF0aW9uXCI7XG5pbXBvcnQgeyBIYW5kbGVyU3RhcnRPcGVyYXRpb25SZXN1bHQgfSBmcm9tIFwiLi9zdGFydC1vcGVyYXRpb24tcmVzdWx0XCI7XG5pbXBvcnQge1xuICBPcGVyYXRpb25Db250ZXh0LFxuICBTdGFydE9wZXJhdGlvbkNvbnRleHQsXG4gIEdldE9wZXJhdGlvblJlc3VsdENvbnRleHQsXG4gIEdldE9wZXJhdGlvbkluZm9Db250ZXh0LFxuICBDYW5jZWxPcGVyYXRpb25Db250ZXh0LFxufSBmcm9tIFwiLi9vcGVyYXRpb24tY29udGV4dFwiO1xuaW1wb3J0IHsgU2VydmljZUhhbmRsZXIgfSBmcm9tIFwiLi9zZXJ2aWNlLWhhbmRsZXJcIjtcbmltcG9ydCB7IENvbXBpbGVkT3BlcmF0aW9uSGFuZGxlckZvciB9IGZyb20gXCIuL29wZXJhdGlvbi1oYW5kbGVyXCI7XG5cbi8qKlxuICogVGhlIHJvb3QgTmV4dXMgaGFuZGxlciwgd2hpY2ggZGlzcGF0Y2hlcyBOZXh1cyByZXF1ZXN0cyB0byBhIGNvbGxlY3Rpb24gb2YgcmVnaXN0ZXJlZCBzZXJ2aWNlXG4gKiBpbXBsZW1lbnRhdGlvbnMuXG4gKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgY2xhc3MgU2VydmljZVJlZ2lzdHJ5IHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcge0BsaW5rIFNlcnZpY2VSZWdpc3RyeX0uXG4gICAqXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgY3JlYXRlKHNlcnZpY2VzOiBTZXJ2aWNlSGFuZGxlcjxhbnk+W10pIHtcbiAgICBjb25zdCBzZXJ2aWNlTWFwID0gbmV3IE1hcDxzdHJpbmcsIFNlcnZpY2VIYW5kbGVyPigpO1xuXG4gICAgZm9yIChjb25zdCBzIG9mIHNlcnZpY2VzKSB7XG4gICAgICBjb25zdCBuYW1lID0gcy5kZWZpbml0aW9uLm5hbWU7XG4gICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRyaWVkIHRvIHJlZ2lzdGVyIGEgTmV4dXMgc2VydmljZSB3aXRoIG5vIG5hbWVcIik7XG4gICAgICB9XG4gICAgICBpZiAoc2VydmljZU1hcC5oYXMobmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRHVwbGljYXRlIHJlZ2lzdHJhdGlvbiBvZiBuZXh1cyBzZXJ2aWNlICcke25hbWV9J2ApO1xuICAgICAgfVxuICAgICAgc2VydmljZU1hcC5zZXQobmFtZSwgcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTZXJ2aWNlUmVnaXN0cnkoc2VydmljZU1hcCk7XG4gIH1cblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyZWQgc2VydmljZSBoYW5kbGVycyB0byB3aGljaCB0aGlzIHJlZ2lzdHJ5IGRpc3BhdGNoZXMgcmVxdWVzdHMuXG4gICAgICovXG4gICAgcHJpdmF0ZSByZWFkb25seSBzZXJ2aWNlcyA9IG5ldyBNYXA8c3RyaW5nLCBTZXJ2aWNlSGFuZGxlcj4oKSxcbiAgKSB7fVxuXG4gIHByaXZhdGUgZ2V0T3BlcmF0aW9uSGFuZGxlcihjdHg6IE9wZXJhdGlvbkNvbnRleHQpOiBDb21waWxlZE9wZXJhdGlvbkhhbmRsZXJGb3I8YW55PiB7XG4gICAgY29uc3QgeyBzZXJ2aWNlLCBvcGVyYXRpb24gfSA9IGN0eDtcbiAgICBjb25zdCBzZXJ2aWNlSGFuZGxlciA9IHRoaXMuc2VydmljZXMuZ2V0KHNlcnZpY2UpO1xuICAgIGlmIChzZXJ2aWNlSGFuZGxlciA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSGFuZGxlckVycm9yKFxuICAgICAgICBcIk5PVF9GT1VORFwiLFxuICAgICAgICBgTm8gc2VydmljZSBoYW5kbGVyIHJlZ2lzdGVyZWQgZm9yIHNlcnZpY2UgbmFtZSAnJHtzZXJ2aWNlfSdgLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcnZpY2VIYW5kbGVyLmdldE9wZXJhdGlvbkhhbmRsZXIob3BlcmF0aW9uKTtcbiAgfVxuXG4gIGFzeW5jIHN0YXJ0KFxuICAgIGN0eDogU3RhcnRPcGVyYXRpb25Db250ZXh0LFxuICAgIGx2OiBMYXp5VmFsdWUsXG4gICk6IFByb21pc2U8SGFuZGxlclN0YXJ0T3BlcmF0aW9uUmVzdWx0PGFueT4+IHtcbiAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5nZXRPcGVyYXRpb25IYW5kbGVyKGN0eCk7XG4gICAgY29uc3QgaW5wdXQgPSBhd2FpdCBsdi5jb25zdW1lPGFueT4oKTtcbiAgICByZXR1cm4gYXdhaXQgaGFuZGxlci5zdGFydChjdHgsIGlucHV0KTtcbiAgfVxuXG4gIGFzeW5jIGdldEluZm8oY3R4OiBHZXRPcGVyYXRpb25JbmZvQ29udGV4dCwgdG9rZW46IHN0cmluZyk6IFByb21pc2U8T3BlcmF0aW9uSW5mbz4ge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldE9wZXJhdGlvbkhhbmRsZXIoY3R4KS5nZXRJbmZvKGN0eCwgdG9rZW4pO1xuICB9XG5cbiAgYXN5bmMgZ2V0UmVzdWx0KGN0eDogR2V0T3BlcmF0aW9uUmVzdWx0Q29udGV4dCwgdG9rZW46IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0T3BlcmF0aW9uSGFuZGxlcihjdHgpLmdldFJlc3VsdChjdHgsIHRva2VuKTtcbiAgfVxuXG4gIGFzeW5jIGNhbmNlbChjdHg6IENhbmNlbE9wZXJhdGlvbkNvbnRleHQsIHRva2VuOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRPcGVyYXRpb25IYW5kbGVyKGN0eCkuY2FuY2VsKGN0eCwgdG9rZW4pO1xuICB9XG59XG4iLCIvKiogQGltcG9ydCB7IE9wZXJhdGlvbkhhbmRsZXIgfSBmcm9tIFwiLi9vcGVyYXRpb24taGFuZGxlclwiICovXG5cbi8qKlxuICogQW4gaW50ZXJuYWwgc3ltYm9sLCB1c2VkIHRvIHByZXZlbnQgZGlyZWN0IGltcGxlbWVudGF0aW9uIG9mIGludGVyZmFjZXMuXG4gKlxuICogQGhpZGRlblxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IGlzSGFuZGxlclN0YXJ0T3BlcmF0aW9uUmVzdWx0U3ltYm9sID0gU3ltYm9sKFwiX19uZXh1c19pc0hhbmRsZXJTdGFydE9wZXJhdGlvblJlc3VsdFwiKTtcblxuLyoqXG4gKiBUaGUgcmV0dXJuIHR5cGUgZnJvbSB0aGUge0BsaW5rIE9wZXJhdGlvbkhhbmRsZXIuc3RhcnR9IG1ldGhvZC5cbiAqXG4gKiBVc2UgZWl0aGVyIHtAbGluayBIYW5kbGVyU3RhcnRPcGVyYXRpb25SZXN1bHQuc3luY30gb3Ige0BsaW5rIEhhbmRsZXJTdGFydE9wZXJhdGlvblJlc3VsdC5hc3luY31cbiAqIHRvIGNyZWF0ZSBhIHJlc3VsdCBvYmplY3QuIERvIG5vdCBpbXBsZW1lbnQgdGhpcyBpbnRlcmZhY2UgZGlyZWN0bHkuXG4gKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgdHlwZSBIYW5kbGVyU3RhcnRPcGVyYXRpb25SZXN1bHQ8VCA9IHVua25vd24+ID1cbiAgfCBIYW5kbGVyU3RhcnRPcGVyYXRpb25SZXN1bHRTeW5jPFQ+XG4gIHwgSGFuZGxlclN0YXJ0T3BlcmF0aW9uUmVzdWx0QXN5bmM7XG5cbi8qKlxuICogVGhlIHJldHVybiB0eXBlIGZyb20gdGhlIHtAbGluayBPcGVyYXRpb25IYW5kbGVyLnN0YXJ0fSBtZXRob2QuXG4gKlxuICogVXNlIGVpdGhlciB7QGxpbmsgSGFuZGxlclN0YXJ0T3BlcmF0aW9uUmVzdWx0LnN5bmN9IG9yIHtAbGluayBIYW5kbGVyU3RhcnRPcGVyYXRpb25SZXN1bHQuYXN5bmN9XG4gKiB0byBjcmVhdGUgYSByZXN1bHQgb2JqZWN0LiBEbyBub3QgaW1wbGVtZW50IHRoaXMgaW50ZXJmYWNlIGRpcmVjdGx5LlxuICpcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IGNvbnN0IEhhbmRsZXJTdGFydE9wZXJhdGlvblJlc3VsdCA9IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJlc3VsdCB0aGF0IGluZGljYXRlcyB0aGF0IGFuIG9wZXJhdGlvbiBoYXMgYmVlbiBhY2NlcHRlZCBhbmQgd2lsbCBjb21wbGV0ZSBhc3luY2hyb25vdXNseS5cbiAgICovXG4gIGFzeW5jKHRva2VuOiBzdHJpbmcpOiBIYW5kbGVyU3RhcnRPcGVyYXRpb25SZXN1bHRBc3luYyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzQXN5bmM6IHRydWUsXG4gICAgICB0b2tlbixcbiAgICAgIFtpc0hhbmRsZXJTdGFydE9wZXJhdGlvblJlc3VsdFN5bWJvbF06IHRydWUsXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlIGEgcmVzdWx0IHRoYXQgaW5kaWNhdGVzIHRoYXQgYW4gb3BlcmF0aW9uIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG4gICAqL1xuICBzeW5jPFQ+KHZhbHVlOiBUKTogSGFuZGxlclN0YXJ0T3BlcmF0aW9uUmVzdWx0U3luYzxUPiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzQXN5bmM6IGZhbHNlLFxuICAgICAgdmFsdWUsXG4gICAgICBbaXNIYW5kbGVyU3RhcnRPcGVyYXRpb25SZXN1bHRTeW1ib2xdOiB0cnVlLFxuICAgIH07XG4gIH0sXG5cbiAgW1N5bWJvbC5oYXNJbnN0YW5jZV06IGZ1bmN0aW9uICh0aGlzOiBhbnksIHZhbHVlOiBvYmplY3QpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgKHZhbHVlIGFzIGFueSlbaXNIYW5kbGVyU3RhcnRPcGVyYXRpb25SZXN1bHRTeW1ib2xdID09PSB0cnVlXG4gICAgKTtcbiAgfSxcbn07XG5cbi8qKlxuICogQSByZXN1bHQgdGhhdCBpbmRpY2F0ZXMgdGhhdCBhbiBvcGVyYXRpb24gY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cbiAqXG4gKiBVc2Uge0BsaW5rIEhhbmRsZXJTdGFydE9wZXJhdGlvblJlc3VsdC5zeW5jfSB0byBjcmVhdGUgYSBzeW5jIHJlc3VsdCBvYmplY3QuXG4gKiBEbyBub3QgaW1wbGVtZW50IHRoaXMgaW50ZXJmYWNlIGRpcmVjdGx5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAgIHJldHVybiBIYW5kbGVyU3RhcnRPcGVyYXRpb25SZXN1bHQuc3luYyg0Mik7XG4gKiBgYGBcbiAqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSGFuZGxlclN0YXJ0T3BlcmF0aW9uUmVzdWx0U3luYzxUID0gdW5rbm93bj4ge1xuICAvKipcbiAgICogSW5kaWNhdGUgd2hldGhlciB0aGUgb3BlcmF0aW9uIGNvbXBsZXRlZCBzeW5jaHJvbm91c2x5IChmYWxzZSkgb3Igd2lsbCBjb21wbGV0ZVxuICAgKiBhc3luY2hyb25vdXNseSAodHJ1ZSkuXG4gICAqL1xuICBpc0FzeW5jOiBmYWxzZTtcblxuICAvKipcbiAgICogVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgb3BlcmF0aW9uLlxuICAgKi9cbiAgdmFsdWU6IFQ7XG5cbiAgLyoqXG4gICAqIFByZXZlbnRzIGRpcmVjdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGludGVyZmFjZS5cbiAgICpcbiAgICogQGhpZGRlblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIFtpc0hhbmRsZXJTdGFydE9wZXJhdGlvblJlc3VsdFN5bWJvbF06IHRydWU7XG59XG5cbi8qKlxuICogQSByZXN1bHQgdGhhdCBpbmRpY2F0ZXMgdGhhdCBhbiBvcGVyYXRpb24gaGFzIGJlZW4gYWNjZXB0ZWQgYW5kIHdpbGwgY29tcGxldGUgYXN5bmNocm9ub3VzbHkuXG4gKlxuICogVXNlIHtAbGluayBIYW5kbGVyU3RhcnRPcGVyYXRpb25SZXN1bHQuYXN5bmN9IHRvIGNyZWF0ZSBhbiBhc3luYyByZXN1bHQgb2JqZWN0LlxuICogRG8gbm90IGltcGxlbWVudCB0aGlzIGludGVyZmFjZSBkaXJlY3RseS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogICByZXR1cm4gSGFuZGxlclN0YXJ0T3BlcmF0aW9uUmVzdWx0LmFzeW5jKFwidW5pcXVlIHRva2VuXCIpO1xuICogYGBgXG4gKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEhhbmRsZXJTdGFydE9wZXJhdGlvblJlc3VsdEFzeW5jIHtcbiAgLyoqXG4gICAqIEluZGljYXRlIHdoZXRoZXIgdGhlIG9wZXJhdGlvbiBjb21wbGV0ZWQgc3luY2hyb25vdXNseSAoZmFsc2UpIG9yIHdpbGwgY29tcGxldGVcbiAgICogYXN5bmNocm9ub3VzbHkgKHRydWUpLlxuICAgKi9cbiAgaXNBc3luYzogdHJ1ZTtcblxuICAvKipcbiAgICogQSB0b2tlbiB0byBpZGVudGlmeSB0aGUgb3BlcmF0aW9uIGluIGZvbGxvd3VwIGhhbmRsZXIgbWV0aG9kcyBzdWNoIGFzIHtAbGluayBPcGVyYXRpb25IYW5kbGVyLmdldFJlc3VsdH1cbiAgICogYW5kIHtAbGluayBPcGVyYXRpb25IYW5kbGVyLmNhbmNlbH0uXG4gICAqL1xuICB0b2tlbjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBQcmV2ZW50cyBkaXJlY3QgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBpbnRlcmZhY2UuXG4gICAqXG4gICAqIEBoaWRkZW5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBbaXNIYW5kbGVyU3RhcnRPcGVyYXRpb25SZXN1bHRTeW1ib2xdOiB0cnVlO1xufVxuIiwiZXhwb3J0ICogZnJvbSBcIi4vY29tbW9uXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zZXJ2aWNlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9oYW5kbGVyXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zZXJpYWxpemF0aW9uXCI7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IGJ5IG1hcHBpbmcgYWxsIHN0cmluZyBwcm9wZXJ0aWVzIChrZXlzIGFuZCB2YWx1ZXMpIG9mIGFuIGV4aXN0aW5nIG9iamVjdFxuICogdGhyb3VnaCBhIG1hcHBlciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gb2JqIC0gVGhlIHNvdXJjZSBvYmplY3QsIHdob3NlIHByb3BlcnRpZXMgd2lsbCBiZSBtYXBwZWQuXG4gKiBAcGFyYW0gZm4gLSBUaGUgbWFwcGVyIGZ1bmN0aW9uLlxuICpcbiAqIEByZXR1cm5zIEEgbmV3IG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIG1hcHBlZCB0byB0aGUgbmV3IHR5cGUuXG4gKlxuICogQGludGVybmFsXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBLZXlWYWx1ZXM8VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4sIFU+KFxuICBvYmo6IFQsXG4gIGZuOiAoa2V5OiBrZXlvZiBUICYgc3RyaW5nLCB2YWx1ZTogVFtrZXlvZiBUICYgc3RyaW5nXSkgPT4gVSxcbik6IFJlY29yZDxrZXlvZiBULCBVPiB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMob2JqKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gW2tleSwgZm4oa2V5LCB2YWx1ZSldKSxcbiAgKSBhcyBSZWNvcmQ8a2V5b2YgVCwgVT47XG59XG4iLCIvKipcbiAqIEluamVjdCBhIGN1c3RvbSAnaW5zdGFuY2VvZicgaGFuZGxlciBvbiB0aGUgZ2l2ZW4gY2xhc3MsIHRoYXQgd29ya3MgY29ycmVjdGx5IGFjcm9zcyBleGVjdXRpb24gY29udGV4dHMuXG4gKlxuICogIyMjIERldGFpbHMgIyMjXG4gKlxuICogQWNjb3JkaW5nIHRvIHRoZSBFY21hU2NyaXB0J3Mgc3BlYywgdGhlIGRlZmF1bHQgYmVoYXZpb3Igb2YgSmF2YVNjcmlwdCdzIGB4IGluc3RhbmNlb2YgWWAgb3BlcmF0b3IgaXMgdG8gd2FsayB1cCB0aGVcbiAqIHByb3RvdHlwZSBjaGFpbiBvZiBvYmplY3QgJ3gnLCBjaGVja2luZyBpZiBhbnkgY29uc3RydWN0b3IgaW4gdGhhdCBoaWVyYXJjaHkgaXMgX2V4YWN0bHkgdGhlIHNhbWUgb2JqZWN0XyBhcyB0aGVcbiAqIGNvbnN0cnVjdG9yIGZ1bmN0aW9uICdZJy5cbiAqXG4gKiBVbmZvcnR1bmF0ZWx5LCBpdCBoYXBwZW5zIGluIHZhcmlvdXMgc2l0dWF0aW9ucyB0aGF0IGRpZmZlcmVudCBjb25zdHJ1Y3RvciBmdW5jdGlvbiBvYmplY3RzIGdldCBjcmVhdGVkIGZvciB3aGF0XG4gKiBhcHBlYXJzIHRvIGJlIHRoZSB2ZXJ5IHNhbWUgY2xhc3MuIFRoaXMgbGVhZHMgdG8gc3VycHJpc2luZyBiZWhhdmlvciB3aGVyZSBgaW5zdGFuY2VvZmAgcmV0dXJucyBmYWxzZSB0aG91Z2ggaXQgaXNcbiAqIGtub3duIHRoYXQgdGhlIG9iamVjdCBpcyBpbmRlZWQgYW4gaW5zdGFuY2Ugb2YgdGhhdCBjbGFzcy4gT25lIHBhcnRpY3VsYXIgY2FzZSB3aGVyZSB0aGlzIGhhcHBlbnMgaXMgd2hlbiBjb25zdHJ1Y3RvclxuICogJ1knIGJlbG9uZ3MgdG8gYSBkaWZmZXJlbnQgcmVhbG0gdGhhbiB0aGUgY29uc3R1Y3RvciB3aXRoIHdoaWNoICd4JyB3YXMgaW5zdGFudGlhdGVkLiBBbm90aGVyIGNhc2UgaXMgd2hlbiB0d28gY29waWVzXG4gKiBvZiB0aGUgc2FtZSBsaWJyYXJ5IGdldHMgbG9hZGVkIGluIHRoZSBzYW1lIHJlYWxtLlxuICpcbiAqIEluIHByYWN0aWNlLCB0aGlzIHRlbmRzIHRvIGNhdXNlIGlzc3VlcyB3aGVuIGNyb3NzaW5nIHRoZSB3b3JrZmxvdy1zYW5kYm94aW5nIGJvdW5kYXJ5IChzaW5jZSBOb2RlJ3Mgdm0gbW9kdWxlXG4gKiByZWFsbHkgY3JlYXRlcyBuZXcgZXhlY3V0aW9uIHJlYWxtcyksIGFzIHdlbGwgYXMgd2hlbiBydW5uaW5nIHRlc3RzIHVzaW5nIEplc3QgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vamVzdGpzL2plc3QvaXNzdWVzLzI1NDlcbiAqIGZvciBzb21lIGRldGFpbHMgb24gdGhhdCBvbmUpLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaW5qZWN0cyBhIGN1c3RvbSAnaW5zdGFuY2VvZicgaGFuZGxlciBpbnRvIHRoZSBwcm90b3R5cGUgb2YgJ2NsYXp6Jywgd2hpY2ggaXMgYm90aCBjcm9zcy1yZWFsbSBzYWZlIGFuZFxuICogY3Jvc3MtY29waWVzLW9mLXRoZS1zYW1lLWxpYiBzYWZlLiBJdCB3b3JrcyBieSBhZGRpbmcgYSBzcGVjaWFsIHN5bWJvbCBwcm9wZXJ0eSB0byB0aGUgcHJvdG90eXBlIG9mICdjbGF6eicsIGFuZCB0aGVuXG4gKiBjaGVja2luZyBmb3IgdGhlIHByZXNlbmNlIG9mIHRoYXQgc3ltYm9sLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5qZWN0U3ltYm9sQmFzZWRJbnN0YW5jZU9mPEU+KGNsYXp6OiBDbGFzczxFPiwgbWFya2VyTmFtZTogc3RyaW5nKTogdm9pZCB7XG4gIC8vIEl0IG1heSBzZWVtIHJlZHVuZGFudCB0byBoYXZlIGFuIGV4cGxpY2l0IG1hcmtlck5hbWUgYXJndW1lbnQgaGVyZS4gQ2FuJ3Qgd2Ugc2ltcGx5IHVzZSB0aGUgY2xhc3NcbiAgLy8gZnVuY3Rpb24gbmFtZSBmb3IgdGhhdD8gVW5mb3J0dW5hdGVseSwgbm8sIGFzIHRoZSBjbGFzcyBuYW1lIG1heSBnZXQgbWFuZ2xlZCBpZiB0aGUgZmlsZSBnZXRzIG1pbmlmaWVkLlxuICBjb25zdCBtYXJrZXIgPSBTeW1ib2wuZm9yKGBfX25leHVzX2lzJHttYXJrZXJOYW1lfWApO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGF6ei5wcm90b3R5cGUsIFwibmFtZVwiLCB7IHZhbHVlOiBtYXJrZXJOYW1lLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhenoucHJvdG90eXBlLCBtYXJrZXIsIHsgdmFsdWU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhenosIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAodGhpczogYW55LCB2YWx1ZTogb2JqZWN0KTogYm9vbGVhbiB7XG4gICAgICBpZiAodGhpcyA9PT0gY2xhenopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAodmFsdWUgYXMgYW55KVttYXJrZXJdID09PSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gJ3RoaXMnIG11c3QgYmUgYSBfc3ViY2xhc3NfIG9mIGNsYXp6IHRoYXQgZG9lc24ndCByZWRlZmluZWQgW1N5bWJvbC5oYXNJbnN0YW5jZV0sIHNvIHRoYXQgaXQgaW5oZXJpdGVkXG4gICAgICAgIC8vIGZyb20gY2xhenoncyBbU3ltYm9sLmhhc0luc3RhbmNlXS4gSWYgd2UgZG9uJ3QgaGFuZGxlIHRoaXMgcGFydGljdWxhciBzaXR1YXRpb24sIHRoZW5cbiAgICAgICAgLy8gYHggaW5zdGFuY2VvZiBTdWJjbGFzc09mUGFyZW50YCB3b3VsZCByZXR1cm4gdHJ1ZSBmb3IgYW55IGluc3RhbmNlIG9mICdQYXJlbnQnLCB3aGljaCBpcyBjbGVhcmx5IHdyb25nLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZGVhbGx5LCBpdCdkIGJlIHByZWZlcmFibGUgdG8gYXZvaWQgdGhpcyBjYXNlIGVudGlyZWx5LCBieSBtYWtpbmcgc3VyZSB0aGF0IGFsbCBzdWJjbGFzc2VzIG9mICdjbGF6eidcbiAgICAgICAgLy8gcmVkZWZpbmUgW1N5bWJvbC5oYXNJbnN0YW5jZV0sIGJ1dCB3ZSBjYW4ndCBlbmZvcmNlIHRoYXQuIFdlIHRoZXJlZm9yZSBmYWxsYmFjayB0byB0aGUgZGVmYXVsdCBpbnN0YW5jZW9mXG4gICAgICAgIC8vIGJlaGF2aW9yICh3aGljaCBpcyBOT1QgY3Jvc3MtcmVhbG0gc2FmZSkuXG4gICAgICAgIHJldHVybiB0aGlzLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKHZhbHVlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgIH1cbiAgICB9LFxuICB9KTtcbn1cblxuLyoqXG4gKiBUeXBlIGRlZmluaXRpb24gZm9yIGEgY2xhc3MuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2xhc3M8RT4ge1xuICBuZXcgKC4uLmFyZ3M6IGFueVtdKTogRTtcbiAgcHJvdG90eXBlOiBFO1xufVxuIiwiZXhwb3J0IHsgTGF6eVZhbHVlIH0gZnJvbSBcIi4vbGF6eS12YWx1ZVwiO1xuZXhwb3J0IHsgdHlwZSBTZXJpYWxpemVyIH0gZnJvbSBcIi4vc2VyaWFsaXplclwiO1xuZXhwb3J0IHsgdHlwZSBDb250ZW50IH0gZnJvbSBcIi4vY29udGVudFwiO1xuIiwiaW1wb3J0IHsgaW5qZWN0U3ltYm9sQmFzZWRJbnN0YW5jZU9mIH0gZnJvbSBcIi4uL2ludGVybmFsL3N5bWJvbC1pbnN0YW5jZW9mXCI7XG5pbXBvcnQgeyBTZXJpYWxpemVyIH0gZnJvbSBcIi4vc2VyaWFsaXplclwiO1xuXG4vKipcbiAqIEEgY29udGFpbmVyIGZvciBhIHZhbHVlIGVuY29kZWQgaW4gYW4gdW5kZXJseWluZyBzdHJlYW0uXG4gKiBJdCBpcyB1c2VkIHRvIHN0cmVhbSBpbnB1dHMgYW5kIG91dHB1dHMgaW4gdGhlIHZhcmlvdXMgY2xpZW50IGFuZCBzZXJ2ZXIgQVBJcy5cbiAqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCBjbGFzcyBMYXp5VmFsdWUge1xuICAvKipcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcmVhZG9ubHkgc2VyaWFsaXplcjogU2VyaWFsaXplcixcblxuICAgIC8qKlxuICAgICAqIEhlYWRlcnMgdGhhdCBzaG91bGQgaW5jbHVkZSBpbmZvcm1hdGlvbiBvbiBob3cgdG8gcHJvY2VzcyB0aGUgc3RyZWFtJ3MgY29udGVudC5cbiAgICAgKiBIZWFkZXJzIGNvbnN0cnVjdGVkIGJ5IHRoZSBmcmFtZXdvcmsgYWx3YXlzIGhhdmUgbG93ZXIgY2FzZSBrZXlzLlxuICAgICAqIFVzZXIgcHJvdmlkZWQga2V5cyBhcmUgY29uc2lkZXJlZCBjYXNlLWluc2Vuc2l0aXZlIGJ5IHRoZSBmcmFtZXdvcmsuXG4gICAgICovXG4gICAgcmVhZG9ubHkgaGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPixcblxuICAgIC8qKlxuICAgICAqIFJlYWRhYmxlU3RyZWFtIHRoYXQgY29udGFpbnMgcmVxdWVzdCBvciByZXNwb25zZSBkYXRhLiBNYXkgYmUgdW5kZWZpbmVkIGZvciBlbXB0eSBkYXRhLlxuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBzdHJlYW0/OiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PixcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBDb25zdW1lIHRoZSB1bmRlcmx5aW5nIHJlYWRlciBzdHJlYW0sIGRlc2VyaWFsaXppbmcgdmlhIHRoZSBlbWJlZGRlZCBzZXJpYWxpemVyLlxuICAgKi9cbiAgYXN5bmMgY29uc3VtZTxUID0gdW5rbm93bj4oKTogUHJvbWlzZTxUPiB7XG4gICAgaWYgKHRoaXMuc3RyZWFtID09IG51bGwpIHtcbiAgICAgIC8vIFJldHVybiBhIGRlZmF1bHQgdmFsdWUgZnJvbSB0aGUgc2VyaWFsaXplci5cbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgfVxuICAgIGNvbnN0IHJlYWRlciA9IHRoaXMuc3RyZWFtLmdldFJlYWRlcigpO1xuICAgIGNvbnN0IGNodW5rcyA9IEFycmF5PFVpbnQ4QXJyYXk+KCk7XG4gICAgbGV0IGxlbmd0aCA9IDA7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmIChkb25lKSBicmVhaztcbiAgICAgIGNodW5rcy5wdXNoKHZhbHVlKTtcbiAgICAgIGxlbmd0aCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICAgIGRhdGEuc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVyLmRlc2VyaWFsaXplPFQ+KHsgaGVhZGVyczogdGhpcy5oZWFkZXJzLCBkYXRhIH0pO1xuICB9XG59XG5cbmluamVjdFN5bWJvbEJhc2VkSW5zdGFuY2VPZihMYXp5VmFsdWUsIFwiTGF6eVZhbHVlXCIpO1xuIiwiaW1wb3J0IHsgbWFwS2V5VmFsdWVzIH0gZnJvbSBcIi4uL2ludGVybmFsL29iamVjdC11dGlsc1wiO1xuaW1wb3J0IHsgU2ltcGxpZnkgfSBmcm9tIFwiLi4vaW50ZXJuYWwvdHlwZXNcIjtcbmltcG9ydCB7IGlucHV0QnJhbmQsIG91dHB1dEJyYW5kLCB2YWxpZGF0ZVNlcnZpY2VEZWZpbml0aW9uIH0gZnJvbSBcIi4vc2VydmljZS1kZWZpbml0aW9uXCI7XG5pbXBvcnQgeyBPcGVyYXRpb25EZWZpbml0aW9uLCBTZXJ2aWNlRGVmaW5pdGlvbiB9IGZyb20gXCIuL3NlcnZpY2UtZGVmaW5pdGlvblwiO1xuXG4vKipcbiAqIENvbnN0cnVjdCBhIHNlcnZpY2UgZGVmaW5pdGlvbiBmb3IgYSBjb2xsZWN0aW9uIG9mIG9wZXJhdGlvbnMuXG4gKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VydmljZTxPcHMgZXh0ZW5kcyBQYXJ0aWFsT3BlcmF0aW9uTWFwPihcbiAgbmFtZTogc3RyaW5nLFxuICBvcGVyYXRpb25zOiBPcHMsXG4pOiBTZXJ2aWNlRGVmaW5pdGlvbjxTaW1wbGlmeTxPcGVyYXRpb25NYXBGcm9tUGFydGlhbDxPcHM+Pj4ge1xuICBjb25zdCBzZXJ2aWNlID0ge1xuICAgIG5hbWUsXG4gICAgb3BlcmF0aW9uczogbWFwS2V5VmFsdWVzKG9wZXJhdGlvbnMsIChrZXksIG9wOiBQYXJ0aWFsT3BlcmF0aW9uPGFueSwgYW55PikgPT4gKHtcbiAgICAgIC4uLm9wLFxuICAgICAgbmFtZTogb3AubmFtZSB8fCBrZXksXG4gICAgfSkpLFxuICB9IGFzIFNlcnZpY2VEZWZpbml0aW9uPE9wZXJhdGlvbk1hcEZyb21QYXJ0aWFsPE9wcz4+O1xuXG4gIHZhbGlkYXRlU2VydmljZURlZmluaXRpb24oc2VydmljZSk7XG4gIHJldHVybiBzZXJ2aWNlO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdCBhbiBvcGVyYXRpb24gZGVmaW5pdGlvbiBhcyBwYXJ0IG9mIGEgc2VydmljZSBjb250cmFjdC5cbiAqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvcGVyYXRpb248SSwgTz4ob3A/OiBPcGVyYXRpb25PcHRpb25zPEksIE8+KTogUGFydGlhbE9wZXJhdGlvbjxJLCBPPiB7XG4gIHJldHVybiB7IC4uLm9wIH0gYXMgUGFydGlhbE9wZXJhdGlvbjxJLCBPPjtcbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciB0aGUge0BsaW5rIG9wZXJhdGlvbn0gZnVuY3Rpb24uXG4gKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgaW50ZXJmYWNlIE9wZXJhdGlvbk9wdGlvbnM8X0ksIF9PPiB7XG4gIG5hbWU/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQSBuYW1lZCBjb2xsZWN0aW9uIG9mIHBhcnRpYWwgb3BlcmF0aW9uIGhhbmRsZXJzLiBJbnB1dCBmb3IgdGhlIHtAbGluayBzZXJ2aWNlfSBmdW5jdGlvbi5cbiAqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCB0eXBlIFBhcnRpYWxPcGVyYXRpb25NYXAgPSBSZWNvcmQ8c3RyaW5nLCBQYXJ0aWFsT3BlcmF0aW9uPGFueSwgYW55Pj47XG5cbi8qKlxuICogQSB0eXBlIHRoYXQgdHJhbnNmb3JtcyBhIHtAbGluayBQYXJ0aWFsT3BlcmF0aW9uTWFwfSBpbnRvIGFuIHtAbGluayBPcGVyYXRpb25NYXB9LlxuICpcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IHR5cGUgT3BlcmF0aW9uTWFwRnJvbVBhcnRpYWw8VCBleHRlbmRzIFBhcnRpYWxPcGVyYXRpb25NYXA+ID0ge1xuICBbSyBpbiBrZXlvZiBUICYgc3RyaW5nXTogVFtLXSBleHRlbmRzIFBhcnRpYWxPcGVyYXRpb248aW5mZXIgSSwgaW5mZXIgTz5cbiAgICA/IE9wZXJhdGlvbkRlZmluaXRpb248SSwgTz5cbiAgICA6IG5ldmVyO1xufTtcblxuLyoqXG4gKiBBIHBhcnRpYWwge0BsaW5rIE9wZXJhdGlvbkRlZmluaXRpb259IHRoYXQgaXMgdXNlZCB0byBkZWZpbmUgYW4gb3BlcmF0aW9uIGluIGEge0BsaW5rIFNlcnZpY2VEZWZpbml0aW9ufS5cbiAqXG4gKiBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoaXMgYW5kIHtAbGluayBPcGVyYXRpb25EZWZpbml0aW9ufSBpcyB0aGF0IHRoZSBuYW1lIGlzIG9wdGlvbmFsLlxuICpcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYXJ0aWFsT3BlcmF0aW9uPEksIE8+IHtcbiAgbmFtZT86IHN0cmluZztcbiAgW2lucHV0QnJhbmRdOiBJO1xuICBbb3V0cHV0QnJhbmRdOiBPO1xufVxuIiwiZXhwb3J0IHtcbiAgdHlwZSBTZXJ2aWNlRGVmaW5pdGlvbixcbiAgdHlwZSBPcGVyYXRpb25EZWZpbml0aW9uLFxuICB0eXBlIE9wZXJhdGlvbk1hcCxcbiAgdHlwZSBPcGVyYXRpb25JbnB1dCxcbiAgdHlwZSBPcGVyYXRpb25PdXRwdXQsXG4gIHR5cGUgT3BlcmF0aW9uS2V5LFxufSBmcm9tIFwiLi9zZXJ2aWNlLWRlZmluaXRpb25cIjtcblxuZXhwb3J0IHtcbiAgc2VydmljZSxcbiAgb3BlcmF0aW9uLFxuICB0eXBlIE9wZXJhdGlvbk9wdGlvbnMsXG4gIHR5cGUgUGFydGlhbE9wZXJhdGlvbk1hcCxcbiAgdHlwZSBPcGVyYXRpb25NYXBGcm9tUGFydGlhbCxcbiAgdHlwZSBQYXJ0aWFsT3BlcmF0aW9uLFxufSBmcm9tIFwiLi9oZWxwZXJzXCI7XG4iLCJleHBvcnQgZGVjbGFyZSBjb25zdCBpbnB1dEJyYW5kOiB1bmlxdWUgc3ltYm9sO1xuZXhwb3J0IGRlY2xhcmUgY29uc3Qgb3V0cHV0QnJhbmQ6IHVuaXF1ZSBzeW1ib2w7XG5cbi8qKlxuICogRGVmaW5pdGlvbiBvZiBhIE5leHVzIHNlcnZpY2UgY29udHJhY3QsIGluY2x1ZGluZyBpdHMgbmFtZSBhbmQgb3BlcmF0aW9ucy5cbiAqXG4gKiBDYW4gb25seSBiZSBjb25zdHJ1Y3RlZCBieSB0aGUge0BsaW5rIHNlcnZpY2V9IGZ1bmN0aW9uLlxuICpcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZXJ2aWNlRGVmaW5pdGlvbjxPcHMgZXh0ZW5kcyBPcGVyYXRpb25NYXAgPSBPcGVyYXRpb25NYXA+IHtcbiAgbmFtZTogc3RyaW5nO1xuICBvcGVyYXRpb25zOiBPcHM7XG59XG5cbi8qKlxuICogQW4gb3BlcmF0aW9uIGNvbnRyYWN0IHRoYXQgZGVzY3JpYmVzIHRoZSBuYW1lLCBhbmQgaW5wdXQgYW5kIG91dHB1dCB0eXBlcyBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgaW50ZXJmYWNlIE9wZXJhdGlvbkRlZmluaXRpb248SSwgTz4ge1xuICBuYW1lOiBzdHJpbmc7XG4gIFtpbnB1dEJyYW5kXTogSTtcbiAgW291dHB1dEJyYW5kXTogTztcbn1cblxuLyoqXG4gKiBBIG5hbWVkIGNvbGxlY3Rpb24gb2Ygb3BlcmF0aW9ucywgYXMgZGVmaW5lZCBieSBhIHtAbGluayBTZXJ2aWNlRGVmaW5pdGlvbn0uXG4gKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgdHlwZSBPcGVyYXRpb25NYXAgPSBSZWNvcmQ8c3RyaW5nLCBPcGVyYXRpb25EZWZpbml0aW9uPGFueSwgYW55Pj47XG5cbi8qKlxuICogQSBtYXBwZWQgdHlwZSB0aGF0IGV4dHJhY3RzIHRoZSBpbnB1dCB0eXBlIGZyb20gYW4gb3BlcmF0aW9uIGluIGEgc2VydmljZS5cbiAqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCB0eXBlIE9wZXJhdGlvbklucHV0PFQ+ID0gVCBleHRlbmRzIE9wZXJhdGlvbkRlZmluaXRpb248aW5mZXIgSSwgYW55PiA/IEkgOiBhbnk7XG5cbi8qKlxuICogQSBtYXBwZWQgdHlwZSB0aGF0IGV4dHJhY3RzIHRoZSBvdXRwdXQgdHlwZSBmcm9tIGFuIG9wZXJhdGlvbiBpbiBhIHNlcnZpY2UuXG4gKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5leHBvcnQgdHlwZSBPcGVyYXRpb25PdXRwdXQ8VD4gPSBUIGV4dGVuZHMgT3BlcmF0aW9uRGVmaW5pdGlvbjxhbnksIGluZmVyIE8+ID8gTyA6IGFueTtcblxuLyoqXG4gKiBBIG1hcHBlZCB0eXBlIHRoYXQgZXh0cmFjdHMgYWxsIG9wZXJhdGlvbiBuYW1lcyBmcm9tIGEgc2VydmljZS5cbiAqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCB0eXBlIE9wZXJhdGlvbktleTxUPiA9IHtcbiAgW0sgaW4ga2V5b2YgVCAmIHN0cmluZ106IFRbS10gZXh0ZW5kcyBPcGVyYXRpb25EZWZpbml0aW9uPGFueSwgYW55PiA/IEsgOiBuZXZlcjtcbn1ba2V5b2YgVCAmIHN0cmluZ107XG5cbi8qKlxuICogQ29uZmlybSB0aGF0IGEgc2VydmljZSBkZWZpbml0aW9uIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSBzZXJ2aWNlIC0gVGhlIHNlcnZpY2UgZGVmaW5pdGlvbiB0byB2YWxpZGF0ZS5cbiAqXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHRoZSBzZXJ2aWNlIGRlZmluaXRpb24gaXMgaW52YWxpZC5cbiAqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVNlcnZpY2VEZWZpbml0aW9uKHNlcnZpY2U6IFNlcnZpY2VEZWZpbml0aW9uKSB7XG4gIGlmICh0eXBlb2Ygc2VydmljZS5uYW1lICE9PSBcInN0cmluZ1wiIHx8ICFzZXJ2aWNlLm5hbWUpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU2VydmljZSBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpO1xuICB9XG5cbiAgY29uc3Qgb3BlcmF0aW9uTmFtZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgZm9yIChjb25zdCBbcHJvcE5hbWUsIG9wZXJhdGlvbl0gb2YgT2JqZWN0LmVudHJpZXMoc2VydmljZS5vcGVyYXRpb25zKSkge1xuICAgIGNvbnN0IG9wZXJhdGlvbk5hbWUgPSBvcGVyYXRpb24ubmFtZTtcbiAgICBpZiAodHlwZW9mIG9wZXJhdGlvbk5hbWUgIT09IFwic3RyaW5nXCIgfHwgIW9wZXJhdGlvbk5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE9wZXJhdGlvbiBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLCBmb3IgcHJvcGVydHkgJyR7cHJvcE5hbWV9J2ApO1xuICAgIH1cbiAgICBpZiAob3BlcmF0aW9uTmFtZXMuaGFzKG9wZXJhdGlvbk5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBEdXBsaWNhdGUgb3BlcmF0aW9uIGRlZmluaXRpb24gZm9yIG5hbWU6ICcke29wZXJhdGlvbk5hbWV9J2ApO1xuICAgIH1cbiAgICBvcGVyYXRpb25OYW1lcy5hZGQob3BlcmF0aW9uTmFtZSk7XG4gIH1cbn1cbiIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJcbmNvbnN0IGFwaSA9IHJlcXVpcmUoJ0B0ZW1wb3JhbGlvL3dvcmtmbG93L2xpYi93b3JrZXItaW50ZXJmYWNlLmpzJyk7XG5leHBvcnRzLmFwaSA9IGFwaTtcblxuY29uc3QgeyBvdmVycmlkZUdsb2JhbHMgfSA9IHJlcXVpcmUoJ0B0ZW1wb3JhbGlvL3dvcmtmbG93L2xpYi9nbG9iYWwtb3ZlcnJpZGVzLmpzJyk7XG5vdmVycmlkZUdsb2JhbHMoKTtcblxuZXhwb3J0cy5pbXBvcnRXb3JrZmxvd3MgPSBmdW5jdGlvbiBpbXBvcnRXb3JrZmxvd3MoKSB7XG4gIHJldHVybiByZXF1aXJlKC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvaG9tZS9tb2hhbWVkL3Byb2plY3QtMTEvbGlicy9vcmNoZXN0cmF0b3Ivc3JjL3dvcmtmbG93cy9jbG9uZS9jbG9uZS53b3JrZmxvdy50c1wiKTtcbn1cblxuZXhwb3J0cy5pbXBvcnRJbnRlcmNlcHRvcnMgPSBmdW5jdGlvbiBpbXBvcnRJbnRlcmNlcHRvcnMoKSB7XG4gIHJldHVybiBbXG4gICAgXG4gIF07XG59XG4iXSwibmFtZXMiOlsicHJveHlBY3Rpdml0aWVzIiwicmVzb2x2ZUNvbW1pdCIsImZldGNoU25hcHNob3QiLCJzdGFydFRvQ2xvc2VUaW1lb3V0IiwicmV0cnkiLCJtYXhpbXVtQXR0ZW1wdHMiLCJpbml0aWFsSW50ZXJ2YWwiLCJjbG9uZVJlcG9Xb3JrZmxvdyIsImlucHV0IiwiY29uc29sZSIsImxvZyIsInJlcG9VcmwiLCJyZWYiLCJzaGEiLCJwYXRoIl0sInNvdXJjZVJvb3QiOiIifQ==